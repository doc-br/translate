# $FreeBSD$
# Hongyou Bai <bhy1924@gmail.com>, 2019. #zanata, 2020.
# Danilo G. Baio <dbaio@FreeBSD.org>, 2020.
# wenheping <wen@freebsd.org>, 2020.
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2020-06-06 11:10-0300\n"
"PO-Revision-Date: 2020-04-29 11:29+0000\n"
"Last-Translator: Hongyou Bai <bhy1924@gmail.com>\n"
"Language-Team: Chinese (Simplified) <https://translate-dev.freebsd.org/"
"projects/freebsd-doc/boooks_arch-handbook/zh_CN/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 3.11.3\n"

#. Put one translator per line, in the form NAME <EMAIL>, YEAR1, YEAR2
msgctxt "_"
msgid "translator-credits"
msgstr ""

#. (itstool) path: info/title
#: book.translate.xml:142
msgid "FreeBSD Architecture Handbook"
msgstr "FreeBSD 系统结构手册"

#. (itstool) path: info/author
#: book.translate.xml:144
msgid "<orgname>The FreeBSD Documentation Project</orgname>"
msgstr "<orgname>FreeBSD 文档计划</orgname>"

#. (itstool) path: info/pubdate
#. (itstool) path: info/releaseinfo
#: book.translate.xml:147 book.translate.xml:226
#, fuzzy
#| msgid ""
#| "$FreeBSD: head/en_US.ISO8859-1/books/arch-handbook/book.xml 51016 "
#| "2017-10-01 12:11:13Z wosch $"
msgid ""
"$FreeBSD: head/en_US.ISO8859-1/books/arch-handbook/book.xml 53369 2019-09-05 "
"15:28:22Z bcr $"
msgstr ""
"$FreeBSD: head/en_US.ISO8859-1/books/arch-handbook/book.xml 51016 2017-10-01 "
"12:11:13Z wosch $"

#. (itstool) path: info/copyright
#: book.translate.xml:149
msgid ""
"<year>2000</year> <year>2001</year> <year>2002</year> <year>2003</year> "
"<year>2004</year> <year>2005</year> <year>2006</year> <year>2012</year> "
"<year>2013</year> <holder>The FreeBSD Documentation Project</holder>"
msgstr ""
"<year>2000</year> <year>2001</year> <year>2002</year> <year>2003</year> "
"<year>2004</year> <year>2005</year> <year>2006</year> <year>2012</year> "
"<year>2013</year> <holder>The FreeBSD Documentation Project</holder>"

#. (itstool) path: legalnotice/para
#: book.translate.xml:163
msgid "FreeBSD is a registered trademark of the FreeBSD Foundation."
msgstr "FreeBSD 是 FreeBSD 基金会的注册商标。"

#. (itstool) path: legalnotice/para
#: book.translate.xml:165
msgid ""
"UNIX is a registered trademark of The Open Group in the United States and "
"other countries."
msgstr "UNIX 是 Open Group 在美国和其它国家的注册商标。"

#. (itstool) path: legalnotice/para
#: book.translate.xml:167
msgid ""
"Apple, AirPort, FireWire, iMac, iPhone, iPad, Mac, Macintosh, Mac OS, "
"Quicktime, and TrueType are trademarks of Apple Inc., registered in the U.S. "
"and other countries."
msgstr ""
"Apple、Airport、FireWire、Imac、iMac、iPad、Mac、Macintosh、mac OS、"
"QuickTime 和 TrueType 是苹果公司在美国和其他国家注册的商标。"

#. (itstool) path: legalnotice/para
#: book.translate.xml:172
msgid ""
"Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media and Windows "
"NT are either registered trademarks or trademarks of Microsoft Corporation "
"in the United States and/or other countries."
msgstr ""
"微软、智能鼠标、MS-DOS、Outlook、Windows、Windows Media和 Windows NT 是微软公"
"司在美国和其他国家的注册商标或商标。"

#. (itstool) path: legalnotice/para
#: book.translate.xml:176
msgid ""
"Many of the designations used by manufacturers and sellers to distinguish "
"their products are claimed as trademarks. Where those designations appear in "
"this document, and the FreeBSD Project was aware of the trademark claim, the "
"designations have been followed by the <quote>™</quote> or the <quote>®</"
"quote> symbol."
msgstr ""
"制造商和销售商为区分其产品而使用的许多名称都被认作商标。如果这些标识出现在本"
"文档中, 并且 FreeBSD 项目知道商标声明, 则在这些名称之后增加 <quote>™</quote> "
"或 <quote>®</quote> 标记。"

#. (itstool) path: legalnotice/title
#: book.translate.xml:186
msgid "Copyright"
msgstr "版权"

#. (itstool) path: legalnotice/para
#: book.translate.xml:188
msgid ""
"Redistribution and use in source (XML DocBook) and 'compiled' forms (XML, "
"HTML, PDF, PostScript, RTF and so forth) with or without modification, are "
"permitted provided that the following conditions are met:"
msgstr ""
"允许在源文件（XML DocBook）和以“已编译”（XML，HTML，PDF，PostScript，RTF等）"
"格式重新分发和使用（无论是否经过修改），但必须满足以下条件："

#. (itstool) path: listitem/para
#: book.translate.xml:195
msgid ""
"Redistributions of source code (XML DocBook) must retain the above copyright "
"notice, this list of conditions and the following disclaimer as the first "
"lines of this file unmodified."
msgstr ""
"源代码形式 (XML DocBook) 的重新分发必须保留上述版权声明、且此条件列表和以下免"
"责声明作为此文件的第一行, 而不进行改动。"

#. (itstool) path: listitem/para
#: book.translate.xml:201 book.translate.xml:4385
msgid ""
"Redistributions in compiled form (transformed to other DTDs, converted to "
"PDF, PostScript, RTF and other formats) must reproduce the above copyright "
"notice, this list of conditions and the following disclaimer in the "
"documentation and/or other materials provided with the distribution."
msgstr ""
"以编译形式重新分发（转换为其他DTD，转换为PDF，PostScript，RTF和其他格式）必须"
"在随分发提供的文档和/或其他材料中复制上述版权声明，此条件列表和以下免责声明。"

#. (itstool) path: important/para
#: book.translate.xml:210
msgid ""
"THIS DOCUMENTATION IS PROVIDED BY THE FREEBSD DOCUMENTATION PROJECT \"AS IS"
"\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE "
"IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE "
"ARE DISCLAIMED. IN NO EVENT SHALL THE FREEBSD DOCUMENTATION PROJECT BE "
"LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR "
"CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF "
"SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS "
"INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN "
"CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) "
"ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF "
"THE POSSIBILITY OF SUCH DAMAGE."
msgstr ""
"本文档由 FreeBSD 文档项目“按原样”提供，并且不承担任何明示或暗示的担保，包括但"
"不限于对适销性和特定用途的适用性的暗示担保。在任何情况下，FreeBSD 文档项目均"
"不对任何直接，间接，偶然，特殊，惩戒或后果性损害（包括但不限于采购替代商品或"
"服务;使用，数据或利润损失;或商业中断）无论如何引起并承担任何责任理论，无论是"
"合同，严格责任，还是侵权（包括疏忽或其他情况），以任何方式使用本文档，即使被"
"告知此类损害的可能性。"

#. (itstool) path: abstract/para
#: book.translate.xml:229
msgid ""
"Welcome to the FreeBSD Architecture Handbook. This manual is a "
"<emphasis>work in progress</emphasis> and is the work of many individuals. "
"Many sections do not yet exist and some of those that do exist need to be "
"updated. If you are interested in helping with this project, send email to "
"the <link xlink:href=\"http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc"
"\">FreeBSD documentation project mailing list</link>."
msgstr ""
"欢迎您阅读《FreeBSD系统结构手册》。 这本手册还在不断由许多人<emphasis>继续书"
"写</emphasis>。 许多章节还是空白，有的章节亟待更新。 如果您对这个项目感兴趣并"
"愿意有所贡献，请发信给<link xlink:href=\"http://lists.FreeBSD.org/mailman/"
"listinfo/freebsd-doc\">FreeBSD 文档计划邮件列表</link>."

#. (itstool) path: abstract/para
#: book.translate.xml:236
msgid ""
"The latest version of this document is always available from the <link xlink:"
"href=\"@@URL_RELPREFIX@@/index.html\">FreeBSD World Wide Web server</link>. "
"It may also be downloaded in a variety of formats and compression options "
"from the <link xlink:href=\"https://download.freebsd.org/ftp/doc/\">FreeBSD "
"FTP server</link> or one of the numerous <link xlink:href="
"\"@@URL_RELPREFIX@@/doc/en_US.ISO8859-1/books/handbook/mirrors-ftp.html"
"\">mirror sites</link>."
msgstr ""
"本文档最新版本可从 <link xlink:href=\"@@URL_RELPREFIX@@/index.html\">FreeBSD "
"World Wide Web server</link>获得。您还可以从<link xlink:href=\"https://"
"download.freebsd.org/ftp/doc/\">FreeBSD FTP server</link> 或任意一个 <link "
"xlink:href=\"@@URL_RELPREFIX@@/doc/en_US.ISO8859-1/books/handbook/mirrors-"
"ftp.html\">镜像站点</link>获取本文档的压缩文件其他格式文件。"

#. (itstool) path: part/title
#: book.translate.xml:246
msgid "Kernel"
msgstr "内核"

#. (itstool) path: info/title
#: book.translate.xml:262
msgid "Bootstrapping and Kernel Initialization"
msgstr "引导过程与内核初始化"

#. (itstool) path: authorgroup/author
#: book.translate.xml:265
msgid ""
"<personname> <firstname>Sergey</firstname> <surname>Lyubka</surname> </"
"personname> <contrib>Contributed by </contrib>"
msgstr ""
"<personname> <firstname>Sergey</firstname> <surname>Lyubka</surname> </"
"personname> <contrib>Contributed by </contrib>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:277
msgid ""
"<personname> <firstname>Sergio Andrés</firstname> <surname> Gómez del Real</"
"surname> </personname> <contrib>Updated and enhanced by </contrib>"
msgstr ""
"<personname> <firstname>Sergio Andrés</firstname> <surname> Gómez del Real</"
"surname> </personname> <contrib>Updated and enhanced by </contrib>"

#. (itstool) path: sect1/title
#: book.translate.xml:290 book.translate.xml:4412 book.translate.xml:16510
#: book.translate.xml:19480
msgid "Synopsis"
msgstr "简介"

#. (itstool) path: sect1/indexterm
#. (itstool) path: para/indexterm
#: book.translate.xml:292 book.translate.xml:20828
msgid "<primary>BIOS</primary>"
msgstr "<primary>BIOS</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:293
msgid "<primary>firmware</primary>"
msgstr "<primary>固件</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:294
msgid "<primary>POST</primary>"
msgstr "<primary>POST</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:295
msgid "<primary>IA-32</primary>"
msgstr "<primary>IA-32</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:296
msgid "<primary>booting</primary>"
msgstr "<primary> 启动 </primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:297
msgid "<primary>system initialization</primary>"
msgstr "<primary>系统初始化</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:298
msgid ""
"This chapter is an overview of the boot and system initialization processes, "
"starting from the <acronym>BIOS</acronym> (firmware) <acronym>POST</"
"acronym>, to the first user process creation. Since the initial steps of "
"system startup are very architecture dependent, the IA-32 architecture is "
"used as an example."
msgstr ""
"这一章是对引导过程和系统初始化过程的总览。这些过程始于<acronym>BIOS</"
"acronym>(固件)<acronym>POST</acronym>，直到第一个用户进程建立。由于系统启动的"
"最初步骤是与硬件结构相关的、是紧配合的， 这里用IA-32(Intel Architecture "
"32bit)结构作为例子。"

#. (itstool) path: sect1/para
#: book.translate.xml:305
msgid ""
"The FreeBSD boot process can be surprisingly complex. After control is "
"passed from the <acronym>BIOS</acronym>, a considerable amount of low-level "
"configuration must be done before the kernel can be loaded and executed. "
"This setup must be done in a simple and flexible manner, allowing the user a "
"great deal of customization possibilities."
msgstr ""
"FreeBSD 启动过程非常复杂。从<acronym>BIOS</acronym>传递控制后，必须先执行大量"
"低级配置，然后才能加载和执行内核。此设置必须以简单和灵活的方式完成，允许用户"
"自定义。"

#. (itstool) path: sect1/title
#. (itstool) path: sect2/title
#: book.translate.xml:314 book.translate.xml:23530
msgid "Overview"
msgstr "总览"

#. (itstool) path: sect1/para
#: book.translate.xml:316
msgid ""
"The boot process is an extremely machine-dependent activity. Not only must "
"code be written for every computer architecture, but there may also be "
"multiple types of booting on the same architecture. For example, a directory "
"listing of <filename>/usr/src/sys/boot</filename> reveals a great amount of "
"architecture-dependent code. There is a directory for each of the various "
"supported architectures. In the x86-specific <filename>i386</filename> "
"directory, there are subdirectories for different boot standards like "
"<filename>mbr</filename> (Master Boot Record), <filename>gpt</filename> "
"(<acronym>GUID</acronym> Partition Table), and <filename>efi</filename> "
"(Extensible Firmware Interface). Each boot standard has its own conventions "
"and data structures. The example that follows shows booting an x86 computer "
"from an <acronym>MBR</acronym> hard drive with the FreeBSD <filename>boot0</"
"filename> multi-boot loader stored in the very first sector. That boot code "
"starts the FreeBSD three-stage boot process."
msgstr ""
"启动过程与计算机架构息息相关。不仅必须为每个计算机体系结构编写代码，而且在同"
"一体系结构上也可能有多个不同类型的引导。例如,<filename>/usr/src/sys/boot</"
"filename>的目录列表显示了大量依赖于体系结构的代码。每个受支持的体系结构都有一"
"个目录。在特定于 x86 的 <filename>i386</filename> 目录中，有不同引导标准的子"
"目录，如<filename>mbr</filename>(主引导记录)、<filename>gpt</"
"filename>(<acronym>GUID</acronym>分区表)和<filename>efi</filename>(可扩展固件"
"接口)。每个引导标准都有自己的约定和数据结构。以下示例显示,使用存储在第一扇区"
"的 FreeBSD <filename>boot0</filename> 多引导加载程序，从<acronym>MBR</"
"acronym> 硬盘驱动器启动 x86 计算机。该引导代码启动 FreeBSD 三阶段引导过程。"

#. (itstool) path: sect1/para
#: book.translate.xml:335
msgid ""
"The key to understanding this process is that it is a series of stages of "
"increasing complexity. These stages are <filename>boot1</filename>, "
"<filename>boot2</filename>, and <filename>loader</filename> (see "
"<citerefentry><refentrytitle>boot</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> for more detail). The boot system executes each stage in "
"sequence. The last stage, <filename>loader</filename>, is responsible for "
"loading the FreeBSD kernel. Each stage is examined in the following sections."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:344
msgid ""
"Here is an example of the output generated by the different boot stages. "
"Actual output may differ from machine to machine:"
msgstr "下面是由不同引导阶段生成的输出的示例。实际输出可能因机器而异:"

#. (itstool) path: row/entry
#: book.translate.xml:352
msgid "FreeBSD Component"
msgstr "FreeBSD 组件"

#. (itstool) path: row/entry
#: book.translate.xml:353
msgid "Output (may vary)"
msgstr "输出（可能有所不同）"

#. (itstool) path: row/entry
#: book.translate.xml:357
msgid "<literal>boot0</literal>"
msgstr "<literal>boot0</literal>"

#. (itstool) path: entry/screen
#: book.translate.xml:358
#, no-wrap
msgid ""
"F1    FreeBSD\n"
"F2    BSD\n"
"F5    Disk 2"
msgstr ""
"F1    FreeBSD\n"
"F2    BSD\n"
"F5    Disk 2"

#. (itstool) path: footnote/para
#: book.translate.xml:365
msgid ""
"This prompt will appear if the user presses a key just after selecting an OS "
"to boot at the <literal>boot0</literal> stage."
msgstr ""
"This prompt will appear if the user presses a key just after selecting an OS "
"to boot at the <literal>boot0</literal> stage."

#. (itstool) path: row/entry
#: book.translate.xml:364
msgid "<literal>boot2</literal> <_:footnote-1/>"
msgstr "<literal>boot2</literal> <_:footnote-1/>"

#. (itstool) path: entry/screen
#: book.translate.xml:369
#, no-wrap
msgid ""
"&gt;&gt;FreeBSD/i386 BOOT\n"
"Default: 1:ad(1,a)/boot/loader\n"
"boot:"
msgstr ""
"&gt;&gt;FreeBSD/i386 BOOT\n"
"Default: 1:ad(1,a)/boot/loader\n"
"boot:"

#. (itstool) path: row/entry
#: book.translate.xml:375
msgid "<filename>loader</filename>"
msgstr "<filename>loader</filename>"

#. (itstool) path: entry/screen
#: book.translate.xml:376
#, no-wrap
msgid ""
"BTX loader 1.00 BTX version is 1.02\n"
"Consoles: internal video/keyboard\n"
"BIOS drive C: is disk0\n"
"BIOS 639kB/2096064kB available memory\n"
"\n"
"FreeBSD/x86 bootstrap loader, Revision 1.1\n"
"Console internal video/keyboard\n"
"(root@snap.freebsd.org, Thu Jan 16 22:18:05 UTC 2014)\n"
"Loading /boot/defaults/loader.conf\n"
"/boot/kernel/kernel text=0xed9008 data=0x117d28+0x176650 syms=[0x8+0x137988+0x8+0x1515f8]"
msgstr ""
"BTX loader 1.00 BTX version is 1.02\n"
"Consoles: internal video/keyboard\n"
"BIOS drive C: is disk0\n"
"BIOS 639kB/2096064kB available memory\n"
"\n"
"FreeBSD/x86 bootstrap loader, Revision 1.1\n"
"Console internal video/keyboard\n"
"(root@snap.freebsd.org, Thu Jan 16 22:18:05 UTC 2014)\n"
"Loading /boot/defaults/loader.conf\n"
"/boot/kernel/kernel text=0xed9008 data=0x117d28+0x176650 syms=[0x8+0x137988+0x8+0x1515f8]"

#. (itstool) path: row/entry
#: book.translate.xml:389
msgid "kernel"
msgstr "kernel"

#. (itstool) path: entry/screen
#: book.translate.xml:390
#, no-wrap
msgid ""
"Copyright (c) 1992-2013 The FreeBSD Project.\n"
"Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994\n"
"        The Regents of the University of California. All rights reserved.\n"
"FreeBSD is a registered trademark of The FreeBSD Foundation.\n"
"FreeBSD 10.0-RELEASE #0 r260789: Thu Jan 16 22:34:59 UTC 2014\n"
"    root@snap.freebsd.org:/usr/obj/usr/src/sys/GENERIC amd64\n"
"FreeBSD clang version 3.3 (tags/RELEASE_33/final 183502) 20130610"
msgstr ""
"Copyright (c) 1992-2013 The FreeBSD Project.\n"
"Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994\n"
"        The Regents of the University of California. All rights reserved.\n"
"FreeBSD is a registered trademark of The FreeBSD Foundation.\n"
"FreeBSD 10.0-RELEASE #0 r260789: Thu Jan 16 22:34:59 UTC 2014\n"
"    root@snap.freebsd.org:/usr/obj/usr/src/sys/GENERIC amd64\n"
"FreeBSD clang version 3.3 (tags/RELEASE_33/final 183502) 20130610"

#. (itstool) path: sect1/title
#: book.translate.xml:404
#, fuzzy
msgid "The <acronym>BIOS</acronym>"
msgstr "The <acronym>BIOS</acronym>"

#. (itstool) path: sect1/para
#: book.translate.xml:406
msgid ""
"When the computer powers on, the processor's registers are set to some "
"predefined values. One of the registers is the <emphasis>instruction "
"pointer</emphasis> register, and its value after a power on is well defined: "
"it is a 32-bit value of <literal>0xfffffff0</literal>. The instruction "
"pointer register (also known as the Program Counter) points to code to be "
"executed by the processor. Another important register is the <literal>cr0</"
"literal> 32-bit control register, and its value just after a reboot is "
"<literal>0</literal>. One of <literal>cr0</literal>'s bits, the PE "
"(Protection Enabled) bit, indicates whether the processor is running in 32-"
"bit protected mode or 16-bit real mode. Since this bit is cleared at boot "
"time, the processor boots in 16-bit real mode. Real mode means, among other "
"things, that linear and physical addresses are identical. The reason for the "
"processor not to start immediately in 32-bit protected mode is backwards "
"compatibility. In particular, the boot process relies on the services "
"provided by the <acronym>BIOS</acronym>, and the <acronym>BIOS</acronym> "
"itself works in legacy, 16-bit code."
msgstr ""
"当PC加电后，处理器的寄存器被设为某些特定值。在这些寄存器中， <emphasis>指令指"
"针</emphasis>寄存器被设为32位值0xfffffff0。 指令指针寄存器指向处理器将要执行"
"的指令代码。<literal>cr1</literal>， 一个32位控制寄存器，在刚启动时值被设为"
"0。cr1的PE(Protected Enabled， 保护模式使能)位用来指示处理器是处于保护模式还"
"是实地址模式。 由于启动时该位被清位，处理器在实地址模式中引导。在实地址模式"
"中， 线性地址与物理地址是等同的。"

#. (itstool) path: sect1/para
#: book.translate.xml:426
#, fuzzy
#| msgid ""
#| "The value of <literal>0xfffffff0</literal> is slightly less than 4 GB, so "
#| "unless the machine has 4 GB of physical memory, it cannot point to a "
#| "valid memory address. The computer's hardware translates this address so "
#| "that it points to a <acronym>BIOS</acronym> memory block."
msgid ""
"The value of <literal>0xfffffff0</literal> is slightly less than 4 GB, so "
"unless the machine has 4 GB of physical memory, it cannot point to a valid "
"memory address. The computer's hardware translates this address so that it "
"points to a <acronym>BIOS</acronym> memory block."
msgstr ""
"值0xfffffff0略小于4G,因此计算机没有4G字节物理内存， 这就不会是一个有效的内存"
"地址。计算机硬件将这个地址转指向BIOS存储块。"

#. (itstool) path: sect1/para
#: book.translate.xml:432
msgid ""
"The <acronym>BIOS</acronym> (Basic Input Output System) is a chip on the "
"motherboard that has a relatively small amount of read-only memory "
"(<acronym>ROM</acronym>). This memory contains various low-level routines "
"that are specific to the hardware supplied with the motherboard. The "
"processor will first jump to the address 0xfffffff0, which really resides in "
"the <acronym>BIOS</acronym>'s memory. Usually this address contains a jump "
"instruction to the <acronym>BIOS</acronym>'s POST routines."
msgstr ""
"BIOS表示<emphasis>Basic Input Output System</emphasis> (基本输入输出系统)。在"
"主板上，它被固化在一个相对容量较小的 只读存储器(Read-Only Memory, ROM)。BIOS"
"包含各种各样为主板硬件 定制的底层例程。就这样，处理器首先指向常驻BIOS存储器的"
"地址 0xfffffff0。通常这个位置包含一条跳转指令，指向BIOS的POST例程。"

#. (itstool) path: sect1/para
#: book.translate.xml:442
msgid ""
"The <acronym>POST</acronym> (Power On Self Test) is a set of routines "
"including the memory check, system bus check, and other low-level "
"initialization so the <acronym>CPU</acronym> can set up the computer "
"properly. The important step of this stage is determining the boot device. "
"Modern <acronym>BIOS</acronym> implementations permit the selection of a "
"boot device, allowing booting from a floppy, <acronym>CD-ROM</acronym>, hard "
"disk, or other devices."
msgstr ""
"POST表示<emphasis>Power On Self Test</emphasis>(加电自检)。 这套程序包括内存"
"检查，系统总线检查和其它底层工具， 从而使得CPU能够初始化整台计算机。这一阶段"
"中有一个重要步骤， 就是确定引导设备。现在所有的BIOS都允许手工选择引导设备。 "
"你可以从软盘、光盘驱动器、硬盘等设备引导。"

#. (itstool) path: sect1/para
#: book.translate.xml:451
msgid ""
"The very last thing in the <acronym>POST</acronym> is the <literal>INT 0x19</"
"literal> instruction. The <literal>INT 0x19</literal> handler reads 512 "
"bytes from the first sector of boot device into the memory at address "
"<literal>0x7c00</literal>. The term <emphasis>first sector</emphasis> "
"originates from hard drive architecture, where the magnetic plate is divided "
"into a number of cylindrical tracks. Tracks are numbered, and every track is "
"divided into a number (usually 64) of sectors. Track numbers start at 0, but "
"sector numbers start from 1. Track 0 is the outermost on the magnetic plate, "
"and sector 1, the first sector, has a special purpose. It is also called the "
"<acronym>MBR</acronym>, or Master Boot Record. The remaining sectors on the "
"first track are never used."
msgstr ""
"<acronym>POST</acronym>的最后一步是执行<literal>INT 0x19</literal>指令。 这个"
"指令从引导设备第一个扇区读取512字节，装入地址<literal>0x7c00</literal>。 "
"<emphasis>第一个扇区</emphasis>的说法最早起源于硬盘的结构，硬盘面被分为若干圆"
"柱形轨道。给轨道编号，同时又将轨道分为 一定数目(通常是64)的扇形。0号轨道是硬"
"盘的最外圈，1号扇区， 第一个扇区(轨道、柱面都从0开始编号，而扇区从1开始编号) "
"有着特殊的作用，它又被称为主引导记录(Master Boot Record, <acronym>MBR</"
"acronym>)。 第一轨剩余的扇区常常不使用。"

#. (itstool) path: sect1/para
#: book.translate.xml:466
msgid ""
"This sector is our boot-sequence starting point. As we will see, this sector "
"contains a copy of our <filename>boot0</filename> program. A jump is made by "
"the <acronym>BIOS</acronym> to address <literal>0x7c00</literal> so it "
"starts executing."
msgstr ""

#. (itstool) path: sect1/title
#: book.translate.xml:474
msgid "The Master Boot Record (<literal>boot0</literal>)"
msgstr "主引导记录 (<literal>boot0</literal>)"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:476
msgid "<primary>MBR</primary>"
msgstr "<primary>MBR</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:478
msgid ""
"After control is received from the <acronym>BIOS</acronym> at memory address "
"<literal>0x7c00</literal>, <filename>boot0</filename> starts executing. It "
"is the first piece of code under FreeBSD control. The task of "
"<filename>boot0</filename> is quite simple: scan the partition table and let "
"the user choose which partition to boot from. The Partition Table is a "
"special, standard data structure embedded in the <acronym>MBR</acronym> "
"(hence embedded in <filename>boot0</filename>) describing the four standard "
"PC <quote>partitions</quote> <_:footnote-1/>. <filename>boot0</filename> "
"resides in the filesystem as <filename>/boot/boot0</filename>. It is a small "
"512-byte file, and it is exactly what FreeBSD's installation procedure wrote "
"to the hard disk's <acronym>MBR</acronym> if you chose the "
"<quote>bootmanager</quote> option at installation time. Indeed, "
"<filename>boot0</filename> <emphasis>is</emphasis> the <acronym>MBR</"
"acronym>."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:498
msgid ""
"As mentioned previously, the <literal>INT 0x19</literal> instruction causes "
"the <literal>INT 0x19</literal> handler to load an <acronym>MBR</acronym> "
"(<filename>boot0</filename>) into memory at address <literal>0x7c00</"
"literal>. The source file for <filename>boot0</filename> can be found in "
"<filename>sys/boot/i386/boot0/boot0.S</filename> - which is an awesome piece "
"of code written by Robert Nordier."
msgstr ""
"如前所述， <literal>INT 0x19</literal> 指令装载 MBR， 也就是 "
"<filename>boot0</filename> 的内容至内存地址 0x7c00。 再看文件 <filename>sys/"
"boot/i386/boot0/boot0.S</filename>， 可以猜想这里面发生了什么 - 这是引导管理"
"器， 一段由 Robert Nordier书写的令人起敬的程序片段。"

#. (itstool) path: sect1/para
#: book.translate.xml:506
msgid ""
"A special structure starting from offset <literal>0x1be</literal> in the "
"<acronym>MBR</acronym> is called the <emphasis>partition table</emphasis>. "
"It has four records of 16 bytes each, called <emphasis>partition records</"
"emphasis>, which represent how the hard disk is partitioned, or, in "
"FreeBSD's terminology, sliced. One byte of those 16 says whether a partition "
"(slice) is bootable or not. Exactly one record must have that flag set, "
"otherwise <filename>boot0</filename>'s code will refuse to proceed."
msgstr ""
"MBR里，也就是<filename>boot0</filename>里， 从偏移量0x1be开始有一个特殊的结"
"构，称为 <emphasis>分区表</emphasis>。其中有4条记录 (称为<emphasis>分区记录</"
"emphasis>)，每条记录16字节。 分区记录表示硬盘如何被划分，在FreeBSD的术语中， "
"这被称为slice(d)。16字节中有一个标志字节决定这个分区是否可引导。 有仅只能有一"
"个分区可设定这一标志。否则， <filename>boot0</filename>的代码将拒绝继续执行。"

#. (itstool) path: sect1/para
#: book.translate.xml:516
msgid "A partition record has the following fields:"
msgstr "一个分区记录有如下域："

#. (itstool) path: listitem/para
#: book.translate.xml:520
msgid "the 1-byte filesystem type"
msgstr "1字节 文件系统类型"

#. (itstool) path: listitem/para
#: book.translate.xml:524
msgid "the 1-byte bootable flag"
msgstr "1字节 可引导标志"

#. (itstool) path: listitem/para
#: book.translate.xml:528
msgid "the 6 byte descriptor in CHS format"
msgstr "6字节 CHS格式描述符"

#. (itstool) path: listitem/para
#: book.translate.xml:532
msgid "the 8 byte descriptor in LBA format"
msgstr "8字节 LBA格式描述符"

#. (itstool) path: sect1/para
#: book.translate.xml:536
msgid ""
"A partition record descriptor contains information about where exactly the "
"partition resides on the drive. Both descriptors, <acronym>LBA</acronym> and "
"<acronym>CHS</acronym>, describe the same information, but in different "
"ways: <acronym>LBA</acronym> (Logical Block Addressing) has the starting "
"sector for the partition and the partition's length, while <acronym>CHS</"
"acronym> (Cylinder Head Sector) has coordinates for the first and last "
"sectors of the partition. The partition table ends with the special "
"signature <literal>0xaa55</literal>."
msgstr ""
"一个分区记录描述符包含某一分区在硬盘上的确切位置信息。 LBA和CHS两种描述符指示"
"相同的信息，但是指示方式有所不同：LBA (逻辑块寻址，Logical Block Addressing)"
"指示分区的起始扇区和分区长度， 而CHS(柱面 磁头 扇区)指示首扇区和末扇区。"

#. (itstool) path: sect1/para
#: book.translate.xml:547
msgid ""
"The <acronym>MBR</acronym> must fit into 512 bytes, a single disk sector. "
"This program uses low-level <quote>tricks</quote> like taking advantage of "
"the side effects of certain instructions and reusing register values from "
"previous operations to make the most out of the fewest possible "
"instructions. Care must also be taken when handling the partition table, "
"which is embedded in the <acronym>MBR</acronym> itself. For these reasons, "
"be very careful when modifying <filename>boot0.S</filename>."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:557
msgid ""
"Note that the <filename>boot0.S</filename> source file is assembled "
"<quote>as is</quote>: instructions are translated one by one to binary, with "
"no additional information (no <acronym>ELF</acronym> file format, for "
"example). This kind of low-level control is achieved at link time through "
"special control flags passed to the linker. For example, the text section of "
"the program is set to be located at address <literal>0x600</literal>. In "
"practice this means that <filename>boot0</filename> must be loaded to memory "
"address <literal>0x600</literal> in order to function properly."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:568
msgid ""
"It is worth looking at the <filename>Makefile</filename> for "
"<filename>boot0</filename> (<filename>sys/boot/i386/boot0/Makefile</"
"filename>), as it defines some of the run-time behavior of <filename>boot0</"
"filename>. For instance, if a terminal connected to the serial port (COM1) "
"is used for I/O, the macro <literal>SIO</literal> must be defined (<literal>-"
"DSIO</literal>). <literal>-DPXE</literal> enables boot through <acronym>PXE</"
"acronym> by pressing <keycap>F6</keycap>. Additionally, the program defines "
"a set of <emphasis>flags</emphasis> that allow further modification of its "
"behavior. All of this is illustrated in the <filename>Makefile</filename>. "
"For example, look at the linker directives which command the linker to start "
"the text section at address <literal>0x600</literal>, and to build the "
"output file <quote>as is</quote> (strip out any file formatting):"
msgstr ""

#. (itstool) path: figure/title
#: book.translate.xml:587
msgid "<filename>sys/boot/i386/boot0/Makefile</filename>"
msgstr "<filename>sys/boot/i386/boot0/Makefile</filename>"

#. (itstool) path: figure/programlisting
#: book.translate.xml:589
#, no-wrap
msgid ""
"      BOOT_BOOT0_ORG?=0x600\n"
"      LDFLAGS=-e start -Ttext ${BOOT_BOOT0_ORG} \\\n"
"      -Wl,-N,-S,--oformat,binary"
msgstr ""
"      BOOT_BOOT0_ORG?=0x600\n"
"      LDFLAGS=-e start -Ttext ${BOOT_BOOT0_ORG} \\\n"
"      -Wl,-N,-S,--oformat,binary"

#. (itstool) path: sect1/para
#: book.translate.xml:594
msgid ""
"Let us now start our study of the <acronym>MBR</acronym>, or "
"<filename>boot0</filename>, starting where execution begins."
msgstr ""

#. (itstool) path: note/para
#: book.translate.xml:599
msgid ""
"Some modifications have been made to some instructions in favor of better "
"exposition. For example, some macros are expanded, and some macro tests are "
"omitted when the result of the test is known. This applies to all of the "
"code examples shown."
msgstr ""

#. (itstool) path: figure/title
#: book.translate.xml:607 book.translate.xml:635 book.translate.xml:702
#: book.translate.xml:732 book.translate.xml:760 book.translate.xml:804
#: book.translate.xml:823 book.translate.xml:841 book.translate.xml:911
msgid "<filename>sys/boot/i386/boot0/boot0.S</filename>"
msgstr "<filename>sys/boot/i386/boot0/boot0.S</filename>"

#. (itstool) path: figure/programlisting
#: book.translate.xml:609
#, no-wrap
msgid ""
"start:\n"
"      cld\t\t\t# String ops inc\n"
"      xorw %ax,%ax\t\t# Zero\n"
"      movw %ax,%es\t\t# Address\n"
"      movw %ax,%ds\t\t#  data\n"
"      movw %ax,%ss\t\t# Set up\n"
"      movw 0x7c00,%sp\t\t#  stack"
msgstr ""
"start:\n"
"      cld\t\t\t# String ops inc\n"
"      xorw %ax,%ax\t\t# Zero\n"
"      movw %ax,%es\t\t# Address\n"
"      movw %ax,%ds\t\t#  data\n"
"      movw %ax,%ss\t\t# Set up\n"
"      movw 0x7c00,%sp\t\t#  stack"

#. (itstool) path: footnote/para
#: book.translate.xml:623
msgid ""
"When in doubt, we refer the reader to the official Intel manuals, which "
"describe the exact semantics for each instruction: <link xlink:href=\"http://"
"www.intel.com/content/www/us/en/processors/architectures-software-developer-"
"manuals.html\"/>."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:618
msgid ""
"This first block of code is the entry point of the program. It is where the "
"<acronym>BIOS</acronym> transfers control. First, it makes sure that the "
"string operations autoincrement its pointer operands (the <literal>cld</"
"literal> instruction) <_:footnote-1/>. Then, as it makes no assumption about "
"the state of the segment registers, it initializes them. Finally, it sets "
"the stack pointer register (<literal>%sp</literal>) to address "
"<literal>0x7c00</literal>, so we have a working stack."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:631
msgid ""
"The next block is responsible for the relocation and subsequent jump to the "
"relocated code."
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:637
#, no-wrap
msgid ""
"      movw $0x7c00,%si\t# Source\n"
"      movw $0x600,%di\t\t# Destination\n"
"      movw $512,%cx\t\t# Word count\n"
"      rep\t\t\t# Relocate\n"
"      movsb\t\t\t#  code\n"
"      movw %di,%bp\t\t# Address variables\n"
"      movb $16,%cl\t\t# Words to clear\n"
"      rep\t\t\t# Zero\n"
"      stosb\t\t\t#  them\n"
"      incb -0xe(%di)\t\t# Set the S field to 1\n"
"      jmp main-0x7c00+0x600\t# Jump to relocated code"
msgstr ""
"      movw $0x7c00,%si\t# Source\n"
"      movw $0x600,%di\t\t# Destination\n"
"      movw $512,%cx\t\t# Word count\n"
"      rep\t\t\t# Relocate\n"
"      movsb\t\t\t#  code\n"
"      movw %di,%bp\t\t# Address variables\n"
"      movb $16,%cl\t\t# Words to clear\n"
"      rep\t\t\t# Zero\n"
"      stosb\t\t\t#  them\n"
"      incb -0xe(%di)\t\t# Set the S field to 1\n"
"      jmp main-0x7c00+0x600\t# Jump to relocated code"

#. (itstool) path: sect1/para
#: book.translate.xml:650
msgid ""
"Because <filename>boot0</filename> is loaded by the <acronym>BIOS</acronym> "
"to address <literal>0x7C00</literal>, it copies itself to address "
"<literal>0x600</literal> and then transfers control there (recall that it "
"was linked to execute at address <literal>0x600</literal>). The source "
"address, <literal>0x7c00</literal>, is copied to register <literal>%si</"
"literal>. The destination address, <literal>0x600</literal>, to register "
"<literal>%di</literal>. The number of bytes to copy, <literal>512</literal> "
"(the program's size), is copied to register <literal>%cx</literal>. Next, "
"the <literal>rep</literal> instruction repeats the instruction that follows, "
"that is, <literal>movsb</literal>, the number of times dictated by the "
"<literal>%cx</literal> register. The <literal>movsb</literal> instruction "
"copies the byte pointed to by <literal>%si</literal> to the address pointed "
"to by <literal>%di</literal>. This is repeated another 511 times. On each "
"repetition, both the source and destination registers, <literal>%si</"
"literal> and <literal>%di</literal>, are incremented by one. Thus, upon "
"completion of the 512-byte copy, <literal>%di</literal> has the value "
"<literal>0x600</literal>+<literal>512</literal>= <literal>0x800</literal>, "
"and <literal>%si</literal> has the value <literal>0x7c00</literal>"
"+<literal>512</literal>= <literal>0x7e00</literal>; we have thus completed "
"the code <emphasis>relocation</emphasis>."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:676
msgid ""
"Next, the destination register <literal>%di</literal> is copied to <literal>"
"%bp</literal>. <literal>%bp</literal> gets the value <literal>0x800</"
"literal>. The value <literal>16</literal> is copied to <literal>%cl</"
"literal> in preparation for a new string operation (like our previous "
"<literal>movsb</literal>). Now, <literal>stosb</literal> is executed 16 "
"times. This instruction copies a <literal>0</literal> value to the address "
"pointed to by the destination register (<literal>%di</literal>, which is "
"<literal>0x800</literal>), and increments it. This is repeated another 15 "
"times, so <literal>%di</literal> ends up with value <literal>0x810</"
"literal>. Effectively, this clears the address range <literal>0x800</"
"literal>-<literal>0x80f</literal>. This range is used as a (fake) partition "
"table for writing the <acronym>MBR</acronym> back to disk. Finally, the "
"sector field for the <acronym>CHS</acronym> addressing of this fake "
"partition is given the value 1 and a jump is made to the main function from "
"the relocated code. Note that until this jump to the relocated code, any "
"reference to an absolute address was avoided."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:697
msgid ""
"The following code block tests whether the drive number provided by the "
"<acronym>BIOS</acronym> should be used, or the one stored in "
"<filename>boot0</filename>."
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:704
#, no-wrap
msgid ""
"main:\n"
"      testb $SETDRV,-69(%bp)\t# Set drive number?\n"
"      jnz disable_update\t# Yes\n"
"      testb %dl,%dl\t\t# Drive number valid?\n"
"      js save_curdrive\t\t# Possibly (0x80 set)"
msgstr ""
"main:\n"
"      testb $SETDRV,-69(%bp)\t# Set drive number?\n"
"      jnz disable_update\t# Yes\n"
"      testb %dl,%dl\t\t# Drive number valid?\n"
"      js save_curdrive\t\t# Possibly (0x80 set)"

#. (itstool) path: sect1/para
#: book.translate.xml:711
msgid ""
"This code tests the <literal>SETDRV</literal> bit (<literal>0x20</literal>) "
"in the <emphasis>flags</emphasis> variable. Recall that register <literal>"
"%bp</literal> points to address location <literal>0x800</literal>, so the "
"test is done to the <emphasis>flags</emphasis> variable at address "
"<literal>0x800</literal>-<literal>69</literal>= <literal>0x7bb</literal>. "
"This is an example of the type of modifications that can be done to "
"<filename>boot0</filename>. The <literal>SETDRV</literal> flag is not set by "
"default, but it can be set in the <filename>Makefile</filename>. When set, "
"the drive number stored in the <acronym>MBR</acronym> is used instead of the "
"one provided by the <acronym>BIOS</acronym>. We assume the defaults, and "
"that the <acronym>BIOS</acronym> provided a valid drive number, so we jump "
"to <literal>save_curdrive</literal>."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:727
msgid ""
"The next block saves the drive number provided by the <acronym>BIOS</"
"acronym>, and calls <literal>putn</literal> to print a new line on the "
"screen."
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:734
#, no-wrap
msgid ""
"save_curdrive:\n"
"      movb %dl, (%bp)\t\t# Save drive number\n"
"      pushw %dx\t\t\t# Also in the stack\n"
"#ifdef\tTEST\t/* test code, print internal bios drive */\n"
"      rolb $1, %dl\n"
"      movw $drive, %si\n"
"      call putkey\n"
"#endif\n"
"      callw putn\t\t# Print a newline"
msgstr ""
"save_curdrive:\n"
"      movb %dl, (%bp)\t\t# Save drive number\n"
"      pushw %dx\t\t\t# Also in the stack\n"
"#ifdef\tTEST\t/* test code, print internal bios drive */\n"
"      rolb $1, %dl\n"
"      movw $drive, %si\n"
"      call putkey\n"
"#endif\n"
"      callw putn\t\t# Print a newline"

#. (itstool) path: sect1/para
#: book.translate.xml:745
msgid ""
"Note that we assume <varname>TEST</varname> is not defined, so the "
"conditional code in it is not assembled and will not appear in our "
"executable <filename>boot0</filename>."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:749
msgid ""
"Our next block implements the actual scanning of the partition table. It "
"prints to the screen the partition type for each of the four entries in the "
"partition table. It compares each type with a list of well-known operating "
"system file systems. Examples of recognized partition types are "
"<acronym>NTFS</acronym> (<trademark class=\"registered\">Windows</"
"trademark>, ID 0x7), <literal>ext2fs</literal> (<trademark class=\"registered"
"\">Linux</trademark>, ID 0x83), and, of course, <literal>ffs</literal>/"
"<literal>ufs2</literal> (FreeBSD, ID 0xa5). The implementation is fairly "
"simple."
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:762
#, no-wrap
msgid ""
"      movw $(partbl+0x4),%bx\t# Partition table (+4)\n"
"      xorw %dx,%dx\t\t# Item number\n"
"\n"
"read_entry:\n"
"      movb %ch,-0x4(%bx)\t# Zero active flag (ch == 0)\n"
"      btw %dx,_FLAGS(%bp)\t# Entry enabled?\n"
"      jnc next_entry\t\t# No\n"
"      movb (%bx),%al\t\t# Load type\n"
"      test %al, %al\t\t# skip empty partition\n"
"      jz next_entry\n"
"      movw $bootable_ids,%di\t# Lookup tables\n"
"      movb $(TLEN+1),%cl\t# Number of entries\n"
"      repne\t\t\t# Locate\n"
"      scasb\t\t\t#  type\n"
"      addw $(TLEN-1), %di\t# Adjust\n"
"      movb (%di),%cl\t\t# Partition\n"
"      addw %cx,%di\t\t#  description\n"
"      callw putx\t\t# Display it\n"
"\n"
"next_entry:\n"
"      incw %dx\t\t\t# Next item\n"
"      addb $0x10,%bl\t\t# Next entry\n"
"      jnc read_entry\t\t# Till done"
msgstr ""
"      movw $(partbl+0x4),%bx\t# Partition table (+4)\n"
"      xorw %dx,%dx\t\t# Item number\n"
"\n"
"read_entry:\n"
"      movb %ch,-0x4(%bx)\t# Zero active flag (ch == 0)\n"
"      btw %dx,_FLAGS(%bp)\t# Entry enabled?\n"
"      jnc next_entry\t\t# No\n"
"      movb (%bx),%al\t\t# Load type\n"
"      test %al, %al\t\t# skip empty partition\n"
"      jz next_entry\n"
"      movw $bootable_ids,%di\t# Lookup tables\n"
"      movb $(TLEN+1),%cl\t# Number of entries\n"
"      repne\t\t\t# Locate\n"
"      scasb\t\t\t#  type\n"
"      addw $(TLEN-1), %di\t# Adjust\n"
"      movb (%di),%cl\t\t# Partition\n"
"      addw %cx,%di\t\t#  description\n"
"      callw putx\t\t# Display it\n"
"\n"
"next_entry:\n"
"      incw %dx\t\t\t# Next item\n"
"      addb $0x10,%bl\t\t# Next entry\n"
"      jnc read_entry\t\t# Till done"

#. (itstool) path: sect1/para
#: book.translate.xml:787
msgid ""
"It is important to note that the active flag for each entry is cleared, so "
"after the scanning, <emphasis>no</emphasis> partition entry is active in our "
"memory copy of <filename>boot0</filename>. Later, the active flag will be "
"set for the selected partition. This ensures that only one active partition "
"exists if the user chooses to write the changes back to disk."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:795
msgid ""
"The next block tests for other drives. At startup, the <acronym>BIOS</"
"acronym> writes the number of drives present in the computer to address "
"<literal>0x475</literal>. If there are any other drives present, "
"<filename>boot0</filename> prints the current drive to screen. The user may "
"command <filename>boot0</filename> to scan partitions on another drive later."
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:806
#, no-wrap
msgid ""
"      popw %ax\t\t\t# Drive number\n"
"      subb $0x79,%al\t\t# Does next\n"
"      cmpb 0x475,%al\t\t#  drive exist? (from BIOS?)\n"
"      jb print_drive\t\t# Yes\n"
"      decw %ax\t\t\t# Already drive 0?\n"
"      jz print_prompt\t\t# Yes"
msgstr ""
"      popw %ax\t\t\t# Drive number\n"
"      subb $0x79,%al\t\t# Does next\n"
"      cmpb 0x475,%al\t\t#  drive exist? (from BIOS?)\n"
"      jb print_drive\t\t# Yes\n"
"      decw %ax\t\t\t# Already drive 0?\n"
"      jz print_prompt\t\t# Yes"

#. (itstool) path: sect1/para
#: book.translate.xml:814
msgid ""
"We make the assumption that a single drive is present, so the jump to "
"<literal>print_drive</literal> is not performed. We also assume nothing "
"strange happened, so we jump to <literal>print_prompt</literal>."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:819
msgid ""
"This next block just prints out a prompt followed by the default option:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:825
#, no-wrap
msgid ""
"print_prompt:\n"
"      movw $prompt,%si\t\t# Display\n"
"      callw putstr\t\t#  prompt\n"
"      movb _OPT(%bp),%dl\t# Display\n"
"      decw %si\t\t\t#  default\n"
"      callw putkey\t\t#  key\n"
"      jmp start_input\t\t# Skip beep"
msgstr ""
"print_prompt:\n"
"      movw $prompt,%si\t\t# Display\n"
"      callw putstr\t\t#  prompt\n"
"      movb _OPT(%bp),%dl\t# Display\n"
"      decw %si\t\t\t#  default\n"
"      callw putkey\t\t#  key\n"
"      jmp start_input\t\t# Skip beep"

#. (itstool) path: sect1/para
#: book.translate.xml:834
msgid ""
"Finally, a jump is performed to <literal>start_input</literal>, where the "
"<acronym>BIOS</acronym> services are used to start a timer and for reading "
"user input from the keyboard; if the timer expires, the default option will "
"be selected:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:843
#, no-wrap
msgid ""
"start_input:\n"
"      xorb %ah,%ah\t\t# BIOS: Get\n"
"      int $0x1a\t\t\t#  system time\n"
"      movw %dx,%di\t\t# Ticks when\n"
"      addw _TICKS(%bp),%di\t#  timeout\n"
"read_key:\n"
"      movb $0x1,%ah\t\t# BIOS: Check\n"
"      int $0x16\t\t\t#  for keypress\n"
"      jnz got_key\t\t# Have input\n"
"      xorb %ah,%ah\t\t# BIOS: int 0x1a, 00\n"
"      int $0x1a\t\t\t#  get system time\n"
"      cmpw %di,%dx\t\t# Timeout?\n"
"      jb read_key\t\t# No"
msgstr ""
"start_input:\n"
"      xorb %ah,%ah\t\t# BIOS: Get\n"
"      int $0x1a\t\t\t#  system time\n"
"      movw %dx,%di\t\t# Ticks when\n"
"      addw _TICKS(%bp),%di\t#  timeout\n"
"read_key:\n"
"      movb $0x1,%ah\t\t# BIOS: Check\n"
"      int $0x16\t\t\t#  for keypress\n"
"      jnz got_key\t\t# Have input\n"
"      xorb %ah,%ah\t\t# BIOS: int 0x1a, 00\n"
"      int $0x1a\t\t\t#  get system time\n"
"      cmpw %di,%dx\t\t# Timeout?\n"
"      jb read_key\t\t# No"

#. (itstool) path: sect1/para
#: book.translate.xml:858
msgid ""
"An interrupt is requested with number <literal>0x1a</literal> and argument "
"<literal>0</literal> in register <literal>%ah</literal>. The <acronym>BIOS</"
"acronym> has a predefined set of services, requested by applications as "
"software-generated interrupts through the <literal>int</literal> instruction "
"and receiving arguments in registers (in this case, <literal>%ah</literal>). "
"Here, particularly, we are requesting the number of clock ticks since last "
"midnight; this value is computed by the <acronym>BIOS</acronym> through the "
"<acronym>RTC</acronym> (Real Time Clock). This clock can be programmed to "
"work at frequencies ranging from 2 Hz to 8192 Hz. The <acronym>BIOS</"
"acronym> sets it to 18.2 Hz at startup. When the request is satisfied, a 32-"
"bit result is returned by the <acronym>BIOS</acronym> in registers <literal>"
"%cx</literal> and <literal>%dx</literal> (lower bytes in <literal>%dx</"
"literal>). This result (the <literal>%dx</literal> part) is copied to "
"register <literal>%di</literal>, and the value of the <varname>TICKS</"
"varname> variable is added to <literal>%di</literal>. This variable resides "
"in <filename>boot0</filename> at offset <literal>_TICKS</literal> (a "
"negative value) from register <literal>%bp</literal> (which, recall, points "
"to <literal>0x800</literal>). The default value of this variable is "
"<literal>0xb6</literal> (182 in decimal). Now, the idea is that "
"<filename>boot0</filename> constantly requests the time from the "
"<acronym>BIOS</acronym>, and when the value returned in register <literal>"
"%dx</literal> is greater than the value stored in <literal>%di</literal>, "
"the time is up and the default selection will be made. Since the RTC ticks "
"18.2 times per second, this condition will be met after 10 seconds (this "
"default behavior can be changed in the <filename>Makefile</filename>). Until "
"this time has passed, <filename>boot0</filename> continually asks the "
"<acronym>BIOS</acronym> for any user input; this is done through "
"<literal>int 0x16</literal>, argument <literal>1</literal> in <literal>%ah</"
"literal>."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:895
msgid ""
"Whether a key was pressed or the time expired, subsequent code validates the "
"selection. Based on the selection, the register <literal>%si</literal> is "
"set to point to the appropriate partition entry in the partition table. This "
"new selection overrides the previous default one. Indeed, it becomes the new "
"default. Finally, the ACTIVE flag of the selected partition is set. If it "
"was enabled at compile time, the in-memory version of <filename>boot0</"
"filename> with these modified values is written back to the <acronym>MBR</"
"acronym> on disk. We leave the details of this implementation to the reader."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:907
msgid ""
"We now end our study with the last code block from the <filename>boot0</"
"filename> program:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:913
#, no-wrap
msgid ""
"      movw $0x7c00,%bx\t\t# Address for read\n"
"      movb $0x2,%ah\t\t# Read sector\n"
"      callw intx13\t\t#  from disk\n"
"      jc beep\t\t\t# If error\n"
"      cmpw $0xaa55,0x1fe(%bx)\t# Bootable?\n"
"      jne beep\t\t\t# No\n"
"      pushw %si\t\t\t# Save ptr to selected part.\n"
"      callw putn\t\t# Leave some space\n"
"      popw %si\t\t\t# Restore, next stage uses it\n"
"      jmp *%bx\t\t\t# Invoke bootstrap"
msgstr ""
"      movw $0x7c00,%bx\t\t# Address for read\n"
"      movb $0x2,%ah\t\t# Read sector\n"
"      callw intx13\t\t#  from disk\n"
"      jc beep\t\t\t# If error\n"
"      cmpw $0xaa55,0x1fe(%bx)\t# Bootable?\n"
"      jne beep\t\t\t# No\n"
"      pushw %si\t\t\t# Save ptr to selected part.\n"
"      callw putn\t\t# Leave some space\n"
"      popw %si\t\t\t# Restore, next stage uses it\n"
"      jmp *%bx\t\t\t# Invoke bootstrap"

#. (itstool) path: sect1/para
#: book.translate.xml:925
msgid ""
"Recall that <literal>%si</literal> points to the selected partition entry. "
"This entry tells us where the partition begins on disk. We assume, of "
"course, that the partition selected is actually a FreeBSD slice."
msgstr ""

#. (itstool) path: note/para
#: book.translate.xml:931
msgid ""
"From now on, we will favor the use of the technically more accurate term "
"<quote>slice</quote> rather than <quote>partition</quote>."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:936
msgid ""
"The transfer buffer is set to <literal>0x7c00</literal> (register <literal>"
"%bx</literal>), and a read for the first sector of the FreeBSD slice is "
"requested by calling <literal>intx13</literal>. We assume that everything "
"went okay, so a jump to <literal>beep</literal> is not performed. In "
"particular, the new sector read must end with the magic sequence "
"<literal>0xaa55</literal>. Finally, the value at <literal>%si</literal> (the "
"pointer to the selected partition table) is preserved for use by the next "
"stage, and a jump is performed to address <literal>0x7c00</literal>, where "
"execution of our next stage (the just-read block) is started."
msgstr ""

#. (itstool) path: sect1/title
#: book.translate.xml:950
msgid "<literal>boot1</literal> Stage"
msgstr "<literal>boot1</literal> 阶段"

#. (itstool) path: sect1/para
#: book.translate.xml:952
msgid "So far we have gone through the following sequence:"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:956
msgid ""
"The <acronym>BIOS</acronym> did some early hardware initialization, "
"including the <acronym>POST</acronym>. The <acronym>MBR</acronym> "
"(<filename>boot0</filename>) was loaded from absolute disk sector one to "
"address <literal>0x7c00</literal>. Execution control was passed to that "
"location."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:965
msgid ""
"<filename>boot0</filename> relocated itself to the location it was linked to "
"execute (<literal>0x600</literal>), followed by a jump to continue execution "
"at the appropriate place. Finally, <filename>boot0</filename> loaded the "
"first disk sector from the FreeBSD slice to address <literal>0x7c00</"
"literal>. Execution control was passed to that location."
msgstr ""

#. (itstool) path: footnote/para
#: book.translate.xml:989
msgid ""
"There is a file <filename>/boot/boot1</filename>, but it is not the written "
"to the beginning of the FreeBSD slice. Instead, it is concatenated with "
"<filename>boot2</filename> to form <filename>boot</filename>, which "
"<emphasis>is</emphasis> written to the beginning of the FreeBSD slice and "
"read at boot time."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:975
msgid ""
"<filename>boot1</filename> is the next step in the boot-loading sequence. It "
"is the first of three boot stages. Note that we have been dealing "
"exclusively with disk sectors. Indeed, the <acronym>BIOS</acronym> loads the "
"absolute first sector, while <filename>boot0</filename> loads the first "
"sector of the FreeBSD slice. Both loads are to address <literal>0x7c00</"
"literal>. We can conceptually think of these disk sectors as containing the "
"files <filename>boot0</filename> and <filename>boot1</filename>, "
"respectively, but in reality this is not entirely true for <filename>boot1</"
"filename>. Strictly speaking, unlike <filename>boot0</filename>, "
"<filename>boot1</filename> is not part of the boot blocks <_:footnote-1/>. "
"Instead, a single, full-blown file, <filename>boot</filename> (<filename>/"
"boot/boot</filename>), is what ultimately is written to disk. This file is a "
"combination of <filename>boot1</filename>, <filename>boot2</filename> and "
"the <literal>Boot Extender</literal> (or <acronym>BTX</acronym>). This "
"single file is greater in size than a single sector (greater than 512 "
"bytes). Fortunately, <filename>boot1</filename> occupies <emphasis>exactly</"
"emphasis> the first 512 bytes of this single file, so when <filename>boot0</"
"filename> loads the first sector of the FreeBSD slice (512 bytes), it is "
"actually loading <filename>boot1</filename> and transferring control to it."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1009
msgid ""
"The main task of <filename>boot1</filename> is to load the next boot stage. "
"This next stage is somewhat more complex. It is composed of a server called "
"the <quote>Boot Extender</quote>, or <acronym>BTX</acronym>, and a client, "
"called <filename>boot2</filename>. As we will see, the last boot stage, "
"<filename>loader</filename>, is also a client of the <acronym>BTX</acronym> "
"server."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1017
msgid ""
"Let us now look in detail at what exactly is done by <filename>boot1</"
"filename>, starting like we did for <filename>boot0</filename>, at its entry "
"point:"
msgstr ""

#. (itstool) path: figure/title
#: book.translate.xml:1022 book.translate.xml:1033 book.translate.xml:1073
#: book.translate.xml:1118 book.translate.xml:1153 book.translate.xml:1180
#: book.translate.xml:1209 book.translate.xml:1316
msgid "<filename>sys/boot/i386/boot2/boot1.S</filename>"
msgstr "<filename>sys/boot/i386/boot2/boot1.S</filename>"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1024
#, no-wrap
msgid ""
"start:\n"
"\tjmp main"
msgstr ""
"start:\n"
"\tjmp main"

#. (itstool) path: sect1/para
#: book.translate.xml:1028
msgid ""
"The entry point at <literal>start</literal> simply jumps past a special data "
"area to the label <literal>main</literal>, which in turn looks like this:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1035
#, no-wrap
msgid ""
"main:\n"
"      cld\t\t\t# String ops inc\n"
"      xor %cx,%cx\t\t# Zero\n"
"      mov %cx,%es\t\t# Address\n"
"      mov %cx,%ds\t\t#  data\n"
"      mov %cx,%ss\t\t# Set up\n"
"      mov $start,%sp\t\t#  stack\n"
"      mov %sp,%si\t\t# Source\n"
"      mov $0x700,%di\t\t# Destination\n"
"      incb %ch\t\t\t# Word count\n"
"      rep\t\t\t# Copy\n"
"      movsw\t\t\t#  code"
msgstr ""
"main:\n"
"      cld\t\t\t# String ops inc\n"
"      xor %cx,%cx\t\t# Zero\n"
"      mov %cx,%es\t\t# Address\n"
"      mov %cx,%ds\t\t#  data\n"
"      mov %cx,%ss\t\t# Set up\n"
"      mov $start,%sp\t\t#  stack\n"
"      mov %sp,%si\t\t# Source\n"
"      mov $0x700,%di\t\t# Destination\n"
"      incb %ch\t\t\t# Word count\n"
"      rep\t\t\t# Copy\n"
"      movsw\t\t\t#  code"

#. (itstool) path: sect1/para
#: book.translate.xml:1049
msgid ""
"Just like <filename>boot0</filename>, this code relocates <filename>boot1</"
"filename>, this time to memory address <literal>0x700</literal>. However, "
"unlike <filename>boot0</filename>, it does not jump there. <filename>boot1</"
"filename> is linked to execute at address <literal>0x7c00</literal>, "
"effectively where it was loaded in the first place. The reason for this "
"relocation will be discussed shortly."
msgstr ""

#. (itstool) path: footnote/para
#: book.translate.xml:1062
msgid ""
"Actually we did pass a pointer to the slice entry in register <literal>%si</"
"literal>. However, <filename>boot1</filename> does not assume that it was "
"loaded by <filename>boot0</filename> (perhaps some other <acronym>MBR</"
"acronym> loaded it, and did not pass this information), so it assumes "
"nothing."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1058
msgid ""
"Next comes a loop that looks for the FreeBSD slice. Although "
"<filename>boot0</filename> loaded <filename>boot1</filename> from the "
"FreeBSD slice, no information was passed to it about this <_:footnote-1/>, "
"so <filename>boot1</filename> must rescan the partition table to find where "
"the FreeBSD slice starts. Therefore it rereads the <acronym>MBR</acronym>:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1075
#, no-wrap
msgid ""
"      mov $part4,%si\t\t# Partition\n"
"      cmpb $0x80,%dl\t\t# Hard drive?\n"
"      jb main.4\t\t\t# No\n"
"      movb $0x1,%dh\t\t# Block count\n"
"      callw nread\t\t# Read MBR"
msgstr ""
"      mov $part4,%si\t\t# Partition\n"
"      cmpb $0x80,%dl\t\t# Hard drive?\n"
"      jb main.4\t\t\t# No\n"
"      movb $0x1,%dh\t\t# Block count\n"
"      callw nread\t\t# Read MBR"

#. (itstool) path: sect1/para
#: book.translate.xml:1082
msgid ""
"In the code above, register <literal>%dl</literal> maintains information "
"about the boot device. This is passed on by the <acronym>BIOS</acronym> and "
"preserved by the <acronym>MBR</acronym>. Numbers <literal>0x80</literal> and "
"greater tells us that we are dealing with a hard drive, so a call is made to "
"<literal>nread</literal>, where the <acronym>MBR</acronym> is read. "
"Arguments to <literal>nread</literal> are passed through <literal>%si</"
"literal> and <literal>%dh</literal>. The memory address at label "
"<literal>part4</literal> is copied to <literal>%si</literal>. This memory "
"address holds a <quote>fake partition</quote> to be used by <literal>nread</"
"literal>. The following is the data in the fake partition:"
msgstr ""

#. (itstool) path: figure/title
#: book.translate.xml:1098 book.translate.xml:1392 book.translate.xml:1405
#: book.translate.xml:1437 book.translate.xml:1478
msgid "<filename>sys/boot/i386/boot2/Makefile</filename>"
msgstr "<filename>sys/boot/i386/boot2/Makefile</filename>"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1100
#, no-wrap
msgid ""
"      part4:\n"
"\t.byte 0x80, 0x00, 0x01, 0x00\n"
"\t.byte 0xa5, 0xfe, 0xff, 0xff\n"
"\t.byte 0x00, 0x00, 0x00, 0x00\n"
"\t.byte 0x50, 0xc3, 0x00, 0x00"
msgstr ""
"      part4:\n"
"\t.byte 0x80, 0x00, 0x01, 0x00\n"
"\t.byte 0xa5, 0xfe, 0xff, 0xff\n"
"\t.byte 0x00, 0x00, 0x00, 0x00\n"
"\t.byte 0x50, 0xc3, 0x00, 0x00"

#. (itstool) path: sect1/para
#: book.translate.xml:1107
msgid ""
"In particular, the <acronym>LBA</acronym> for this fake partition is "
"hardcoded to zero. This is used as an argument to the <acronym>BIOS</"
"acronym> for reading absolute sector one from the hard drive. Alternatively, "
"CHS addressing could be used. In this case, the fake partition holds "
"cylinder 0, head 0 and sector 1, which is equivalent to absolute sector one."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1114
msgid "Let us now proceed to take a look at <literal>nread</literal>:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1120
#, no-wrap
msgid ""
"nread:\n"
"      mov $0x8c00,%bx\t\t# Transfer buffer\n"
"      mov 0x8(%si),%ax\t\t# Get\n"
"      mov 0xa(%si),%cx\t\t#  LBA\n"
"      push %cs\t\t\t# Read from\n"
"      callw xread.1\t\t#  disk\n"
"      jnc return\t\t# If success, return"
msgstr ""
"nread:\n"
"      mov $0x8c00,%bx\t\t# Transfer buffer\n"
"      mov 0x8(%si),%ax\t\t# Get\n"
"      mov 0xa(%si),%cx\t\t#  LBA\n"
"      push %cs\t\t\t# Read from\n"
"      callw xread.1\t\t#  disk\n"
"      jnc return\t\t# If success, return"

#. (itstool) path: footnote/para
#: book.translate.xml:1132
msgid "In the context of 16-bit real mode, a word is 2 bytes."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1129
msgid ""
"Recall that <literal>%si</literal> points to the fake partition. The word <_:"
"footnote-1/> at offset <literal>0x8</literal> is copied to register <literal>"
"%ax</literal> and word at offset <literal>0xa</literal> to <literal>%cx</"
"literal>. They are interpreted by the <acronym>BIOS</acronym> as the lower 4-"
"byte value denoting the LBA to be read (the upper four bytes are assumed to "
"be zero). Register <literal>%bx</literal> holds the memory address where the "
"<acronym>MBR</acronym> will be loaded. The instruction pushing <literal>%cs</"
"literal> onto the stack is very interesting. In this context, it "
"accomplishes nothing. However, as we will see shortly, <filename>boot2</"
"filename>, in conjunction with the <acronym>BTX</acronym> server, also uses "
"<literal>xread.1</literal>. This mechanism will be discussed in the next "
"section."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1148
msgid ""
"The code at <literal>xread.1</literal> further calls the <literal>read</"
"literal> function, which actually calls the <acronym>BIOS</acronym> asking "
"for the disk sector:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1155
#, no-wrap
msgid ""
"xread.1:\n"
"\tpushl $0x0\t\t#  absolute\n"
"\tpush %cx\t\t#  block\n"
"\tpush %ax\t\t#  number\n"
"\tpush %es\t\t# Address of\n"
"\tpush %bx\t\t#  transfer buffer\n"
"\txor %ax,%ax\t\t# Number of\n"
"\tmovb %dh,%al\t\t#  blocks to\n"
"\tpush %ax\t\t#  transfer\n"
"\tpush $0x10\t\t# Size of packet\n"
"\tmov %sp,%bp\t\t# Packet pointer\n"
"\tcallw read\t\t# Read from disk\n"
"\tlea 0x10(%bp),%sp\t# Clear stack\n"
"\tlret\t\t\t# To far caller"
msgstr ""
"xread.1:\n"
"\tpushl $0x0\t\t#  absolute\n"
"\tpush %cx\t\t#  block\n"
"\tpush %ax\t\t#  number\n"
"\tpush %es\t\t# Address of\n"
"\tpush %bx\t\t#  transfer buffer\n"
"\txor %ax,%ax\t\t# Number of\n"
"\tmovb %dh,%al\t\t#  blocks to\n"
"\tpush %ax\t\t#  transfer\n"
"\tpush $0x10\t\t# Size of packet\n"
"\tmov %sp,%bp\t\t# Packet pointer\n"
"\tcallw read\t\t# Read from disk\n"
"\tlea 0x10(%bp),%sp\t# Clear stack\n"
"\tlret\t\t\t# To far caller"

#. (itstool) path: sect1/para
#: book.translate.xml:1171
msgid ""
"Note the long return instruction at the end of this block. This instruction "
"pops out the <literal>%cs</literal> register pushed by <literal>nread</"
"literal>, and returns. Finally, <literal>nread</literal> also returns."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1176
msgid ""
"With the <acronym>MBR</acronym> loaded to memory, the actual loop for "
"searching the FreeBSD slice begins:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1182
#, no-wrap
msgid ""
"\tmov $0x1,%cx\t\t # Two passes\n"
"main.1:\n"
"\tmov $0x8dbe,%si # Partition table\n"
"\tmovb $0x1,%dh\t\t # Partition\n"
"main.2:\n"
"\tcmpb $0xa5,0x4(%si)\t # Our partition type?\n"
"\tjne main.3\t\t # No\n"
"\tjcxz main.5\t\t # If second pass\n"
"\ttestb $0x80,(%si)\t # Active?\n"
"\tjnz main.5\t\t # Yes\n"
"main.3:\n"
"\tadd $0x10,%si\t\t # Next entry\n"
"\tincb %dh\t\t # Partition\n"
"\tcmpb $0x5,%dh\t\t # In table?\n"
"\tjb main.2\t\t # Yes\n"
"\tdec %cx\t\t\t # Do two\n"
"\tjcxz main.1\t\t #  passes"
msgstr ""
"\tmov $0x1,%cx\t\t # Two passes\n"
"main.1:\n"
"\tmov $0x8dbe,%si # Partition table\n"
"\tmovb $0x1,%dh\t\t # Partition\n"
"main.2:\n"
"\tcmpb $0xa5,0x4(%si)\t # Our partition type?\n"
"\tjne main.3\t\t # No\n"
"\tjcxz main.5\t\t # If second pass\n"
"\ttestb $0x80,(%si)\t # Active?\n"
"\tjnz main.5\t\t # Yes\n"
"main.3:\n"
"\tadd $0x10,%si\t\t # Next entry\n"
"\tincb %dh\t\t # Partition\n"
"\tcmpb $0x5,%dh\t\t # In table?\n"
"\tjb main.2\t\t # Yes\n"
"\tdec %cx\t\t\t # Do two\n"
"\tjcxz main.1\t\t #  passes"

#. (itstool) path: sect1/para
#: book.translate.xml:1201
msgid ""
"If a FreeBSD slice is identified, execution continues at <literal>main.5</"
"literal>. Note that when a FreeBSD slice is found <literal>%si</literal> "
"points to the appropriate entry in the partition table, and <literal>%dh</"
"literal> holds the partition number. We assume that a FreeBSD slice is "
"found, so we continue execution at <literal>main.5</literal>:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1211
#, no-wrap
msgid ""
"main.5:\n"
"\tmov %dx,0x900\t\t\t   # Save args\n"
"\tmovb $0x10,%dh\t\t\t   # Sector count\n"
"\tcallw nread\t\t\t   # Read disk\n"
"\tmov $0x9000,%bx\t\t\t   # BTX\n"
"\tmov 0xa(%bx),%si\t\t   # Get BTX length and set\n"
"\tadd %bx,%si\t\t\t   #  %si to start of boot2.bin\n"
"\tmov $0xc000,%di\t\t\t   # Client page 2\n"
"\tmov $0xa200,%cx\t\t\t   # Byte\n"
"\tsub %si,%cx\t\t\t   #  count\n"
"\trep\t\t\t\t   # Relocate\n"
"\tmovsb\t\t\t\t   #  client"
msgstr ""
"main.5:\n"
"\tmov %dx,0x900\t\t\t   # Save args\n"
"\tmovb $0x10,%dh\t\t\t   # Sector count\n"
"\tcallw nread\t\t\t   # Read disk\n"
"\tmov $0x9000,%bx\t\t\t   # BTX\n"
"\tmov 0xa(%bx),%si\t\t   # Get BTX length and set\n"
"\tadd %bx,%si\t\t\t   #  %si to start of boot2.bin\n"
"\tmov $0xc000,%di\t\t\t   # Client page 2\n"
"\tmov $0xa200,%cx\t\t\t   # Byte\n"
"\tsub %si,%cx\t\t\t   #  count\n"
"\trep\t\t\t\t   # Relocate\n"
"\tmovsb\t\t\t\t   #  client"

#. (itstool) path: sect1/para
#: book.translate.xml:1225
msgid ""
"Recall that at this point, register <literal>%si</literal> points to the "
"FreeBSD slice entry in the <acronym>MBR</acronym> partition table, so a call "
"to <literal>nread</literal> will effectively read sectors at the beginning "
"of this partition. The argument passed on register <literal>%dh</literal> "
"tells <literal>nread</literal> to read 16 disk sectors. Recall that the "
"first 512 bytes, or the first sector of the FreeBSD slice, coincides with "
"the <filename>boot1</filename> program. Also recall that the file written to "
"the beginning of the FreeBSD slice is not <filename>/boot/boot1</filename>, "
"but <filename>/boot/boot</filename>. Let us look at the size of these files "
"in the filesystem:"
msgstr ""

#. (itstool) path: sect1/screen
#. (itstool) id: book.translate.xml#boot-boot1-filesize
#: book.translate.xml:1238
#, no-wrap
msgid ""
"-r--r--r--  1 root  wheel   512B Jan  8 00:15 /boot/boot0\n"
"-r--r--r--  1 root  wheel   512B Jan  8 00:15 /boot/boot1\n"
"-r--r--r--  1 root  wheel   7.5K Jan  8 00:15 /boot/boot2\n"
"-r--r--r--  1 root  wheel   8.0K Jan  8 00:15 /boot/boot"
msgstr ""
"-r--r--r--  1 root  wheel   512B Jan  8 00:15 /boot/boot0\n"
"-r--r--r--  1 root  wheel   512B Jan  8 00:15 /boot/boot1\n"
"-r--r--r--  1 root  wheel   7.5K Jan  8 00:15 /boot/boot2\n"
"-r--r--r--  1 root  wheel   8.0K Jan  8 00:15 /boot/boot"

#. (itstool) path: sect1/para
#: book.translate.xml:1243
msgid ""
"Both <filename>boot0</filename> and <filename>boot1</filename> are 512 bytes "
"each, so they fit <emphasis>exactly</emphasis> in one disk sector. "
"<filename>boot2</filename> is much bigger, holding both the <acronym>BTX</"
"acronym> server and the <filename>boot2</filename> client. Finally, a file "
"called simply <filename>boot</filename> is 512 bytes larger than "
"<filename>boot2</filename>. This file is a concatenation of <filename>boot1</"
"filename> and <filename>boot2</filename>. As already noted, <filename>boot0</"
"filename> is the file written to the absolute first disk sector (the "
"<acronym>MBR</acronym>), and <filename>boot</filename> is the file written "
"to the first sector of the FreeBSD slice; <filename>boot1</filename> and "
"<filename>boot2</filename> are <emphasis>not</emphasis> written to disk. The "
"command used to concatenate <filename>boot1</filename> and <filename>boot2</"
"filename> into a single <filename>boot</filename> is merely <command>cat "
"boot1 boot2 &gt; boot</command>."
msgstr ""

#. (itstool) path: footnote/para
#: book.translate.xml:1271
msgid "512*16=8192 bytes, exactly the size of <filename>boot</filename>"
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1263
msgid ""
"So <filename>boot1</filename> occupies exactly the first 512 bytes of "
"<filename>boot</filename> and, because <filename>boot</filename> is written "
"to the first sector of the FreeBSD slice, <filename>boot1</filename> fits "
"exactly in this first sector. Because <literal>nread</literal> reads the "
"first 16 sectors of the FreeBSD slice, it effectively reads the entire "
"<filename>boot</filename> file <_:footnote-1/>. We will see more details "
"about how <filename>boot</filename> is formed from <filename>boot1</"
"filename> and <filename>boot2</filename> in the next section."
msgstr ""

#. (itstool) path: footnote/para
#: book.translate.xml:1287
msgid ""
"Historically known as <quote>disklabel</quote>. If you ever wondered where "
"FreeBSD stored this information, it is in this region. See "
"<citerefentry><refentrytitle>bsdlabel</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>"
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1277
msgid ""
"Recall that <literal>nread</literal> uses memory address <literal>0x8c00</"
"literal> as the transfer buffer to hold the sectors read. This address is "
"conveniently chosen. Indeed, because <filename>boot1</filename> belongs to "
"the first 512 bytes, it ends up in the address range <literal>0x8c00</"
"literal>-<literal>0x8dff</literal>. The 512 bytes that follows (range "
"<literal>0x8e00</literal>-<literal>0x8fff</literal>) is used to store the "
"<emphasis>bsdlabel</emphasis> <_:footnote-1/>."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1291
msgid ""
"Starting at address <literal>0x9000</literal> is the beginning of the "
"<acronym>BTX</acronym> server, and immediately following is the "
"<filename>boot2</filename> client. The <acronym>BTX</acronym> server acts as "
"a kernel, and executes in protected mode in the most privileged level. In "
"contrast, the <acronym>BTX</acronym> clients (<filename>boot2</filename>, "
"for example), execute in user mode. We will see how this is accomplished in "
"the next section. The code after the call to <literal>nread</literal> "
"locates the beginning of <filename>boot2</filename> in the memory buffer, "
"and copies it to memory address <literal>0xc000</literal>. This is because "
"the <acronym>BTX</acronym> server arranges <filename>boot2</filename> to "
"execute in a segment starting at <literal>0xa000</literal>. We explore this "
"in detail in the following section."
msgstr ""

#. (itstool) path: footnote/para
#: book.translate.xml:1310
msgid ""
"This is necessary for legacy reasons. Interested readers should see <link "
"xlink:href=\"http://en.wikipedia.org/wiki/A20_line\"/>."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1307
msgid ""
"The last code block of <filename>boot1</filename> enables access to memory "
"above 1MB <_:footnote-1/> and concludes with a jump to the starting point of "
"the <acronym>BTX</acronym> server:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1318
#, no-wrap
msgid ""
"seta20:\n"
"\tcli\t\t\t# Disable interrupts\n"
"seta20.1:\n"
"\tdec %cx\t\t\t# Timeout?\n"
"\tjz seta20.3\t\t# Yes\n"
"\n"
"\tinb $0x64,%al\t\t# Get status\n"
"\ttestb $0x2,%al\t\t# Busy?\n"
"\tjnz seta20.1\t\t# Yes\n"
"\tmovb $0xd1,%al\t\t# Command: Write\n"
"\toutb %al,$0x64\t\t#  output port\n"
"seta20.2:\n"
"\tinb $0x64,%al\t\t# Get status\n"
"\ttestb $0x2,%al\t\t# Busy?\n"
"\tjnz seta20.2\t\t# Yes\n"
"\tmovb $0xdf,%al\t\t# Enable\n"
"\toutb %al,$0x60\t\t#  A20\n"
"seta20.3:\n"
"\tsti\t\t\t# Enable interrupts\n"
"\tjmp 0x9010\t\t# Start BTX"
msgstr ""
"seta20:\n"
"\tcli\t\t\t# Disable interrupts\n"
"seta20.1:\n"
"\tdec %cx\t\t\t# Timeout?\n"
"\tjz seta20.3\t\t# Yes\n"
"\n"
"\tinb $0x64,%al\t\t# Get status\n"
"\ttestb $0x2,%al\t\t# Busy?\n"
"\tjnz seta20.1\t\t# Yes\n"
"\tmovb $0xd1,%al\t\t# Command: Write\n"
"\toutb %al,$0x64\t\t#  output port\n"
"seta20.2:\n"
"\tinb $0x64,%al\t\t# Get status\n"
"\ttestb $0x2,%al\t\t# Busy?\n"
"\tjnz seta20.2\t\t# Yes\n"
"\tmovb $0xdf,%al\t\t# Enable\n"
"\toutb %al,$0x60\t\t#  A20\n"
"seta20.3:\n"
"\tsti\t\t\t# Enable interrupts\n"
"\tjmp 0x9010\t\t# Start BTX"

#. (itstool) path: sect1/para
#: book.translate.xml:1340
msgid "Note that right before the jump, interrupts are enabled."
msgstr ""

#. (itstool) path: sect1/title
#: book.translate.xml:1345
msgid "The <acronym>BTX</acronym> Server"
msgstr "<acronym>BTX</acronym> 服务器"

#. (itstool) path: sect1/para
#: book.translate.xml:1347
msgid ""
"Next in our boot sequence is the <acronym>BTX</acronym> Server. Let us "
"quickly remember how we got here:"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1353
msgid ""
"The <acronym>BIOS</acronym> loads the absolute sector one (the <acronym>MBR</"
"acronym>, or <filename>boot0</filename>), to address <literal>0x7c00</"
"literal> and jumps there."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1360
msgid ""
"<filename>boot0</filename> relocates itself to <literal>0x600</literal>, the "
"address it was linked to execute, and jumps over there. It then reads the "
"first sector of the FreeBSD slice (which consists of <filename>boot1</"
"filename>) into address <literal>0x7c00</literal> and jumps over there."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1369
msgid ""
"<filename>boot1</filename> loads the first 16 sectors of the FreeBSD slice "
"into address <literal>0x8c00</literal>. This 16 sectors, or 8192 bytes, is "
"the whole file <filename>boot</filename>. The file is a concatenation of "
"<filename>boot1</filename> and <filename>boot2</filename>. <filename>boot2</"
"filename>, in turn, contains the <acronym>BTX</acronym> server and the "
"<filename>boot2</filename> client. Finally, a jump is made to address "
"<literal>0x9010</literal>, the entry point of the <acronym>BTX</acronym> "
"server."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1382
msgid ""
"Before studying the <acronym>BTX</acronym> Server in detail, let us further "
"review how the single, all-in-one <filename>boot</filename> file is created. "
"The way <filename>boot</filename> is built is defined in its "
"<filename>Makefile</filename> (<filename>/usr/src/sys/boot/i386/boot2/"
"Makefile</filename>). Let us look at the rule that creates the "
"<filename>boot</filename> file:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1394
#, no-wrap
msgid ""
"      boot: boot1 boot2\n"
"\tcat boot1 boot2 &gt; boot"
msgstr ""
"      boot: boot1 boot2\n"
"\tcat boot1 boot2 &gt; boot"

#. (itstool) path: sect1/para
#: book.translate.xml:1398
msgid ""
"This tells us that <filename>boot1</filename> and <filename>boot2</filename> "
"are needed, and the rule simply concatenates them to produce a single file "
"called <filename>boot</filename>. The rules for creating <filename>boot1</"
"filename> are also quite simple:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1407
#, no-wrap
msgid ""
"      boot1: boot1.out\n"
"\tobjcopy -S -O binary boot1.out boot1\n"
"\n"
"      boot1.out: boot1.o\n"
"\tld -e start -Ttext 0x7c00 -o boot1.out boot1.o"
msgstr ""
"      boot1: boot1.out\n"
"\tobjcopy -S -O binary boot1.out boot1\n"
"\n"
"      boot1.out: boot1.o\n"
"\tld -e start -Ttext 0x7c00 -o boot1.out boot1.o"

#. (itstool) path: sect1/para
#: book.translate.xml:1414
msgid ""
"To apply the rule for creating <filename>boot1</filename>, <filename>boot1."
"out</filename> must be resolved. This, in turn, depends on the existence of "
"<filename>boot1.o</filename>. This last file is simply the result of "
"assembling our familiar <filename>boot1.S</filename>, without linking. Now, "
"the rule for creating <filename>boot1.out</filename> is applied. This tells "
"us that <filename>boot1.o</filename> should be linked with <literal>start</"
"literal> as its entry point, and starting at address <literal>0x7c00</"
"literal>. Finally, <filename>boot1</filename> is created from "
"<filename>boot1.out</filename> applying the appropriate rule. This rule is "
"the <filename>objcopy</filename> command applied to <filename>boot1.out</"
"filename>. Note the flags passed to <filename>objcopy</filename>: <literal>-"
"S</literal> tells it to strip all relocation and symbolic information; "
"<literal>-O binary</literal> indicates the output format, that is, a simple, "
"unformatted binary file."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1433
msgid ""
"Having <filename>boot1</filename>, let us take a look at how "
"<filename>boot2</filename> is constructed:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1439
#, no-wrap
msgid ""
"      boot2: boot2.ld\n"
"\t@set -- `ls -l boot2.ld`; x=$$((7680-$$5)); \\\n"
"\t    echo \"$$x bytes available\"; test $$x -ge 0\n"
"\tdd if=boot2.ld of=boot2 obs=7680 conv=osync\n"
"\n"
"      boot2.ld: boot2.ldr boot2.bin ../btx/btx/btx\n"
"\tbtxld -v -E 0x2000 -f bin -b ../btx/btx/btx -l boot2.ldr \\\n"
"\t    -o boot2.ld -P 1 boot2.bin\n"
"\n"
"      boot2.ldr:\n"
"\tdd if=/dev/zero of=boot2.ldr bs=512 count=1\n"
"\n"
"      boot2.bin: boot2.out\n"
"\tobjcopy -S -O binary boot2.out boot2.bin\n"
"\n"
"      boot2.out: ../btx/lib/crt0.o boot2.o sio.o\n"
"\tld -Ttext 0x2000 -o boot2.out\n"
"\n"
"      boot2.o: boot2.s\n"
"\t${CC} ${ACFLAGS} -c boot2.s\n"
"\n"
"      boot2.s: boot2.c boot2.h ${.CURDIR}/../../common/ufsread.c\n"
"\t${CC} ${CFLAGS} -S -o boot2.s.tmp ${.CURDIR}/boot2.c\n"
"\tsed -e '/align/d' -e '/nop/d' \"MISSING\" boot2.s.tmp &gt; boot2.s\n"
"\trm -f boot2.s.tmp\n"
"\n"
"      boot2.h: boot1.out\n"
"\t${NM} -t d ${.ALLSRC} | awk '/([0-9])+ T xread/ \\\n"
"\t    { x = $$1 - ORG1; \\\n"
"\t    printf(\"#define XREADORG %#x\\n\", REL1 + x) }' \\\n"
"\t    ORG1=`printf \"%d\" ${ORG1}` \\\n"
"\t    REL1=`printf \"%d\" ${REL1}` &gt; ${.TARGET}"
msgstr ""
"      boot2: boot2.ld\n"
"\t@set -- `ls -l boot2.ld`; x=$$((7680-$$5)); \\\n"
"\t    echo \"$$x bytes available\"; test $$x -ge 0\n"
"\tdd if=boot2.ld of=boot2 obs=7680 conv=osync\n"
"\n"
"      boot2.ld: boot2.ldr boot2.bin ../btx/btx/btx\n"
"\tbtxld -v -E 0x2000 -f bin -b ../btx/btx/btx -l boot2.ldr \\\n"
"\t    -o boot2.ld -P 1 boot2.bin\n"
"\n"
"      boot2.ldr:\n"
"\tdd if=/dev/zero of=boot2.ldr bs=512 count=1\n"
"\n"
"      boot2.bin: boot2.out\n"
"\tobjcopy -S -O binary boot2.out boot2.bin\n"
"\n"
"      boot2.out: ../btx/lib/crt0.o boot2.o sio.o\n"
"\tld -Ttext 0x2000 -o boot2.out\n"
"\n"
"      boot2.o: boot2.s\n"
"\t${CC} ${ACFLAGS} -c boot2.s\n"
"\n"
"      boot2.s: boot2.c boot2.h ${.CURDIR}/../../common/ufsread.c\n"
"\t${CC} ${CFLAGS} -S -o boot2.s.tmp ${.CURDIR}/boot2.c\n"
"\tsed -e '/align/d' -e '/nop/d' \"MISSING\" boot2.s.tmp &gt; boot2.s\n"
"\trm -f boot2.s.tmp\n"
"\n"
"      boot2.h: boot1.out\n"
"\t${NM} -t d ${.ALLSRC} | awk '/([0-9])+ T xread/ \\\n"
"\t    { x = $$1 - ORG1; \\\n"
"\t    printf(\"#define XREADORG %#x\\n\", REL1 + x) }' \\\n"
"\t    ORG1=`printf \"%d\" ${ORG1}` \\\n"
"\t    REL1=`printf \"%d\" ${REL1}` &gt; ${.TARGET}"

#. (itstool) path: sect1/para
#: book.translate.xml:1473
msgid ""
"The mechanism for building <filename>boot2</filename> is far more elaborate. "
"Let us point out the most relevant facts. The dependency list is as follows:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1480
#, no-wrap
msgid ""
"      boot2: boot2.ld\n"
"      boot2.ld: boot2.ldr boot2.bin ${BTXDIR}/btx/btx\n"
"      boot2.bin: boot2.out\n"
"      boot2.out: ${BTXDIR}/lib/crt0.o boot2.o sio.o\n"
"      boot2.o: boot2.s\n"
"      boot2.s: boot2.c boot2.h ${.CURDIR}/../../common/ufsread.c\n"
"      boot2.h: boot1.out"
msgstr ""
"      boot2: boot2.ld\n"
"      boot2.ld: boot2.ldr boot2.bin ${BTXDIR}/btx/btx\n"
"      boot2.bin: boot2.out\n"
"      boot2.out: ${BTXDIR}/lib/crt0.o boot2.o sio.o\n"
"      boot2.o: boot2.s\n"
"      boot2.s: boot2.c boot2.h ${.CURDIR}/../../common/ufsread.c\n"
"      boot2.h: boot1.out"

#. (itstool) path: sect1/para
#: book.translate.xml:1489
msgid ""
"Note that initially there is no header file <filename>boot2.h</filename>, "
"but its creation depends on <filename>boot1.out</filename>, which we already "
"have. The rule for its creation is a bit terse, but the important thing is "
"that the output, <filename>boot2.h</filename>, is something like this:"
msgstr ""

#. (itstool) path: figure/title
#: book.translate.xml:1497
msgid "<filename>sys/boot/i386/boot2/boot2.h</filename>"
msgstr "<filename>sys/boot/i386/boot2/boot2.h</filename>"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1499
#, fuzzy, no-wrap
#| msgid ""
#| "\n"
#| "      #define XREADORG 0x725"
msgid "#define XREADORG 0x725"
msgstr ""
"\n"
"      #define XREADORG 0x725"

#. (itstool) path: sect1/para
#: book.translate.xml:1502
msgid ""
"Recall that <filename>boot1</filename> was relocated (i.e., copied from "
"<literal>0x7c00</literal> to <literal>0x700</literal>). This relocation will "
"now make sense, because as we will see, the <acronym>BTX</acronym> server "
"reclaims some memory, including the space where <filename>boot1</filename> "
"was originally loaded. However, the <acronym>BTX</acronym> server needs "
"access to <filename>boot1</filename>'s <literal>xread</literal> function; "
"this function, according to the output of <filename>boot2.h</filename>, is "
"at location <literal>0x725</literal>. Indeed, the <acronym>BTX</acronym> "
"server uses the <literal>xread</literal> function from <filename>boot1</"
"filename>'s relocated code. This function is now accessible from within the "
"<filename>boot2</filename> client."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1519
msgid ""
"We next build <filename>boot2.s</filename> from files <filename>boot2.h</"
"filename>, <filename>boot2.c</filename> and <filename>/usr/src/sys/boot/"
"common/ufsread.c</filename>. The rule for this is to compile the code in "
"<filename>boot2.c</filename> (which includes <filename>boot2.h</filename> "
"and <filename>ufsread.c</filename>) into assembly code. Having "
"<filename>boot2.s</filename>, the next rule assembles <filename>boot2.s</"
"filename>, creating the object file <filename>boot2.o</filename>. The next "
"rule directs the linker to link various files (<filename>crt0.o</filename>, "
"<filename>boot2.o</filename> and <filename>sio.o</filename>). Note that the "
"output file, <filename>boot2.out</filename>, is linked to execute at address "
"<literal>0x2000</literal>. Recall that <filename>boot2</filename> will be "
"executed in user mode, within a special user segment set up by the "
"<acronym>BTX</acronym> server. This segment starts at <literal>0xa000</"
"literal>. Also, remember that the <filename>boot2</filename> portion of "
"<filename>boot</filename> was copied to address <literal>0xc000</literal>, "
"that is, offset <literal>0x2000</literal> from the start of the user "
"segment, so <filename>boot2</filename> will work properly when we transfer "
"control to it. Next, <filename>boot2.bin</filename> is created from "
"<filename>boot2.out</filename> by stripping its symbols and format "
"information; boot2.bin is a <emphasis>raw</emphasis> binary. Now, note that "
"a file <filename>boot2.ldr</filename> is created as a 512-byte file full of "
"zeros. This space is reserved for the bsdlabel."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1548
msgid ""
"Now that we have files <filename>boot1</filename>, <filename>boot2.bin</"
"filename> and <filename>boot2.ldr</filename>, only the <acronym>BTX</"
"acronym> server is missing before creating the all-in-one <filename>boot</"
"filename> file. The <acronym>BTX</acronym> server is located in <filename>/"
"usr/src/sys/boot/i386/btx/btx</filename>; it has its own <filename>Makefile</"
"filename> with its own set of rules for building. The important thing to "
"notice is that it is also compiled as a <emphasis>raw</emphasis> binary, and "
"that it is linked to execute at address <literal>0x9000</literal>. The "
"details can be found in <filename>/usr/src/sys/boot/i386/btx/btx/Makefile</"
"filename>."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1562
msgid ""
"Having the files that comprise the <filename>boot</filename> program, the "
"final step is to <emphasis>merge</emphasis> them. This is done by a special "
"program called <filename>btxld</filename> (source located in <filename>/usr/"
"src/usr.sbin/btxld</filename>). Some arguments to this program include the "
"name of the output file (<filename>boot</filename>), its entry point "
"(<literal>0x2000</literal>) and its file format (raw binary). The various "
"files are finally merged by this utility into the file <filename>boot</"
"filename>, which consists of <filename>boot1</filename>, <filename>boot2</"
"filename>, the <literal>bsdlabel</literal> and the <acronym>BTX</acronym> "
"server. This file, which takes exactly 16 sectors, or 8192 bytes, is what is "
"actually written to the beginning of the FreeBSD slice during installation. "
"Let us now proceed to study the <acronym>BTX</acronym> server program."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1581
msgid ""
"The <acronym>BTX</acronym> server prepares a simple environment and switches "
"from 16-bit real mode to 32-bit protected mode, right before passing control "
"to the client. This includes initializing and updating the following data "
"structures:"
msgstr ""

#. (itstool) path: sect1/indexterm
#: book.translate.xml:1587
msgid "<primary>virtual v86 mode</primary>"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1590
msgid ""
"Modifies the <literal>Interrupt Vector Table (IVT)</literal>. The "
"<acronym>IVT</acronym> provides exception and interrupt handlers for Real-"
"Mode code."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1597
msgid ""
"The <literal>Interrupt Descriptor Table (IDT)</literal> is created. Entries "
"are provided for processor exceptions, hardware interrupts, two system calls "
"and V86 interface. The IDT provides exception and interrupt handlers for "
"Protected-Mode code."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1605
msgid ""
"A <literal>Task-State Segment (TSS)</literal> is created. This is necessary "
"because the processor works in the <emphasis>least</emphasis> privileged "
"level when executing the client (<filename>boot2</filename>), but in the "
"<emphasis>most</emphasis> privileged level when executing the <acronym>BTX</"
"acronym> server."
msgstr ""

#. (itstool) path: footnote/para
#: book.translate.xml:1619
msgid ""
"Real-mode code and data are necessary when switching back to real mode from "
"protected mode, as suggested by the Intel manuals."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:1614
msgid ""
"The <acronym>GDT</acronym> (Global Descriptor Table) is set up. Entries "
"(descriptors) are provided for supervisor code and data, user code and data, "
"and real-mode code and data. <_:footnote-1/>"
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1625
msgid ""
"Let us now start studying the actual implementation. Recall that "
"<filename>boot1</filename> made a jump to address <literal>0x9010</literal>, "
"the <acronym>BTX</acronym> server's entry point. Before studying program "
"execution there, note that the <acronym>BTX</acronym> server has a special "
"header at address range <literal>0x9000-0x900f</literal>, right before its "
"entry point. This header is defined as follows:"
msgstr ""

#. (itstool) path: figure/title
#: book.translate.xml:1634 book.translate.xml:1665 book.translate.xml:1694
#: book.translate.xml:1735 book.translate.xml:1763 book.translate.xml:1834
#: book.translate.xml:1860 book.translate.xml:1911
msgid "<filename>sys/boot/i386/btx/btx/btx.S</filename>"
msgstr "<filename>sys/boot/i386/btx/btx/btx.S</filename>"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1636
#, no-wrap
msgid ""
"start:\t\t\t\t\t\t# Start of code\n"
"/*\n"
" * BTX header.\n"
" */\n"
"btx_hdr:\t.byte 0xeb\t\t\t# Machine ID\n"
"\t\t.byte 0xe\t\t\t# Header size\n"
"\t\t.ascii \"BTX\"\t\t\t# Magic\n"
"\t\t.byte 0x1\t\t\t# Major version\n"
"\t\t.byte 0x2\t\t\t# Minor version\n"
"\t\t.byte BTX_FLAGS\t\t\t# Flags\n"
"\t\t.word PAG_CNT-MEM_ORG&gt;&gt;0xc\t# Paging control\n"
"\t\t.word break-start\t\t# Text size\n"
"\t\t.long 0x0\t\t\t# Entry address"
msgstr ""
"start:\t\t\t\t\t\t# Start of code\n"
"/*\n"
" * BTX header.\n"
" */\n"
"btx_hdr:\t.byte 0xeb\t\t\t# Machine ID\n"
"\t\t.byte 0xe\t\t\t# Header size\n"
"\t\t.ascii \"BTX\"\t\t\t# Magic\n"
"\t\t.byte 0x1\t\t\t# Major version\n"
"\t\t.byte 0x2\t\t\t# Minor version\n"
"\t\t.byte BTX_FLAGS\t\t\t# Flags\n"
"\t\t.word PAG_CNT-MEM_ORG&gt;&gt;0xc\t# Paging control\n"
"\t\t.word break-start\t\t# Text size\n"
"\t\t.long 0x0\t\t\t# Entry address"

#. (itstool) path: sect1/para
#: book.translate.xml:1651
msgid ""
"Note the first two bytes are <literal>0xeb</literal> and <literal>0xe</"
"literal>. In the IA-32 architecture, these two bytes are interpreted as a "
"relative jump past the header into the entry point, so in theory, "
"<filename>boot1</filename> could jump here (address <literal>0x9000</"
"literal>) instead of address <literal>0x9010</literal>. Note that the last "
"field in the <acronym>BTX</acronym> header is a pointer to the client's "
"(<filename>boot2</filename>) entry point. This field is patched at link time."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1661
msgid ""
"Immediately following the header is the <acronym>BTX</acronym> server's "
"entry point:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1667
#, no-wrap
msgid ""
"/*\n"
" * Initialization routine.\n"
" */\n"
"init:\t\tcli\t\t\t\t# Disable interrupts\n"
"\t\txor %ax,%ax\t\t\t# Zero/segment\n"
"\t\tmov %ax,%ss\t\t\t# Set up\n"
"\t\tmov $0x1800,%sp\t\t#  stack\n"
"\t\tmov %ax,%es\t\t\t# Address\n"
"\t\tmov %ax,%ds\t\t\t#  data\n"
"\t\tpushl $0x2\t\t\t# Clear\n"
"\t\tpopfl\t\t\t\t#  flags"
msgstr ""
"/*\n"
" * Initialization routine.\n"
" */\n"
"init:\t\tcli\t\t\t\t# Disable interrupts\n"
"\t\txor %ax,%ax\t\t\t# Zero/segment\n"
"\t\tmov %ax,%ss\t\t\t# Set up\n"
"\t\tmov $0x1800,%sp\t\t#  stack\n"
"\t\tmov %ax,%es\t\t\t# Address\n"
"\t\tmov %ax,%ds\t\t\t#  data\n"
"\t\tpushl $0x2\t\t\t# Clear\n"
"\t\tpopfl\t\t\t\t#  flags"

#. (itstool) path: sect1/para
#: book.translate.xml:1680
msgid ""
"This code disables interrupts, sets up a working stack (starting at address "
"<literal>0x1800</literal>) and clears the flags in the EFLAGS register. Note "
"that the <literal>popfl</literal> instruction pops out a doubleword (4 "
"bytes) from the stack and places it in the EFLAGS register. Because the "
"value actually popped is <literal>2</literal>, the EFLAGS register is "
"effectively cleared (IA-32 requires that bit 2 of the EFLAGS register always "
"be 1)."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1689
msgid ""
"Our next code block clears (sets to <literal>0</literal>) the memory range "
"<literal>0x5e00-0x8fff</literal>. This range is where the various data "
"structures will be created:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1696
#, no-wrap
msgid ""
"/*\n"
" * Initialize memory.\n"
" */\n"
"\t\tmov $0x5e00,%di\t\t# Memory to initialize\n"
"\t\tmov $(0x9000-0x5e00)/2,%cx\t# Words to zero\n"
"\t\trep\t\t\t\t# Zero-fill\n"
"\t\tstosw\t\t\t\t#  memory"
msgstr ""
"/*\n"
" * Initialize memory.\n"
" */\n"
"\t\tmov $0x5e00,%di\t\t# Memory to initialize\n"
"\t\tmov $(0x9000-0x5e00)/2,%cx\t# Words to zero\n"
"\t\trep\t\t\t\t# Zero-fill\n"
"\t\tstosw\t\t\t\t#  memory"

#. (itstool) path: sect1/para
#: book.translate.xml:1705
msgid ""
"Recall that <filename>boot1</filename> was originally loaded to address "
"<literal>0x7c00</literal>, so, with this memory initialization, that copy "
"effectively disappeared. However, also recall that <filename>boot1</"
"filename> was relocated to <literal>0x700</literal>, so <emphasis>that</"
"emphasis> copy is still in memory, and the <acronym>BTX</acronym> server "
"will make use of it."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1713
msgid ""
"Next, the real-mode <acronym>IVT</acronym> (Interrupt Vector Table is "
"updated. The <acronym>IVT</acronym> is an array of segment/offset pairs for "
"exception and interrupt handlers. The <acronym>BIOS</acronym> normally maps "
"hardware interrupts to interrupt vectors <literal>0x8</literal> to "
"<literal>0xf</literal> and <literal>0x70</literal> to <literal>0x77</"
"literal> but, as will be seen, the 8259A Programmable Interrupt Controller, "
"the chip controlling the actual mapping of hardware interrupts to interrupt "
"vectors, is programmed to remap these interrupt vectors from "
"<literal>0x8-0xf</literal> to <literal>0x20-0x27</literal> and from "
"<literal>0x70-0x77</literal> to <literal>0x28-0x2f</literal>. Thus, "
"interrupt handlers are provided for interrupt vectors <literal>0x20-0x2f</"
"literal>. The reason the <acronym>BIOS</acronym>-provided handlers are not "
"used directly is because they work in 16-bit real mode, but not 32-bit "
"protected mode. Processor mode will be switched to 32-bit protected mode "
"shortly. However, the <acronym>BTX</acronym> server sets up a mechanism to "
"effectively use the handlers provided by the <acronym>BIOS</acronym>:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1737
#, no-wrap
msgid ""
"/*\n"
" * Update real mode IDT for reflecting hardware interrupts.\n"
" */\n"
"\t\tmov $intr20,%bx\t\t\t# Address first handler\n"
"\t\tmov $0x10,%cx\t\t\t# Number of handlers\n"
"\t\tmov $0x20*4,%di\t\t\t# First real mode IDT entry\n"
"init.0:\t\tmov %bx,(%di)\t\t\t# Store IP\n"
"\t\tinc %di\t\t\t\t# Address next\n"
"\t\tinc %di\t\t\t\t#  entry\n"
"\t\tstosw\t\t\t\t# Store CS\n"
"\t\tadd $4,%bx\t\t\t# Next handler\n"
"\t\tloop init.0\t\t\t# Next IRQ"
msgstr ""
"/*\n"
" * Update real mode IDT for reflecting hardware interrupts.\n"
" */\n"
"\t\tmov $intr20,%bx\t\t\t# Address first handler\n"
"\t\tmov $0x10,%cx\t\t\t# Number of handlers\n"
"\t\tmov $0x20*4,%di\t\t\t# First real mode IDT entry\n"
"init.0:\t\tmov %bx,(%di)\t\t\t# Store IP\n"
"\t\tinc %di\t\t\t\t# Address next\n"
"\t\tinc %di\t\t\t\t#  entry\n"
"\t\tstosw\t\t\t\t# Store CS\n"
"\t\tadd $4,%bx\t\t\t# Next handler\n"
"\t\tloop init.0\t\t\t# Next IRQ"

#. (itstool) path: sect1/para
#: book.translate.xml:1751
msgid ""
"The next block creates the <acronym>IDT</acronym> (Interrupt Descriptor "
"Table). The <acronym>IDT</acronym> is analogous, in protected mode, to the "
"<acronym>IVT</acronym> in real mode. That is, the <acronym>IDT</acronym> "
"describes the various exception and interrupt handlers used when the "
"processor is executing in protected mode. In essence, it also consists of an "
"array of segment/offset pairs, although the structure is somewhat more "
"complex, because segments in protected mode are different than in real mode, "
"and various protection mechanisms apply:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1765
#, no-wrap
msgid ""
"/*\n"
" * Create IDT.\n"
" */\n"
"\t\tmov $0x5e00,%di\t\t\t# IDT's address\n"
"\t\tmov $idtctl,%si\t\t\t# Control string\n"
"init.1:\t\tlodsb\t\t\t\t# Get entry\n"
"\t\tcbw\t\t\t\t#  count\n"
"\t\txchg %ax,%cx\t\t\t#  as word\n"
"\t\tjcxz init.4\t\t\t# If done\n"
"\t\tlodsb\t\t\t\t# Get segment\n"
"\t\txchg %ax,%dx\t\t\t#  P:DPL:type\n"
"\t\tlodsw\t\t\t\t# Get control\n"
"\t\txchg %ax,%bx\t\t\t#  set\n"
"\t\tlodsw\t\t\t\t# Get handler offset\n"
"\t\tmov $SEL_SCODE,%dh\t\t# Segment selector\n"
"init.2:\t\tshr %bx\t\t\t\t# Handle this int?\n"
"\t\tjnc init.3\t\t\t# No\n"
"\t\tmov %ax,(%di)\t\t\t# Set handler offset\n"
"\t\tmov %dh,0x2(%di)\t\t#  and selector\n"
"\t\tmov %dl,0x5(%di)\t\t# Set P:DPL:type\n"
"\t\tadd $0x4,%ax\t\t\t# Next handler\n"
"init.3:\t\tlea 0x8(%di),%di\t\t# Next entry\n"
"\t\tloop init.2\t\t\t# Till set done\n"
"\t\tjmp init.1\t\t\t# Continue"
msgstr ""
"/*\n"
" * Create IDT.\n"
" */\n"
"\t\tmov $0x5e00,%di\t\t\t# IDT's address\n"
"\t\tmov $idtctl,%si\t\t\t# Control string\n"
"init.1:\t\tlodsb\t\t\t\t# Get entry\n"
"\t\tcbw\t\t\t\t#  count\n"
"\t\txchg %ax,%cx\t\t\t#  as word\n"
"\t\tjcxz init.4\t\t\t# If done\n"
"\t\tlodsb\t\t\t\t# Get segment\n"
"\t\txchg %ax,%dx\t\t\t#  P:DPL:type\n"
"\t\tlodsw\t\t\t\t# Get control\n"
"\t\txchg %ax,%bx\t\t\t#  set\n"
"\t\tlodsw\t\t\t\t# Get handler offset\n"
"\t\tmov $SEL_SCODE,%dh\t\t# Segment selector\n"
"init.2:\t\tshr %bx\t\t\t\t# Handle this int?\n"
"\t\tjnc init.3\t\t\t# No\n"
"\t\tmov %ax,(%di)\t\t\t# Set handler offset\n"
"\t\tmov %dh,0x2(%di)\t\t#  and selector\n"
"\t\tmov %dl,0x5(%di)\t\t# Set P:DPL:type\n"
"\t\tadd $0x4,%ax\t\t\t# Next handler\n"
"init.3:\t\tlea 0x8(%di),%di\t\t# Next entry\n"
"\t\tloop init.2\t\t\t# Till set done\n"
"\t\tjmp init.1\t\t\t# Continue"

#. (itstool) path: sect1/para
#: book.translate.xml:1791
msgid ""
"Each entry in the <literal>IDT</literal> is 8 bytes long. Besides the "
"segment/offset information, they also describe the segment type, privilege "
"level, and whether the segment is present in memory or not. The construction "
"is such that interrupt vectors from <literal>0</literal> to <literal>0xf</"
"literal> (exceptions) are handled by function <literal>intx00</literal>; "
"vector <literal>0x10</literal> (also an exception) is handled by "
"<literal>intx10</literal>; hardware interrupts, which are later configured "
"to start at interrupt vector <literal>0x20</literal> all the way to "
"interrupt vector <literal>0x2f</literal>, are handled by function "
"<literal>intx20</literal>. Lastly, interrupt vector <literal>0x30</literal>, "
"which is used for system calls, is handled by <literal>intx30</literal>, and "
"vectors <literal>0x31</literal> and <literal>0x32</literal> are handled by "
"<literal>intx31</literal>. It must be noted that only descriptors for "
"interrupt vectors <literal>0x30</literal>, <literal>0x31</literal> and "
"<literal>0x32</literal> are given privilege level 3, the same privilege "
"level as the <filename>boot2</filename> client, which means the client can "
"execute a software-generated interrupt to this vectors through the "
"<literal>int</literal> instruction without failing (this is the way "
"<filename>boot2</filename> use the services provided by the <acronym>BTX</"
"acronym> server). Also, note that <emphasis>only</emphasis> software-"
"generated interrupts are protected from code executing in lesser privilege "
"levels. Hardware-generated interrupts and processor-generated exceptions are "
"<emphasis>always</emphasis> handled adequately, regardless of the actual "
"privileges involved."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1821
msgid ""
"The next step is to initialize the <acronym>TSS</acronym> (Task-State "
"Segment). The <acronym>TSS</acronym> is a hardware feature that helps the "
"operating system or executive software implement multitasking functionality "
"through process abstraction. The IA-32 architecture demands the creation and "
"use of <emphasis>at least</emphasis> one <acronym>TSS</acronym> if "
"multitasking facilities are used or different privilege levels are defined. "
"Because the <filename>boot2</filename> client is executed in privilege level "
"3, but the <acronym>BTX</acronym> server does in privilege level 0, a "
"<acronym>TSS</acronym> must be defined:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1836
#, no-wrap
msgid ""
"/*\n"
" * Initialize TSS.\n"
" */\n"
"init.4:\t\tmovb $_ESP0H,TSS_ESP0+1(%di)\t# Set ESP0\n"
"\t\tmovb $SEL_SDATA,TSS_SS0(%di)\t# Set SS0\n"
"\t\tmovb $_TSSIO,TSS_MAP(%di)\t# Set I/O bit map base"
msgstr ""
"/*\n"
" * Initialize TSS.\n"
" */\n"
"init.4:\t\tmovb $_ESP0H,TSS_ESP0+1(%di)\t# Set ESP0\n"
"\t\tmovb $SEL_SDATA,TSS_SS0(%di)\t# Set SS0\n"
"\t\tmovb $_TSSIO,TSS_MAP(%di)\t# Set I/O bit map base"

#. (itstool) path: sect1/para
#: book.translate.xml:1844
msgid ""
"Note that a value is given for the Privilege Level 0 stack pointer and stack "
"segment in the <acronym>TSS</acronym>. This is needed because, if an "
"interrupt or exception is received while executing <filename>boot2</"
"filename> in Privilege Level 3, a change to Privilege Level 0 is "
"automatically performed by the processor, so a new working stack is needed. "
"Finally, the I/O Map Base Address field of the <acronym>TSS</acronym> is "
"given a value, which is a 16-bit offset from the beginning of the "
"<acronym>TSS</acronym> to the I/O Permission Bitmap and the Interrupt "
"Redirection Bitmap."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1855
msgid ""
"After the <acronym>IDT</acronym> and <acronym>TSS</acronym> are created, the "
"processor is ready to switch to protected mode. This is done in the next "
"block:"
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1862
#, no-wrap
msgid ""
"/*\n"
" * Bring up the system.\n"
" */\n"
"\t\tmov $0x2820,%bx\t\t\t# Set protected mode\n"
"\t\tcallw setpic\t\t\t#  IRQ offsets\n"
"\t\tlidt idtdesc\t\t\t# Set IDT\n"
"\t\tlgdt gdtdesc\t\t\t# Set GDT\n"
"\t\tmov %cr0,%eax\t\t\t# Switch to protected\n"
"\t\tinc %ax\t\t\t\t#  mode\n"
"\t\tmov %eax,%cr0\t\t\t#\n"
"\t\tljmp $SEL_SCODE,$init.8\t\t# To 32-bit code\n"
"\t\t.code32\n"
"init.8:\t\txorl %ecx,%ecx\t\t\t# Zero\n"
"\t\tmovb $SEL_SDATA,%cl\t\t# To 32-bit\n"
"\t\tmovw %cx,%ss\t\t\t#  stack"
msgstr ""
"/*\n"
" * Bring up the system.\n"
" */\n"
"\t\tmov $0x2820,%bx\t\t\t# Set protected mode\n"
"\t\tcallw setpic\t\t\t#  IRQ offsets\n"
"\t\tlidt idtdesc\t\t\t# Set IDT\n"
"\t\tlgdt gdtdesc\t\t\t# Set GDT\n"
"\t\tmov %cr0,%eax\t\t\t# Switch to protected\n"
"\t\tinc %ax\t\t\t\t#  mode\n"
"\t\tmov %eax,%cr0\t\t\t#\n"
"\t\tljmp $SEL_SCODE,$init.8\t\t# To 32-bit code\n"
"\t\t.code32\n"
"init.8:\t\txorl %ecx,%ecx\t\t\t# Zero\n"
"\t\tmovb $SEL_SDATA,%cl\t\t# To 32-bit\n"
"\t\tmovw %cx,%ss\t\t\t#  stack"

#. (itstool) path: sect1/para
#: book.translate.xml:1879
msgid ""
"First, a call is made to <literal>setpic</literal> to program the 8259A "
"<acronym>PIC</acronym> (Programmable Interrupt Controller). This chip is "
"connected to multiple hardware interrupt sources. Upon receiving an "
"interrupt from a device, it signals the processor with the appropriate "
"interrupt vector. This can be customized so that specific interrupts are "
"associated with specific interrupt vectors, as explained before. Next, the "
"<acronym>IDTR</acronym> (Interrupt Descriptor Table Register) and "
"<acronym>GDTR</acronym> (Global Descriptor Table Register) are loaded with "
"the instructions <literal>lidt</literal> and <literal>lgdt</literal>, "
"respectively. These registers are loaded with the base address and limit "
"address for the <acronym>IDT</acronym> and <acronym>GDT</acronym>. The "
"following three instructions set the Protection Enable (PE) bit of the "
"<literal>%cr0</literal> register. This effectively switches the processor to "
"32-bit protected mode. Next, a long jump is made to <literal>init.8</"
"literal> using segment selector SEL_SCODE, which selects the Supervisor Code "
"Segment. The processor is effectively executing in CPL 0, the most "
"privileged level, after this jump. Finally, the Supervisor Data Segment is "
"selected for the stack by assigning the segment selector SEL_SDATA to the "
"<literal>%ss</literal> register. This data segment also has a privilege "
"level of <literal>0</literal>."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1904
msgid ""
"Our last code block is responsible for loading the <acronym>TR</acronym> "
"(Task Register) with the segment selector for the <acronym>TSS</acronym> we "
"created earlier, and setting the User Mode environment before passing "
"execution control to the <filename>boot2</filename> client."
msgstr ""

#. (itstool) path: figure/programlisting
#: book.translate.xml:1913
#, no-wrap
msgid ""
"/*\n"
" * Launch user task.\n"
" */\n"
"\t\tmovb $SEL_TSS,%cl\t\t# Set task\n"
"\t\tltr %cx\t\t\t\t#  register\n"
"\t\tmovl $0xa000,%edx\t\t# User base address\n"
"\t\tmovzwl %ss:BDA_MEM,%eax\t\t# Get free memory\n"
"\t\tshll $0xa,%eax\t\t\t# To bytes\n"
"\t\tsubl $ARGSPACE,%eax\t\t# Less arg space\n"
"\t\tsubl %edx,%eax\t\t\t# Less base\n"
"\t\tmovb $SEL_UDATA,%cl\t\t# User data selector\n"
"\t\tpushl %ecx\t\t\t# Set SS\n"
"\t\tpushl %eax\t\t\t# Set ESP\n"
"\t\tpush $0x202\t\t\t# Set flags (IF set)\n"
"\t\tpush $SEL_UCODE\t\t\t# Set CS\n"
"\t\tpushl btx_hdr+0xc\t\t# Set EIP\n"
"\t\tpushl %ecx\t\t\t# Set GS\n"
"\t\tpushl %ecx\t\t\t# Set FS\n"
"\t\tpushl %ecx\t\t\t# Set DS\n"
"\t\tpushl %ecx\t\t\t# Set ES\n"
"\t\tpushl %edx\t\t\t# Set EAX\n"
"\t\tmovb $0x7,%cl\t\t\t# Set remaining\n"
"init.9:\t\tpush $0x0\t\t\t#  general\n"
"\t\tloop init.9\t\t\t#  registers\n"
"\t\tpopa\t\t\t\t#  and initialize\n"
"\t\tpopl %es\t\t\t# Initialize\n"
"\t\tpopl %ds\t\t\t#  user\n"
"\t\tpopl %fs\t\t\t#  segment\n"
"\t\tpopl %gs\t\t\t#  registers\n"
"\t\tiret\t\t\t\t# To user mode"
msgstr ""
"/*\n"
" * Launch user task.\n"
" */\n"
"\t\tmovb $SEL_TSS,%cl\t\t# Set task\n"
"\t\tltr %cx\t\t\t\t#  register\n"
"\t\tmovl $0xa000,%edx\t\t# User base address\n"
"\t\tmovzwl %ss:BDA_MEM,%eax\t\t# Get free memory\n"
"\t\tshll $0xa,%eax\t\t\t# To bytes\n"
"\t\tsubl $ARGSPACE,%eax\t\t# Less arg space\n"
"\t\tsubl %edx,%eax\t\t\t# Less base\n"
"\t\tmovb $SEL_UDATA,%cl\t\t# User data selector\n"
"\t\tpushl %ecx\t\t\t# Set SS\n"
"\t\tpushl %eax\t\t\t# Set ESP\n"
"\t\tpush $0x202\t\t\t# Set flags (IF set)\n"
"\t\tpush $SEL_UCODE\t\t\t# Set CS\n"
"\t\tpushl btx_hdr+0xc\t\t# Set EIP\n"
"\t\tpushl %ecx\t\t\t# Set GS\n"
"\t\tpushl %ecx\t\t\t# Set FS\n"
"\t\tpushl %ecx\t\t\t# Set DS\n"
"\t\tpushl %ecx\t\t\t# Set ES\n"
"\t\tpushl %edx\t\t\t# Set EAX\n"
"\t\tmovb $0x7,%cl\t\t\t# Set remaining\n"
"init.9:\t\tpush $0x0\t\t\t#  general\n"
"\t\tloop init.9\t\t\t#  registers\n"
"\t\tpopa\t\t\t\t#  and initialize\n"
"\t\tpopl %es\t\t\t# Initialize\n"
"\t\tpopl %ds\t\t\t#  user\n"
"\t\tpopl %fs\t\t\t#  segment\n"
"\t\tpopl %gs\t\t\t#  registers\n"
"\t\tiret\t\t\t\t# To user mode"

#. (itstool) path: sect1/para
#: book.translate.xml:1945
msgid ""
"Note that the client's environment include a stack segment selector and "
"stack pointer (registers <literal>%ss</literal> and <literal>%esp</"
"literal>). Indeed, once the <acronym>TR</acronym> is loaded with the "
"appropriate stack segment selector (instruction <literal>ltr</literal>), the "
"stack pointer is calculated and pushed onto the stack along with the stack's "
"segment selector. Next, the value <literal>0x202</literal> is pushed onto "
"the stack; it is the value that the EFLAGS will get when control is passed "
"to the client. Also, the User Mode code segment selector and the client's "
"entry point are pushed. Recall that this entry point is patched in the "
"<acronym>BTX</acronym> header at link time. Finally, segment selectors "
"(stored in register <literal>%ecx</literal>) for the segment registers "
"<literal>%gs, %fs, %ds and %es</literal> are pushed onto the stack, along "
"with the value at <literal>%edx</literal> (<literal>0xa000</literal>). Keep "
"in mind the various values that have been pushed onto the stack (they will "
"be popped out shortly). Next, values for the remaining general purpose "
"registers are also pushed onto the stack (note the <literal>loop</literal> "
"that pushes the value <literal>0</literal> seven times). Now, values will be "
"started to be popped out of the stack. First, the <literal>popa</literal> "
"instruction pops out of the stack the latest seven values pushed. They are "
"stored in the general purpose registers in order <literal>%edi, %esi, %ebp, "
"%ebx, %edx, %ecx, %eax</literal>. Then, the various segment selectors pushed "
"are popped into the various segment registers. Five values still remain on "
"the stack. They are popped when the <literal>iret</literal> instruction is "
"executed. This instruction first pops the value that was pushed from the "
"<acronym>BTX</acronym> header. This value is a pointer to <filename>boot2</"
"filename>'s entry point. It is placed in the register <literal>%eip</"
"literal>, the instruction pointer register. Next, the segment selector for "
"the User Code Segment is popped and copied to register <literal>%cs</"
"literal>. Remember that this segment's privilege level is 3, the least "
"privileged level. This means that we must provide values for the stack of "
"this privilege level. This is why the processor, besides further popping the "
"value for the EFLAGS register, does two more pops out of the stack. These "
"values go to the stack pointer (<literal>%esp</literal>) and the stack "
"segment (<literal>%ss</literal>). Now, execution continues at "
"<literal>boot0</literal>'s entry point."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:1991
msgid ""
"It is important to note how the User Code Segment is defined. This segment's "
"<emphasis>base address</emphasis> is set to <literal>0xa000</literal>. This "
"means that code memory addresses are <emphasis>relative</emphasis> to "
"address 0xa000; if code being executed is fetched from address "
"<literal>0x2000</literal>, the <emphasis>actual</emphasis> memory addressed "
"is <literal>0xa000+0x2000=0xc000</literal>."
msgstr ""

#. (itstool) path: sect1/title
#: book.translate.xml:2002
msgid "<application>boot2</application> Stage"
msgstr "<application>boot2</application> 阶段"

#. (itstool) path: sect1/para
#: book.translate.xml:2004
#, fuzzy
msgid ""
"<literal>boot2</literal> defines an important structure, <literal>struct "
"bootinfo</literal>. This structure is initialized by <literal>boot2</"
"literal> and passed to the loader, and then further to the kernel. Some "
"nodes of this structures are set by <literal>boot2</literal>, the rest by "
"the loader. This structure, among other information, contains the kernel "
"filename, <acronym>BIOS</acronym> harddisk geometry, <acronym>BIOS</acronym> "
"drive number for boot device, physical memory available, <literal>envp</"
"literal> pointer etc. The definition for it is:"
msgstr ""
"boot2 定义了很重要的引导信息数据结构。此结构由 boot2 初始化，然后传递到加载程"
"序，再传到内核。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2015
#, no-wrap
msgid ""
"<filename>/usr/include/machine/bootinfo.h:</filename>\n"
"struct bootinfo {\n"
"\tu_int32_t\tbi_version;\n"
"\tu_int32_t\tbi_kernelname;\t\t/* represents a char * */\n"
"\tu_int32_t\tbi_nfs_diskless;\t/* struct nfs_diskless * */\n"
"\t\t\t\t/* End of fields that are always present. */\n"
"#define\tbi_endcommon\tbi_n_bios_used\n"
"\tu_int32_t\tbi_n_bios_used;\n"
"\tu_int32_t\tbi_bios_geom[N_BIOS_GEOM];\n"
"\tu_int32_t\tbi_size;\n"
"\tu_int8_t\tbi_memsizes_valid;\n"
"\tu_int8_t\tbi_bios_dev;\t\t/* bootdev BIOS unit number */\n"
"\tu_int8_t\tbi_pad[2];\n"
"\tu_int32_t\tbi_basemem;\n"
"\tu_int32_t\tbi_extmem;\n"
"\tu_int32_t\tbi_symtab;\t\t/* struct symtab * */\n"
"\tu_int32_t\tbi_esymtab;\t\t/* struct symtab * */\n"
"\t\t\t\t/* Items below only from advanced bootloader */\n"
"\tu_int32_t\tbi_kernend;\t\t/* end of kernel space */\n"
"\tu_int32_t\tbi_envp;\t\t/* environment */\n"
"\tu_int32_t\tbi_modulep;\t\t/* preloaded modules */\n"
"};"
msgstr ""
"<filename>/usr/include/machine/bootinfo.h:</filename>\n"
"struct bootinfo {\n"
"\tu_int32_t\tbi_version;\n"
"\tu_int32_t\tbi_kernelname;\t\t/* represents a char * */\n"
"\tu_int32_t\tbi_nfs_diskless;\t/* struct nfs_diskless * */\n"
"\t\t\t\t/* End of fields that are always present. */\n"
"#define\tbi_endcommon\tbi_n_bios_used\n"
"\tu_int32_t\tbi_n_bios_used;\n"
"\tu_int32_t\tbi_bios_geom[N_BIOS_GEOM];\n"
"\tu_int32_t\tbi_size;\n"
"\tu_int8_t\tbi_memsizes_valid;\n"
"\tu_int8_t\tbi_bios_dev;\t\t/* bootdev BIOS unit number */\n"
"\tu_int8_t\tbi_pad[2];\n"
"\tu_int32_t\tbi_basemem;\n"
"\tu_int32_t\tbi_extmem;\n"
"\tu_int32_t\tbi_symtab;\t\t/* struct symtab * */\n"
"\tu_int32_t\tbi_esymtab;\t\t/* struct symtab * */\n"
"\t\t\t\t/* Items below only from advanced bootloader */\n"
"\tu_int32_t\tbi_kernend;\t\t/* end of kernel space */\n"
"\tu_int32_t\tbi_envp;\t\t/* environment */\n"
"\tu_int32_t\tbi_modulep;\t\t/* preloaded modules */\n"
"};"

#. (itstool) path: sect1/para
#: book.translate.xml:2038
msgid ""
"<literal>boot2</literal> enters into an infinite loop waiting for user "
"input, then calls <function>load()</function>. If the user does not press "
"anything, the loop breaks by a timeout, so <function>load()</function> will "
"load the default file (<filename>/boot/loader</filename>). Functions "
"<function>ino_t lookup(char *filename)</function> and <function>int "
"xfsread(ino_t inode, void *buf, size_t nbyte)</function> are used to read "
"the content of a file into memory. <filename>/boot/loader</filename> is an "
"<acronym>ELF</acronym> binary, but where the <acronym>ELF</acronym> header "
"is prepended with <filename>a.out</filename>'s <literal>struct exec</"
"literal> structure. <function>load()</function> scans the loader's ELF "
"header, loading the content of <filename>/boot/loader</filename> into "
"memory, and passing the execution to the loader's entry:"
msgstr ""

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2055
#, no-wrap
msgid ""
"<filename>sys/boot/i386/boot2/boot2.c:</filename>\n"
"    __exec((caddr_t)addr, RB_BOOTINFO | (opts &amp; RBX_MASK),\n"
"\t   MAKEBOOTDEV(dev_maj[dsk.type], 0, dsk.slice, dsk.unit, dsk.part),\n"
"\t   0, 0, 0, VTOP(&amp;bootinfo));"
msgstr ""
"<filename>sys/boot/i386/boot2/boot2.c:</filename>\n"
"    __exec((caddr_t)addr, RB_BOOTINFO | (opts &amp; RBX_MASK),\n"
"\t   MAKEBOOTDEV(dev_maj[dsk.type], 0, dsk.slice, dsk.unit, dsk.part),\n"
"\t   0, 0, 0, VTOP(&amp;bootinfo));"

#. (itstool) path: sect1/title
#: book.translate.xml:2062
msgid "<application>loader</application> Stage"
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:2064
msgid ""
"<application>loader</application> is a <acronym>BTX</acronym> client as "
"well. I will not describe it here in detail, there is a comprehensive man "
"page written by Mike Smith, <citerefentry><refentrytitle>loader</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>. The underlying "
"mechanisms and <acronym>BTX</acronym> were discussed above."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:2070
msgid ""
"The main task for the loader is to boot the kernel. When the kernel is "
"loaded into memory, it is being called by the loader:"
msgstr ""

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2074
#, no-wrap
msgid ""
"<filename>sys/boot/common/boot.c:</filename>\n"
"    /* Call the exec handler from the loader matching the kernel */\n"
"    module_formats[km-&gt;m_loader]-&gt;l_exec(km);"
msgstr ""

#. (itstool) path: sect1/title
#: book.translate.xml:2080
msgid "Kernel Initialization"
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:2082
msgid ""
"Let us take a look at the command that links the kernel. This will help "
"identify the exact location where the loader passes execution to the kernel. "
"This location is the kernel's actual entry point."
msgstr ""

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2087
#, no-wrap
msgid ""
"<filename>sys/conf/Makefile.i386:</filename>\n"
"ld -elf -Bdynamic -T /usr/src/sys/conf/ldscript.i386  -export-dynamic \\\n"
"-dynamic-linker /red/herring -o kernel -X locore.o \\\n"
"&lt;lots of kernel .o files&gt;"
msgstr ""

#. (itstool) path: sect1/indexterm
#: book.translate.xml:2092
msgid "<primary>ELF</primary>"
msgstr "<primary> ELF </primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:2093
msgid ""
"A few interesting things can be seen here. First, the kernel is an ELF "
"dynamically linked binary, but the dynamic linker for kernel is <filename>/"
"red/herring</filename>, which is definitely a bogus file. Second, taking a "
"look at the file <filename>sys/conf/ldscript.i386</filename> gives an idea "
"about what <application>ld</application> options are used when compiling a "
"kernel. Reading through the first few lines, the string"
msgstr ""

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2102
#, no-wrap
msgid ""
"<filename>sys/conf/ldscript.i386:</filename>\n"
"ENTRY(btext)"
msgstr ""
"<filename>sys/conf/ldscript.i386:</filename>\n"
"ENTRY(btext)"

#. (itstool) path: sect1/para
#: book.translate.xml:2105
msgid ""
"says that a kernel's entry point is the symbol `btext'. This symbol is "
"defined in <filename>locore.s</filename>:"
msgstr ""

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2108
#, no-wrap
msgid ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"\t.text\n"
"/**********************************************************************\n"
" *\n"
" * This is where the bootblocks start us, set the ball rolling...\n"
" *\n"
" */\n"
"NON_GPROF_ENTRY(btext)"
msgstr ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"\t.text\n"
"/**********************************************************************\n"
" *\n"
" * This is where the bootblocks start us, set the ball rolling...\n"
" *\n"
" */\n"
"NON_GPROF_ENTRY(btext)"

#. (itstool) path: sect1/para
#: book.translate.xml:2117
msgid ""
"First, the register EFLAGS is set to a predefined value of 0x00000002. Then "
"all the segment registers are initialized:"
msgstr ""

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2121
#, no-wrap
msgid ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"/* Don't trust what the BIOS gives for eflags. */\n"
"\tpushl\t$PSL_KERNEL\n"
"\tpopfl\n"
"\n"
"/*\n"
" * Don't trust what the BIOS gives for %fs and %gs.  Trust the bootstrap\n"
" * to set %cs, %ds, %es and %ss.\n"
" */\n"
"\tmov\t%ds, %ax\n"
"\tmov\t%ax, %fs\n"
"\tmov\t%ax, %gs"
msgstr ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"/* Don't trust what the BIOS gives for eflags. */\n"
"\tpushl\t$PSL_KERNEL\n"
"\tpopfl\n"
"\n"
"/*\n"
" * Don't trust what the BIOS gives for %fs and %gs.  Trust the bootstrap\n"
" * to set %cs, %ds, %es and %ss.\n"
" */\n"
"\tmov\t%ds, %ax\n"
"\tmov\t%ax, %fs\n"
"\tmov\t%ax, %gs"

#. (itstool) path: sect1/para
#: book.translate.xml:2134
msgid ""
"btext calls the routines <function>recover_bootinfo()</function>, "
"<function>identify_cpu()</function>, <function>create_pagetables()</"
"function>, which are also defined in <filename>locore.s</filename>. Here is "
"a description of what they do:"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2145
msgid "<function>recover_bootinfo</function>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2146
msgid ""
"This routine parses the parameters to the kernel passed from the bootstrap. "
"The kernel may have been booted in 3 ways: by the loader, described above, "
"by the old disk boot blocks, or by the old diskless boot procedure. This "
"function determines the booting method, and stores the <literal>struct "
"bootinfo</literal> structure into the kernel memory."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2156
msgid "<function>identify_cpu</function>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2157
msgid ""
"This functions tries to find out what CPU it is running on, storing the "
"value found in a variable <varname>_cpu</varname>."
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2163
msgid "<function>create_pagetables</function>"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:2164
msgid ""
"This function allocates and fills out a Page Table Directory at the top of "
"the kernel memory area."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:2171
msgid "The next steps are enabling VME, if the CPU supports it:"
msgstr ""

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2174
#, no-wrap
msgid ""
"\ttestl\t$CPUID_VME, R(_cpu_feature)\n"
"\tjz\t1f\n"
"\tmovl\t%cr4, %eax\n"
"\torl\t$CR4_VME, %eax\n"
"\tmovl\t%eax, %cr4"
msgstr ""
"\ttestl\t$CPUID_VME, R(_cpu_feature)\n"
"\tjz\t1f\n"
"\tmovl\t%cr4, %eax\n"
"\torl\t$CR4_VME, %eax\n"
"\tmovl\t%eax, %cr4"

#. (itstool) path: sect1/para
#: book.translate.xml:2180
msgid "Then, enabling paging:"
msgstr ""

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2182
#, no-wrap
msgid ""
"/* Now enable paging */\n"
"\tmovl\tR(_IdlePTD), %eax\n"
"\tmovl\t%eax,%cr3\t\t\t/* load ptd addr into mmu */\n"
"\tmovl\t%cr0,%eax\t\t\t/* get control word */\n"
"\torl\t$CR0_PE|CR0_PG,%eax\t\t/* enable paging */\n"
"\tmovl\t%eax,%cr0\t\t\t/* and let's page NOW! */"
msgstr ""
"/* Now enable paging */\n"
"\tmovl\tR(_IdlePTD), %eax\n"
"\tmovl\t%eax,%cr3\t\t\t/* load ptd addr into mmu */\n"
"\tmovl\t%cr0,%eax\t\t\t/* get control word */\n"
"\torl\t$CR0_PE|CR0_PG,%eax\t\t/* enable paging */\n"
"\tmovl\t%eax,%cr0\t\t\t/* and let's page NOW! */"

#. (itstool) path: sect1/para
#: book.translate.xml:2189
msgid ""
"The next three lines of code are because the paging was set, so the jump is "
"needed to continue the execution in virtualized address space:"
msgstr ""

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2193
#, no-wrap
msgid ""
"\tpushl\t$begin\t\t\t\t/* jump to high virtualized address */\n"
"\tret\n"
"\n"
"/* now running relocated at KERNBASE where the system is linked to run */\n"
"begin:"
msgstr ""
"\tpushl\t$begin\t\t\t\t/* jump to high virtualized address */\n"
"\tret\n"
"\n"
"/* now running relocated at KERNBASE where the system is linked to run */\n"
"begin:"

#. (itstool) path: sect1/para
#: book.translate.xml:2199
msgid ""
"The function <function>init386()</function> is called with a pointer to the "
"first free physical page, after that <function>mi_startup()</function>. "
"<function>init386</function> is an architecture dependent initialization "
"function, and <function>mi_startup()</function> is an architecture "
"independent one (the 'mi_' prefix stands for Machine Independent). The "
"kernel never returns from <function>mi_startup()</function>, and by calling "
"it, the kernel finishes booting:"
msgstr ""

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2208
#, no-wrap
msgid ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"\tmovl\tphysfree, %esi\n"
"\tpushl\t%esi\t\t\t\t/* value of first for init386(first) */\n"
"\tcall\t_init386\t\t\t/* wire 386 chip for unix operation */\n"
"\tcall\t_mi_startup\t\t\t/* autoconfiguration, mountroot etc */\n"
"\thlt\t\t/* never returns to here */"
msgstr ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"\tmovl\tphysfree, %esi\n"
"\tpushl\t%esi\t\t\t\t/* value of first for init386(first) */\n"
"\tcall\t_init386\t\t\t/* wire 386 chip for unix operation */\n"
"\tcall\t_mi_startup\t\t\t/* autoconfiguration, mountroot etc */\n"
"\thlt\t\t/* never returns to here */"

#. (itstool) path: sect2/title
#: book.translate.xml:2216
msgid "<function>init386()</function>"
msgstr ""

#. (itstool) path: sect2/para
#: book.translate.xml:2218
msgid ""
"<function>init386()</function> is defined in <filename>sys/i386/i386/machdep."
"c</filename> and performs low-level initialization specific to the i386 "
"chip. The switch to protected mode was performed by the loader. The loader "
"has created the very first task, in which the kernel continues to operate. "
"Before looking at the code, consider the tasks the processor must complete "
"to initialize protected mode execution:"
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:2229
msgid ""
"Initialize the kernel tunable parameters, passed from the bootstrapping "
"program."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:2234
msgid "Prepare the GDT."
msgstr "准备GDT(全局描述符表)。"

#. (itstool) path: listitem/para
#: book.translate.xml:2238
msgid "Prepare the IDT."
msgstr "准备IDT(中断描述符表)。"

#. (itstool) path: listitem/para
#: book.translate.xml:2242
msgid "Initialize the system console."
msgstr "初始化系统控制台。"

#. (itstool) path: listitem/para
#: book.translate.xml:2246
msgid "Initialize the DDB, if it is compiled into kernel."
msgstr "初始化DDB(内核的点调试器)，如果它被编译进内核的话。"

#. (itstool) path: listitem/para
#: book.translate.xml:2251
msgid "Initialize the TSS."
msgstr "初始化TSS(任务状态段)。"

#. (itstool) path: listitem/para
#: book.translate.xml:2255
msgid "Prepare the LDT."
msgstr "准备LDT(局部描述符表)。"

#. (itstool) path: listitem/para
#: book.translate.xml:2259
msgid "Set up proc0's pcb."
msgstr "建立proc0(0号进程，即内核的进程)的pcb(进程控制块)。"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:2263
msgid "<primary>parameters</primary>"
msgstr "<primary>parameters(参数)</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:2264
msgid ""
"<function>init386()</function> initializes the tunable parameters passed "
"from bootstrap by setting the environment pointer (envp) and calling "
"<function>init_param1()</function>. The envp pointer has been passed from "
"loader in the <literal>bootinfo</literal> structure:"
msgstr ""
"<function>init386()</function>首先初始化内核的可调整参数，\n"
"        这些参数由引导程序传来。先设置环境指针(environment pointer, envp)调"
"用，\n"
"        再调用<function>init_param1()</function>。\n"
"        envp指针已由loader存放在结构<literal>bootinfo</literal>中:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2270
#, no-wrap
msgid ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\t\tkern_envp = (caddr_t)bootinfo.bi_envp + KERNBASE;\n"
"\n"
"\t/* Init basic tunables, hz etc */\n"
"\tinit_param1();"
msgstr ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\t\tkern_envp = (caddr_t)bootinfo.bi_envp + KERNBASE;\n"
"\n"
"\t/* Init basic tunables, hz etc */\n"
"\tinit_param1();"

#. (itstool) path: sect2/para
#: book.translate.xml:2276
msgid ""
"<function>init_param1()</function> is defined in <filename>sys/kern/"
"subr_param.c</filename>. That file has a number of sysctls, and two "
"functions, <function>init_param1()</function> and <function>init_param2()</"
"function>, that are called from <function>init386()</function>:"
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2283
#, no-wrap
msgid ""
"<filename>sys/kern/subr_param.c:</filename>\n"
"\thz = HZ;\n"
"\tTUNABLE_INT_FETCH(\"kern.hz\", &amp;hz);"
msgstr ""
"<filename>sys/kern/subr_param.c:</filename>\n"
"\thz = HZ;\n"
"\tTUNABLE_INT_FETCH(\"kern.hz\", &amp;hz);"

#. (itstool) path: sect2/para
#: book.translate.xml:2287
msgid ""
"TUNABLE_&lt;typename&gt;_FETCH is used to fetch the value from the "
"environment:"
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2290
#, no-wrap
msgid ""
"<filename>/usr/src/sys/sys/kernel.h:</filename>\n"
"#define\tTUNABLE_INT_FETCH(path, var)\tgetenv_int((path), (var))"
msgstr ""
"<filename>/usr/src/sys/sys/kernel.h:</filename>\n"
"#define\tTUNABLE_INT_FETCH(path, var)\tgetenv_int((path), (var))"

#. (itstool) path: sect2/para
#: book.translate.xml:2293
msgid ""
"Sysctl <literal>kern.hz</literal> is the system clock tick. Additionally, "
"these sysctls are set by <function>init_param1()</function>: <literal>kern."
"maxswzone, kern.maxbcache, kern.maxtsiz, kern.dfldsiz, kern.maxdsiz, kern."
"dflssiz, kern.maxssiz, kern.sgrowsiz</literal>."
msgstr ""

#. (itstool) path: sect2/indexterm
#: book.translate.xml:2299
msgid "<primary>Global Descriptors Table (GDT)</primary>"
msgstr ""

#. (itstool) path: sect2/para
#: book.translate.xml:2303
msgid ""
"Then <function>init386()</function> prepares the Global Descriptors Table "
"(GDT). Every task on an x86 is running in its own virtual address space, and "
"this space is addressed by a segment:offset pair. Say, for instance, the "
"current instruction to be executed by the processor lies at CS:EIP, then the "
"linear virtual address for that instruction would be <quote>the virtual "
"address of code segment CS</quote> + EIP. For convenience, segments begin at "
"virtual address 0 and end at a 4Gb boundary. Therefore, the instruction's "
"linear virtual address for this example would just be the value of EIP. "
"Segment registers such as CS, DS etc are the selectors, i.e., indexes, into "
"GDT (to be more precise, an index is not a selector itself, but the INDEX "
"field of a selector). FreeBSD's GDT holds descriptors for 15 selectors per "
"CPU:"
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2319
#, no-wrap
msgid ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"union descriptor gdt[NGDT * MAXCPU];\t/* global descriptor table */\n"
"\n"
"<filename>sys/i386/include/segments.h:</filename>\n"
"/*\n"
" * Entries in the Global Descriptor Table (GDT)\n"
" */\n"
"#define\tGNULL_SEL\t0\t/* Null Descriptor */\n"
"#define\tGCODE_SEL\t1\t/* Kernel Code Descriptor */\n"
"#define\tGDATA_SEL\t2\t/* Kernel Data Descriptor */\n"
"#define\tGPRIV_SEL\t3\t/* SMP Per-Processor Private Data */\n"
"#define\tGPROC0_SEL\t4\t/* Task state process slot zero and up */\n"
"#define\tGLDT_SEL\t5\t/* LDT - eventually one per process */\n"
"#define\tGUSERLDT_SEL\t6\t/* User LDT */\n"
"#define\tGTGATE_SEL\t7\t/* Process task switch gate */\n"
"#define\tGBIOSLOWMEM_SEL\t8\t/* BIOS low memory access (must be entry 8) */\n"
"#define\tGPANIC_SEL\t9\t/* Task state to consider panic from */\n"
"#define GBIOSCODE32_SEL\t10\t/* BIOS interface (32bit Code) */\n"
"#define GBIOSCODE16_SEL\t11\t/* BIOS interface (16bit Code) */\n"
"#define GBIOSDATA_SEL\t12\t/* BIOS interface (Data) */\n"
"#define GBIOSUTIL_SEL\t13\t/* BIOS interface (Utility) */\n"
"#define GBIOSARGS_SEL\t14\t/* BIOS interface (Arguments) */"
msgstr ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"union descriptor gdt[NGDT * MAXCPU];\t/* global descriptor table */\n"
"\n"
"<filename>sys/i386/include/segments.h:</filename>\n"
"/*\n"
" * Entries in the Global Descriptor Table (GDT)\n"
" */\n"
"#define\tGNULL_SEL\t0\t/* Null Descriptor */\n"
"#define\tGCODE_SEL\t1\t/* Kernel Code Descriptor */\n"
"#define\tGDATA_SEL\t2\t/* Kernel Data Descriptor */\n"
"#define\tGPRIV_SEL\t3\t/* SMP Per-Processor Private Data */\n"
"#define\tGPROC0_SEL\t4\t/* Task state process slot zero and up */\n"
"#define\tGLDT_SEL\t5\t/* LDT - eventually one per process */\n"
"#define\tGUSERLDT_SEL\t6\t/* User LDT */\n"
"#define\tGTGATE_SEL\t7\t/* Process task switch gate */\n"
"#define\tGBIOSLOWMEM_SEL\t8\t/* BIOS low memory access (must be entry 8) */\n"
"#define\tGPANIC_SEL\t9\t/* Task state to consider panic from */\n"
"#define GBIOSCODE32_SEL\t10\t/* BIOS interface (32bit Code) */\n"
"#define GBIOSCODE16_SEL\t11\t/* BIOS interface (16bit Code) */\n"
"#define GBIOSDATA_SEL\t12\t/* BIOS interface (Data) */\n"
"#define GBIOSUTIL_SEL\t13\t/* BIOS interface (Utility) */\n"
"#define GBIOSARGS_SEL\t14\t/* BIOS interface (Arguments) */"

#. (itstool) path: sect2/para
#: book.translate.xml:2342
msgid ""
"Note that those #defines are not selectors themselves, but just a field "
"INDEX of a selector, so they are exactly the indices of the GDT. for "
"example, an actual selector for the kernel code (GCODE_SEL) has the value "
"0x08."
msgstr ""

#. (itstool) path: sect2/indexterm
#: book.translate.xml:2347
msgid "<primary>Interrupt Descriptor Table (IDT)</primary>"
msgstr ""

#. (itstool) path: sect2/para
#: book.translate.xml:2349
msgid ""
"The next step is to initialize the Interrupt Descriptor Table (IDT). This "
"table is referenced by the processor when a software or hardware interrupt "
"occurs. For example, to make a system call, user application issues the "
"<literal>INT 0x80</literal> instruction. This is a software interrupt, so "
"the processor's hardware looks up a record with index 0x80 in the IDT. This "
"record points to the routine that handles this interrupt, in this particular "
"case, this will be the kernel's syscall gate. The IDT may have a maximum of "
"256 (0x100) records. The kernel allocates NIDT records for the IDT, where "
"NIDT is the maximum (256):"
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2361
#, no-wrap
msgid ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"static struct gate_descriptor idt0[NIDT];\n"
"struct gate_descriptor *idt = &amp;idt0[0];\t/* interrupt descriptor table */"
msgstr ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"static struct gate_descriptor idt0[NIDT];\n"
"struct gate_descriptor *idt = &amp;idt0[0];\t/* interrupt descriptor table */"

#. (itstool) path: sect2/para
#: book.translate.xml:2365
msgid ""
"For each interrupt, an appropriate handler is set. The syscall gate for "
"<literal>INT 0x80</literal> is set as well:"
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2369
#, no-wrap
msgid ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\tsetidt(0x80, &amp;IDTVEC(int0x80_syscall),\n"
"\t\t\tSDT_SYS386TGT, SEL_UPL, GSEL(GCODE_SEL, SEL_KPL));"
msgstr ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\tsetidt(0x80, &amp;IDTVEC(int0x80_syscall),\n"
"\t\t\tSDT_SYS386TGT, SEL_UPL, GSEL(GCODE_SEL, SEL_KPL));"

#. (itstool) path: sect2/para
#: book.translate.xml:2373
msgid ""
"So when a userland application issues the <literal>INT 0x80</literal> "
"instruction, control will transfer to the function "
"<function>_Xint0x80_syscall</function>, which is in the kernel code segment "
"and will be executed with supervisor privileges."
msgstr ""

#. (itstool) path: sect2/para
#: book.translate.xml:2379
msgid "Console and DDB are then initialized:"
msgstr ""

#. (itstool) path: sect2/indexterm
#: book.translate.xml:2380
msgid "<primary>DDB</primary>"
msgstr "<primary>DDB</primary>"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2382
#, no-wrap
msgid ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\tcninit();\n"
"/* skipped */\n"
"#ifdef DDB\n"
"\tkdb_init();\n"
"\tif (boothowto &amp; RB_KDB)\n"
"\t\tDebugger(\"Boot flags requested debugger\");\n"
"#endif"
msgstr ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\tcninit();\n"
"/* skipped */\n"
"#ifdef DDB\n"
"\tkdb_init();\n"
"\tif (boothowto &amp; RB_KDB)\n"
"\t\tDebugger(\"Boot flags requested debugger\");\n"
"#endif"

#. (itstool) path: sect2/para
#: book.translate.xml:2391
msgid ""
"The Task State Segment is another x86 protected mode structure, the TSS is "
"used by the hardware to store task information when a task switch occurs."
msgstr ""

#. (itstool) path: sect2/para
#: book.translate.xml:2395
msgid ""
"The Local Descriptors Table is used to reference userland code and data. "
"Several selectors are defined to point to the LDT, they are the system call "
"gates and the user code and data selectors:"
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2400
#, no-wrap
msgid ""
"<filename>/usr/include/machine/segments.h:</filename>\n"
"#define\tLSYS5CALLS_SEL\t0\t/* forced by intel BCS */\n"
"#define\tLSYS5SIGR_SEL\t1\n"
"#define\tL43BSDCALLS_SEL\t2\t/* notyet */\n"
"#define\tLUCODE_SEL\t3\n"
"#define\tLSOL26CALLS_SEL\t4\t/* Solaris &gt;= 2.6 system call gate */\n"
"#define\tLUDATA_SEL\t5\n"
"/* separate stack, es,fs,gs sels ? */\n"
"/* #define\tLPOSIXCALLS_SEL\t5*/\t/* notyet */\n"
"#define LBSDICALLS_SEL\t16\t/* BSDI system call gate */\n"
"#define NLDT\t\t(LBSDICALLS_SEL + 1)"
msgstr ""
"<filename>/usr/include/machine/segments.h:</filename>\n"
"#define\tLSYS5CALLS_SEL\t0\t/* forced by intel BCS */\n"
"#define\tLSYS5SIGR_SEL\t1\n"
"#define\tL43BSDCALLS_SEL\t2\t/* notyet */\n"
"#define\tLUCODE_SEL\t3\n"
"#define\tLSOL26CALLS_SEL\t4\t/* Solaris &gt;= 2.6 system call gate */\n"
"#define\tLUDATA_SEL\t5\n"
"/* separate stack, es,fs,gs sels ? */\n"
"/* #define\tLPOSIXCALLS_SEL\t5*/\t/* notyet */\n"
"#define LBSDICALLS_SEL\t16\t/* BSDI system call gate */\n"
"#define NLDT\t\t(LBSDICALLS_SEL + 1)"

#. (itstool) path: sect2/para
#: book.translate.xml:2412
msgid ""
"Next, proc0's Process Control Block (<literal>struct pcb</literal>) "
"structure is initialized. proc0 is a <literal>struct proc</literal> "
"structure that describes a kernel process. It is always present while the "
"kernel is running, therefore it is declared as global:"
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2418
#, no-wrap
msgid ""
"<filename>sys/kern/kern_init.c:</filename>\n"
"    struct\tproc proc0;"
msgstr ""
"<filename>sys/kern/kern_init.c:</filename>\n"
"    struct\tproc proc0;"

#. (itstool) path: sect2/para
#: book.translate.xml:2421
msgid ""
"The structure <literal>struct pcb</literal> is a part of a proc structure. "
"It is defined in <filename>/usr/include/machine/pcb.h</filename> and has a "
"process's information specific to the i386 architecture, such as registers "
"values."
msgstr ""

#. (itstool) path: sect2/title
#: book.translate.xml:2429
msgid "<function>mi_startup()</function>"
msgstr ""

#. (itstool) path: sect2/para
#: book.translate.xml:2431
msgid ""
"This function performs a bubble sort of all the system initialization "
"objects and then calls the entry of each object one by one:"
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2435
#, no-wrap
msgid ""
"<filename>sys/kern/init_main.c:</filename>\n"
"\tfor (sipp = sysinit; *sipp; sipp++) {\n"
"\n"
"\t\t/* ... skipped ... */\n"
"\n"
"\t\t/* Call function */\n"
"\t\t(*((*sipp)-&gt;func))((*sipp)-&gt;udata);\n"
"\t\t/* ... skipped ... */\n"
"\t}"
msgstr ""
"<filename>sys/kern/init_main.c:</filename>\n"
"\tfor (sipp = sysinit; *sipp; sipp++) {\n"
"\n"
"\t\t/* ... skipped ... */\n"
"\n"
"\t\t/* Call function */\n"
"\t\t(*((*sipp)-&gt;func))((*sipp)-&gt;udata);\n"
"\t\t/* ... skipped ... */\n"
"\t}"

#. (itstool) path: sect2/para
#: book.translate.xml:2445
msgid ""
"Although the sysinit framework is described in the <link xlink:href="
"\"@@URL_RELPREFIX@@/doc/en_US.ISO8859-1/books/developers-handbook"
"\">Developers' Handbook</link>, I will discuss the internals of it."
msgstr ""

#. (itstool) path: sect2/indexterm
#: book.translate.xml:2448
msgid "<primary>sysinit objects</primary>"
msgstr ""

#. (itstool) path: sect2/para
#: book.translate.xml:2449
msgid ""
"Every system initialization object (sysinit object) is created by calling a "
"SYSINIT() macro. Let us take as example an <literal>announce</literal> "
"sysinit object. This object prints the copyright message:"
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2454
#, no-wrap
msgid ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static void\n"
"print_caddr_t(void *data __unused)\n"
"{\n"
"\tprintf(\"%s\", (char *)data);\n"
"}\n"
"SYSINIT(announce, SI_SUB_COPYRIGHT, SI_ORDER_FIRST, print_caddr_t, copyright)"
msgstr ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static void\n"
"print_caddr_t(void *data __unused)\n"
"{\n"
"\tprintf(\"%s\", (char *)data);\n"
"}\n"
"SYSINIT(announce, SI_SUB_COPYRIGHT, SI_ORDER_FIRST, print_caddr_t, copyright)"

#. (itstool) path: sect2/para
#: book.translate.xml:2462
msgid ""
"The subsystem ID for this object is SI_SUB_COPYRIGHT (0x0800001), which "
"comes right after the SI_SUB_CONSOLE (0x0800000). So, the copyright message "
"will be printed out first, just after the console initialization."
msgstr ""

#. (itstool) path: sect2/para
#: book.translate.xml:2467
msgid ""
"Let us take a look at what exactly the macro <literal>SYSINIT()</literal> "
"does. It expands to a <literal>C_SYSINIT()</literal> macro. The "
"<literal>C_SYSINIT()</literal> macro then expands to a static "
"<literal>struct sysinit</literal> structure declaration with another "
"<literal>DATA_SET</literal> macro call:"
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2474
#, no-wrap
msgid ""
"<filename>/usr/include/sys/kernel.h:</filename>\n"
"      #define C_SYSINIT(uniquifier, subsystem, order, func, ident) \\\n"
"      static struct sysinit uniquifier ## _sys_init = { \\ subsystem, \\\n"
"      order, \\ func, \\ ident \\ }; \\ DATA_SET(sysinit_set,uniquifier ##\n"
"      _sys_init);\n"
"\n"
"#define\tSYSINIT(uniquifier, subsystem, order, func, ident)\t\\\n"
"\tC_SYSINIT(uniquifier, subsystem, order,\t\t\t\\\n"
"\t(sysinit_cfunc_t)(sysinit_nfunc_t)func, (void *)ident)"
msgstr ""
"<filename>/usr/include/sys/kernel.h:</filename>\n"
"      #define C_SYSINIT(uniquifier, subsystem, order, func, ident) \\\n"
"      static struct sysinit uniquifier ## _sys_init = { \\ subsystem, \\\n"
"      order, \\ func, \\ ident \\ }; \\ DATA_SET(sysinit_set,uniquifier ##\n"
"      _sys_init);\n"
"\n"
"#define\tSYSINIT(uniquifier, subsystem, order, func, ident)\t\\\n"
"\tC_SYSINIT(uniquifier, subsystem, order,\t\t\t\\\n"
"\t(sysinit_cfunc_t)(sysinit_nfunc_t)func, (void *)ident)"

#. (itstool) path: sect2/para
#: book.translate.xml:2484
msgid ""
"The <literal>DATA_SET()</literal> macro expands to a <literal>MAKE_SET()</"
"literal>, and that macro is the point where all the sysinit magic is hidden:"
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2488
#, no-wrap
msgid ""
"<filename>/usr/include/linker_set.h:</filename>\n"
"#define MAKE_SET(set, sym)\t\t\t\t\t\t\\\n"
"\tstatic void const * const __set_##set##_sym_##sym = &amp;sym;\t\\\n"
"\t__asm(\".section .set.\" #set \",\\\"aw\\\"\");\t\t\t\t\\\n"
"\t__asm(\".long \" #sym);\t\t\t\t\t\t\\\n"
"\t__asm(\".previous\")\n"
"#endif\n"
"#define TEXT_SET(set, sym) MAKE_SET(set, sym)\n"
"#define DATA_SET(set, sym) MAKE_SET(set, sym)"
msgstr ""
"<filename>/usr/include/linker_set.h:</filename>\n"
"#define MAKE_SET(set, sym)\t\t\t\t\t\t\\\n"
"\tstatic void const * const __set_##set##_sym_##sym = &amp;sym;\t\\\n"
"\t__asm(\".section .set.\" #set \",\\\"aw\\\"\");\t\t\t\t\\\n"
"\t__asm(\".long \" #sym);\t\t\t\t\t\t\\\n"
"\t__asm(\".previous\")\n"
"#endif\n"
"#define TEXT_SET(set, sym) MAKE_SET(set, sym)\n"
"#define DATA_SET(set, sym) MAKE_SET(set, sym)"

#. (itstool) path: sect2/para
#: book.translate.xml:2498
msgid "In our case, the following declaration will occur:"
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2500
#, no-wrap
msgid ""
"static struct sysinit announce_sys_init = {\n"
"\tSI_SUB_COPYRIGHT,\n"
"\tSI_ORDER_FIRST,\n"
"\t(sysinit_cfunc_t)(sysinit_nfunc_t)  print_caddr_t,\n"
"\t(void *) copyright\n"
"};\n"
"\n"
"static void const *const __set_sysinit_set_sym_announce_sys_init =\n"
"    &amp;announce_sys_init;\n"
"__asm(\".section .set.sysinit_set\" \",\\\"aw\\\"\");\n"
"__asm(\".long \" \"announce_sys_init\");\n"
"__asm(\".previous\");"
msgstr ""
"static struct sysinit announce_sys_init = {\n"
"\tSI_SUB_COPYRIGHT,\n"
"\tSI_ORDER_FIRST,\n"
"\t(sysinit_cfunc_t)(sysinit_nfunc_t)  print_caddr_t,\n"
"\t(void *) copyright\n"
"};\n"
"\n"
"static void const *const __set_sysinit_set_sym_announce_sys_init =\n"
"    &amp;announce_sys_init;\n"
"__asm(\".section .set.sysinit_set\" \",\\\"aw\\\"\");\n"
"__asm(\".long \" \"announce_sys_init\");\n"
"__asm(\".previous\");"

#. (itstool) path: sect2/para
#: book.translate.xml:2513
msgid ""
"The first <literal>__asm</literal> instruction will create an ELF section "
"within the kernel's executable. This will happen at kernel link time. The "
"section will have the name <literal>.set.sysinit_set</literal>. The content "
"of this section is one 32-bit value, the address of announce_sys_init "
"structure, and that is what the second <literal>__asm</literal> is. The "
"third <literal>__asm</literal> instruction marks the end of a section. If a "
"directive with the same section name occurred before, the content, i.e., the "
"32-bit value, will be appended to the existing section, so forming an array "
"of 32-bit pointers."
msgstr ""

#. (itstool) path: sect2/para
#: book.translate.xml:2526
msgid ""
"Running <application>objdump</application> on a kernel binary, you may "
"notice the presence of such small sections:"
msgstr ""

#. (itstool) path: sect2/screen
#: book.translate.xml:2530
#, no-wrap
msgid ""
"<prompt>%</prompt> <userinput>objdump -h /kernel</userinput>\n"
"  7 .set.cons_set 00000014  c03164c0  c03164c0  002154c0  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
"  8 .set.kbddriver_set 00000010  c03164d4  c03164d4  002154d4  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
"  9 .set.scrndr_set 00000024  c03164e4  c03164e4  002154e4  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 10 .set.scterm_set 0000000c  c0316508  c0316508  00215508  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 11 .set.sysctl_set 0000097c  c0316514  c0316514  00215514  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 12 .set.sysinit_set 00000664  c0316e90  c0316e90  00215e90  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA"
msgstr ""
"<prompt>%</prompt> <userinput>objdump -h /kernel</userinput>\n"
"  7 .set.cons_set 00000014  c03164c0  c03164c0  002154c0  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
"  8 .set.kbddriver_set 00000010  c03164d4  c03164d4  002154d4  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
"  9 .set.scrndr_set 00000024  c03164e4  c03164e4  002154e4  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 10 .set.scterm_set 0000000c  c0316508  c0316508  00215508  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 11 .set.sysctl_set 0000097c  c0316514  c0316514  00215514  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 12 .set.sysinit_set 00000664  c0316e90  c0316e90  00215e90  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA"

#. (itstool) path: sect2/para
#: book.translate.xml:2544
msgid ""
"This screen dump shows that the size of .set.sysinit_set section is 0x664 "
"bytes, so <literal>0x664/sizeof(void *)</literal> sysinit objects are "
"compiled into the kernel. The other sections such as <literal>.set."
"sysctl_set</literal> represent other linker sets."
msgstr ""

#. (itstool) path: sect2/para
#: book.translate.xml:2550
msgid ""
"By defining a variable of type <literal>struct linker_set</literal> the "
"content of <literal>.set.sysinit_set</literal> section will be "
"<quote>collected</quote> into that variable:"
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2555
#, no-wrap
msgid ""
"<filename>sys/kern/init_main.c:</filename>\n"
"      extern struct linker_set sysinit_set; /* XXX */"
msgstr ""
"<filename>sys/kern/init_main.c:</filename>\n"
"      extern struct linker_set sysinit_set; /* XXX */"

#. (itstool) path: sect2/para
#: book.translate.xml:2558
msgid "The <literal>struct linker_set</literal> is defined as follows:"
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2561
#, no-wrap
msgid ""
"<filename>/usr/include/linker_set.h:</filename>\n"
"  struct linker_set {\n"
"\tint\tls_length;\n"
"\tvoid\t*ls_items[1];\t\t/* really ls_length of them, trailing NULL */\n"
"};"
msgstr ""
"<filename>/usr/include/linker_set.h:</filename>\n"
"  struct linker_set {\n"
"\tint\tls_length;\n"
"\tvoid\t*ls_items[1];\t\t/* really ls_length of them, trailing NULL */\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:2567
msgid ""
"The first node will be equal to the number of a sysinit objects, and the "
"second node will be a NULL-terminated array of pointers to them."
msgstr ""

#. (itstool) path: sect2/para
#: book.translate.xml:2571
msgid ""
"Returning to the <function>mi_startup()</function> discussion, it is must be "
"clear now, how the sysinit objects are being organized. The "
"<function>mi_startup()</function> function sorts them and calls each. The "
"very last object is the system scheduler:"
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2577
#, no-wrap
msgid ""
"<filename>/usr/include/sys/kernel.h:</filename>\n"
"enum sysinit_sub_id {\n"
"\tSI_SUB_DUMMY\t\t= 0x0000000,\t/* not executed; for linker*/\n"
"\tSI_SUB_DONE\t\t= 0x0000001,\t/* processed*/\n"
"\tSI_SUB_CONSOLE\t\t= 0x0800000,\t/* console*/\n"
"\tSI_SUB_COPYRIGHT\t= 0x0800001,\t/* first use of console*/\n"
"...\n"
"\tSI_SUB_RUN_SCHEDULER\t= 0xfffffff\t/* scheduler: no return*/\n"
"};"
msgstr ""
"<filename>/usr/include/sys/kernel.h:</filename>\n"
"enum sysinit_sub_id {\n"
"\tSI_SUB_DUMMY\t\t= 0x0000000,\t/* not executed; for linker*/\n"
"\tSI_SUB_DONE\t\t= 0x0000001,\t/* processed*/\n"
"\tSI_SUB_CONSOLE\t\t= 0x0800000,\t/* console*/\n"
"\tSI_SUB_COPYRIGHT\t= 0x0800001,\t/* first use of console*/\n"
"...\n"
"\tSI_SUB_RUN_SCHEDULER\t= 0xfffffff\t/* scheduler: no return*/\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:2587
msgid ""
"The system scheduler sysinit object is defined in the file <filename>sys/vm/"
"vm_glue.c</filename>, and the entry point for that object is "
"<function>scheduler()</function>. That function is actually an infinite "
"loop, and it represents a process with PID 0, the swapper process. The proc0 "
"structure, mentioned before, is used to describe it."
msgstr ""

#. (itstool) path: sect2/para
#: book.translate.xml:2594
msgid ""
"The first user process, called <emphasis>init</emphasis>, is created by the "
"sysinit object <literal>init</literal>:"
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2598
#, no-wrap
msgid ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static void\n"
"create_init(const void *udata __unused)\n"
"{\n"
"\tint error;\n"
"\tint s;\n"
"\n"
"\ts = splhigh();\n"
"\terror = fork1(&amp;proc0, RFFDG | RFPROC, &amp;initproc);\n"
"\tif (error)\n"
"\t\tpanic(\"cannot fork init: %d\\n\", error);\n"
"\tinitproc-&gt;p_flag |= P_INMEM | P_SYSTEM;\n"
"\tcpu_set_fork_handler(initproc, start_init, NULL);\n"
"\tremrunqueue(initproc);\n"
"\tsplx(s);\n"
"}\n"
"SYSINIT(init,SI_SUB_CREATE_INIT, SI_ORDER_FIRST, create_init, NULL)"
msgstr ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static void\n"
"create_init(const void *udata __unused)\n"
"{\n"
"\tint error;\n"
"\tint s;\n"
"\n"
"\ts = splhigh();\n"
"\terror = fork1(&amp;proc0, RFFDG | RFPROC, &amp;initproc);\n"
"\tif (error)\n"
"\t\tpanic(\"cannot fork init: %d\\n\", error);\n"
"\tinitproc-&gt;p_flag |= P_INMEM | P_SYSTEM;\n"
"\tcpu_set_fork_handler(initproc, start_init, NULL);\n"
"\tremrunqueue(initproc);\n"
"\tsplx(s);\n"
"}\n"
"SYSINIT(init,SI_SUB_CREATE_INIT, SI_ORDER_FIRST, create_init, NULL)"

#. (itstool) path: sect2/para
#: book.translate.xml:2616
msgid ""
"The <function>create_init()</function> allocates a new process by calling "
"<function>fork1()</function>, but does not mark it runnable. When this new "
"process is scheduled for execution by the scheduler, the "
"<function>start_init()</function> will be called. That function is defined "
"in <filename>init_main.c</filename>. It tries to load and exec the "
"<filename>init</filename> binary, probing <filename>/sbin/init</filename> "
"first, then <filename>/sbin/oinit</filename>, <filename>/sbin/init.bak</"
"filename>, and finally <filename>/stand/sysinstall</filename>:"
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2628
#, no-wrap
msgid ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static char init_path[MAXPATHLEN] =\n"
"#ifdef\tINIT_PATH\n"
"    __XSTRING(INIT_PATH);\n"
"#else\n"
"    \"/sbin/init:/sbin/oinit:/sbin/init.bak:/stand/sysinstall\";\n"
"#endif"
msgstr ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static char init_path[MAXPATHLEN] =\n"
"#ifdef\tINIT_PATH\n"
"    __XSTRING(INIT_PATH);\n"
"#else\n"
"    \"/sbin/init:/sbin/oinit:/sbin/init.bak:/stand/sysinstall\";\n"
"#endif"

#. (itstool) path: chapter/title
#: book.translate.xml:2647
msgid "Locking Notes"
msgstr "内核中的锁"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2649
msgid "<primary>SMP Next Generation Project</primary>"
msgstr "<primary>SMP Next Generation Project</primary>"

#. (itstool) path: chapter/para
#: book.translate.xml:2653
msgid ""
"<emphasis>This chapter is maintained by the FreeBSD SMP Next Generation "
"Project.</emphasis>"
msgstr "<emphasis>这一章由 FreeBSD SMP Next Generation Project 维护</emphasis>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2656
msgid "<primary>locking</primary>"
msgstr "<primary>locking(锁)</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2657
msgid "<primary>multi-processing</primary>"
msgstr "<primary>multi-processing(多处理)</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2658
msgid "<primary>mutexes</primary>"
msgstr "<primary>mutexes(同时/独占, mutual exclusion)</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2659
msgid "<primary>lockmgr</primary>"
msgstr "<primary>lockmgr(锁管理器)</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2660
msgid "<primary>atomic operations</primary>"
msgstr "<primary>atomic operations(原子操作)</primary>"

#. (itstool) path: chapter/para
#: book.translate.xml:2661
msgid ""
"This document outlines the locking used in the FreeBSD kernel to permit "
"effective multi-processing within the kernel. Locking can be achieved via "
"several means. Data structures can be protected by mutexes or "
"<citerefentry><refentrytitle>lockmgr</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> locks. A few variables are protected simply by "
"always using atomic operations to access them."
msgstr ""

#. (itstool) path: sect1/title
#: book.translate.xml:2669
msgid "Mutexes"
msgstr "Mutex"

#. (itstool) path: sect1/para
#: book.translate.xml:2671
msgid ""
"A mutex is simply a lock used to guarantee mutual exclusion. Specifically, a "
"mutex may only be owned by one entity at a time. If another entity wishes to "
"obtain a mutex that is already owned, it must wait until the mutex is "
"released. In the FreeBSD kernel, mutexes are owned by processes."
msgstr ""
"Mutex就是一种用来解决共享/排它矛盾的锁。 一个mutex在一个时刻只可以被一个实体"
"拥有。如果另一个实体要获得已经被拥有的mutex， 就会进入等待，直到这个mutex被释"
"放。在FreeBSD内核中，mutex被进程所拥有。"

#. (itstool) path: sect1/para
#: book.translate.xml:2677
msgid ""
"Mutexes may be recursively acquired, but they are intended to be held for a "
"short period of time. Specifically, one may not sleep while holding a mutex. "
"If you need to hold a lock across a sleep, use a "
"<citerefentry><refentrytitle>lockmgr</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> lock."
msgstr ""
"Mutex 可以被递归的索要，但是 mutex 一般只被一个实体拥有较短的一段时间，因此一"
"个实体不能在持有 mutex 时睡眠。如果你需要在持有 mutex 时睡眠，可使用一个"
"<citerefentry><refentrytitle>lockmgr</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry>的锁。"

#. (itstool) path: sect1/para
#: book.translate.xml:2682
msgid "Each mutex has several properties of interest:"
msgstr "每个mutex有几个令人感兴趣的属性："

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2686 book.translate.xml:2780 book.translate.xml:2938
msgid "Variable Name"
msgstr "变量名"

#. (itstool) path: listitem/para
#: book.translate.xml:2688
msgid "The name of the <type>struct mtx</type> variable in the kernel source."
msgstr "在内核源代码中<type>struct mtx</type>变量的名字。"

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2694 book.translate.xml:2781
msgid "Logical Name"
msgstr "逻辑名"

#. (itstool) path: listitem/para
#: book.translate.xml:2696
msgid ""
"The name of the mutex assigned to it by <function>mtx_init</function>. This "
"name is displayed in KTR trace messages and witness errors and warnings and "
"is used to distinguish mutexes in the witness code."
msgstr ""
"由函数<function>mtx_init</function>指派的mutex的名字。 这个名字显示在KTR跟踪"
"消息和witness出错与警告信息里。 这个名字还用于区分标识在witness代码中的各个"
"mutex。"

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2704 book.translate.xml:2782
msgid "Type"
msgstr "类型"

#. (itstool) path: listitem/para
#: book.translate.xml:2706
msgid ""
"The type of the mutex in terms of the <constant>MTX_*</constant> flags. The "
"meaning for each flag is related to its meaning as documented in "
"<citerefentry><refentrytitle>mutex</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry>."
msgstr ""
"Mutex的类型，用标志<constant>MTX_*</constant>_*表示。 每个标志的意义在"
"<citerefentry><refentrytitle>mutex</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry>有所描述。"

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2713 book.translate.xml:2871
msgid "<constant>MTX_DEF</constant>"
msgstr "<constant>MTX_DEF</constant>"

#. (itstool) path: listitem/para
#: book.translate.xml:2715
msgid "A sleep mutex"
msgstr "一个睡眠 mutex"

#. (itstool) path: varlistentry/term
#: book.translate.xml:2720
msgid "<constant>MTX_SPIN</constant>"
msgstr "<constant>MTX_SPIN</constant>"

#. (itstool) path: listitem/para
#: book.translate.xml:2722
msgid "A spin mutex"
msgstr "一个循环 mutex"

#. (itstool) path: varlistentry/term
#: book.translate.xml:2727
msgid "<constant>MTX_RECURSE</constant>"
msgstr "<constant>MTX_RECURSE</constant>"

#. (itstool) path: listitem/para
#: book.translate.xml:2729
msgid "This mutex is allowed to recurse."
msgstr "这个 mutex 允许递归。"

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2737 book.translate.xml:2783 book.translate.xml:2939
msgid "Protectees"
msgstr "保护对象"

#. (itstool) path: listitem/para
#: book.translate.xml:2739
msgid ""
"A list of data structures or data structure members that this entry "
"protects. For data structure members, the name will be in the form of "
"<varname remap=\"structname\">structure name</varname>.<varname remap="
"\"structfield\">member name</varname>."
msgstr ""
"这个入口所要保护的数据结构列表或数据结构成员列表。 对于数据结构成员，将按照"
"<varname remap=\"structname\">结构名</varname>.<varname remap=\"structfield"
"\">成员名</varname>的形式命名。"

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2746 book.translate.xml:2784
msgid "Dependent Functions"
msgstr "依赖函数"

#. (itstool) path: listitem/para
#: book.translate.xml:2748
msgid "Functions that can only be called if this mutex is held."
msgstr "仅当mutex被持有时才可以被调用的函数。"

#. (itstool) path: table/title
#: book.translate.xml:2755
msgid "Mutex List"
msgstr "Mutex列表"

#. (itstool) path: table/indexterm
#: book.translate.xml:2757
msgid "<primary>locks</primary> <secondary>sched_lock</secondary>"
msgstr "<primary>locks</primary> <secondary>sched_lock</secondary>"

#. (itstool) path: table/indexterm
#: book.translate.xml:2762
msgid "<primary>locks</primary> <secondary>vm86pcb_lock</secondary>"
msgstr "<primary>locks</primary> <secondary>vm86pcb_lock</secondary>"

#. (itstool) path: table/indexterm
#: book.translate.xml:2767
msgid "<primary>locks</primary> <secondary>Giant</secondary>"
msgstr "<primary>locks</primary> <secondary>Giant</secondary>"

#. (itstool) path: table/indexterm
#: book.translate.xml:2772
msgid "<primary>locks</primary> <secondary>callout_lock</secondary>"
msgstr "<primary>locks</primary> <secondary>callout_lock</secondary>"

#. (itstool) path: row/entry
#: book.translate.xml:2791
msgid "sched_lock"
msgstr "sched_lock"

#. (itstool) path: row/entry
#: book.translate.xml:2792
msgid "<quote>sched lock</quote>"
msgstr "<quote>sched lock</quote>"

#. (itstool) path: row/entry
#: book.translate.xml:2794 book.translate.xml:2894
msgid "<constant>MTX_SPIN</constant> | <constant>MTX_RECURSE</constant>"
msgstr "<constant>MTX_SPIN</constant> | <constant>MTX_RECURSE</constant>"

#. (itstool) path: row/entry
#: book.translate.xml:2797
msgid ""
"<varname>_gmonparam</varname>, <varname>cnt.v_swtch</varname>, "
"<varname>cp_time</varname>, <varname>curpriority</varname>, <varname remap="
"\"structname\">mtx</varname>.<varname remap=\"structfield\">mtx_blocked</"
"varname>, <varname remap=\"structname\">mtx</varname>.<varname remap="
"\"structfield\">mtx_contested</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_procq</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_slpq</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_sflag</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_stat</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_estcpu</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_cpticks</varname> <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_pctcpu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_wchan</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_wmesg</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_swtime</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_slptime</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_runtime</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_uu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_su</varname>, "
"<varname remap=\"structname\">proc</varname>.<varname remap=\"structfield"
"\">p_iu</varname>, <varname remap=\"structname\">proc</varname>.<varname "
"remap=\"structfield\">p_uticks</varname>, <varname remap=\"structname"
"\">proc</varname>.<varname remap=\"structfield\">p_sticks</varname>, "
"<varname remap=\"structname\">proc</varname>.<varname remap=\"structfield"
"\">p_iticks</varname>, <varname remap=\"structname\">proc</varname>.<varname "
"remap=\"structfield\">p_oncpu</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_lastcpu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_rqindex</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_heldmtx</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_blocked</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_mtxname</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_contested</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_priority</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_usrpri</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_nativepri</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_nice</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_rtprio</"
"varname>, <varname>pscnt</varname>, <varname>slpque</varname>, "
"<varname>itqueuebits</varname>, <varname>itqueues</varname>, "
"<varname>rtqueuebits</varname>, <varname>rtqueues</varname>, "
"<varname>queuebits</varname>, <varname>queues</varname>, "
"<varname>idqueuebits</varname>, <varname>idqueues</varname>, "
"<varname>switchtime</varname>, <varname>switchticks</varname>"
msgstr ""
"<varname>_gmonparam</varname>, <varname>cnt.v_swtch</varname>, "
"<varname>cp_time</varname>, <varname>curpriority</varname>, <varname remap="
"\"structname\">mtx</varname>.<varname remap=\"structfield\">mtx_blocked</"
"varname>, <varname remap=\"structname\">mtx</varname>.<varname remap="
"\"structfield\">mtx_contested</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_procq</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_slpq</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_sflag</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_stat</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_estcpu</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_cpticks</varname> <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_pctcpu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_wchan</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_wmesg</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_swtime</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_slptime</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_runtime</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_uu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_su</varname>, "
"<varname remap=\"structname\">proc</varname>.<varname remap=\"structfield"
"\">p_iu</varname>, <varname remap=\"structname\">proc</varname>.<varname "
"remap=\"structfield\">p_uticks</varname>, <varname remap=\"structname"
"\">proc</varname>.<varname remap=\"structfield\">p_sticks</varname>, "
"<varname remap=\"structname\">proc</varname>.<varname remap=\"structfield"
"\">p_iticks</varname>, <varname remap=\"structname\">proc</varname>.<varname "
"remap=\"structfield\">p_oncpu</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_lastcpu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_rqindex</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_heldmtx</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_blocked</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_mtxname</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_contested</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_priority</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_usrpri</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_nativepri</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_nice</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_rtprio</"
"varname>, <varname>pscnt</varname>, <varname>slpque</varname>, "
"<varname>itqueuebits</varname>, <varname>itqueues</varname>, "
"<varname>rtqueuebits</varname>, <varname>rtqueues</varname>, "
"<varname>queuebits</varname>, <varname>queues</varname>, "
"<varname>idqueuebits</varname>, <varname>idqueues</varname>, "
"<varname>switchtime</varname>, <varname>switchticks</varname>"

#. (itstool) path: row/entry
#: book.translate.xml:2846
msgid ""
"<function>setrunqueue</function>, <function>remrunqueue</function>, "
"<function>mi_switch</function>, <function>chooseproc</function>, "
"<function>schedclock</function>, <function>resetpriority</function>, "
"<function>updatepri</function>, <function>maybe_resched</function>, "
"<function>cpu_switch</function>, <function>cpu_throw</function>, "
"<function>need_resched</function>, <function>resched_wanted</function>, "
"<function>clear_resched</function>, <function>aston</function>, "
"<function>astoff</function>, <function>astpending</function>, "
"<function>calcru</function>, <function>proc_compare</function>"
msgstr ""
"<function>setrunqueue</function>, <function>remrunqueue</function>, "
"<function>mi_switch</function>, <function>chooseproc</function>, "
"<function>schedclock</function>, <function>resetpriority</function>, "
"<function>updatepri</function>, <function>maybe_resched</function>, "
"<function>cpu_switch</function>, <function>cpu_throw</function>, "
"<function>need_resched</function>, <function>resched_wanted</function>, "
"<function>clear_resched</function>, <function>aston</function>, "
"<function>astoff</function>, <function>astpending</function>, "
"<function>calcru</function>, <function>proc_compare</function>"

#. (itstool) path: row/entry
#: book.translate.xml:2869
msgid "vm86pcb_lock"
msgstr "vm86pcb_lock"

#. (itstool) path: row/entry
#: book.translate.xml:2870
msgid "<quote>vm86pcb lock</quote>"
msgstr "<quote>vm86pcb lock</quote>"

#. (itstool) path: row/entry
#: book.translate.xml:2873
msgid "<varname>vm86pcb</varname>"
msgstr "<varname>vm86pcb</varname>"

#. (itstool) path: row/entry
#: book.translate.xml:2875
msgid "<function>vm86_bioscall</function>"
msgstr "<function>vm86_bioscall</function>"

#. (itstool) path: row/entry
#: book.translate.xml:2881
msgid "Giant"
msgstr "Giant"

#. (itstool) path: row/entry
#: book.translate.xml:2882
msgid "<quote>Giant</quote>"
msgstr "<quote>Giant</quote>(巨锁)"

#. (itstool) path: row/entry
#: book.translate.xml:2883
msgid "<constant>MTX_DEF</constant> | <constant>MTX_RECURSE</constant>"
msgstr "<constant>MTX_DEF</constant> | <constant>MTX_RECURSE</constant>"

#. (itstool) path: row/entry
#: book.translate.xml:2886
msgid "nearly everything"
msgstr "几乎可以是任何东西"

#. (itstool) path: row/entry
#: book.translate.xml:2887
msgid "lots"
msgstr "许多"

#. (itstool) path: row/entry
#: book.translate.xml:2892
msgid "callout_lock"
msgstr "callout_lock"

#. (itstool) path: row/entry
#: book.translate.xml:2893
msgid "<quote>callout lock</quote>"
msgstr "<quote>callout lock</quote>(延时调用锁)"

#. (itstool) path: row/entry
#: book.translate.xml:2897
msgid ""
"<varname>callfree</varname>, <varname>callwheel</varname>, "
"<varname>nextsoftcheck</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_itcallout</varname>, <varname "
"remap=\"structname\">proc</varname>.<varname remap=\"structfield"
"\">p_slpcallout</varname>, <varname>softticks</varname>, <varname>ticks</"
"varname>"
msgstr ""
"<varname>callfree</varname>, <varname>callwheel</varname>, "
"<varname>nextsoftcheck</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_itcallout</varname>, <varname "
"remap=\"structname\">proc</varname>.<varname remap=\"structfield"
"\">p_slpcallout</varname>, <varname>softticks</varname>, <varname>ticks</"
"varname>"

#. (itstool) path: sect1/title
#: book.translate.xml:2913
msgid "Shared Exclusive Locks"
msgstr "共享互斥锁"

#. (itstool) path: sect1/para
#: book.translate.xml:2915
msgid ""
"These locks provide basic reader-writer type functionality and may be held "
"by a sleeping process. Currently they are backed by "
"<citerefentry><refentrytitle>lockmgr</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry>."
msgstr ""
"这些锁提供基本的读/写类型的功能，可以被一个正在睡眠的进程持有。 现在它们被统"
"一到l<citerefentry><refentrytitle>lockmgr</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry>之中。"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:2918
msgid "<primary>locks</primary> <secondary>shared exclusive</secondary>"
msgstr ""
"<primary>locks(锁)</primary><secondary>shared exclusive(共享互斥)</secondary>"

#. (itstool) path: table/title
#: book.translate.xml:2924
msgid "Shared Exclusive Lock List"
msgstr "共享互斥锁列表"

#. (itstool) path: table/indexterm
#: book.translate.xml:2926
msgid "<primary>locks</primary> <secondary>allproc_lock</secondary>"
msgstr "<primary>locks</primary> <secondary>allproc_lock</secondary>"

#. (itstool) path: table/indexterm
#: book.translate.xml:2930
msgid "<primary>locks</primary> <secondary>proctree_lock</secondary>"
msgstr "<primary>locks</primary> <secondary>proctree_lock</secondary>"

#. (itstool) path: row/entry
#: book.translate.xml:2944
msgid "<varname>allproc_lock</varname>"
msgstr "<varname>allproc_lock</varname>"

#. (itstool) path: row/entry
#: book.translate.xml:2945
msgid ""
"<varname>allproc</varname> <varname>zombproc</varname> <varname>pidhashtbl</"
"varname> <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_list</varname> <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_hash</varname> <varname>nextpid</"
"varname>"
msgstr ""
"<varname>allproc</varname> <varname>zombproc</varname> <varname>pidhashtbl</"
"varname> <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_list</varname> <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_hash</varname> <varname>nextpid</"
"varname>"

#. (itstool) path: row/entry
#: book.translate.xml:2955
msgid "<varname>proctree_lock</varname>"
msgstr "<varname>proctree_lock</varname>"

#. (itstool) path: row/entry
#: book.translate.xml:2956
msgid ""
"<varname remap=\"structname\">proc</varname>.<varname remap=\"structfield"
"\">p_children</varname> <varname remap=\"structname\">proc</varname>."
"<varname remap=\"structfield\">p_sibling</varname>"
msgstr ""
"<varname remap=\"structname\">proc</varname>.<varname remap=\"structfield"
"\">p_children</varname> <varname remap=\"structname\">proc</varname>."
"<varname remap=\"structfield\">p_sibling</varname>"

#. (itstool) path: sect1/title
#: book.translate.xml:2966
msgid "Atomically Protected Variables"
msgstr "原子保护变量"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:2968
msgid "<primary>atomically protected variables</primary>"
msgstr "<primary>atomically protected variables(原子保护变量)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:2972
msgid ""
"An atomically protected variable is a special variable that is not protected "
"by an explicit lock. Instead, all data accesses to the variables use special "
"atomic operations as described in <citerefentry><refentrytitle>atomic</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>. Very few variables "
"are treated this way, although other synchronization primitives such as "
"mutexes are implemented with atomically protected variables."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:2982
msgid ""
"<varname remap=\"structname\">mtx</varname>.<varname remap=\"structfield"
"\">mtx_lock</varname>"
msgstr ""
"<varname remap=\"structname\">mtx</varname>.<varname remap=\"structfield"
"\">mtx_lock</varname>"

#. (itstool) path: chapter/title
#: book.translate.xml:2995
msgid "Kernel Objects"
msgstr "内核对象"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2997
msgid "<primary>Kernel Objects</primary>"
msgstr "<primary>内核对象</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2998
msgid "<primary>Object-Oriented</primary>"
msgstr "<primary>Object-Oriented(面向对象)</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2999
msgid "<primary>binary compatibility</primary>"
msgstr "<primary>binary compatibility(二进制兼容性)</primary>"

#. (itstool) path: chapter/para
#: book.translate.xml:3000
msgid ""
"Kernel Objects, or <firstterm>Kobj</firstterm> provides an object-oriented C "
"programming system for the kernel. As such the data being operated on "
"carries the description of how to operate on it. This allows operations to "
"be added and removed from an interface at run time and without breaking "
"binary compatibility."
msgstr ""
"内核对象，也就是<firstterm>Kobj</firstterm>，为内核提供了一种面向对象的C语言"
"编程方式。被操作的数据也承载操作它的方法。这使得在不破坏二进制兼容性的前提"
"下，某一个接口能够增/减相应的操作。"

#. (itstool) path: sect1/title
#: book.translate.xml:3008 book.translate.xml:4125
msgid "Terminology"
msgstr "术语"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:3010
msgid "<primary>object</primary>"
msgstr "<primary>object(对象)</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:3011
msgid "<primary>method</primary>"
msgstr "<primary>method(方法)</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:3012
msgid "<primary>class</primary>"
msgstr "<primary>class(类)</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:3013
msgid "<primary>interface</primary>"
msgstr "<primary>interface(接口)</primary>"

#. (itstool) path: varlistentry/term
#: book.translate.xml:3017
msgid "Object"
msgstr "对象"

#. (itstool) path: listitem/para
#: book.translate.xml:3018
msgid "A set of data - data structure - data allocation."
msgstr "数据集合-数据结构-数据分配的集合。"

#. (itstool) path: varlistentry/term
#: book.translate.xml:3023
msgid "Method"
msgstr "方法"

#. (itstool) path: listitem/para
#: book.translate.xml:3025
msgid "An operation - function."
msgstr "某一种操作──函数。"

#. (itstool) path: varlistentry/term
#: book.translate.xml:3029
msgid "Class"
msgstr "类"

#. (itstool) path: listitem/para
#: book.translate.xml:3031
msgid "One or more methods."
msgstr "一种或多种方法。"

#. (itstool) path: varlistentry/term
#. (itstool) path: sect2/title
#: book.translate.xml:3035 book.translate.xml:4187
msgid "Interface"
msgstr "接口"

#. (itstool) path: listitem/para
#: book.translate.xml:3037
msgid "A standard set of one or more methods."
msgstr "一种或多种方法的一个标准集合。"

#. (itstool) path: sect1/title
#: book.translate.xml:3044
msgid "Kobj Operation"
msgstr "Kobj的工作流程"

#. (itstool) path: sect1/para
#: book.translate.xml:3046
msgid ""
"Kobj works by generating descriptions of methods. Each description holds a "
"unique id as well as a default function. The description's address is used "
"to uniquely identify the method within a class' method table."
msgstr ""
"Kobj工作时，产生方法的描述。每个描述有一个唯一的标识和一个缺省函数。 某个描述"
"的地址被用来在一个类的方法表里唯一的标识方法。"

#. (itstool) path: sect1/para
#: book.translate.xml:3051
msgid ""
"A class is built by creating a method table associating one or more "
"functions with method descriptions. Before use the class is compiled. The "
"compilation allocates a cache and associates it with the class. A unique id "
"is assigned to each method description within the method table of the class "
"if not already done so by another referencing class compilation. For every "
"method to be used a function is generated by script to qualify arguments and "
"automatically reference the method description for a lookup. The generated "
"function looks up the method by using the unique id associated with the "
"method description as a hash into the cache associated with the object's "
"class. If the method is not cached the generated function proceeds to use "
"the class' table to find the method. If the method is found then the "
"associated function within the class is used; otherwise, the default "
"function associated with the method description is used."
msgstr ""
"构建一个类，就是要建立一张方法表，并将这张表关联到一个或多个函数(方法)； 这些"
"函数(方法)都带有方法描述。使用前，类要被编译。编译时要为这个类分配一些缓存。 "
"在方法表中的每个方法描述都会被指派一个唯一的标识， 除非已经被其它引用它的类在"
"编译时指派了标识。对于每个将要被使用的方法， 都会由脚本生成一个函数(方法查找"
"函数)，以解析外来参数， 并在被查询时给出方法描述的地址。被生成的函数(方法查找"
"函数) 凭着那个方法描述的唯一标识按Hash的方法查找对象的类的缓存。 如果这个方法"
"不在缓存中，函数会查找使用类的方法表。如果这个方法被找到了， 类里的相关函数"
"(也就是某个方法的实现代码)就会被使用。 否则，这个方法描述的缺省函数将被使用。"

#. (itstool) path: sect1/para
#: book.translate.xml:3068
msgid "These indirections can be visualized as the following:"
msgstr "这些过程可被表示如下："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:3071
#, no-wrap
msgid "object-&gt;cache&lt;-&gt;class"
msgstr "对象-&gt;缓存&lt;-&gt;类"

#. (itstool) path: sect1/title
#: book.translate.xml:3076
msgid "Using Kobj"
msgstr "使用Kobj"

#. (itstool) path: sect2/title
#: book.translate.xml:3079
msgid "Structures"
msgstr "结构"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3081
#, no-wrap
msgid "struct kobj_method"
msgstr "struct kobj_method"

#. (itstool) path: sect2/title
#: book.translate.xml:3085
msgid "Functions"
msgstr "结构"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3087
#, no-wrap
msgid ""
"void kobj_class_compile(kobj_class_t cls);\n"
"void kobj_class_compile_static(kobj_class_t cls, kobj_ops_t ops);\n"
"void kobj_class_free(kobj_class_t cls);\n"
"kobj_t kobj_create(kobj_class_t cls, struct malloc_type *mtype, int mflags);\n"
"void kobj_init(kobj_t obj, kobj_class_t cls);\n"
"void kobj_delete(kobj_t obj, struct malloc_type *mtype);"
msgstr ""
"void kobj_class_compile(kobj_class_t cls);\n"
"void kobj_class_compile_static(kobj_class_t cls, kobj_ops_t ops);\n"
"void kobj_class_free(kobj_class_t cls);\n"
"kobj_t kobj_create(kobj_class_t cls, struct malloc_type *mtype, int mflags);\n"
"void kobj_init(kobj_t obj, kobj_class_t cls);\n"
"void kobj_delete(kobj_t obj, struct malloc_type *mtype);"

#. (itstool) path: sect2/title
#. (itstool) path: sect3/title
#: book.translate.xml:3096 book.translate.xml:4196
msgid "Macros"
msgstr "宏"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3098
#, no-wrap
msgid ""
"KOBJ_CLASS_FIELDS\n"
"KOBJ_FIELDS\n"
"DEFINE_CLASS(name, methods, size)\n"
"KOBJMETHOD(NAME, FUNC)"
msgstr ""
"KOBJ_CLASS_FIELDS\n"
"KOBJ_FIELDS\n"
"DEFINE_CLASS(name, methods, size)\n"
"KOBJMETHOD(NAME, FUNC)"

#. (itstool) path: sect2/title
#. (itstool) path: sect3/title
#: book.translate.xml:3105 book.translate.xml:4190
msgid "Headers"
msgstr "头文件"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3107
#, no-wrap
msgid ""
"&lt;sys/param.h&gt;\n"
"&lt;sys/kobj.h&gt;"
msgstr ""
"&lt;sys/param.h&gt;\n"
"&lt;sys/kobj.h&gt;"

#. (itstool) path: sect2/title
#: book.translate.xml:3112
msgid "Creating an Interface Template"
msgstr "建立一个接口的模板"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3114
msgid "<primary>Kernel Objects</primary> <secondary>interface</secondary>"
msgstr ""
"<primary>Kernel Objects(内核对象)</primary><secondary>interface(接口)</"
"secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:3117
msgid ""
"The first step in using Kobj is to create an Interface. Creating the "
"interface involves creating a template that the script <filename>src/sys/"
"kern/makeobjops.pl</filename> can use to generate the header and code for "
"the method declarations and method lookup functions."
msgstr ""
"使用Kobj的第一步是建立一个接口。建立接口包括建立模板的工作。建立模板可用脚本"
"<filename>src/sys/kern/makeobjops.pl</filename>完成，它会产生申明方法的头文件"
"和代码，脚本还会生成方法查找函数。"

#. (itstool) path: sect2/para
#: book.translate.xml:3124
msgid ""
"Within this template the following keywords are used: <literal>#include</"
"literal>, <literal>INTERFACE</literal>, <literal>CODE</literal>, "
"<literal>METHOD</literal>, <literal>STATICMETHOD</literal>, and "
"<literal>DEFAULT</literal>."
msgstr ""
"在这个模板中如下关键词会被使用:<literal>#include</literal>, "
"<literal>INTERFACE</literal>，<literal>CODE</literal>, <literal>METHOD</"
"literal>，<literal>STATICMETHOD</literal>，和<literal>DEFAULT</literal>."

#. (itstool) path: sect2/para
#: book.translate.xml:3130
msgid ""
"The <literal>#include</literal> statement and what follows it is copied "
"verbatim to the head of the generated code file."
msgstr ""
"<literal>#include</literal>语句的整行内容将被一字不差的\n"
"        复制到被生成的代码文件的头部。"

#. (itstool) path: sect2/para
#: book.translate.xml:3134 book.translate.xml:3143 book.translate.xml:3151
#: book.translate.xml:3164 book.translate.xml:3180 book.translate.xml:3217
msgid "For example:"
msgstr "例如："

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3136
#, no-wrap
msgid "#include &lt;sys/foo.h&gt;"
msgstr "#include &lt;sys/foo.h&gt;"

#. (itstool) path: sect2/para
#: book.translate.xml:3138
msgid ""
"The <literal>INTERFACE</literal> keyword is used to define the interface "
"name. This name is concatenated with each method name as [interface "
"name]_[method name]. Its syntax is INTERFACE [interface name];."
msgstr ""
"关键词<literal>INTERFACE</literal>用来定义接口名。这个名字将与每个方法名接合"
"在一起，形成 [interface name]_[method name]。语法是：INTERFACE [接口名];。"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3145
#, no-wrap
msgid "INTERFACE foo;"
msgstr "INTERFACE foo;"

#. (itstool) path: sect2/para
#: book.translate.xml:3147
msgid ""
"The <literal>CODE</literal> keyword copies its arguments verbatim into the "
"code file. Its syntax is <literal>CODE { [whatever] };</literal>"
msgstr ""
"关键词<literal>CODE</literal>会将它的参数一字不差的复制到代码文件中。语法是"
"<literal>CODE { [任何代码] };</literal>"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3153
#, no-wrap
msgid ""
"CODE {\n"
"\tstruct foo * foo_alloc_null(struct bar *)\n"
"\t{\n"
"\t\treturn NULL;\n"
"}\n"
"};"
msgstr ""
"CODE {\n"
"\tstruct foo * foo_alloc_null(struct bar *)\n"
"\t{\n"
"\t\treturn NULL;\n"
"}\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:3160
msgid ""
"The <literal>METHOD</literal> keyword describes a method. Its syntax is "
"<literal>METHOD [return type] [method name] { [object [, arguments]] };</"
"literal>"
msgstr ""
"关键词<literal>METHOD</literal>用来描述一个方法。语法是:<literal>METHOD [返回"
"值类型] [方法名] { [对象 [,参数若干]] };</literal>"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3166
#, no-wrap
msgid ""
"METHOD int bar {\n"
"\tstruct object *;\n"
"\tstruct foo *;\n"
"\tstruct bar;\n"
"};"
msgstr ""
"METHOD int bar {\n"
"\tstruct object *;\n"
"\tstruct foo *;\n"
"\tstruct bar;\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:3172
msgid ""
"The <literal>DEFAULT</literal> keyword may follow the <literal>METHOD</"
"literal> keyword. It extends the <literal>METHOD</literal> key word to "
"include the default function for method. The extended syntax is "
"<literal>METHOD [return type] [method name] { [object; [other arguments]] }"
"DEFAULT [default function];</literal>"
msgstr ""
"关键词<literal>DEFAULT</literal>跟在关键词<literal>METHOD</literal>之后，是对"
"关键词<literal>METHOD</literal>的补充。它给这个方法补充上缺省函数。语法是： "
"<literal>METHOD [返回值类型] [方法名] {[对象; [其它参数]] }DEFAULT [缺省函"
"数];</literal>"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3182
#, no-wrap
msgid ""
"METHOD int bar {\n"
"\tstruct object *;\n"
"\tstruct foo *;\n"
"\tint bar;\n"
"} DEFAULT foo_hack;"
msgstr ""
"METHOD int bar {\n"
"\tstruct object *;\n"
"\tstruct foo *;\n"
"\tint bar;\n"
"} DEFAULT foo_hack;"

#. (itstool) path: sect2/para
#: book.translate.xml:3188
msgid ""
"The <literal>STATICMETHOD</literal> keyword is used like the "
"<literal>METHOD</literal> keyword except the kobj data is not at the head of "
"the object structure so casting to kobj_t would be incorrect. Instead "
"<literal>STATICMETHOD</literal> relies on the Kobj data being referenced as "
"'ops'. This is also useful for calling methods directly out of a class's "
"method table."
msgstr ""
"关键词<literal>STATICMETHOD</literal>类似关键词<literal>METHOD</literal>。对"
"于每个Kobj对象，一般其头部都有一些Kobj专有的数据。<literal>METHOD</literal>定"
"义的方法就假设这些专有数据位于对象头部；假如对象头部没有这些专有数据，这些方"
"法对这个对象的访问就可能出错。而<literal>STATICMETHOD</literal>定义的对象可以"
"不受这个限制：这样描述出的方法，其操作的数据不由这个类的某个对象实例给出，而"
"是全都由调用这个方法时的操作数(译者注:即参数)给出。这也对于在某个类的方法表之"
"外调用这个方法有用。"

#. (itstool) path: sect2/para
#: book.translate.xml:3195
msgid "Other complete examples:"
msgstr "其它完整的例子:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3197
#, no-wrap
msgid ""
"src/sys/kern/bus_if.m\n"
"src/sys/kern/device_if.m"
msgstr ""
"src/sys/kern/bus_if.m\n"
"src/sys/kern/device_if.m"

#. (itstool) path: sect2/title
#: book.translate.xml:3203
msgid "Creating a Class"
msgstr "创建类"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3205
msgid "<primary>Kernel Objects</primary> <secondary>class</secondary>"
msgstr ""
"<primary>Kernel Objects(内核对象)</primary><secondary>class(类)</secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:3208
msgid ""
"The second step in using Kobj is to create a class. A class consists of a "
"name, a table of methods, and the size of objects if Kobj's object handling "
"facilities are used. To create the class use the macro "
"<function>DEFINE_CLASS()</function>. To create the method table create an "
"array of kobj_method_t terminated by a NULL entry. Each non-NULL entry may "
"be created using the macro <function>KOBJMETHOD()</function>."
msgstr ""
"使用Kobj的第二步是建立一个类。一个类的组有名字、方法表；假如使用了Kobj的“对象"
"管理工具”(Object Handling Facilities)，类中还包含对象的大小。建立类时使用宏"
"<function>DEFINE_CLASS()</function>。建立方法表时，须建立一个 kobj_method_t "
"数组，用NULL项结尾。每个非 NULL 项可用宏<function>KOBJMETHOD()</function>建"
"立。"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3219
#, no-wrap
msgid ""
"DEFINE_CLASS(fooclass, foomethods, sizeof(struct foodata));\n"
"\n"
"kobj_method_t foomethods[] = {\n"
"\tKOBJMETHOD(bar_doo, foo_doo),\n"
"\tKOBJMETHOD(bar_foo, foo_foo),\n"
"\t{ NULL, NULL}\n"
"};"
msgstr ""
"DEFINE_CLASS(fooclass, foomethods, sizeof(struct foodata));\n"
"\n"
"kobj_method_t foomethods[] = {\n"
"\tKOBJMETHOD(bar_doo, foo_doo),\n"
"\tKOBJMETHOD(bar_foo, foo_foo),\n"
"\t{ NULL, NULL}\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:3227
msgid ""
"The class must be <quote>compiled</quote>. Depending on the state of the "
"system at the time that the class is to be initialized a statically "
"allocated cache, <quote>ops table</quote> have to be used. This can be "
"accomplished by declaring a <varname remap=\"structname\">struct kobj_ops</"
"varname> and using <function>kobj_class_compile_static();</function> "
"otherwise, <function>kobj_class_compile()</function> should be used."
msgstr ""
"类须被<quote>编译</quote>。根据该类被初始化时系统的状态，将要用到一个静态分配"
"的缓存和<quote>操作数表</quote>(ops table，译者注：即<quote>参数表</quote>)。"
"这些操作可通过声明一个结构体<varname remap=\"structname\">struct kobj_ops</"
"varname>并使用<function>kobj_class_compile_static()</function>，或是只使用"
"<function>kobj_class_compile()</function>来完成。"

#. (itstool) path: sect2/title
#: book.translate.xml:3237
msgid "Creating an Object"
msgstr "建立一个对象"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3239
msgid "<primary>Kernel Objects</primary> <secondary>object</secondary>"
msgstr ""
"<primary>Kernel Objects(内核对象)</primary><secondary>object(对象)</"
"secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:3242
msgid ""
"The third step in using Kobj involves how to define the object. Kobj object "
"creation routines assume that Kobj data is at the head of an object. If this "
"in not appropriate you will have to allocate the object yourself and then "
"use <function>kobj_init()</function> on the Kobj portion of it; otherwise, "
"you may use <function>kobj_create()</function> to allocate and initialize "
"the Kobj portion of the object automatically. <function>kobj_init()</"
"function> may also be used to change the class that an object uses."
msgstr ""
"使用Kobj的第三步是定义对象。Kobj对象建立程序假定Kobj专有数据在一个对象的头"
"部。如果不是如此，应当先自行分配对象，再使用<function>kobj_init()</function>"
"初始化对象中的Kobj专有数据；其实可以使用<function>kobj_create()</function>分"
"配对象，并自动初始化对象中的Kobj专有内容。<function>kobj_init()</function>也"
"可以用来改变一个对象所使用的类。"

#. (itstool) path: sect2/para
#: book.translate.xml:3252
msgid "To integrate Kobj into the object you should use the macro KOBJ_FIELDS."
msgstr "将Kobj的数据集成到对象中要使用宏KOBJ_FIELDS。"

#. (itstool) path: sect2/para
#: book.translate.xml:3255
msgid "For example"
msgstr "例如"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3257
#, no-wrap
msgid ""
"struct foo_data {\n"
"\tKOBJ_FIELDS;\n"
"\tfoo_foo;\n"
"\tfoo_bar;\n"
"};"
msgstr ""
"struct foo_data {\n"
"\tKOBJ_FIELDS;\n"
"\tfoo_foo;\n"
"\tfoo_bar;\n"
"};"

#. (itstool) path: sect2/title
#: book.translate.xml:3265
msgid "Calling Methods"
msgstr "调用方法"

#. (itstool) path: sect2/para
#: book.translate.xml:3267
msgid ""
"The last step in using Kobj is to simply use the generated functions to use "
"the desired method within the object's class. This is as simple as using the "
"interface name and the method name with a few modifications. The interface "
"name should be concatenated with the method name using a '_' between them, "
"all in upper case."
msgstr ""
"使用Kobj的最后一部就是通过生成的函数调用对象类中的方法。调用时，接口名与方法"
"名用'_'接合，而且全部使用大写字母。"

#. (itstool) path: sect2/para
#: book.translate.xml:3274
msgid ""
"For example, if the interface name was foo and the method was bar then the "
"call would be:"
msgstr "例如，接口名为foo，方法为bar，调用就是:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3277
#, no-wrap
msgid "[return value = ] FOO_BAR(object [, other parameters]);"
msgstr "[返回值 = ] FOO_BAR(对象 [, 其它参数]);"

#. (itstool) path: sect2/title
#: book.translate.xml:3282
msgid "Cleaning Up"
msgstr "善后处理"

#. (itstool) path: sect2/para
#: book.translate.xml:3284
msgid ""
"When an object allocated through <function>kobj_create()</function> is no "
"longer needed <function>kobj_delete()</function> may be called on it, and "
"when a class is no longer being used <function>kobj_class_free()</function> "
"may be called on it."
msgstr ""
"当一个用<function>kobj_create()</function>不再需要被使用时，可对这个对象调用"
"<function>kobj_delete()</function>。当一个类不再需要被使用时，可对这个类调用"
"<function>kobj_class_free()</function>。"

#. (itstool) path: info/title
#: book.translate.xml:3301
msgid "The Jail Subsystem"
msgstr "Jail子系统"

#. (itstool) path: affiliation/address
#: book.translate.xml:3309
#, no-wrap
msgid ""
"\n"
"\t  <email>evms@cs.bu.edu</email>\n"
"\t"
msgstr ""
"\n"
"\t  <email>evms@cs.bu.edu</email>\n"
"\t"

#. (itstool) path: info/author
#: book.translate.xml:3303
msgid ""
"<personname> <firstname>Evan</firstname> <surname>Sarmiento</surname> </"
"personname> <affiliation> <_:address-1/> </affiliation>"
msgstr ""
"<personname> <firstname>Evan</firstname> <surname>Sarmiento</surname> </"
"personname> <affiliation> <_:address-1/> </affiliation>"

#. (itstool) path: info/copyright
#: book.translate.xml:3314
msgid ""
"<year>2001</year> <holder role=\"mailto:evms@cs.bu.edu\">Evan Sarmiento</"
"holder>"
msgstr ""
"<year>2001</year> <holder role=\"mailto:evms@cs.bu.edu\">Evan Sarmiento</"
"holder>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:3320
msgid "<primary>security</primary>"
msgstr "<primary>安全</primary>"

#. (itstool) path: chapter/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:3321 book.translate.xml:15468
msgid "<primary>Jail</primary>"
msgstr "<primary>Jail</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:3322
msgid "<primary>root</primary>"
msgstr "<primary>root</primary>"

#. (itstool) path: chapter/para
#: book.translate.xml:3324
msgid ""
"On most <trademark class=\"registered\">UNIX</trademark> systems, "
"<literal>root</literal> has omnipotent power. This promotes insecurity. If "
"an attacker gained <literal>root</literal> on a system, he would have every "
"function at his fingertips. In FreeBSD there are sysctls which dilute the "
"power of <literal>root</literal>, in order to minimize the damage caused by "
"an attacker. Specifically, one of these functions is called <literal>secure "
"levels</literal>. Similarly, another function which is present from FreeBSD "
"4.0 and onward, is a utility called <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>. <application>Jail</"
"application> chroots an environment and sets certain restrictions on "
"processes which are forked within the <application>jail</application>. For "
"example, a jailed process cannot affect processes outside the "
"<application>jail</application>, utilize certain system calls, or inflict "
"any damage on the host environment."
msgstr ""
"在大多数<trademark class=\"registered\">UNIX</trademark> 系统中，用户"
"<literal>root</literal>是万能的。这也就增加了许多危险。如果一个攻击者获得了一"
"个系统中的<literal>root</literal>，就可以在他的指尖掌握系统中所有的功能。在"
"FreeBSD里，有一些sysctl项削弱了<literal>root</literal>的权限，这样就可以将攻"
"击者造成的损害减小到最低限度。这些安全功能中，有一种叫安全级别。另一种在"
"FreeBSD 4.0及以后版本中提供的安全功能，就是 "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry>。<application>Jail</application>将一个运行环境的文件树根切换到"
"某一特定位置，并且对这样环境中叉分生成的进程做出限制。例如，一个被监禁的进程"
"不能影响这个<application>jail</application>之外的进程、不能使用一些特定的系统"
"调用，也就不能对主计算机造成破坏。"

#. (itstool) path: chapter/para
#: book.translate.xml:3339
msgid ""
"<application>Jail</application> is becoming the new security model. People "
"are running potentially vulnerable servers such as <application>Apache</"
"application>, <application>BIND</application>, and <application>sendmail</"
"application> within jails, so that if an attacker gains <literal>root</"
"literal> within the <application>jail</application>, it is only an "
"annoyance, and not a devastation. This article mainly focuses on the "
"internals (source code) of <application>jail</application>. For information "
"on how to set up a jail see the <link xlink:href=\"@@URL_RELPREFIX@@/doc/"
"en_US.ISO8859-1/books/handbook/jails.html\">handbook entry on jails</link>."
msgstr ""
"<application>Jail</application>已经成为一种新型的安全模型。人们可以在jail中运"
"行各种可能很脆弱的服务器程序，如<application>Apache</application>、"
"<application>BIND</application>和<application>sendmail</application>。这样一"
"来，即使有攻击者取得了<application>jail</application>中的<literal>root</"
"literal>，这最多让人们皱皱眉头，而不会使人们惊慌失措。本文主要关注"
"<application>jail</application>的内部原理(源代码)。如果你正在寻找设置"
"<application>Jail</application>的指南性文档，我建议你阅读我的另一篇文章，发表"
"在Sys Admin Magazine, May 2001，《Securing FreeBSD using <application>Jail</"
"application>》。"

#. (itstool) path: sect1/title
#: book.translate.xml:3352
msgid "Architecture"
msgstr "Jail的系统结构"

#. (itstool) path: sect1/para
#: book.translate.xml:3354
msgid ""
"<application>Jail</application> consists of two realms: the userland "
"program, <citerefentry><refentrytitle>jail</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>, and the code implemented within the kernel: the "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> system call and associated restrictions. I will be discussing "
"the userland program and then how <application>jail</application> is "
"implemented within the kernel."
msgstr ""
"<application>Jail</application>由两部分组成：用户级程序，也就是"
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry>；还有在内核中Jail的实现代码："
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> 系统调用和相关的约束。我将讨论用户级程序和<application>jail</"
"application>在内核中的实现原理。"

#. (itstool) path: sect2/title
#: book.translate.xml:3362
msgid "Userland Code"
msgstr "用户级代码"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3364
msgid "<primary>Jail</primary> <secondary>Userland Program</secondary>"
msgstr ""
"<primary>Jail</primary> <secondary>Userland Program（用户级程序）</secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:3367
msgid ""
"The source for the userland <application>jail</application> is located in "
"<filename>/usr/src/usr.sbin/jail</filename>, consisting of one file, "
"<filename>jail.c</filename>. The program takes these arguments: the path of "
"the <application>jail</application>, hostname, IP address, and the command "
"to be executed."
msgstr ""
"<application>Jail</application>的用户级源代码在<filename>/usr/src/usr.sbin/"
"jail</filename>，由一个文件<filename>jail.c</filename>组成。这个程序有这些参"
"数：<application>jail</application>的路径，主机名，IP地址，还有需要执行的命"
"令。"

#. (itstool) path: sect3/title
#: book.translate.xml:3375
msgid "Data Structures"
msgstr "数据结构"

#. (itstool) path: sect3/para
#: book.translate.xml:3377
msgid ""
"In <filename>jail.c</filename>, the first thing I would note is the "
"declaration of an important structure <literal>struct jail j;</literal> "
"which was included from <filename>/usr/include/sys/jail.h</filename>."
msgstr ""
"在<filename>jail.c</filename>中，我将最先注解的是一个重要结构体"
"<literal>struct jail j;</literal>的声明，这个结构类型的声明包含在<filename>/"
"usr/include/sys/jail.h</filename>之中。"

#. (itstool) path: sect3/para
#: book.translate.xml:3382
msgid "The definition of the <literal>jail</literal> structure is:"
msgstr "<literal>jail</literal>结构的定义是："

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3385
#, no-wrap
msgid ""
"<filename>/usr/include/sys/jail.h</filename>:\n"
"\n"
"struct jail {\n"
"        u_int32_t       version;\n"
"        char            *path;\n"
"        char            *hostname;\n"
"        u_int32_t       ip_number;\n"
"};"
msgstr ""
"<filename>/usr/include/sys/jail.h</filename>:\n"
"\n"
"struct jail {\n"
"        u_int32_t       version;\n"
"        char            *path;\n"
"        char            *hostname;\n"
"        u_int32_t       ip_number;\n"
"};"

#. (itstool) path: sect3/para
#: book.translate.xml:3394
msgid ""
"As you can see, there is an entry for each of the arguments passed to the "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> program, and indeed, they are set during its execution."
msgstr ""
"正如你所见，传送给命令<citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>的每个参数都在这里有对应"
"的一项。事实上，当命令<citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>被执行时，这些参数才由命"
"令行真正传入。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3398
#, no-wrap
msgid ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>\n"
"char path[PATH_MAX];\n"
"...\n"
"if (realpath(argv[0], path) == NULL)\n"
"    err(1, \"realpath: %s\", argv[0]);\n"
"if (chdir(path) != 0)\n"
"    err(1, \"chdir: %s\", path);\n"
"memset(&amp;j, 0, sizeof(j));\n"
"j.version = 0;\n"
"j.path = path;\n"
"j.hostname = argv[1];"
msgstr ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>\n"
"char path[PATH_MAX];\n"
"...\n"
"if (realpath(argv[0], path) == NULL)\n"
"    err(1, \"realpath: %s\", argv[0]);\n"
"if (chdir(path) != 0)\n"
"    err(1, \"chdir: %s\", path);\n"
"memset(&amp;j, 0, sizeof(j));\n"
"j.version = 0;\n"
"j.path = path;\n"
"j.hostname = argv[1];"

#. (itstool) path: sect3/title
#: book.translate.xml:3412
msgid "Networking"
msgstr "网络设置"

#. (itstool) path: sect3/para
#: book.translate.xml:3414
msgid ""
"One of the arguments passed to the <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry> program is an IP "
"address with which the <application>jail</application> can be accessed over "
"the network. <citerefentry><refentrytitle>jail</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry> translates the IP address given into host byte "
"order and then stores it in <literal>j</literal> (the <literal>jail</"
"literal> structure)."
msgstr ""
">传给<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>的参数中有一个是IP地址。这是在网络上访问"
"<application>jail</application>时的地址。<citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>将IP地址翻译成网络字节顺"
"序，并存入<literal>j</literal>(<literal>jail</literal>类型的结构体)。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3421
#, no-wrap
msgid ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>:\n"
"struct in_addr in;\n"
"...\n"
"if (inet_aton(argv[2], &amp;in) == 0)\n"
"    errx(1, \"Could not make sense of ip-number: %s\", argv[2]);\n"
"j.ip_number = ntohl(in.s_addr);"
msgstr ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>:\n"
"struct in_addr in;\n"
"...\n"
"if (inet_aton(argv[2], &amp;in) == 0)\n"
"    errx(1, \"Could not make sense of ip-number: %s\", argv[2]);\n"
"j.ip_number = ntohl(in.s_addr);"

#. (itstool) path: sect3/para
#: book.translate.xml:3428
msgid ""
"The <citerefentry><refentrytitle>inet_aton</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry> function \"interprets the specified character "
"string as an Internet address, placing the address into the structure "
"provided.\" The <literal>ip_number</literal> member in the <literal>jail</"
"literal> structure is set only when the IP address placed onto the "
"<literal>in</literal> structure by <citerefentry><refentrytitle>inet_aton</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry> is translated into "
"host byte order by <citerefentry><refentrytitle>ntohl</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>."
msgstr ""
">函数<citerefentry><refentrytitle>inet_aton</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry>“将指定的字符串解释为一个Internet地址，并将其转存到"
"指定的结构体中”。<citerefentry><refentrytitle>inet_aton</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>设定了结构体in，之后in中"
"的内容再用<citerefentry><refentrytitle>ntohl</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry>转换成主机字节顺序，并置入<literal>jail</literal>结"
"构体的<literal>ip_number</literal>成员。"

#. (itstool) path: sect3/title
#: book.translate.xml:3439
msgid "Jailing the Process"
msgstr "囚禁进程"

#. (itstool) path: sect3/para
#: book.translate.xml:3441
msgid ""
"Finally, the userland program jails the process. <application>Jail</"
"application> now becomes an imprisoned process itself and then executes the "
"command given using <citerefentry><refentrytitle>execv</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>."
msgstr ""
"最后，用户级程序囚禁进程。现在Jail自身变成了一个被囚禁的进程，并使用"
"<citerefentry><refentrytitle>execv</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>执行用户指定的命令。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3446
#, no-wrap
msgid ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>\n"
"i = jail(&amp;j);\n"
"...\n"
"if (execv(argv[3], argv + 3) != 0)\n"
"    err(1, \"execv: %s\", argv[3]);"
msgstr ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>\n"
"i = jail(&amp;j);\n"
"...\n"
"if (execv(argv[3], argv + 3) != 0)\n"
"    err(1, \"execv: %s\", argv[3]);"

#. (itstool) path: sect3/para
#: book.translate.xml:3452
msgid ""
"As you can see, the <literal>jail()</literal> function is called, and its "
"argument is the <literal>jail</literal> structure which has been filled with "
"the arguments given to the program. Finally, the program you specify is "
"executed. I will now discuss how <application>jail</application> is "
"implemented within the kernel."
msgstr ""
"正如你所见，函数<literal>jail()</literal>被调用，参数是结构体<literal>jail</"
"literal>中被填入数据项，而如前所述，这些数据项又来自"
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry>的命令行参数。最后，执行了用户指定的命令。下面我将开始讨论"
"<literal>jail</literal>在内核中的实现。"

#. (itstool) path: sect2/title
#: book.translate.xml:3462
msgid "Kernel Space"
msgstr "内核空间"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3464
msgid "<primary>Jail</primary> <secondary>Kernel Architecture</secondary>"
msgstr ""
"<primary>Jail</primary> <secondary>Kernel Architecture（内核架构）</"
"secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:3467
msgid ""
"We will now be looking at the file <filename>/usr/src/sys/kern/kern_jail.c</"
"filename>. This is the file where the <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> system call, "
"appropriate sysctls, and networking functions are defined."
msgstr ""
"现在我们来看文件<filename>/usr/src/sys/kern/kern_jail.c</filename>。\n"
"        在这里定义了<citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>的系统调用、相关的sysctl"
"项，还有网络函数。"

#. (itstool) path: sect3/title
#: book.translate.xml:3473
msgid "Sysctls"
msgstr "Sysctls选项"

#. (itstool) path: sect3/indexterm
#: book.translate.xml:3475
msgid "<primary>sysctl</primary>"
msgstr "<primary>sysctl选项</primary>"

#. (itstool) path: sect3/para
#: book.translate.xml:3477
msgid "In <filename>kern_jail.c</filename>, the following sysctls are defined:"
msgstr "在<filename>kern_jail.c</filename>里定义了如下sysctl项："

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3480
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"int     jail_set_hostname_allowed = 1;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, set_hostname_allowed, CTLFLAG_RW,\n"
"    &amp;jail_set_hostname_allowed, 0,\n"
"    \"Processes in jail can set their hostnames\");\n"
"\n"
"int     jail_socket_unixiproute_only = 1;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, socket_unixiproute_only, CTLFLAG_RW,\n"
"    &amp;jail_socket_unixiproute_only, 0,\n"
"    \"Processes in jail are limited to creating UNIX/IPv4/route sockets only\");\n"
"\n"
"int     jail_sysvipc_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, sysvipc_allowed, CTLFLAG_RW,\n"
"    &amp;jail_sysvipc_allowed, 0,\n"
"    \"Processes in jail can use System V IPC primitives\");\n"
"\n"
"static int jail_enforce_statfs = 2;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, enforce_statfs, CTLFLAG_RW,\n"
"    &amp;jail_enforce_statfs, 0,\n"
"    \"Processes in jail cannot see all mounted file systems\");\n"
"\n"
"int    jail_allow_raw_sockets = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, allow_raw_sockets, CTLFLAG_RW,\n"
"    &amp;jail_allow_raw_sockets, 0,\n"
"    \"Prison root can create raw sockets\");\n"
"\n"
"int    jail_chflags_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, chflags_allowed, CTLFLAG_RW,\n"
"    &amp;jail_chflags_allowed, 0,\n"
"    \"Processes in jail can alter system file flags\");\n"
"\n"
"int     jail_mount_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, mount_allowed, CTLFLAG_RW,\n"
"    &amp;jail_mount_allowed, 0,\n"
"    \"Processes in jail can mount/unmount jail-friendly file systems\");"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"int     jail_set_hostname_allowed = 1;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, set_hostname_allowed, CTLFLAG_RW,\n"
"    &amp;jail_set_hostname_allowed, 0,\n"
"    \"Processes in jail can set their hostnames\");\n"
"\n"
"int     jail_socket_unixiproute_only = 1;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, socket_unixiproute_only, CTLFLAG_RW,\n"
"    &amp;jail_socket_unixiproute_only, 0,\n"
"    \"Processes in jail are limited to creating UNIX/IPv4/route sockets only\");\n"
"\n"
"int     jail_sysvipc_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, sysvipc_allowed, CTLFLAG_RW,\n"
"    &amp;jail_sysvipc_allowed, 0,\n"
"    \"Processes in jail can use System V IPC primitives\");\n"
"\n"
"static int jail_enforce_statfs = 2;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, enforce_statfs, CTLFLAG_RW,\n"
"    &amp;jail_enforce_statfs, 0,\n"
"    \"Processes in jail cannot see all mounted file systems\");\n"
"\n"
"int    jail_allow_raw_sockets = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, allow_raw_sockets, CTLFLAG_RW,\n"
"    &amp;jail_allow_raw_sockets, 0,\n"
"    \"Prison root can create raw sockets\");\n"
"\n"
"int    jail_chflags_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, chflags_allowed, CTLFLAG_RW,\n"
"    &amp;jail_chflags_allowed, 0,\n"
"    \"Processes in jail can alter system file flags\");\n"
"\n"
"int     jail_mount_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, mount_allowed, CTLFLAG_RW,\n"
"    &amp;jail_mount_allowed, 0,\n"
"    \"Processes in jail can mount/unmount jail-friendly file systems\");"

#. (itstool) path: sect3/para
#: book.translate.xml:3516
msgid ""
"Each of these sysctls can be accessed by the user through the "
"<citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> program. Throughout the kernel, these specific sysctls are "
"recognized by their name. For example, the name of the first sysctl is "
"<literal>security.jail.set_hostname_allowed</literal>."
msgstr ""
"这些sysctl项中的每一个都可以用命令<citerefentry><refentrytitle>sysctl</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>访问。在整个内核中，这些"
"sysctl项按名称标识。例如，上述第一个sysctl项的名字是<literal>security.jail."
"set_hostname_allowed</literal>。"

#. (itstool) path: sect3/title
#: book.translate.xml:3524
msgid ""
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> System Call"
msgstr ""
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> 系统调用"

#. (itstool) path: sect3/para
#: book.translate.xml:3526
msgid ""
"Like all system calls, the <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> system call takes two "
"arguments, <literal>struct thread *td</literal> and <literal>struct "
"jail_args *uap</literal>. <literal>td</literal> is a pointer to the "
"<literal>thread</literal> structure which describes the calling thread. In "
"this context, <literal>uap</literal> is a pointer to the structure in which "
"a pointer to the <literal>jail</literal> structure passed by the userland "
"<filename>jail.c</filename> is contained. When I described the userland "
"program before, you saw that the <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> system call was given "
"a <literal>jail</literal> structure as its own argument."
msgstr ""
"像所有的系统调用一样，系统调用<citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>带有两个参数，"
"<literal>struct thread *td</literal>和<literal>struct jail_args *uap</"
"literal>。<literal>td</literal>是一个指向<literal>thread</literal>结构体的指"
"针，该指针用于描述调用<citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>的线程。在这个上下文中，"
"<literal>uap</literal>指向一个结构体，这个结构体中包含了一个指向从用户级"
"<filename>jail.c</filename>传送过来的<literal>jail</literal>结构体的指针。在"
"前面我讲述用户级程序时，你已经看到过一个<literal>jail</literal>结构体被作为参"
"数传送给系统调用<citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3539
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"/*\n"
" * struct jail_args {\n"
" *  struct jail *jail;\n"
" * };\n"
" */\n"
"int\n"
"jail(struct thread *td, struct jail_args *uap)"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"/*\n"
" * struct jail_args {\n"
" *  struct jail *jail;\n"
" * };\n"
" */\n"
"int\n"
"jail(struct thread *td, struct jail_args *uap)"

#. (itstool) path: sect3/para
#: book.translate.xml:3548
msgid ""
"Therefore, <literal>uap-&gt;jail</literal> can be used to access the "
"<literal>jail</literal> structure which was passed to the system call. Next, "
"the system call copies the <literal>jail</literal> structure into kernel "
"space using the <citerefentry><refentrytitle>copyin</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> function. "
"<citerefentry><refentrytitle>copyin</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> takes three arguments: the address of the data which is to be "
"copied into kernel space, <literal>uap-&gt;jail</literal>, where to store "
"it, <literal>j</literal> and the size of the storage. The <literal>jail</"
"literal> structure pointed by <literal>uap-&gt;jail</literal> is copied into "
"kernel space and is stored in another <literal>jail</literal> structure, "
"<literal>j</literal>."
msgstr ""
"于是<literal>uap-&gt;jail</literal>可以用于访问被传递给"
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>的<literal>jail</literal>结构体。然后，"
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>使用<citerefentry><refentrytitle>copyin</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>将<literal>jail</"
"literal>结构体复制到内核内存空间中。<citerefentry><refentrytitle>copyin</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>需要三个参数：要复制进内"
"核内存空间的数据的地址<literal>uap-&gt;jail</literal>，在内核内存空间存放数据"
"的<literal>j</literal>，以及数据的大小。<literal>uap-&gt;jail</literal>指向的"
"Jail结构体被复制进内核内存空间，并被存放在另一个<literal>jail</literal>结构体"
"<literal>j</literal>里。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3561
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"error = copyin(uap-&gt;jail, &amp;j, sizeof(j));"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"error = copyin(uap-&gt;jail, &amp;j, sizeof(j));"

#. (itstool) path: sect3/para
#: book.translate.xml:3564
msgid ""
"There is another important structure defined in <filename>jail.h</filename>. "
"It is the <literal>prison</literal> structure. The <literal>prison</literal> "
"structure is used exclusively within kernel space. Here is the definition of "
"the <literal>prison</literal> structure."
msgstr ""
"在jail.h中定义了另一个重要的结构体型prison。结构体<literal>prison</literal>只"
"被用在内核空间中。下面是<literal>prison</literal>结构体的定义。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3571
#, no-wrap
msgid ""
"<filename>/usr/include/sys/jail.h</filename>:\n"
"struct prison {\n"
"        LIST_ENTRY(prison) pr_list;                     /* (a) all prisons */\n"
"        int              pr_id;                         /* (c) prison id */\n"
"        int              pr_ref;                        /* (p) refcount */\n"
"        char             pr_path[MAXPATHLEN];           /* (c) chroot path */\n"
"        struct vnode    *pr_root;                       /* (c) vnode to rdir */\n"
"        char             pr_host[MAXHOSTNAMELEN];       /* (p) jail hostname */\n"
"        u_int32_t        pr_ip;                         /* (c) ip addr host */\n"
"        void            *pr_linux;                      /* (p) linux abi */\n"
"        int              pr_securelevel;                /* (p) securelevel */\n"
"        struct task      pr_task;                       /* (d) destroy task */\n"
"        struct mtx       pr_mtx;\n"
"      void            **pr_slots;                     /* (p) additional data */\n"
"};"
msgstr ""
"<filename>/usr/include/sys/jail.h</filename>:\n"
"struct prison {\n"
"        LIST_ENTRY(prison) pr_list;                     /* (a) all prisons */\n"
"        int              pr_id;                         /* (c) prison id */\n"
"        int              pr_ref;                        /* (p) refcount */\n"
"        char             pr_path[MAXPATHLEN];           /* (c) chroot path */\n"
"        struct vnode    *pr_root;                       /* (c) vnode to rdir */\n"
"        char             pr_host[MAXHOSTNAMELEN];       /* (p) jail hostname */\n"
"        u_int32_t        pr_ip;                         /* (c) ip addr host */\n"
"        void            *pr_linux;                      /* (p) linux abi */\n"
"        int              pr_securelevel;                /* (p) securelevel */\n"
"        struct task      pr_task;                       /* (d) destroy task */\n"
"        struct mtx       pr_mtx;\n"
"      void            **pr_slots;                     /* (p) additional data */\n"
"};"

#. (itstool) path: sect3/para
#: book.translate.xml:3587
msgid ""
"The <citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> system call then allocates memory for a "
"<literal>prison</literal> structure and copies data between the "
"<literal>jail</literal> and <literal>prison</literal> structure."
msgstr ""
"然后，系统调用<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>为一个<literal>prison</literal>结构体分配一块内存，"
"并在<literal>jail</literal>和<literal>prison</literal>结构体之间复制数据。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3592
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>:\n"
"MALLOC(pr, struct prison *, sizeof(*pr), M_PRISON, M_WAITOK | M_ZERO);\n"
"...\n"
"error = copyinstr(j.path, &amp;pr-&gt;pr_path, sizeof(pr-&gt;pr_path), 0);\n"
"if (error)\n"
"    goto e_killmtx;\n"
"...\n"
"error = copyinstr(j.hostname, &amp;pr-&gt;pr_host, sizeof(pr-&gt;pr_host), 0);\n"
"if (error)\n"
"     goto e_dropvnref;\n"
"pr-&gt;pr_ip = j.ip_number;"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>:\n"
"MALLOC(pr, struct prison *, sizeof(*pr), M_PRISON, M_WAITOK | M_ZERO);\n"
"...\n"
"error = copyinstr(j.path, &amp;pr-&gt;pr_path, sizeof(pr-&gt;pr_path), 0);\n"
"if (error)\n"
"    goto e_killmtx;\n"
"...\n"
"error = copyinstr(j.hostname, &amp;pr-&gt;pr_host, sizeof(pr-&gt;pr_host), 0);\n"
"if (error)\n"
"     goto e_dropvnref;\n"
"pr-&gt;pr_ip = j.ip_number;"

#. (itstool) path: sect3/para
#: book.translate.xml:3604
msgid ""
"Next, we will discuss another important system call "
"<citerefentry><refentrytitle>jail_attach</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>, which implements the function to put a process "
"into the <application>jail</application>."
msgstr ""
"下面，我们将讨论另外一个重要的系统调用"
"<citerefentry><refentrytitle>jail_attach</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>，它实现了将进程监禁的功能。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3608
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>:\n"
"/*\n"
" * struct jail_attach_args {\n"
" *      int jid;\n"
" * };\n"
" */\n"
"int\n"
"jail_attach(struct thread *td, struct jail_attach_args *uap)"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>:\n"
"/*\n"
" * struct jail_attach_args {\n"
" *      int jid;\n"
" * };\n"
" */\n"
"int\n"
"jail_attach(struct thread *td, struct jail_attach_args *uap)"

#. (itstool) path: sect3/para
#: book.translate.xml:3617
msgid ""
"This system call makes the changes that can distinguish a jailed process "
"from those unjailed ones. To understand what "
"<citerefentry><refentrytitle>jail_attach</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> does for us, certain background information is "
"needed."
msgstr ""
"这个系统调用做出一些可以用于区分被监禁和未被监禁的进程的改变。要理解"
"<citerefentry><refentrytitle>jail_attach</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>为我们做了什么，我们首先要理解一些背景信息。"

#. (itstool) path: sect3/para
#: book.translate.xml:3622
msgid ""
"On FreeBSD, each kernel visible thread is identified by its <literal>thread</"
"literal> structure, while the processes are described by their "
"<literal>proc</literal> structures. You can find the definitions of the "
"<literal>thread</literal> and <literal>proc</literal> structure in "
"<filename>/usr/include/sys/proc.h</filename>. For example, the <literal>td</"
"literal> argument in any system call is actually a pointer to the calling "
"thread's <literal>thread</literal> structure, as stated before. The "
"<literal>td_proc</literal> member in the <literal>thread</literal> structure "
"pointed by <literal>td</literal> is a pointer to the <literal>proc</literal> "
"structure which represents the process that contains the thread represented "
"by <literal>td</literal>. The <literal>proc</literal> structure contains "
"members which can describe the owner's identity(<literal>p_ucred</literal>), "
"the process resource limits(<literal>p_limit</literal>), and so on. In the "
"<literal>ucred</literal> structure pointed by <literal>p_ucred</literal> "
"member in the <literal>proc</literal> structure, there is a pointer to the "
"<literal>prison</literal> structure(<literal>cr_prison</literal>)."
msgstr ""
"在FreeBSD中，每个对内核可见的线程是通过其<literal>thread</literal>结构体来识"
"别的，同时，进程都由它们自己的<literal>proc</literal>结构体描述。你可以在"
"<filename>/usr/include/sys/proc.h</filename>中找到<literal>thread</literal>和"
"<literal>proc</literal>结构体的定义。例如，在任何系统调用中，参数"
"<literal>td</literal>实际上是个指向调用线程的<literal>thread</literal>结构体"
"的指针，正如前面所说的那样。<literal>td</literal>所指向的<literal>thread</"
"literal>结构体中的<literal>td_proc</literal>成员是一个指针，这个指针指向"
"<literal>td</literal>所表示的线程所属进程的<literal>proc</literal>结构体。结"
"构体<literal>proc</literal>包含的成员可以描述所有者的身份(<literal>p_ucred</"
"literal>)，进程资源限制(<literal>p_limit</literal>)，等等。在由"
"<literal>proc</literal>结构体的<literal>p_ucred</literal>成员所指向的ucred结"
"构体的定义中，还有一个指向<literal>prison</literal>结构体的指针"
"(<literal>cr_prison</literal>)。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3646
#, no-wrap
msgid ""
"<filename>/usr/include/sys/proc.h:</filename>\n"
"struct thread {\n"
"    ...\n"
"    struct proc *td_proc;\n"
"    ...\n"
"};\n"
"struct proc {\n"
"    ...\n"
"    struct ucred *p_ucred;\n"
"    ...\n"
"};\n"
"<filename>/usr/include/sys/ucred.h</filename>\n"
"struct ucred {\n"
"    ...\n"
"    struct prison *cr_prison;\n"
"    ...\n"
"};"
msgstr ""
"<filename>/usr/include/sys/proc.h:</filename>\n"
"struct thread {\n"
"    ...\n"
"    struct proc *td_proc;\n"
"    ...\n"
"};\n"
"struct proc {\n"
"    ...\n"
"    struct ucred *p_ucred;\n"
"    ...\n"
"};\n"
"<filename>/usr/include/sys/ucred.h</filename>\n"
"struct ucred {\n"
"    ...\n"
"    struct prison *cr_prison;\n"
"    ...\n"
"};"

#. (itstool) path: sect3/para
#: book.translate.xml:3664
msgid ""
"In <filename>kern_jail.c</filename>, the function <literal>jail()</literal> "
"then calls function <literal>jail_attach()</literal> with a given "
"<literal>jid</literal>. And <literal>jail_attach()</literal> calls function "
"<literal>change_root()</literal> to change the root directory of the calling "
"process. The <literal>jail_attach()</literal> then creates a new "
"<literal>ucred</literal> structure, and attaches the newly created "
"<literal>ucred</literal> structure to the calling process after it has "
"successfully attached the <literal>prison</literal> structure to the "
"<literal>ucred</literal> structure. From then on, the calling process is "
"recognized as jailed. When the kernel routine <literal>jailed()</literal> is "
"called in the kernel with the newly created <literal>ucred</literal> "
"structure as its argument, it returns 1 to tell that the credential is "
"connected with a <application>jail</application>. The public ancestor "
"process of all the process forked within the <application>jail</"
"application>, is the process which runs <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>, as it calls the "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> system call. When a program is executed through "
"<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>, it inherits the jailed property of its parent's "
"<literal>ucred</literal> structure, therefore it has a jailed "
"<literal>ucred</literal> structure."
msgstr ""
"在<filename>kern_jail.c</filename>中，函数<literal>jail()</literal>以给定的"
"<literal>jid</literal>调用函数<literal>jail_attach()</literal>。随后"
"<literal>jail_attach()</literal>调用函数<literal>change_root()</literal>以改"
"变调用进程的根目录。接下来，<literal>jail_attach()</literal>创建一个新的"
"<literal>ucred</literal>结构体，并在成功地将<literal>prison</literal>结构体连"
"接到这个<literal>ucred</literal>结构体后，将这个<literal>ucred</literal>结构"
"体连接到调用进程上。从此时起，这个调用进程就会被识别为被监禁的。当我们以新创"
"建的这个<literal>ucred</literal>结构体为参数调用内核路径<literal>jailed()</"
"literal>时，它将返回1来说明这个用户身份是和一个<application>jail</"
"application>相连的。在<application>jail</application>中叉分出来的所有进程的的"
"公共祖先进程就是这个执行了<citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>的进程，因为正是它调用了"
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>系统调用。当一个程序通过<citerefentry><refentrytitle>execve</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>而被执行时，它将从其父进"
"程的<literal>ucred</literal>结构体继承被监禁的属性，因而它也会拥有一个被监禁"
"的<literal>ucred</literal>结构体。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3690
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>\n"
"int\n"
"jail(struct thread *td, struct jail_args *uap)\n"
"{\n"
"...\n"
"    struct jail_attach_args jaa;\n"
"...\n"
"    error = jail_attach(td, &amp;jaa);\n"
"    if (error)\n"
"        goto e_dropprref;\n"
"...\n"
"}\n"
"\n"
"int\n"
"jail_attach(struct thread *td, struct jail_attach_args *uap)\n"
"{\n"
"    struct proc *p;\n"
"    struct ucred *newcred, *oldcred;\n"
"    struct prison *pr;\n"
"...\n"
"    p = td-&gt;td_proc;\n"
"...\n"
"    pr = prison_find(uap-&gt;jid);\n"
"...\n"
"    change_root(pr-&gt;pr_root, td);\n"
"...\n"
"    newcred-&gt;cr_prison = pr;\n"
"    p-&gt;p_ucred = newcred;\n"
"...\n"
"}"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>\n"
"int\n"
"jail(struct thread *td, struct jail_args *uap)\n"
"{\n"
"...\n"
"    struct jail_attach_args jaa;\n"
"...\n"
"    error = jail_attach(td, &amp;jaa);\n"
"    if (error)\n"
"        goto e_dropprref;\n"
"...\n"
"}\n"
"\n"
"int\n"
"jail_attach(struct thread *td, struct jail_attach_args *uap)\n"
"{\n"
"    struct proc *p;\n"
"    struct ucred *newcred, *oldcred;\n"
"    struct prison *pr;\n"
"...\n"
"    p = td-&gt;td_proc;\n"
"...\n"
"    pr = prison_find(uap-&gt;jid);\n"
"...\n"
"    change_root(pr-&gt;pr_root, td);\n"
"...\n"
"    newcred-&gt;cr_prison = pr;\n"
"    p-&gt;p_ucred = newcred;\n"
"...\n"
"}"

#. (itstool) path: sect3/para
#: book.translate.xml:3721
msgid ""
"When a process is forked from its parent process, the "
"<citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> system call uses <literal>crhold()</literal> to maintain the "
"credential for the newly forked process. It inherently keep the newly forked "
"child's credential consistent with its parent, so the child process is also "
"jailed."
msgstr ""
"当一个进程被从其父进程叉分来的时候，系统调用"
"<citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>将用<literal>crhold()</literal>来维护其身份凭证。这样，很自然的"
"就保持了子进程的身份凭证于其父进程一致，所以子进程也是被监禁的。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3728
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_fork.c</filename>:\n"
"p2-&gt;p_ucred = crhold(td-&gt;td_ucred);\n"
"...\n"
"td2-&gt;td_ucred = crhold(p2-&gt;p_ucred);"
msgstr ""
"<filename>/usr/src/sys/kern/kern_fork.c</filename>:\n"
"p2-&gt;p_ucred = crhold(td-&gt;td_ucred);\n"
"...\n"
"td2-&gt;td_ucred = crhold(p2-&gt;p_ucred);"

#. (itstool) path: sect1/title
#: book.translate.xml:3737
msgid "Restrictions"
msgstr "系统对被囚禁程序的限制"

#. (itstool) path: sect1/para
#: book.translate.xml:3739
msgid ""
"Throughout the kernel there are access restrictions relating to jailed "
"processes. Usually, these restrictions only check whether the process is "
"jailed, and if so, returns an error. For example:"
msgstr ""
"在整个内核中，有一系列对被囚禁程序的约束措施。通常，这些约束只对被囚禁的程序"
"有效。如果这些程序试图突破这些约束，相关的函数将出错返回。例如:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:3744
#, no-wrap
msgid ""
"if (jailed(td-&gt;td_ucred))\n"
"    return (EPERM);"
msgstr ""
"if (jailed(td-&gt;td_ucred))\n"
"    return (EPERM);"

#. (itstool) path: sect2/title
#: book.translate.xml:3748
msgid "SysV IPC"
msgstr "SysV进程间通信(IPC)"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3750
msgid "<primary>System V IPC</primary>"
msgstr "<primary>System V IPC(系统V进程间通信)</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:3752
msgid ""
"System V IPC is based on messages. Processes can send each other these "
"messages which tell them how to act. The functions which deal with messages "
"are: <citerefentry><refentrytitle>msgctl</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry>, <citerefentry><refentrytitle>msgget</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>msgsnd</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry> and <citerefentry><refentrytitle>msgrcv</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>. Earlier, I mentioned "
"that there were certain sysctls you could turn on or off in order to affect "
"the behavior of <application>jail</application>. One of these sysctls was "
"<literal>security.jail.sysvipc_allowed</literal>. By default, this sysctl is "
"set to 0. If it were set to 1, it would defeat the whole purpose of having a "
"<application>jail</application>; privileged users from the "
"<application>jail</application> would be able to affect processes outside "
"the jailed environment. The difference between a message and a signal is "
"that the message only consists of the signal number."
msgstr ""
"System V 进程间通信 (IPC) 是通过消息实现的。每个进程都可以向其它进程发送消"
"息， 告诉对方该做什么。处理消息的函数是： "
"<citerefentry><refentrytitle>msgctl</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>、<citerefentry><refentrytitle>msgget</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>、"
"<citerefentry><refentrytitle>msgsnd</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry> 和<citerefentry><refentrytitle>msgrcv</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>。前面已经提到，一些 "
"sysctl 开关可以影响 <application>jail</application> 的行为，其中有一个是 "
"<literal>security.jail.sysvipc_allowed</literal>。 在大多数系统上，这个 "
"sysctl 项会设成0。 如果将它设为1， 则会完全失去 <application>jail</"
"application> 的意义：因为那样在 <application>jail</application> 中特权进程就"
"可以影响被监禁的环境外的进程了。消息与信号的区别是：消息仅由一个信号编号组"
"成。"

#. (itstool) path: sect2/para
#: book.translate.xml:3767
msgid "<filename>/usr/src/sys/kern/sysv_msg.c</filename>:"
msgstr "<filename>/usr/src/sys/kern/sysv_msg.c</filename>:"

#. (itstool) path: listitem/para
#: book.translate.xml:3771
msgid ""
"<literal>msgget(key, msgflg)</literal>: <literal>msgget</literal> returns "
"(and possibly creates) a message descriptor that designates a message queue "
"for use in other functions."
msgstr ""
"<literal>msgget(key, msgflg)</literal><literal>msgget</literal>返回(也可能创"
"建)一个消息描述符，以指派一个在其它函数中使用的消息队列。"

#. (itstool) path: listitem/para
#: book.translate.xml:3778
msgid ""
"<literal>msgctl(msgid, cmd, buf)</literal>: Using this function, a process "
"can query the status of a message descriptor."
msgstr ""
"<literal>msgctl(msgid, cmd, buf)</literal>: 通过这个函数，一个进程可以查询一"
"个消息描述符的状态。"

#. (itstool) path: listitem/para
#: book.translate.xml:3784
msgid ""
"<literal>msgsnd(msgid, msgp, msgsz, msgflg)</literal>: <literal>msgsnd</"
"literal> sends a message to a process."
msgstr ""
"<literal>msgsnd(msgid, msgp, msgsz, msgflg)</literal>:<literal>msgsnd</"
"literal>向一个进程发送一条消息。"

#. (itstool) path: listitem/para
#: book.translate.xml:3790
msgid ""
"<literal>msgrcv(msgid, msgp, msgsz, msgtyp, msgflg)</literal>: a process "
"receives messages using this function"
msgstr ""
"<literal>msgrcv(msgid, msgp, msgsz, msgtyp, msgflg)</literal>:进程用这个函数"
"接收消息"

#. (itstool) path: sect2/para
#: book.translate.xml:3796
msgid ""
"In each of the system calls corresponding to these functions, there is this "
"conditional:"
msgstr "在这些函数对应的系统调用的代码中，都有这样一个条件判断："

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3799
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/sysv_msg.c</filename>:\n"
"if (!jail_sysvipc_allowed &amp;&amp; jailed(td-&gt;td_ucred))\n"
"    return (ENOSYS);"
msgstr ""
"<filename>/usr/src/sys/kern/sysv_msg.c</filename>:\n"
"if (!jail_sysvipc_allowed &amp;&amp; jailed(td-&gt;td_ucred))\n"
"    return (ENOSYS);"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3803
msgid "<primary>semaphores</primary>"
msgstr "<primary>semaphores(信号量)</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:3805
msgid ""
"Semaphore system calls allow processes to synchronize execution by doing a "
"set of operations atomically on a set of semaphores. Basically semaphores "
"provide another way for processes lock resources. However, process waiting "
"on a semaphore, that is being used, will sleep until the resources are "
"relinquished. The following semaphore system calls are blocked inside a "
"<application>jail</application>: <citerefentry><refentrytitle>semget</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>semctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> and <citerefentry><refentrytitle>semop</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>."
msgstr ""
"信号量系统调用使得进程可以通过一系列原子操作实现同步。信号量为进程锁定资源提"
"供了又一种途径。然而，进程将为正在被使用的信号量进入等待状态，一直休眠到资源"
"被释放。在<application>jail</application>中如下的信号量系统调用将会失效: "
"<citerefentry><refentrytitle>semget</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>, <citerefentry><refentrytitle>semctl</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>和"
"<citerefentry><refentrytitle>semop</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>。"

#. (itstool) path: sect2/para
#: book.translate.xml:3814
msgid "<filename>/usr/src/sys/kern/sysv_sem.c</filename>:"
msgstr "<filename>/usr/src/sys/kern/sysv_sem.c</filename>:"

#. (itstool) path: listitem/para
#: book.translate.xml:3818
msgid ""
"<literal>semctl(semid, semnum, cmd, ...)</literal>: <literal>semctl</"
"literal> does the specified <literal>cmd</literal> on the semaphore queue "
"indicated by <literal>semid</literal>."
msgstr ""
"<literal>semctl(semid, num, cmd, ...)</literal>:<literal>semctl</literal>对在"
"信号量队列中用<literal>semid</literal>标识的信号量执行<literal>cmd</literal>"
"指定的命令。"

#. (itstool) path: listitem/para
#: book.translate.xml:3824
msgid ""
"<literal>semget(key, nsems, flag)</literal>: <literal>semget</literal> "
"creates an array of semaphores, corresponding to <literal>key</literal>."
msgstr ""
"<literal>semget(key, nsems, flag)</literal>:<literal>semget</literal>建立一个"
"对应于<literal>key</literal>的信号量数组。"

#. (itstool) path: listitem/para
#: book.translate.xml:3828
msgid ""
"<literal>key and flag take on the same meaning as they do in msgget.</"
"literal>"
msgstr "<literal>参数key和flag与他们在msgget()的意义相同。</literal>"

#. (itstool) path: listitem/para
#: book.translate.xml:3832
msgid ""
"<literal>semop(semid, array, nops)</literal>: <literal>semop</literal> "
"performs a group of operations indicated by <literal>array</literal>, to the "
"set of semaphores identified by <literal>semid</literal>."
msgstr ""
"<literal>setop(semid, array, nops)</literal>:<literal>semop</literal>对semid"
"标识的信号量完成一组由array所指定的操作。"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3839
msgid "<primary>shared memory</primary>"
msgstr "<primary>shared memory(共享内存)</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:3841
msgid ""
"System V IPC allows for processes to share memory. Processes can communicate "
"directly with each other by sharing parts of their virtual address space and "
"then reading and writing data stored in the shared memory. These system "
"calls are blocked within a jailed environment: "
"<citerefentry><refentrytitle>shmdt</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>, <citerefentry><refentrytitle>shmat</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>shmctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> and <citerefentry><refentrytitle>shmget</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>."
msgstr ""
"System V IPC使进程间可以共享内存。进程之间可以通过它们虚拟地址空间共享部分以"
"及相关数据读写操作直接通讯。这些系统调用在被监禁的环境中将会失效:"
"<citerefentry><refentrytitle>shmdt</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>、<citerefentry><refentrytitle>shmat</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>、"
"<citerefentry><refentrytitle>shmctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>和<citerefentry><refentrytitle>shmget</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>。"

#. (itstool) path: sect2/para
#: book.translate.xml:3848
msgid "<filename>/usr/src/sys/kern/sysv_shm.c</filename>:"
msgstr "<filename>/usr/src/sys/kern/sysv_shm.c</filename>:"

#. (itstool) path: listitem/para
#: book.translate.xml:3851
msgid ""
"<literal>shmctl(shmid, cmd, buf)</literal>: <literal>shmctl</literal> does "
"various control operations on the shared memory region identified by "
"<literal>shmid</literal>."
msgstr ""
"<literal>shmctl(shmid, cmd, buf)</literal>:<literal>shmctl</literal>对"
"<literal>id</literal>标识的共享内存区域做各种各样的控制。"

#. (itstool) path: listitem/para
#: book.translate.xml:3857
msgid ""
"<literal>shmget(key, size, flag)</literal>: <literal>shmget</literal> "
"accesses or creates a shared memory region of <literal>size</literal> bytes."
msgstr ""
"<literal>shmget(key, size, flag)</literal>:<literal>shmget</literal>建立/打开"
"<literal>size</literal>字节的共享内存区域。"

#. (itstool) path: listitem/para
#: book.translate.xml:3863
msgid ""
"<literal>shmat(shmid, addr, flag)</literal>: <literal>shmat</literal> "
"attaches a shared memory region identified by <literal>shmid</literal> to "
"the address space of a process."
msgstr ""
"<literal>shmat(shmid, addr, flag)</literal>:<literal>shmat</literal>将"
"<literal>shmid</literal>标识的共享内存区域指派到进程的地址空间里。"

#. (itstool) path: listitem/para
#: book.translate.xml:3869
msgid ""
"<literal>shmdt(addr)</literal>: <literal>shmdt</literal> detaches the shared "
"memory region previously attached at <literal>addr</literal>."
msgstr ""
"<literal>shmdt(addr)</literal>:<literal>shmdt</literal>取消共享内存区域的地址"
"指派。"

#. (itstool) path: sect2/title
#: book.translate.xml:3878
msgid "Sockets"
msgstr "套接字"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3880
msgid "<primary>sockets</primary>"
msgstr "<primary>sockets(套接字)</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:3882
msgid ""
"<application>Jail</application> treats the "
"<citerefentry><refentrytitle>socket</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> system call and related lower-level socket functions in a "
"special manner. In order to determine whether a certain socket is allowed to "
"be created, it first checks to see if the sysctl <literal>security.jail."
"socket_unixiproute_only</literal> is set. If set, sockets are only allowed "
"to be created if the family specified is either <literal>PF_LOCAL</literal>, "
"<literal>PF_INET</literal> or <literal>PF_ROUTE</literal>. Otherwise, it "
"returns an error."
msgstr ""
"<application>Jail</application>以一种特殊的方式处理"
"<citerefentry><refentrytitle>socket</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>系统调用和相关的低级套接字函数。为了决定一个套接字是否允许被创"
"建，它先检查sysctl项<literal>security.jail.socket_unixiproute_only</literal>"
"是否被设置为1。如果被设为1，套接字建立时将只能指定这些协议族："
"<literal>PF_LOCAL</literal>, <literal>PF_INET</literal>,<literal>PF_ROUTE</"
"literal>。否则，<citerefentry><refentrytitle>socket</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>将会返回出错。"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3893
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/uipc_socket.c</filename>:\n"
"int\n"
"socreate(int dom, struct socket **aso, int type, int proto,\n"
"    struct ucred *cred, struct thread *td)\n"
"{\n"
"    struct protosw *prp;\n"
"...\n"
"    if (jailed(cred) &amp;&amp; jail_socket_unixiproute_only &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_LOCAL &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_INET &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_ROUTE) {\n"
"        return (EPROTONOSUPPORT);\n"
"    }\n"
"...\n"
"}"
msgstr ""
"<filename>/usr/src/sys/kern/uipc_socket.c</filename>:\n"
"int\n"
"socreate(int dom, struct socket **aso, int type, int proto,\n"
"    struct ucred *cred, struct thread *td)\n"
"{\n"
"    struct protosw *prp;\n"
"...\n"
"    if (jailed(cred) &amp;&amp; jail_socket_unixiproute_only &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_LOCAL &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_INET &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_ROUTE) {\n"
"        return (EPROTONOSUPPORT);\n"
"    }\n"
"...\n"
"}"

#. (itstool) path: sect2/title
#: book.translate.xml:3911
msgid "Berkeley Packet Filter"
msgstr "Berkeley包过滤器"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3913
msgid "<primary>Berkeley Packet Filter</primary>"
msgstr "<primary>Berkeley Packet Filter(伯克利包过滤器)</primary>"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3914
msgid "<primary>data link layer</primary>"
msgstr "<primary>data link layer(数据链路层)</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:3916
msgid ""
"The <application>Berkeley Packet Filter</application> provides a raw "
"interface to data link layers in a protocol independent fashion. "
"<application>BPF</application> is now controlled by the "
"<citerefentry><refentrytitle>devfs</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> whether it can be used in a jailed environment."
msgstr ""
"<application>Berkeley包过滤器</application>提供了一个与协议无关的，直接通向数"
"据链路层的低级接口。现在<application>BPF</application>是否可以在监禁的环境中"
"被使用是通过<citerefentry><refentrytitle>devfs</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>来控制的。"

#. (itstool) path: sect2/title
#: book.translate.xml:3925
msgid "Protocols"
msgstr "网络协议"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3927
msgid "<primary>protocols</primary>"
msgstr "<primary>protocols(协议)</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:3929
msgid ""
"There are certain protocols which are very common, such as TCP, UDP, IP and "
"ICMP. IP and ICMP are on the same level: the network layer 2. There are "
"certain precautions which are taken in order to prevent a jailed process "
"from binding a protocol to a certain address only if the <literal>nam</"
"literal> parameter is set. <literal>nam</literal> is a pointer to a "
"<literal>sockaddr</literal> structure, which describes the address on which "
"to bind the service. A more exact definition is that <literal>sockaddr</"
"literal> \"may be used as a template for referring to the identifying tag "
"and length of each address\". In the function <literal>in_pcbbind_setup()</"
"literal>, <literal>sin</literal> is a pointer to a <literal>sockaddr_in</"
"literal> structure, which contains the port, address, length and domain "
"family of the socket which is to be bound. Basically, this disallows any "
"processes from <application>jail</application> to be able to specify the "
"address that does not belong to the <application>jail</application> in which "
"the calling process exists."
msgstr ""
"网络协议TCP, UDP, IP和ICMP很常见。IP和ICMP处于同一协议层次：第二层，网络层。"
"当参数<literal>nam</literal>被设置时，有一些限制措施会防止被囚禁的程序绑定到"
"一些网络接口上。<literal>nam</literal>是一个指向<literal>sockaddr</literal>结"
"构体的指针，描述可以绑定服务的地址。一个更确切的定义：<literal>sockaddr</"
"literal>“是一个模板，包含了地址的标识符和地址的长度”。在函数"
"<literal>in_pcbbind_setup()</literal>中<literal>sin</literal>是一个指向"
"<literal>sockaddr_in</literal>结构体的指针，这个结构体包含了套接字可以绑定的"
"端口、地址、长度、协议族。这就禁止了在<application>jail</application>中的进程"
"指定不属于这个进程所存在于的<application>jail</application>的IP地址。"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3950
#, no-wrap
msgid ""
"<filename>/usr/src/sys/netinet/in_pcb.c</filename>:\n"
"int\n"
"in_pcbbind_setup(struct inpcb *inp, struct sockaddr *nam, in_addr_t *laddrp,\n"
"    u_short *lportp, struct ucred *cred)\n"
"{\n"
"    ...\n"
"    struct sockaddr_in *sin;\n"
"    ...\n"
"    if (nam) {\n"
"        sin = (struct sockaddr_in *)nam;\n"
"        ...\n"
"        if (sin-&gt;sin_addr.s_addr != INADDR_ANY)\n"
"            if (prison_ip(cred, 0, &amp;sin-&gt;sin_addr.s_addr))\n"
"                return(EINVAL);\n"
"        ...\n"
"        if (lport) {\n"
"            ...\n"
"            if (prison &amp;&amp; prison_ip(cred, 0, &amp;sin-&gt;sin_addr.s_addr))\n"
"                return (EADDRNOTAVAIL);\n"
"            ...\n"
"        }\n"
"    }\n"
"    if (lport == 0) {\n"
"        ...\n"
"        if (laddr.s_addr != INADDR_ANY)\n"
"            if (prison_ip(cred, 0, &amp;laddr.s_addr))\n"
"                return (EINVAL);\n"
"        ...\n"
"    }\n"
"...\n"
"    if (prison_ip(cred, 0, &amp;laddr.s_addr))\n"
"        return (EINVAL);\n"
"...\n"
"}"
msgstr ""
"<filename>/usr/src/sys/netinet/in_pcb.c</filename>:\n"
"int\n"
"in_pcbbind_setup(struct inpcb *inp, struct sockaddr *nam, in_addr_t *laddrp,\n"
"    u_short *lportp, struct ucred *cred)\n"
"{\n"
"    ...\n"
"    struct sockaddr_in *sin;\n"
"    ...\n"
"    if (nam) {\n"
"        sin = (struct sockaddr_in *)nam;\n"
"        ...\n"
"        if (sin-&gt;sin_addr.s_addr != INADDR_ANY)\n"
"            if (prison_ip(cred, 0, &amp;sin-&gt;sin_addr.s_addr))\n"
"                return(EINVAL);\n"
"        ...\n"
"        if (lport) {\n"
"            ...\n"
"            if (prison &amp;&amp; prison_ip(cred, 0, &amp;sin-&gt;sin_addr.s_addr))\n"
"                return (EADDRNOTAVAIL);\n"
"            ...\n"
"        }\n"
"    }\n"
"    if (lport == 0) {\n"
"        ...\n"
"        if (laddr.s_addr != INADDR_ANY)\n"
"            if (prison_ip(cred, 0, &amp;laddr.s_addr))\n"
"                return (EINVAL);\n"
"        ...\n"
"    }\n"
"...\n"
"    if (prison_ip(cred, 0, &amp;laddr.s_addr))\n"
"        return (EINVAL);\n"
"...\n"
"}"

#. (itstool) path: sect2/para
#: book.translate.xml:3985
msgid ""
"You might be wondering what function <literal>prison_ip()</literal> does. "
"<literal>prison_ip()</literal> is given three arguments, a pointer to the "
"credential(represented by <literal>cred</literal>), any flags, and an IP "
"address. It returns 1 if the IP address does NOT belong to the "
"<application>jail</application> or 0 otherwise. As you can see from the "
"code, if it is indeed an IP address not belonging to the <application>jail</"
"application>, the protocol is not allowed to bind to that address."
msgstr ""
"你也许想知道函数<literal>prison_ip()</literal>做什么。<literal>prison_ip()</"
"literal>有三个参数，一个指向身份凭证的指针(用<literal>cred</literal>表示)，一"
"些标志和一个IP地址。当这个IP地址不属于这个<application>jail</application>时，"
"返回1；否则返回0。正如你从代码中看见的，如果，那个IP地址确实不属于这个"
"<application>jail</application>，就不再允许向这个网络地址绑定协议。"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3996
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"int\n"
"prison_ip(struct ucred *cred, int flag, u_int32_t *ip)\n"
"{\n"
"    u_int32_t tmp;\n"
"\n"
"    if (!jailed(cred))\n"
"        return (0);\n"
"    if (flag)\n"
"        tmp = *ip;\n"
"    else\n"
"        tmp = ntohl(*ip);\n"
"    if (tmp == INADDR_ANY) {\n"
"        if (flag)\n"
"            *ip = cred-&gt;cr_prison-&gt;pr_ip;\n"
"        else\n"
"            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);\n"
"        return (0);\n"
"    }\n"
"    if (tmp == INADDR_LOOPBACK) {\n"
"        if (flag)\n"
"            *ip = cred-&gt;cr_prison-&gt;pr_ip;\n"
"        else\n"
"            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);\n"
"        return (0);\n"
"    }\n"
"    if (cred-&gt;cr_prison-&gt;pr_ip != tmp)\n"
"        return (1);\n"
"    return (0);\n"
"}"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"int\n"
"prison_ip(struct ucred *cred, int flag, u_int32_t *ip)\n"
"{\n"
"    u_int32_t tmp;\n"
"\n"
"    if (!jailed(cred))\n"
"        return (0);\n"
"    if (flag)\n"
"        tmp = *ip;\n"
"    else\n"
"        tmp = ntohl(*ip);\n"
"    if (tmp == INADDR_ANY) {\n"
"        if (flag)\n"
"            *ip = cred-&gt;cr_prison-&gt;pr_ip;\n"
"        else\n"
"            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);\n"
"        return (0);\n"
"    }\n"
"    if (tmp == INADDR_LOOPBACK) {\n"
"        if (flag)\n"
"            *ip = cred-&gt;cr_prison-&gt;pr_ip;\n"
"        else\n"
"            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);\n"
"        return (0);\n"
"    }\n"
"    if (cred-&gt;cr_prison-&gt;pr_ip != tmp)\n"
"        return (1);\n"
"    return (0);\n"
"}"

#. (itstool) path: sect2/title
#: book.translate.xml:4029
msgid "Filesystem"
msgstr "文件系统"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:4031
msgid "<primary>filesystem</primary>"
msgstr "<primary>filesystem（文件系统）</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:4033
msgid ""
"Even <literal>root</literal> users within the <application>jail</"
"application> are not allowed to unset or modify any file flags, such as "
"immutable, append-only, and undeleteable flags, if the securelevel is "
"greater than 0."
msgstr ""
"如果完全级别大于0，即便是<application>jail</application>里面的<literal>root</"
"literal>，也不允许在Jail中取消或更改文件标志，如“不可修改”、“只可添加”、“不可"
"删除”标志。"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:4039
#, no-wrap
msgid ""
"<filename>/usr/src/sys/ufs/ufs/ufs_vnops.c:</filename>\n"
"static int\n"
"ufs_setattr(ap)\n"
"    ...\n"
"{\n"
"    ...\n"
"        if (!priv_check_cred(cred, PRIV_VFS_SYSFLAGS, 0)) {\n"
"            if (ip-&gt;i_flags\n"
"                &amp; (SF_NOUNLINK | SF_IMMUTABLE | SF_APPEND)) {\n"
"                    error = securelevel_gt(cred, 0);\n"
"                    if (error)\n"
"                        return (error);\n"
"            }\n"
"            ...\n"
"        }\n"
"}\n"
"<filename>/usr/src/sys/kern/kern_priv.c</filename>\n"
"int\n"
"priv_check_cred(struct ucred *cred, int priv, int flags)\n"
"{\n"
"    ...\n"
"    error = prison_priv_check(cred, priv);\n"
"    if (error)\n"
"        return (error);\n"
"    ...\n"
"}\n"
"<filename>/usr/src/sys/kern/kern_jail.c</filename>\n"
"int\n"
"prison_priv_check(struct ucred *cred, int priv)\n"
"{\n"
"    ...\n"
"    switch (priv) {\n"
"    ...\n"
"    case PRIV_VFS_SYSFLAGS:\n"
"        if (jail_chflags_allowed)\n"
"            return (0);\n"
"        else\n"
"            return (EPERM);\n"
"    ...\n"
"    }\n"
"    ...\n"
"}"
msgstr ""
"<filename>/usr/src/sys/ufs/ufs/ufs_vnops.c:</filename>\n"
"static int\n"
"ufs_setattr(ap)\n"
"    ...\n"
"{\n"
"    ...\n"
"        if (!priv_check_cred(cred, PRIV_VFS_SYSFLAGS, 0)) {\n"
"            if (ip-&gt;i_flags\n"
"                &amp; (SF_NOUNLINK | SF_IMMUTABLE | SF_APPEND)) {\n"
"                    error = securelevel_gt(cred, 0);\n"
"                    if (error)\n"
"                        return (error);\n"
"            }\n"
"            ...\n"
"        }\n"
"}\n"
"<filename>/usr/src/sys/kern/kern_priv.c</filename>\n"
"int\n"
"priv_check_cred(struct ucred *cred, int priv, int flags)\n"
"{\n"
"    ...\n"
"    error = prison_priv_check(cred, priv);\n"
"    if (error)\n"
"        return (error);\n"
"    ...\n"
"}\n"
"<filename>/usr/src/sys/kern/kern_jail.c</filename>\n"
"int\n"
"prison_priv_check(struct ucred *cred, int priv)\n"
"{\n"
"    ...\n"
"    switch (priv) {\n"
"    ...\n"
"    case PRIV_VFS_SYSFLAGS:\n"
"        if (jail_chflags_allowed)\n"
"            return (0);\n"
"        else\n"
"            return (EPERM);\n"
"    ...\n"
"    }\n"
"    ...\n"
"}"

#. (itstool) path: chapter/title
#: book.translate.xml:4092
msgid "The SYSINIT Framework"
msgstr ">SYSINIT框架"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:4094
msgid "<primary>SYSINIT</primary>"
msgstr "<primary>SYSINIT(系统初始化)</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:4097
msgid "<primary>dynamic initialization</primary>"
msgstr "<primary>dynamic initialization(动态初始化)</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:4100
msgid "<primary>kernel initialization</primary> <secondary>dynamic</secondary>"
msgstr ""
"<primary>kernel initialization(内核初始化)</primary><secondary>dynamic(动"
"态)</secondary>"

#. (itstool) path: chapter/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:4104 book.translate.xml:15529
msgid "<primary>kernel modules</primary>"
msgstr "<primary>kernel modules(内核模块)</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:4107
msgid "<primary>kernel linker</primary>"
msgstr "<primary>kernel linker(内核链接器)</primary>"

#. (itstool) path: chapter/para
#: book.translate.xml:4111
msgid ""
"SYSINIT is the framework for a generic call sort and dispatch mechanism. "
"FreeBSD currently uses it for the dynamic initialization of the kernel. "
"SYSINIT allows FreeBSD's kernel subsystems to be reordered, and added, "
"removed, and replaced at kernel link time when the kernel or one of its "
"modules is loaded without having to edit a statically ordered initialization "
"routing and recompile the kernel. This system also allows kernel modules, "
"currently called <firstterm>KLD's</firstterm>, to be separately compiled, "
"linked, and initialized at boot time and loaded even later while the system "
"is already running. This is accomplished using the <quote>kernel linker</"
"quote> and <quote>linker sets</quote>."
msgstr ""
"SYSINIT是一个通用的调用排序与分别执行机制的框架。FreeBSD目前使用它来进行内核"
"的动态初始化。SYSINIT使得FreeBSD的内核各子系统可以在内核或模块动态加载链接时"
"被重整、添加、删除、替换，这样，内核和模块加载时就不必去修改一个静态的有序初"
"始化安排表甚至重新编译内核。这个体系也使得内核模块(现在称为<firstterm>KLD</"
"firstterm>可以与内核不同时编译、链接、在引导系统时加载，甚至在系统运行时加"
"载。这些操作是通过<quote>内核链接器</quote>(kernel linker)和<quote>链接器集合"
"</quote>(linker set)完成的。"

#. (itstool) path: varlistentry/term
#: book.translate.xml:4129
msgid "Linker Set"
msgstr "链接器集合(Linker Set)"

#. (itstool) path: listitem/para
#: book.translate.xml:4131
msgid ""
"A linker technique in which the linker gathers statically declared data "
"throughout a program's source files into a single contiguously addressable "
"unit of data."
msgstr ""
"一种链接方法。这种方法将整个程序源文件中静态申明的数据收集到一个可邻近寻址的"
"数据单元中。"

#. (itstool) path: sect1/title
#: book.translate.xml:4141
msgid "SYSINIT Operation"
msgstr "SYSINIT操作"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:4143
msgid "<primary>linker sets</primary>"
msgstr "<primary>linker sets(链接器集合)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:4145
msgid ""
"SYSINIT relies on the ability of the linker to take static data declared at "
"multiple locations throughout a program's source and group it together as a "
"single contiguous chunk of data. This linker technique is called a "
"<quote>linker set</quote>. SYSINIT uses two linker sets to maintain two data "
"sets containing each consumer's call order, function, and a pointer to the "
"data to pass to that function."
msgstr ""
"SYSINIT要依靠链接器获取遍布整个程序源代码多处申明的静态数据并把它们组成一个彼"
"此相邻的数据块。这种链接方法被称为<quote>链接器集合</quote>(linker set)。"
"SYSINIT使用两个链接器集合以维护两个数据集合，包含每个数据条目的调用顺序、函"
"数、一个会被提交给该函数的数据指针。"

#. (itstool) path: sect1/para
#: book.translate.xml:4153
msgid ""
"SYSINIT uses two priorities when ordering the functions for execution. The "
"first priority is a subsystem ID giving an overall order for SYSINIT's "
"dispatch of functions. Current predeclared ID's are in <filename>&lt;sys/"
"kernel.h&gt;</filename> in the enum list <literal>sysinit_sub_id</literal>. "
"The second priority used is an element order within the subsystem. Current "
"predeclared subsystem element orders are in <filename>&lt;sys/kernel.h&gt;</"
"filename> in the enum list <literal>sysinit_elem_order</literal>."
msgstr ""
"SYSINIT按照两类优先级标识对函数排序以便执行。第一类优先级的标识是子系统的标"
"识，给出SYSINIT分别执行子系统的函数的全局顺序，定义在<filename>&lt;sys/"
"kernel.h&gt;</filename>中的枚举<literal>sysinit_sub_id</literal>内。第二类优"
"先级标识在子系统中的元素的顺序，定义在<filename>&lt;sys/kernel.h&gt;</"
"filename>中的枚举<literal>sysinit_elem_order</literal>内。"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:4164
msgid "<primary>pseudo-devices</primary>"
msgstr "<primary>pseudo-device(伪设备)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:4166
msgid ""
"There are currently two uses for SYSINIT. Function dispatch at system "
"startup and kernel module loads, and function dispatch at system shutdown "
"and kernel module unload. Kernel subsystems often use system startup "
"SYSINIT's to initialize data structures, for example the process scheduling "
"subsystem uses a SYSINIT to initialize the run queue data structure. Device "
"drivers should avoid using <literal>SYSINIT()</literal> directly. Instead "
"drivers for real devices that are part of a bus structure should use "
"<literal>DRIVER_MODULE()</literal> to provide a function that detects the "
"device and, if it is present, initializes the device. It will do a few "
"things specific to devices and then call <literal>SYSINIT()</literal> "
"itself. For pseudo-devices, which are not part of a bus structure, use "
"<literal>DEV_MODULE()</literal>."
msgstr ""
"有两种时刻需要使用SYSINIT：系统启动或内核模块加载时，系统析构或内核模块卸载"
"时。内核子系统通常在系统启动时使用SYSINIT的定义项以初始化数据结构。例如，进程"
"调度子系统使用一个SYSINIT定义项来初始化运行队列数据结构。设备驱动程序应避免直"
"接使用<literal>SYSINIT()</literal>，对于总线结构上的物理真实设备应使用"
"<literal>DRIVER_MODULE()</literal>调用的函数先侦测设备的存在，如果存在，再进"
"行设备的初始化。这一系统过程中，会做一些专门针对设备的事情，然后调用"
"<literal>SYSINIT()</literal>本身。对于非总线结构一部分的虚设备，应改用"
"<literal>DEV_MODULE()</literal>。"

#. (itstool) path: sect1/title
#: book.translate.xml:4184
msgid "Using SYSINIT"
msgstr "使用SYSINIT"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:4192
#, no-wrap
msgid "&lt;sys/kernel.h&gt;"
msgstr "&lt;sys/kernel.h&gt;"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:4198
#, no-wrap
msgid ""
"SYSINIT(uniquifier, subsystem, order, func, ident)\n"
"SYSUNINIT(uniquifier, subsystem, order, func, ident)"
msgstr ""
"SYSINIT(uniquifier, subsystem, order, func, ident)\n"
"SYSUNINIT(uniquifier, subsystem, order, func, ident)"

#. (itstool) path: sect2/title
#: book.translate.xml:4204
msgid "Startup"
msgstr "启动"

#. (itstool) path: sect2/para
#: book.translate.xml:4206
msgid ""
"The <literal>SYSINIT()</literal> macro creates the necessary SYSINIT data in "
"SYSINIT's startup data set for SYSINIT to sort and dispatch a function at "
"system startup and module load. <literal>SYSINIT()</literal> takes a "
"uniquifier that SYSINIT uses to identify the particular function dispatch "
"data, the subsystem order, the subsystem element order, the function to "
"call, and the data to pass the function. All functions must take a constant "
"pointer argument."
msgstr ""
">宏<literal>SYSINIT()</literal>在SYSINIT启动数据集合中建立一个SYSINIT数据项，"
"以便SYSINIT在系统启动或模块加载时排序并执行其中的函数。<literal>SYSINIT()</"
"literal>有一个参数uniquifier，SYSINIT用它来标识数据项，随后是子系统顺序号、子"
"系统元素顺序号、待调用函数、传递给函数的数据。所有的函数必须有一个恒量指针参"
"数。"

#. (itstool) path: example/title
#: book.translate.xml:4216
msgid "Example of a <literal>SYSINIT()</literal>"
msgstr "<literal>SYSINIT()</literal>的例子"

#. (itstool) path: example/programlisting
#: book.translate.xml:4218
#, fuzzy, no-wrap
#| msgid ""
#| "#include &lt;sys/kernel.h&gt;\n"
#| "\n"
#| "void foo_null(void *unused)\n"
#| "{\n"
#| "        foo_doo();\n"
#| "}\n"
#| "SYSINIT(foo, SI_SUB_FOO, SI_ORDER_FOO, foo_null, NULL);\n"
#| "\n"
#| "struct foo foo_voodoo = {\n"
#| "        FOO_VOODOO;\n"
#| "}\n"
#| "\n"
#| "void foo_arg(void *vdata)\n"
#| "{\n"
#| "        struct foo *foo = (struct foo *)vdata;\n"
#| "        foo_data(foo);\n"
#| "}\n"
#| "SYSINIT(bar, SI_SUB_FOO, SI_ORDER_FOO, foo_arg, &amp;foo_voodoo);\n"
#| "\t"
msgid ""
"#include &lt;sys/kernel.h&gt;\n"
"\n"
"void foo_null(void *unused)\n"
"{\n"
"        foo_doo();\n"
"}\n"
"SYSINIT(foo, SI_SUB_FOO, SI_ORDER_FOO, foo_null, NULL);\n"
"\n"
"struct foo foo_voodoo = {\n"
"        FOO_VOODOO;\n"
"}\n"
"\n"
"void foo_arg(void *vdata)\n"
"{\n"
"        struct foo *foo = (struct foo *)vdata;\n"
"        foo_data(foo);\n"
"}\n"
"SYSINIT(bar, SI_SUB_FOO, SI_ORDER_FOO, foo_arg, &amp;foo_voodoo);"
msgstr ""
"#include &lt;sys/kernel.h&gt;\n"
"\n"
"void foo_null(void *unused)\n"
"{\n"
"        foo_doo();\n"
"}\n"
"SYSINIT(foo, SI_SUB_FOO, SI_ORDER_FOO, foo_null, NULL);\n"
"\n"
"struct foo foo_voodoo = {\n"
"        FOO_VOODOO;\n"
"}\n"
"\n"
"void foo_arg(void *vdata)\n"
"{\n"
"        struct foo *foo = (struct foo *)vdata;\n"
"        foo_data(foo);\n"
"}\n"
"SYSINIT(bar, SI_SUB_FOO, SI_ORDER_FOO, foo_arg, &amp;foo_voodoo);\n"
"\t"

#. (itstool) path: sect2/para
#: book.translate.xml:4237
msgid ""
"Note that <literal>SI_SUB_FOO</literal> and <literal>SI_ORDER_FOO</literal> "
"need to be in the <literal>sysinit_sub_id</literal> and "
"<literal>sysinit_elem_order</literal> enum's as mentioned above. Either use "
"existing ones or add your own to the enum's. You can also use math for fine-"
"tuning the order a SYSINIT will run in. This example shows a SYSINIT that "
"needs to be run just barely before the SYSINIT's that handle tuning kernel "
"parameters."
msgstr ""
"注意，<literal>SI_SUB_FOO</literal>和<literal>SI_ORDER_FOO</literal>应当分别"
"在上面提到的枚举<literal>sysinit_sub_id</literal>和"
"<literal>sysinit_elem_order</literal>之中。既可以使用已有的枚举项，也可以将自"
"己的枚举项添加到这两个枚举的定义之中。你可以使用数学表达式微调SYSINIT的执行顺"
"序。以下的例子示例了一个需要刚好要在内核参数调整的SYSINIT之前执行的SYSINIT。"

#. (itstool) path: example/title
#: book.translate.xml:4248
msgid "Example of Adjusting <literal>SYSINIT()</literal> Order"
msgstr "调整<literal>SYSINIT()</literal>顺序的例子"

#. (itstool) path: example/programlisting
#: book.translate.xml:4251
#, no-wrap
msgid ""
"static void\n"
"mptable_register(void *dummy __unused)\n"
"{\n"
"\n"
"\tapic_register_enumerator(&amp;mptable_enumerator);\n"
"}\n"
"\n"
"SYSINIT(mptable_register, SI_SUB_TUNABLES - 1, SI_ORDER_FIRST,\n"
"    mptable_register, NULL);"
msgstr ""
"static void\n"
"mptable_register(void *dummy __unused)\n"
"{\n"
"\n"
"\tapic_register_enumerator(&amp;mptable_enumerator);\n"
"}\n"
"\n"
"SYSINIT(mptable_register, SI_SUB_TUNABLES - 1, SI_ORDER_FIRST,\n"
"    mptable_register, NULL);"

#. (itstool) path: sect2/title
#: book.translate.xml:4264
msgid "Shutdown"
msgstr "关闭"

#. (itstool) path: sect2/para
#: book.translate.xml:4266
msgid ""
"The <literal>SYSUNINIT()</literal> macro behaves similarly to the "
"<literal>SYSINIT()</literal> macro except that it adds the SYSINIT data to "
"SYSINIT's shutdown data set."
msgstr ""
"宏<literal>SYSUNINIT()</literal>的行为与<literal>SYSINIT()</literal>的相当，"
"只是它将数据项填加至SYSINIT的析构数据集合。"

#. (itstool) path: example/title
#: book.translate.xml:4271
msgid "Example of a <literal>SYSUNINIT()</literal>"
msgstr "<literal>SYSUNINIT()</literal>的例子"

#. (itstool) path: example/programlisting
#: book.translate.xml:4273
#, fuzzy, no-wrap
#| msgid ""
#| "#include &lt;sys/kernel.h&gt;\n"
#| "\n"
#| "void foo_cleanup(void *unused)\n"
#| "{\n"
#| "        foo_kill();\n"
#| "}\n"
#| "SYSUNINIT(foobar, SI_SUB_FOO, SI_ORDER_FOO, foo_cleanup, NULL);\n"
#| "\n"
#| "struct foo_stack foo_stack = {\n"
#| "        FOO_STACK_VOODOO;\n"
#| "}\n"
#| "\n"
#| "void foo_flush(void *vdata)\n"
#| "{\n"
#| "}\n"
#| "SYSUNINIT(barfoo, SI_SUB_FOO, SI_ORDER_FOO, foo_flush, &amp;foo_stack);\n"
#| "\t"
msgid ""
"#include &lt;sys/kernel.h&gt;\n"
"\n"
"void foo_cleanup(void *unused)\n"
"{\n"
"        foo_kill();\n"
"}\n"
"SYSUNINIT(foobar, SI_SUB_FOO, SI_ORDER_FOO, foo_cleanup, NULL);\n"
"\n"
"struct foo_stack foo_stack = {\n"
"        FOO_STACK_VOODOO;\n"
"}\n"
"\n"
"void foo_flush(void *vdata)\n"
"{\n"
"}\n"
"SYSUNINIT(barfoo, SI_SUB_FOO, SI_ORDER_FOO, foo_flush, &amp;foo_stack);"
msgstr ""
"#include &lt;sys/kernel.h&gt;\n"
"\n"
"void foo_cleanup(void *unused)\n"
"{\n"
"        foo_kill();\n"
"}\n"
"SYSUNINIT(foobar, SI_SUB_FOO, SI_ORDER_FOO, foo_cleanup, NULL);\n"
"\n"
"struct foo_stack foo_stack = {\n"
"        FOO_STACK_VOODOO;\n"
"}\n"
"\n"
"void foo_flush(void *vdata)\n"
"{\n"
"}\n"
"SYSUNINIT(barfoo, SI_SUB_FOO, SI_ORDER_FOO, foo_flush, &amp;foo_stack);\n"
"\t"

#. (itstool) path: info/title
#: book.translate.xml:4330
msgid "The TrustedBSD MAC Framework"
msgstr "TrustedBSD MAC 框架"

#. (itstool) path: affiliation/address
#: book.translate.xml:4340
#, no-wrap
msgid ""
"\n"
"\t    <email>chris@FreeBSD.org</email>\n"
"\t  "
msgstr ""
"\n"
"\t    <email>chris@FreeBSD.org</email>\n"
"\t  "

#. (itstool) path: authorgroup/author
#: book.translate.xml:4333
msgid ""
"<personname> <firstname>Chris</firstname> <surname>Costello</surname> </"
"personname> <affiliation> <orgname>TrustedBSD Project</orgname> <_:address-1/"
"> </affiliation>"
msgstr ""
"<personname> <firstname>Chris</firstname> <surname>Costello</surname> </"
"personname> <affiliation> <orgname>TrustedBSD Project</orgname> <_:address-1/"
"> </affiliation>"

#. (itstool) path: affiliation/address
#: book.translate.xml:4353
#, no-wrap
msgid ""
"\n"
"\t    <email>rwatson@FreeBSD.org</email>\n"
"\t  "
msgstr ""
"\n"
"\t    <email>rwatson@FreeBSD.org</email>\n"
"\t  "

#. (itstool) path: authorgroup/author
#: book.translate.xml:4346
msgid ""
"<personname> <firstname>Robert</firstname> <surname>Watson</surname> </"
"personname> <affiliation> <orgname>TrustedBSD Project</orgname> <_:address-1/"
"> </affiliation>"
msgstr ""
"<personname> <firstname>Robert</firstname> <surname>Watson</surname> </"
"personname> <affiliation> <orgname>TrustedBSD Project</orgname> <_:address-1/"
"> </affiliation>"

#. (itstool) path: sect1/title
#: book.translate.xml:4362
msgid "MAC Documentation Copyright"
msgstr "MAC 文档版权声明"

#. (itstool) path: sect1/para
#: book.translate.xml:4364
msgid ""
"This documentation was developed for the FreeBSD Project by Chris Costello "
"at Safeport Network Services and Network Associates Laboratories, the "
"Security Research Division of Network Associates, Inc. under DARPA/SPAWAR "
"contract N66001-01-C-8035 (<quote>CBOSS</quote>), as part of the DARPA CHATS "
"research program."
msgstr ""
"本文档是作为 DARPA CHATS 研究计划的一部分，由供职于 Security Research "
"Division of Network Associates公司Safeport Network Services and Network "
"Associates Laboratories 的Chris Costello依据 DARPA/SPAWAR 合同 N66001-01-"
"C-8035 (<quote>CBOSS</quote>)，为 FreeBSD 项目编写的。"

#. (itstool) path: sect1/para
#: book.translate.xml:4371
msgid ""
"Redistribution and use in source (SGML DocBook) and 'compiled' forms (SGML, "
"HTML, PDF, PostScript, RTF and so forth) with or without modification, are "
"permitted provided that the following conditions are met:"
msgstr ""
"Redistribution and use in source (SGML DocBook) and 'compiled' forms (SGML, "
"HTML, PDF, PostScript, RTF and so forth) with or without modification, are "
"permitted provided that the following conditions are met:"

#. (itstool) path: listitem/para
#: book.translate.xml:4378
msgid ""
"Redistributions of source code (SGML DocBook) must retain the above "
"copyright notice, this list of conditions and the following disclaimer as "
"the first lines of this file unmodified."
msgstr ""
"Redistributions of source code (SGML DocBook) must retain the above "
"copyright notice, this list of conditions and the following disclaimer as "
"the first lines of this file unmodified."

#. (itstool) path: important/para
#: book.translate.xml:4395
msgid ""
"THIS DOCUMENTATION IS PROVIDED BY THE NETWORKS ASSOCIATES TECHNOLOGY, INC "
"\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED "
"TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR "
"PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETWORKS ASSOCIATES TECHNOLOGY, "
"INC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR "
"CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF "
"SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS "
"INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN "
"CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) "
"ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF "
"THE POSSIBILITY OF SUCH DAMAGE."
msgstr ""
"THIS DOCUMENTATION IS PROVIDED BY THE NETWORKS ASSOCIATES TECHNOLOGY, INC "
"\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED "
"TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR "
"PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETWORKS ASSOCIATES TECHNOLOGY, "
"INC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR "
"CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF "
"SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS "
"INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN "
"CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) "
"ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF "
"THE POSSIBILITY OF SUCH DAMAGE."

#. (itstool) path: sect1/para
#: book.translate.xml:4414
msgid ""
"FreeBSD includes experimental support for several mandatory access control "
"policies, as well as a framework for kernel security extensibility, the "
"TrustedBSD MAC Framework. The MAC Framework is a pluggable access control "
"framework, permitting new security policies to be easily linked into the "
"kernel, loaded at boot, or loaded dynamically at run-time. The framework "
"provides a variety of features to make it easier to implement new security "
"policies, including the ability to easily tag security labels (such as "
"confidentiality information) onto system objects."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:4425
msgid ""
"This chapter introduces the MAC policy framework and provides documentation "
"for a sample MAC policy module."
msgstr ""

#. (itstool) path: sect1/title
#: book.translate.xml:4431 book.translate.xml:14933 book.translate.xml:16103
#: book.translate.xml:21732 book.translate.xml:22852
msgid "Introduction"
msgstr "介绍"

#. (itstool) path: sect1/para
#: book.translate.xml:4433
msgid ""
"The TrustedBSD MAC framework provides a mechanism to allow the compile-time "
"or run-time extension of the kernel access control model. New system "
"policies may be implemented as kernel modules and linked to the kernel; if "
"multiple policy modules are present, their results will be composed. The MAC "
"Framework provides a variety of access control infrastructure services to "
"assist policy writers, including support for transient and persistent policy-"
"agnostic object security labels. This support is currently considered "
"experimental."
msgstr ""
"TrustedBSD MAC 框架提供的机制,允许在其上运行的内核模块在内核编译或者运行时，"
"对内核的访问控制模型进行扩展。新的系统安全策略作为一个内核模块实现,并被链接到"
"内核中；如果系统中同时存在多个安全策略模块，则它们的决策结果将以某种确定的方"
"式组合。为了给简化新安全策略的开发，MAC 向上提供了大量用于访问控制的基础设"
"施，特别是，对临时的或者持久的、策略无关的对象安全标记的支持。该支持目前仍是"
"试验性质的。"

#. (itstool) path: sect1/para
#: book.translate.xml:4443
msgid ""
"This chapter provides information appropriate for developers of policy "
"modules, as well as potential consumers of MAC-enabled environments, to "
"learn about how the MAC Framework supports access control extension of the "
"kernel."
msgstr ""
"本章所提供的信息不仅将使在 MAC 使能环境下工作的潜在用户受益，也可以为需要了"
"解 MAC 框架是如何支持对内核访问控制进行扩展的策略模块开发人员所用。"

#. (itstool) path: sect1/title
#: book.translate.xml:4450
msgid "Policy Background"
msgstr "安全策略背景知识"

#. (itstool) path: sect1/para
#: book.translate.xml:4452
msgid ""
"Mandatory Access Control (MAC), refers to a set of access control policies "
"that are mandatorily enforced on users by the operating system. MAC policies "
"may be contrasted with Discretionary Access Control (DAC) protections, by "
"which non-administrative users may (at their discretion) protect objects. In "
"traditional UNIX systems, DAC protections include file permissions and "
"access control lists; MAC protections include process controls preventing "
"inter-user debugging and firewalls. A variety of MAC policies have been "
"formulated by operating system designers and security researches, including "
"the Multi-Level Security (MLS) confidentiality policy, the Biba integrity "
"policy, Role-Based Access Control (RBAC), Domain and Type Enforcement (DTE), "
"and Type Enforcement (TE). Each model bases decisions on a variety of "
"factors, including user identity, role, and security clearance, as well as "
"security labels on objects representing concepts such as data sensitivity "
"and integrity."
msgstr ""
"强制访问控制（简称 MAC），是指由操作系统强制实施的一组针对用户的访问控制策"
"略。在某些情况下,强制访问控制的策略可能会与自主访问控制（简称 DAC）所提供的保"
"护措施发生冲突，后者是用来向非管理员用户对数据采取保护措施提供支持的。在传统"
"的 UNIX 系统中，DAC 保护措施包括文件访问模式和访问控制列表；而 MAC 则提供进程"
"控制和防火墙等。操作系统设计者和安全机制研究人员对许多经典的 MAC 安全策略作了"
"形式化的表述，比如，多级安全（MLS)机密性策略，Biba 完整性策略，基于角色的访问"
"控制策略（RBAC），域和型裁决策略(DTE),以及型裁决策略(TE)。安全策略的形式化表"
"述被称为安全模型。每个模型根据一系列条件做出安全相关的决策，这些条件包括，用"
"户的身份、角色和安全信任状，以及对象的安全标记(用来代表该对象数据的机密性/完"
"整性级别)。"

#. (itstool) path: sect1/para
#: book.translate.xml:4470
msgid ""
"The TrustedBSD MAC Framework is capable of supporting policy modules that "
"implement all of these policies, as well as a broad class of system "
"hardening policies, which may use existing security attributes, such as user "
"and group IDs, as well as extended attributes on files, and other system "
"properties. In addition, despite the name, the MAC Framework can also be "
"used to implement purely discretionary policies, as policy modules are given "
"substantial flexibility in how they authorize protections."
msgstr ""
"TrustedBSD MAC 框架所提供的对策略模块的支持，不仅可以用来实现上述所有策略，还"
"能用于实现其他利用已有安全属性(如，用户和组ID、文件扩展属性等）决策的系统安全"
"强化策略。此外，因为具体策略模块在访问授权方面所拥有的高度灵活性和自主性，所"
"以MAC 框架同样可以用来实现完全自主式的安全策略."

#. (itstool) path: sect1/title
#: book.translate.xml:4482
msgid "MAC Framework Kernel Architecture"
msgstr "MAC 框架的内核体系结构"

#. (itstool) path: sect1/para
#: book.translate.xml:4484
msgid ""
"The TrustedBSD MAC Framework permits kernel modules to extend the operating "
"system security policy, as well as providing infrastructure functionality "
"required by many access control modules. If multiple policies are "
"simultaneously loaded, the MAC Framework will usefully (for some definition "
"of useful) compose the results of the policies."
msgstr ""
"TrustedBSD MAC 框架为大多数的访问控制模块提供基本设施，允许它们以内核模块的形"
"式灵活地扩展系统中实施的安全策略。如果系统中同时加载了多个策略，MAC 框架将负"
"责将各个策略的授权结果以一种（某种程度上）有意义的方式组合，形成最后的决策。"

#. (itstool) path: sect2/title
#: book.translate.xml:4492
msgid "Kernel Elements"
msgstr "内核元素"

#. (itstool) path: sect2/para
#: book.translate.xml:4494
msgid "The MAC Framework contains a number of kernel elements:"
msgstr "MAC 框架由下列内核元素组成："

#. (itstool) path: listitem/para
#: book.translate.xml:4499
msgid "Framework management interfaces"
msgstr "框架管理接口"

#. (itstool) path: listitem/para
#: book.translate.xml:4502
msgid "Concurrency and synchronization primitives."
msgstr "并发与同步原语。"

#. (itstool) path: listitem/para
#: book.translate.xml:4505
msgid "Policy registration"
msgstr "策略注册"

#. (itstool) path: listitem/para
#: book.translate.xml:4508
msgid "Extensible security label for kernel objects"
msgstr "内核对象的扩展性安全标记"

#. (itstool) path: listitem/para
#: book.translate.xml:4511
msgid "Policy entry point composition operators"
msgstr "策略入口函数的组合操作"

#. (itstool) path: listitem/para
#: book.translate.xml:4514
msgid "Label management primitives"
msgstr "标记管理原语"

#. (itstool) path: listitem/para
#: book.translate.xml:4517
msgid "Entry point API invoked by kernel services"
msgstr "由内核服务调用的入口函数 API"

#. (itstool) path: listitem/para
#: book.translate.xml:4520
msgid "Entry point API to policy modules"
msgstr "策略模块的入口函数 API"

#. (itstool) path: listitem/para
#: book.translate.xml:4523
msgid ""
"Entry points implementations (policy life cycle, object life cycle/label "
"management, access control checks)."
msgstr "入口函数的实现（包括策略生命周期管理、标记管理和访问控制检查三部分）。"

#. (itstool) path: listitem/para
#: book.translate.xml:4528
msgid "Policy-agnostic label-management system calls"
msgstr "管理策略无关标记的系统调用"

#. (itstool) path: listitem/para
#: book.translate.xml:4531
msgid "<function>mac_syscall()</function> multiplex system call"
msgstr "复用的<function>mac_syscall()</function> 系统调用"

#. (itstool) path: listitem/para
#: book.translate.xml:4535
msgid "Various security policies implemented as MAC policy modules"
msgstr "以 MAC 的策略加载模块形式实现的各种安全策略"

#. (itstool) path: sect2/title
#: book.translate.xml:4542
msgid "Framework Management Interfaces"
msgstr "框架管理接口"

#. (itstool) path: sect2/para
#: book.translate.xml:4544
msgid ""
"The TrustedBSD MAC Framework may be directly managed using sysctl's, loader "
"tunables, and system calls."
msgstr ""
"对 TrustedBSD MAC 框架进行直接管理的方式有三种:通过 sysctl 子系统、通过 "
"loader 配置, 或者使用系统调用。"

#. (itstool) path: sect2/para
#: book.translate.xml:4547
msgid ""
"In most cases, sysctl's and loader tunables of the same name modify the same "
"parameters, and control behavior such as enforcement of protections relating "
"to various kernel subsystems. In addition, if MAC debugging support is "
"compiled into the kernel, several counters will be maintained tracking label "
"allocation. It is generally advisable that per-subsystem enforcement "
"controls not be used to control policy behavior in production environments, "
"as they broadly impact the operation of all active policies. Instead, per-"
"policy controls should be preferred, as they provide greater granularity and "
"greater operational consistency for policy modules."
msgstr ""
"多数情况下，与同一个内核内部变量相关联的 sysctl 变量和 loader 参数的名字是相"
"同的，通过设置它们，可以控制保护措施的实施细节，比如，某个策略在各个内核子系"
"统中的实施与否等等。另外，如果在内核编译时选择支持 MAC 调试选项，内核将维护若"
"干计数器以跟踪标记的分配使用情况。通常不建议在实用环境下通过在不同子系统上设"
"置不同的变量或参数来实施控制，因为这种方法将会作用于系统中所有的活跃策略。如"
"果希望对具体策略实施管理而不相影响其他活跃策略,则应当使用策略级别的控制，因为"
"这种方法的控制粒度更细，并能更好地保证策略模块的功能一致性。"

#. (itstool) path: sect2/para
#: book.translate.xml:4560
msgid ""
"Loading and unloading of policy modules is performed using the system module "
"management system calls and other system interfaces, including boot loader "
"variables; policy modules will have the opportunity to influence load and "
"unload events, including preventing undesired unloading of the policy."
msgstr ""
"与其他内核模块一样，系统管理员可以通过系统的模块管理系统调用和其他系统接口，"
"包括 boot loader 变量，对策略模块执行加载与卸载操作；策略模块可以在加载时,设"
"置加载标志,来指示系统对其加载、卸载操作进行相应控制，比如阻止非期望的卸载操"
"作。"

#. (itstool) path: sect2/title
#: book.translate.xml:4568
msgid "Policy List Concurrency and Synchronization"
msgstr "策略链表的并发与同步"

#. (itstool) path: sect2/para
#: book.translate.xml:4570
msgid ""
"As the set of active policies may change at run-time, and the invocation of "
"entry points is non-atomic, synchronization is required to prevent loading "
"or unloading of policies while an entry point invocation is in progress, "
"freezing the set of active policies for the duration. This is accomplished "
"by means of a framework busy count: whenever an entry point is entered, the "
"busy count is incremented; whenever it is exited, the busy count is "
"decremented. While the busy count is elevated, policy list changes are not "
"permitted, and threads attempting to modify the policy list will sleep until "
"the list is not busy. The busy count is protected by a mutex, and a "
"condition variable is used to wake up sleepers waiting on policy list "
"modifications. One side effect of this synchronization model is that "
"recursion into the MAC Framework from within a policy module is permitted, "
"although not generally used."
msgstr ""
"在运行时,系统中活跃的策略集合可能发生变化，然而对策略入口函数的使用操作并不是"
"原子性的，因此，当某一个入口函数正被使用时，\n"
"        系统需要提供额外的同步机制来阻止对该策略模块的加载与卸载，以确保当前"
"活跃的策略集合不会在此过程中发生改变。\n"
"        通过使用\"框架忙”计数器,就可以做到这一点：一旦某个入口函数被调用，计"
"数器的值被增加1；而每当一个入口函数调用结束时，计数器的值被减少1。检查计数器"
"的值，如果其值为正，框架将阻止对策略链表的修改操作，请求操作的线程将被迫进入"
"睡眠，直到计数器的值重新减少到0为止。计数器本身由一个互斥锁保护，同时结合一个"
"条件变量(用于唤醒等待对策略链表进行修改操作的睡眠线程)。采用这种同步模型的一"
"个副作用是，在同一个策略模块内部，允许嵌套地调用框架，不过这种情况其实很少出"
"现。"

#. (itstool) path: sect2/para
#: book.translate.xml:4587
msgid ""
"Various optimizations are used to reduce the overhead of the busy count, "
"including avoiding the full cost of incrementing and decrementing if the "
"list is empty or contains only static entries (policies that are loaded "
"before the system starts, and cannot be unloaded). A compile-time option is "
"also provided which prevents any change in the set of loaded policies at run-"
"time, which eliminates the mutex locking costs associated with supporting "
"dynamically loaded and unloaded policies as synchronization is no longer "
"required."
msgstr ""
"为了减少由于采用计数器引入的额外开销，设计者采用了各种优化措施。其中包括，当"
"策略链表为空或者其中仅含有静态表项（那些只能在系统运行之前加载而且不能动态卸"
"载的策略）时，框架不对计数器进行操作，其值总是为0，从而将此时的同步开销减到"
"0。另一个极端的办法是，使用一个编译选项来禁止在运行时对加载的策略链表进行修"
"改，此时不再需要对策略链表的使用进行同步保护。"

#. (itstool) path: sect2/para
#: book.translate.xml:4598
msgid ""
"As the MAC Framework is not permitted to block in some entry points, a "
"normal sleep lock cannot be used; as a result, it is possible for the load "
"or unload attempt to block for a substantial period of time waiting for the "
"framework to become idle."
msgstr ""
"因为 MAC 框架不允许在某些入口函数之内阻塞，所以不能使用普通的睡眠锁。故而，加"
"载或卸载操作可能会为等待框架空闲而被阻塞相当长的一段时间。"

#. (itstool) path: sect2/title
#: book.translate.xml:4606
msgid "Label Synchronization"
msgstr "标记同步"

#. (itstool) path: sect2/para
#: book.translate.xml:4608
msgid ""
"As kernel objects of interest may generally be accessed from more than one "
"thread at a time, and simultaneous entry of more than one thread into the "
"MAC Framework is permitted, security attribute storage maintained by the MAC "
"Framework is carefully synchronized. In general, existing kernel "
"synchronization on kernel object data is used to protect MAC Framework "
"security labels on the object: for example, MAC labels on sockets are "
"protected using the existing socket mutex. Likewise, semantics for "
"concurrent access are generally identical to those of the container objects: "
"for credentials, copy-on-write semantics are maintained for label contents "
"as with the remainder of the credential structure. The MAC Framework asserts "
"necessary locks on objects when invoked with an object reference. Policy "
"authors must be aware of these synchronization semantics, as they will "
"sometimes limit the types of accesses permitted on labels: for example, when "
"a read-only reference to a credential is passed to a policy via an entry "
"point, only read operations are permitted on the label state attached to the "
"credential."
msgstr ""
"MAC 框架必须对其负责维护的安全属性标记的存储访问提供同步保护。下列两种情形，"
"可能导致对安全属性标记的不一致访问：第一，作为安全属性标记的持有者，内核对象"
"本身可能同时被多个线程访问；第二，MAC 框架代码是可重入的，即允许多个线程同时"
"在框架内执行。通常，MAC 框架使用内核对象数据上已有的内核同步机制来保护该其上"
"附加的 MAC 安全标记。例如，套接字上的 MAC 标记由已有的套接字互斥锁保护。类似"
"的，对于安全标记的并发访问的过程与对其所在对象进行的并发访问在语义上是一样"
"的，例如，信任状安全标记,将保持与该数据结构中其他内容一致的\"写时复制\"的更新"
"过程。MAC 框架在引用一个内核对象时，将首先对访问该对象上的标记需要用到的锁进"
"行断言。策略模块的编写者必须了解这些同步语义， 因为它们可能会限制对安全标记所"
"能进行的访问类型。 举个例子，如果通过入口函数传给策略模块的是对某个信任状的只"
"读引用，那么在策略内部，只能读该结构对应的标记状态。"

#. (itstool) path: sect2/title
#: book.translate.xml:4631
msgid "Policy Synchronization and Concurrency"
msgstr "策略间的同步与并发"

#. (itstool) path: sect2/para
#: book.translate.xml:4633
msgid ""
"Policy modules must be written to assume that many kernel threads may "
"simultaneously enter one more policy entry points due to the parallel and "
"preemptive nature of the FreeBSD kernel. If the policy module makes use of "
"mutable state, this may require the use of synchronization primitives within "
"the policy to prevent inconsistent views on that state resulting in "
"incorrect operation of the policy. Policies will generally be able to make "
"use of existing FreeBSD synchronization primitives for this purpose, "
"including mutexes, sleep locks, condition variables, and counting "
"semaphores. However, policies should be written to employ these primitives "
"carefully, respecting existing kernel lock orders, and recognizing that some "
"entry points are not permitted to sleep, limiting the use of primitives in "
"those entry points to mutexes and wakeup operations."
msgstr ""
"FreeBSD 内核是一个可抢占式的内核，因此，作为内核一部分的策略模块也必须是可重"
"入的，也就是说，在开发策略模块时必须假设多个内核线程可以同时通过不同的入口函"
"数进入该模块。如果策略模块使用可被修改的内核状态，那么还需要在策略内部使用恰"
"当的同步原语，确保在策略内部的多个线程不会因此观察到不一致的内核状态，从而避"
"免由此产生的策略误操作。为此，策略可以使用 FreeBSD 现有的同步原语，包括互斥"
"锁、睡眠锁、条件变量和计数信号量。对这些同步原语的使用必须慎重，需要特别注意"
"两点：第一，保持现有的内核上锁次序；第二，在非睡眠的入口函数之内不要使用互斥"
"锁和唤醒操作。"

#. (itstool) path: sect2/para
#: book.translate.xml:4649
msgid ""
"When policy modules call out to other kernel subsystems, they will generally "
"need to release any in-policy locks in order to avoid violating the kernel "
"lock order or risking lock recursion. This will maintain policy locks as "
"leaf locks in the global lock order, helping to avoid deadlock."
msgstr ""
"为避免违反内核上锁次序或造成递归上锁，策略模块在调用其他内核子系统之前，通常"
"要释放所有在策略内部申请的锁。这样做的结果是，在全局上锁次序形成的拓朴结构"
"中，策略内部的锁总是作为叶子节点，从而保证了这些锁的使用不会导致由于上锁次序"
"混乱造成的死锁。"

#. (itstool) path: sect2/title
#: book.translate.xml:4657
msgid "Policy Registration"
msgstr "策略注册"

#. (itstool) path: sect2/para
#: book.translate.xml:4659
msgid ""
"The MAC Framework maintains two lists of active policies: a static list, and "
"a dynamic list. The lists differ only with regards to their locking "
"semantics: an elevated reference count is not required to make use of the "
"static list. When kernel modules containing MAC Framework policies are "
"loaded, the policy module will use <literal>SYSINIT</literal> to invoke a "
"registration function; when a policy module is unloaded, <literal>SYSINIT</"
"literal> will likewise invoke a de-registration function. Registration may "
"fail if a policy module is loaded more than once, if insufficient resources "
"are available for the registration (for example, the policy might require "
"labeling and insufficient labeling state might be available), or other "
"policy prerequisites might not be met (some policies may only be loaded "
"prior to boot). Likewise, de-registration may fail if a policy is flagged as "
"not unloadable."
msgstr ""
"为了记录当前使用的策略模块集合，MAC 框架维护两个链表：一个静态链表和一个动态"
"链表。\n"
"       两个链表的数据结构和操作基本相同，只是动态链表还额外使用了一个\"引用计"
"数\"以同步对其的访问操作。\n"
"       当包含 MAC 框架策略的内核模块被加载时，该策略模块会通过 "
"<literal>SYSINIT</literal> 调用一个注册函数；\n"
"       相对应的，每当一个策略模块被卸载，<literal>SYSINIT</literal> 也会调用"
"一个注销函数。只有当遇到下列情况之一时，注册过程才会失败： 一个策略模块被加载"
"多次，或者系统资源不足不能满足注册过程的需要（例如，策略模块需要对内核对象添"
"加标记而可用资源不足），或者其他的策略加载前提条件不满足（有些策略要求只能在"
"系统引导之前加载）。类似的，如果一个策略被标记为不可卸载的，对其调用注销过程"
"将会失败。"

#. (itstool) path: sect2/title
#: book.translate.xml:4678
msgid "Entry Points"
msgstr "入口函数"

#. (itstool) path: sect2/para
#: book.translate.xml:4680
msgid ""
"Kernel services interact with the MAC Framework in two ways: they invoke a "
"series of APIs to notify the framework of relevant events, and they provide "
"a policy-agnostic label structure pointer in security-relevant objects. The "
"label pointer is maintained by the MAC Framework via label management entry "
"points, and permits the Framework to offer a labeling service to policy "
"modules through relatively non-invasive changes to the kernel subsystem "
"maintaining the object. For example, label pointers have been added to "
"processes, process credentials, sockets, pipes, vnodes, Mbufs, network "
"interfaces, IP reassembly queues, and a variety of other security-relevant "
"structures. Kernel services also invoke the MAC Framework when they perform "
"important security decisions, permitting policy modules to augment those "
"decisions based on their own criteria (possibly including data stored in "
"security labels). Most of these security critical decisions will be explicit "
"access control checks; however, some affect more general decision functions "
"such as packet matching for sockets and label transition at program "
"execution."
msgstr ""
"内核服务与 MAC 框架之间进行交互有两种途径：一是，内核服务调用一系列 API 通知 "
"MAC 框架安全事件的发生；二是，内核服务向 MAC 框架提供一个指向安全对象的策略无"
"关安全标记数据结构的指针。标记指针由 MAC 框架经由标记管理入口函数进行维护，并"
"且，只要对管理相关对象的内核子系统稍作修改，就可以允许 MAC 框架向策略模块提供"
"标记服务。例如，在进程、进程信任状、套接字、管道、Mbuf、网络接口、IP 重组队列"
"和其他各种安全相关的数据结构中均增加了指向安全标记的指针。另外，当需要做出重"
"要的安全决策时，内核服务也会调用 MAC 框架，以便各个策略模块根据其自己的标准"
"（可以使用存储在安全标记中的数据）完善这些决策。绝大多数安全相关的关键决策是"
"显式的访问控制检查；也有少数涉及更加一般的决策函数，比如，套接字的数据包匹配"
"和程序执行时刻的标记转换。"

#. (itstool) path: sect2/title
#: book.translate.xml:4703
msgid "Policy Composition"
msgstr "策略组合"

#. (itstool) path: sect2/para
#: book.translate.xml:4705
msgid ""
"When more than one policy module is loaded into the kernel at a time, the "
"results of the policy modules will be composed by the framework using a "
"composition operator. This operator is currently hard-coded, and requires "
"that all active policies must approve a request for it to return success. As "
"policies may return a variety of error conditions (success, access denied, "
"object does not exist, ...), a precedence operator selects the resulting "
"error from the set of errors returned by policies. In general, errors "
"indicating that an object does not exist will be preferred to errors "
"indicating that access to an object is denied. While it is not guaranteed "
"that the resulting composition will be useful or secure, we have found that "
"it is for many useful selections of policies. For example, traditional "
"trusted systems often ship with two or more policies using a similar "
"composition."
msgstr ""
"如果内核中同时加载了多个策略模块，这些策略的决策结果将由框架使用一个合成运算"
"子来进行组合汇总，得出最终的结果。目前，该算子是硬编码的，并且只有当所有的活"
"跃策略均对请求表示同意时才会返回成功。由于各个策略返回的出错条件可能并不相同"
"（成功、访问被拒绝、请求对象不存在等等），需要使用一个选择子先从各个策略返回"
"的错误条件集合中选择出一个作为最终返回结果。一般情况下，与“访问被拒绝”相比，"
"将更倾向于选择“请求对象不存在”。尽管不能从理论上保证合成结果的有效性与安全"
"性，但试验结果表明，对于许多实用的策略集合来说，事实的确如此。例如，传统的可"
"信系统常常采用类似的方法对多个安全策略进行组合。"

#. (itstool) path: sect2/title
#: book.translate.xml:4723
msgid "Labeling Support"
msgstr "标记支持"

#. (itstool) path: sect2/para
#: book.translate.xml:4725
msgid ""
"As many interesting access control extensions rely on security labels on "
"objects, the MAC Framework provides a set of policy-agnostic label "
"management system calls covering a variety of user-exposed objects. Common "
"label types include partition identifiers, sensitivity labels, integrity "
"labels, compartments, domains, roles, and types. By policy agnostic, we mean "
"that policy modules are able to completely define the semantics of meta-data "
"associated with an object. Policy modules participate in the internalization "
"and externalization of string-based labels provides by user applications, "
"and can expose multiple label elements to applications if desired."
msgstr ""
"与许多需要给对象添加安全标记的访问控制扩展一样，MAC 框架为各种用户可见的对象"
"提供了一组用于管理策略无关标记的系统调用。常用的标记类型有，partition标识符、"
"机密性标记、完整性标记、区间（非等级类别）、域、角色和型。“策略无关”的意思是"
"指，标记的语法与使用它的具体策略模块无关，而同时策略模块能够完全独立地定义和"
"使用与对象相关联的元数据的语义。用户应用程序提供统一格式的基于字符串的标记，"
"由使用它的策略模块负责解析其内在含义并决定其外在表示。如果需要，应用程序可以"
"使用多重标记元素。"

#. (itstool) path: sect2/para
#: book.translate.xml:4738
msgid ""
"In-memory labels are stored in slab-allocated <varname remap=\"structname"
"\">struct label</varname>, which consists of a fixed-length array of unions, "
"each holding a <literal>void *</literal> pointer and a <literal>long</"
"literal>. Policies registering for label storage will be assigned a \"slot\" "
"identifier, which may be used to dereference the label storage. The "
"semantics of the storage are left entirely up to the policy module: modules "
"are provided with a variety of entry points associated with the kernel "
"object life cycle, including initialization, association/creation, and "
"destruction. Using these interfaces, it is possible to implement reference "
"counting and other storage models. Direct access to the object structure is "
"generally not required by policy modules to retrieve a label, as the MAC "
"Framework generally passes both a pointer to the object and a direct pointer "
"to the object's label into entry points. The primary exception to this rule "
"is the process credential, which must be manually dereferenced to access the "
"credential label. This may change in future revisions of the MAC Framework."
msgstr ""
"内存中的标记实例被存放在由 slab 分配的<varname remap=\"structname\">struct "
"label</varname>数据结构中。该结构是一个固定长度的数组，每个元素是由一个 "
"<literal>void *</literal>指针和一个 <literal>long</literal>组成的联合结构。申"
"请标记存储的策略模块在向 MAC 注册时，将被分配一个“slot”值，作为框架分配给其使"
"用的策略标记元素在整个标记存储结构中的位置索引。而所分配的存储空间的语义则完"
"全由该策略模块来决定：MAC 框架向策略模块提供了一系列入口函数用于对内核对象生"
"命周期的各种事件进行控制，包括，对象的初始化、标记的关联/创建和对象的注销。使"
"用这些接口，可以实现诸如访问计数等存储模型。MAC 框架总是给入口函数传入一个指"
"向相关对象的指针和一个指向该对象标记的指针，因此，策略模块能够直接访问标记而"
"无需知悉该对象的内部结构。唯一的例外是进程信任状结构，指向其标记的指针必须由"
"策略模块手动解析计算。今后的 MAC 框架实现可能会对此进行改进。"

#. (itstool) path: sect2/para
#: book.translate.xml:4757
msgid ""
"Initialization entry points frequently include a sleeping disposition flag "
"indicating whether or not an initialization is permitted to sleep; if "
"sleeping is not permitted, a failure may be returned to cancel allocation of "
"the label (and hence object). This may occur, for example, in the network "
"stack during interrupt handling, where sleeping is not permitted, or while "
"the caller holds a mutex. Due to the performance cost of maintaining labels "
"on in-flight network packets (Mbufs), policies must specifically declare a "
"requirement that Mbuf labels be allocated. Dynamically loaded policies "
"making use of labels must be able to handle the case where their init "
"function has not been called on an object, as objects may already exist when "
"the policy is loaded. The MAC Framework guarantees that uninitialized label "
"slots will hold a 0 or NULL value, which policies may use to detect "
"uninitialized values. However, as allocation of Mbuf labels is conditional, "
"policies must also be able to handle a NULL label pointer for Mbufs if they "
"have been loaded dynamically."
msgstr ""
"初始化入口函数通常有一个睡眠标志位，用来表明一个初始化操作是否允许中途睡眠等"
"待；如果不允许，则可能会失败返回，并要求撤销此次标记分配操作（乃至对象分配操"
"作）。例如，如果在网络栈上处理中断时因为不允许睡眠或者调用者持有一个互斥锁，"
"就可能出现这种情况。考虑到在处理中的网络数据包（Mbufs）上维护标记的性能损失太"
"大，策略必须就自己对 Mbuf 进行标记的要求向 MAC 框架做出特别声明。动态加载到系"
"统中而又使用标记的策略必须为处理未被其初始化函数处理过的对象作好准备，这些对"
"象在策略加载之前就已经存在,故而无法在初始化时调用策略的相关函数进行处理。MAC "
"框架向策略保证，没有被初始化的标记 slot 的值必为0或者 NULL，策略可以借此检测"
"到未初始化的标记。需要注意的是，因为对 Mbuf 标记的存储分配是有条件的，因此需"
"要使用其标记的动态加载策略还可能需要处理 Mbuf 中值为 NULL 的标记指针。"

#. (itstool) path: sect2/para
#: book.translate.xml:4776
msgid ""
"In the case of file system labels, special support is provided for the "
"persistent storage of security labels in extended attributes. Where "
"available, extended attribute transactions are used to permit consistent "
"compound updates of security labels on vnodes--currently this support is "
"present only in the UFS2 file system. Policy authors may choose to implement "
"multilabel file system object labels using one (or more) extended "
"attributes. For efficiency reasons, the vnode label (<literal>v_label</"
"literal>) is a cache of any on-disk label; policies are able to load values "
"into the cache when the vnode is instantiated, and update the cache as "
"needed. As a result, the extended attribute need not be directly accessed "
"with every access control check."
msgstr ""
"对于文件系统对象的标记，MAC 框架在文件的扩展属性中为其分配永久存储。只要可"
"能，扩展属性的原子化的事务操作就被用于保证对 vnode 上安全标记的复合更新操作的"
"一致性－－目前，该特性只被 UFS2 文件系统支持。为了实现细粒度的文件系统对象标"
"记（即每个文件系统对象一个标记），策略编写者可能选择使用一个（或者若干）扩展"
"属性块。为了提高性能，\tvnode 数据结构中有一个标记 (<literal>v_label</"
"literal>)字段，用作磁盘标记的缓冲；vnode 结构实例化时，策略可以将标记值装入该"
"缓冲，并在需要时对其进行更新。如此，不必在每次进行访问控制检查时，均无条件地"
"访问磁盘上的扩展属性。"

#. (itstool) path: note/para
#: book.translate.xml:4791
msgid ""
"Currently, if a labeled policy permits dynamic unloading, its state slot "
"cannot be reclaimed, which places a strict (and relatively low) bound on the "
"number of unload-reload operations for labeled policies."
msgstr ""
"目前，如果一个使用标记的策略允许被动态卸载，则卸载该模块之后,其状态 slot 尚无"
"法被系统回收重用，由此导致了 MAC 框架对标记策略卸载－重载操作数目上的严格限"
"制。"

#. (itstool) path: sect2/title
#: book.translate.xml:4799
msgid "System Calls"
msgstr "相关系统调用"

#. (itstool) path: sect2/para
#: book.translate.xml:4801
msgid ""
"The MAC Framework implements a number of system calls: most of these calls "
"support the policy-agnostic label retrieval and manipulation APIs exposed to "
"user applications."
msgstr ""
"MAC 框架向应用程序提供了一组系统调用：其中大多数用于向进行查询和修改策略无关"
"标记操作的应用 API提供支持。"

#. (itstool) path: sect2/para
#: book.translate.xml:4806
msgid ""
"The label management calls accept a label description structure, <varname "
"remap=\"structname\">struct mac</varname>, which contains a series of MAC "
"label elements. Each element contains a character string name, and character "
"string value. Each policy will be given the chance to claim a particular "
"element name, permitting policies to expose multiple independent elements if "
"desired. Policy modules perform the internalization and externalization "
"between kernel labels and user-provided labels via entry points, permitting "
"a variety of semantics. Label management system calls are generally wrapped "
"by user library functions to perform memory allocation and error handling, "
"simplifying user applications that must manage labels."
msgstr ""
"这些标记管理系统调用，接受一个标记描述结构， <varname remap=\"structname"
"\">struct mac</varname>，作为输入参数。这个结构的主体是一个数组，其中每个元素"
"包含了一个应用级的 MAC 标记形式。每个元素又由两部分组成:一个字符串名字，和其"
"对应的值。每个策略可以向系统声明一个特定的元素名字，这样一来，如果需要，就可"
"以将若干个相互独立的元素作为一个整体进行处理。策略模块经由入口函数，在内核标"
"记和用户提供的标记之间作翻译转换的工作，这种实现提供了标记元素语义上的高度灵"
"活性。标记管理系统调用通常有对应的库函数包装，这些包装函数可以提供内存分配和"
"错误处理功能，从而简化了用户应用程序的标记管理工作。"

#. (itstool) path: sect2/para
#: book.translate.xml:4820
msgid ""
"The following MAC-related system calls are present in the FreeBSD kernel:"
msgstr "目前的FreeBSD 内核提供了下列 MAC 相关的系统调用："

#. (itstool) path: listitem/para
#: book.translate.xml:4825
msgid ""
"<function>mac_get_proc()</function> may be used to retrieve the label of the "
"current process."
msgstr "<function>mac_get_proc()</function> 用于查询当前进程的安全标记。"

#. (itstool) path: listitem/para
#: book.translate.xml:4830
msgid ""
"<function>mac_set_proc()</function> may be used to request a change in the "
"label of the current process."
msgstr "<function>mac_set_proc()</function> 用于请求改变当前进程的安全标记。"

#. (itstool) path: listitem/para
#: book.translate.xml:4836
msgid ""
"<function>mac_get_fd()</function> may be used to retrieve the label of an "
"object (file, socket, pipe, ...) referenced by a file descriptor."
msgstr ""
"<function>mac_get_fd()</function> 用于查询由文件描述符所引用的对象（ 文件、\n"
"\t  套接字、 管道文件等等） 的安全标记。"

#. (itstool) path: listitem/para
#: book.translate.xml:4842
msgid ""
"<function>mac_get_file()</function> may be used to retrieve the label of an "
"object referenced by a file system path."
msgstr ""
"<function>mac_get_file()</function> 用于查询由文件系统路径所描述的对象的安全"
"标记。"

#. (itstool) path: listitem/para
#: book.translate.xml:4848
msgid ""
"<function>mac_set_fd()</function> may be used to request a change in the "
"label of an object (file, socket, pipe, ...) referenced by a file descriptor."
msgstr ""
"<function>mac_set_fd()</function> 用于请求改变由文件描述符所引用的对象（\n"
"\t  文件、套接字、 管道文件等等） 的安全标记。"

#. (itstool) path: listitem/para
#: book.translate.xml:4854
msgid ""
"<function>mac_set_file()</function> may be used to request a change in the "
"label of an object referenced by a file system path."
msgstr ""
"<function>mac_set_file()</function> 用于请求改变由文件系统路径所描述的对象的"
"安全标记。"

#. (itstool) path: listitem/para
#: book.translate.xml:4860
msgid ""
"<function>mac_syscall()</function> permits policy modules to create new "
"system calls without modifying the system call table; it accepts a target "
"policy name, operation number, and opaque argument for use by the policy."
msgstr ""
"<function>mac_syscall()</function> 通过复用该系统调用,策略模块能够在不修改系"
"统调用表的前提下创建新的系统调用；其调用参数包括：目标策略名字、 操作编号和将"
"被该策略内部使用的参数。"

#. (itstool) path: listitem/para
#: book.translate.xml:4868
msgid ""
"<function>mac_get_pid()</function> may be used to request the label of "
"another process by process id."
msgstr ""
"<function>mac_get_pid()</function> 用于查询由进程号指定的另一个进程的安全标"
"记。"

#. (itstool) path: listitem/para
#: book.translate.xml:4873
msgid ""
"<function>mac_get_link()</function> is identical to "
"<function>mac_get_file()</function>, only it will not follow a symbolic link "
"if it is the final entry in the path, so may be used to retrieve the label "
"on a symlink."
msgstr ""
"<function>mac_get_link()</function> 与<function>mac_get_file()</function> 功"
"能相同，只是当路径参数的最后一项为符号链接时，前者将返回该符号链接的安全标"
"记，而后者将返回其所指文件的安全标记。"

#. (itstool) path: listitem/para
#: book.translate.xml:4881
msgid ""
"<function>mac_set_link()</function> is identical to "
"<function>mac_set_file()</function>, only it will not follow a symbolic link "
"if it is the final entry in a path, so may be used to manipulate the label "
"on a symlink."
msgstr ""
"<function>mac_set_link()</function> 与<function>mac_set_file()</function> 功"
"能相同，只是当路径参数的最后一项为符号链接时，前者将设置该符号链接的安全标"
"记，而后者将设置其所指文件的安全标记。"

#. (itstool) path: listitem/para
#: book.translate.xml:4889
msgid ""
"<function>mac_execve()</function> is identical to the <function>execve()</"
"function> system call, only it also accepts a requested label to set the "
"process label to when beginning execution of a new program. This change in "
"label on execution is referred to as a \"transition\"."
msgstr ""
"<function>mac_execve()</function> 与<function>execve()</function> 功能类似，"
"只是前者还可以在开始执行一个新程序时,根据传入的请求参数,设置执行进程的安全标"
"记。由于执行一个新程序而导致的进程安全标记的改变,被称为“转换”。"

#. (itstool) path: listitem/para
#: book.translate.xml:4898
msgid ""
"<function>mac_get_peer()</function>, actually implemented via a socket "
"option, retrieves the label of a remote peer on a socket, if available."
msgstr ""
"<function>mac_get_peer()</function>，通过一个套接字选项自动实现，用于查询一个"
"远程套接字对等实体的安全标记。"

#. (itstool) path: sect2/para
#: book.translate.xml:4904
msgid ""
"In addition to these system calls, the <literal>SIOCSIGMAC</literal> and "
"<literal>SIOCSIFMAC</literal> network interface ioctls permit the labels on "
"network interfaces to be retrieved and set."
msgstr ""
"除了上述系统调用之外，也可以通过 <literal>SIOCSIGMAC</literal> 和 "
"<literal>SIOCSIFMAC</literal>网络接口的 ioctl 类系统调用来查询和设置网络接口"
"的安全标记。"

#. (itstool) path: sect1/title
#: book.translate.xml:4913
msgid "MAC Policy Architecture"
msgstr "MAC策略模块体系结构"

#. (itstool) path: sect1/para
#: book.translate.xml:4915
msgid ""
"Security policies are either linked directly into the kernel, or compiled "
"into loadable kernel modules that may be loaded at boot, or dynamically "
"using the module loading system calls at runtime. Policy modules interact "
"with the system through a set of declared entry points, providing access to "
"a stream of system events and permitting the policy to influence access "
"control decisions. Each policy contains a number of elements:"
msgstr ""
"安全策略可以直接编入内核，也可以编译成独立的内核模块，在系统引导时或者运行时"
"使用模块加载命令加载。策略模块通过一组预先定义好的入口函数与系统交互。通过它"
"们，策略模块能够掌握某些系统事件的发生，并且在必要的时候影响系统的访问控制决"
"策。每个策略模块包含下列组成部分："

#. (itstool) path: listitem/para
#: book.translate.xml:4926
msgid "Optional configuration parameters for policy."
msgstr "可选：策略配置参数。"

#. (itstool) path: listitem/para
#: book.translate.xml:4930
msgid "Centralized implementation of the policy logic and parameters."
msgstr "策略逻辑和参数的集中实现。"

#. (itstool) path: listitem/para
#: book.translate.xml:4934
msgid ""
"Optional implementation of policy life cycle events, such as initialization "
"and destruction."
msgstr "可选：策略生命周期事件的实现，比如，策略的初始化和销毁。"

#. (itstool) path: listitem/para
#: book.translate.xml:4938
msgid ""
"Optional support for initializing, maintaining, and destroying labels on "
"selected kernel objects."
msgstr "可选：对所选内核对象的安全标记进行初始化、维护和销毁的支持。"

#. (itstool) path: listitem/para
#: book.translate.xml:4943
msgid ""
"Optional support for user process inspection and modification of labels on "
"selected objects."
msgstr "可选：对所选对象的使用进程进行监控以及修改对象安全标记的支持。"

#. (itstool) path: listitem/para
#: book.translate.xml:4948
msgid ""
"Implementation of selected access control entry points that are of interest "
"to the policy."
msgstr "策略相关的访问控制入口函数的实现。"

#. (itstool) path: listitem/para
#: book.translate.xml:4952
msgid ""
"Declaration of policy identity, module entry points, and policy properties."
msgstr "对策略标志、模块入口函数和策略特性的声明。"

#. (itstool) path: sect2/title
#: book.translate.xml:4958
msgid "Policy Declaration"
msgstr "策略注销"

#. (itstool) path: sect2/para
#: book.translate.xml:4960
msgid ""
"Modules may be declared using the <function>MAC_POLICY_SET()</function> "
"macro, which names the policy, provides a reference to the MAC entry point "
"vector, provides load-time flags determining how the policy framework should "
"handle the policy, and optionally requests the allocation of label state by "
"the framework."
msgstr ""
"策略模块可以使用\t<function>MAC_POLICY_SET()</function> 宏来声明。该宏完成以"
"下工作：为该策略命名（向系统声明该策略提供的名字）；提交策略定义的 MAC 入口函"
"数向量的地址；按照策略的要求设置该策略的加载标志位，保证 MAC 框架将以策略所期"
"望的方式对其进行操作；另外，还可能请求框架为策略分配标记状态 slot 值。"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:4967
#, no-wrap
msgid ""
"static struct mac_policy_ops mac_<replaceable>policy</replaceable>_ops =\n"
"{\n"
"        .mpo_destroy = mac_<replaceable>policy</replaceable>_destroy,\n"
"        .mpo_init = mac_<replaceable>policy</replaceable>_init,\n"
"        .mpo_init_bpfdesc_label = mac_<replaceable>policy</replaceable>_init_bpfdesc_label,\n"
"        .mpo_init_cred_label = mac_<replaceable>policy</replaceable>_init_label,\n"
"/* ... */\n"
"        .mpo_check_vnode_setutimes = mac_<replaceable>policy</replaceable>_check_vnode_setutimes,\n"
"        .mpo_check_vnode_stat = mac_<replaceable>policy</replaceable>_check_vnode_stat,\n"
"        .mpo_check_vnode_write = mac_<replaceable>policy</replaceable>_check_vnode_write,\n"
"};"
msgstr ""
"static struct mac_policy_ops mac_<replaceable>policy</replaceable>_ops =\n"
"{\n"
"        .mpo_destroy = mac_<replaceable>policy</replaceable>_destroy,\n"
"        .mpo_init = mac_<replaceable>policy</replaceable>_init,\n"
"        .mpo_init_bpfdesc_label = mac_<replaceable>policy</replaceable>_init_bpfdesc_label,\n"
"        .mpo_init_cred_label = mac_<replaceable>policy</replaceable>_init_label,\n"
"/* ... */\n"
"        .mpo_check_vnode_setutimes = mac_<replaceable>policy</replaceable>_check_vnode_setutimes,\n"
"        .mpo_check_vnode_stat = mac_<replaceable>policy</replaceable>_check_vnode_stat,\n"
"        .mpo_check_vnode_write = mac_<replaceable>policy</replaceable>_check_vnode_write,\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:4979
msgid ""
"The MAC policy entry point vector, <varname>mac_<replaceable>policy</"
"replaceable>_ops</varname> in this example, associates functions defined in "
"the module with specific entry points. A complete listing of available entry "
"points and their prototypes may be found in the MAC entry point reference "
"section. Of specific interest during module registration are the <symbol>."
"mpo_destroy</symbol> and <symbol>.mpo_init</symbol> entry points. <symbol>."
"mpo_init</symbol> will be invoked once a policy is successfully registered "
"with the module framework but prior to any other entry points becoming "
"active. This permits the policy to perform any policy-specific allocation "
"and initialization, such as initialization of any data or locks. <symbol>."
"mpo_destroy</symbol> will be invoked when a policy module is unloaded to "
"permit releasing of any allocated memory and destruction of locks. "
"Currently, these two entry points are invoked with the MAC policy list mutex "
"held to prevent any other entry points from being invoked: this will be "
"changed, but in the mean time, policies should be careful about what kernel "
"primitives they invoke so as to avoid lock ordering or sleeping problems."
msgstr ""
"如上所示，MAC 策略入口函数向量，<varname>mac_<replaceable>policy</"
"replaceable>_ops</varname>，将策略模块中定义的功能函数挂接到特定的入口函数地"
"址上。在稍后的“入口函数参考”小节中，将提供可用入口函数功能描述和原型的完整列"
"表。与模块注册相关的入口函数有两个：<symbol>.mpo_destroy</symbol>和<symbol>."
"mpo_init</symbol>。当某个策略向模块框架注册操作成功时，<symbol>.mpo_init</"
"symbol>将被调用，此后其他的入口函数才能被使用。这种特殊的设计使得策略有机会根"
"据自己的需要，进行特定的分配和初始化操作，比如对特殊数据或锁的初始化。卸载一"
"个策略模块时，将调用 <symbol>.mpo_destroy</symbol> 用来释放策略分配的内存空间"
"或注销其申请的锁。目前，为了防止其他入口函数被同时调用，调用上述两个入口函数"
"的进程必须持有 MAC 策略链表的互斥锁：这种限制将被放开，但与此同时，将要求策略"
"必须谨慎使用内核原语,以避免由于上锁次序或睡眠造成死锁。"

#. (itstool) path: sect2/para
#: book.translate.xml:5001
msgid ""
"The policy declaration's module name field exists so that the module may be "
"uniquely identified for the purposes of module dependencies. An appropriate "
"string should be selected. The full string name of the policy is displayed "
"to the user via the kernel log during load and unload events, and also "
"exported when providing status information to userland processes."
msgstr ""
"之所以向策略声明提供模块名字域，是为了能够唯一标识该模块，以便解析模块依赖关"
"系。选择使用恰当的字符串作为名字。在策略加载和卸载时，策略的完整字符串名字将"
"经由内核日志显示给用户。另外，当向用户进程报告状态信息时也会包含该字符串。"

#. (itstool) path: sect2/title
#: book.translate.xml:5011
msgid "Policy Flags"
msgstr "策略标志"

#. (itstool) path: sect2/para
#: book.translate.xml:5013
msgid ""
"The policy declaration flags field permits the module to provide the "
"framework with information about its capabilities at the time the module is "
"loaded. Currently, three flags are defined:"
msgstr ""
"在声明时提供标志参数域的机制，允许策略模块在作为模块被加载时，就自身特性向 "
"MAC 框架提供说明。目前，已经定义的标志有三个："

#. (itstool) path: varlistentry/term
#: book.translate.xml:5020
msgid "MPC_LOADTIME_FLAG_UNLOADOK"
msgstr "MPC_LOADTIME_FLAG_UNLOADOK"

#. (itstool) path: listitem/para
#: book.translate.xml:5023
msgid ""
"This flag indicates that the policy module may be unloaded. If this flag is "
"not provided, then the policy framework will reject requests to unload the "
"module. This flag might be used by modules that allocate label state and are "
"unable to free that state at runtime."
msgstr ""
"表示该策略模块可以被卸载。如果未提供该标志，则表示该策略模块拒绝被卸载。那些"
"使用安全标记的状态，而又不能在运行时释放该状态的模块可能会设置该标志。"

#. (itstool) path: varlistentry/term
#: book.translate.xml:5033
msgid "MPC_LOADTIME_FLAG_NOTLATE"
msgstr "MPC_LOADTIME_FLAG_NOTLATE"

#. (itstool) path: listitem/para
#: book.translate.xml:5036
msgid ""
"This flag indicates that the policy module must be loaded and initialized "
"early in the boot process. If the flag is specified, attempts to register "
"the module following boot will be rejected. The flag may be used by policies "
"that require pervasive labeling of all system objects, and cannot handle "
"objects that have not been properly initialized by the policy."
msgstr ""
"表示该策略模块必须在系统引导过程时进行加载和初始化。如果该标志被设置，那么在"
"系统引导之后注册该模块的请求将被。"

#. (itstool) path: varlistentry/term
#: book.translate.xml:5047
msgid "MPC_LOADTIME_FLAG_LABELMBUFS"
msgstr "MPC_LOADTIME_FLAG_LABELMBUFS"

#. (itstool) path: listitem/para
#: book.translate.xml:5050
msgid ""
"This flag indicates that the policy module requires labeling of Mbufs, and "
"that memory should always be allocated for the storage of Mbuf labels. By "
"default, the MAC Framework will not allocate label storage for Mbufs unless "
"at least one loaded policy has this flag set. This measurably improves "
"network performance when policies do not require Mbuf labeling. A kernel "
"option, <literal>MAC_ALWAYS_LABEL_MBUF</literal>, exists to force the MAC "
"Framework to allocate Mbuf label storage regardless of the setting of this "
"flag, and may be useful in some environments."
msgstr ""
"表示该策略模块要求为 Mbuf 指定安全标记，并且为存储其标记所需的内存空间总是提"
"前分配好的。缺省情况下，MAC 框架并不会为 Mbuf 分配标记存储，除非系统中注册的"
"策略模块中至少有一个设置了该标志。这种做法在没有策略需要对 Mbuf 做标记时，显"
"著地提升了系统网络性能。另外，在某些特殊环境下，可以通过设置内核选项，"
"<literal>MAC_ALWAYS_LABEL_MBUF</literal>，强制 MAC 框架为 Mbuf 的安全标记分配"
"存储，而不论上述标志如何设置。"

#. (itstool) path: note/para
#: book.translate.xml:5066
msgid ""
"Policies using the <literal>MPC_LOADTIME_FLAG_LABELMBUFS</literal> without "
"the <literal>MPC_LOADTIME_FLAG_NOTLATE</literal> flag set must be able to "
"correctly handle <literal>NULL</literal> Mbuf label pointers passed into "
"entry points. This is necessary as in-flight Mbufs without label storage may "
"persist after a policy enabling Mbuf labeling has been loaded. If a policy "
"is loaded before the network subsystem is active (i.e., the policy is not "
"being loaded late), then all Mbufs are guaranteed to have label storage."
msgstr ""
"<literal>MPC_LOADTIME_FLAG_NOTLATE</literal> 标志的策略模块必须能够正确地处理"
"通过入口函数传入的值为 <literal>NULL</literal>的 Mbuf 安全标记指针。这是因为"
"那些没有分配标记存储的处理中的 Mbuf 在一个需要 Mbuf 安全标记的策略模块加载之"
"后，其安全标记的指针将仍然为空。如果策略在网络子系统活跃之前被加载（即，该策"
"略不是被推迟加载的），那么所有的 Mbuf 的标记存储的分配就可以得到保证。"

#. (itstool) path: sect2/title
#: book.translate.xml:5080
msgid "Policy Entry Points"
msgstr "策略入口函数"

#. (itstool) path: sect2/para
#: book.translate.xml:5082
msgid ""
"Four classes of entry points are offered to policies registered with the "
"framework: entry points associated with the registration and management of "
"policies, entry points denoting initialization, creation, destruction, and "
"other life cycle events for kernel objects, events associated with access "
"control decisions that the policy module may influence, and calls associated "
"with the management of labels on objects. In addition, a "
"<function>mac_syscall()</function> entry point is provided so that policies "
"may extend the kernel interface without registering new system calls."
msgstr ""
"MAC 框架为注册的策略提供四种类型的入口函数：策略注册和管理入口函数；用于处理"
"内核对象声明周期事件，如初始化、创建和销毁，的入口函数；处理该策略模块感兴趣"
"的访问控制决策事件的入口函数；以及用于管理对象安全标记的调用入口函数。此外，"
"还有一个 <function>mac_syscall()</function> 入口函数，被策略模块用于在不注册"
"新的系统调用的前提下，扩展内核接口。"

#. (itstool) path: sect2/para
#: book.translate.xml:5093
msgid ""
"Policy module writers should be aware of the kernel locking strategy, as "
"well as what object locks are available during which entry points. Writers "
"should attempt to avoid deadlock scenarios by avoiding grabbing non-leaf "
"locks inside of entry points, and also follow the locking protocol for "
"object access and modification. In particular, writers should be aware that "
"while necessary locks to access objects and their labels are generally held, "
"sufficient locks to modify an object or its label may not be present for all "
"entry points. Locking information for arguments is documented in the MAC "
"framework entry point document."
msgstr ""
"策略模块的编写人员除了必须清楚在进入特定入口函数之后，哪些对象锁是可用的之"
"外，还应该熟知内核所采用的加锁策略。编程人员在入口函数之内应该避免使用非叶节"
"点锁，并且遵循访问和修改对象时的加锁规程，以降低导致死锁的可能性。特别地，程"
"序员应该清楚，虽然在通常情况下，进入入口函数之后，已经上了一些锁，可以安全地"
"访问对象及其安全标记，但是这并不能保证对它们进行修改（包括对象本身和其安全标"
"记）也是安全的。相关的上锁信息，可以参考 MAC 框架入口函数的相关文档。"

#. (itstool) path: sect2/para
#: book.translate.xml:5105
msgid ""
"Policy entry points will pass a reference to the object label along with the "
"object itself. This permits labeled policies to be unaware of the internals "
"of the object yet still make decisions based on the label. The exception to "
"this is the process credential, which is assumed to be understood by "
"policies as a first class security object in the kernel."
msgstr ""
"策略入口函数把两个分别指向对象本身和其安全标记的指针传递给策略模块。这样一"
"来，即使策略并不熟悉对象内部结构，也能基于标记作出正确决策。只有进程信任状这"
"个对象例外：MAC 框架总是假设所有的策略模块是理解其内部结构的。"

#. (itstool) path: sect1/title
#: book.translate.xml:5116
msgid "MAC Policy Entry Point Reference"
msgstr "MAC策略入口函数参考"

#. (itstool) path: sect2/title
#: book.translate.xml:5119
msgid "General-Purpose Module Entry Points"
msgstr "通用的模块入口函数"

#. (itstool) path: sect3/title
#: book.translate.xml:5122
msgid "<function>mpo_init</function>"
msgstr "<function>mpo_init</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5125
msgid ""
"<funcdef>void <function>mpo_init</function></funcdef> <paramdef>struct "
"mac_policy_conf *<parameter>conf</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_init</function></funcdef> <paramdef>struct "
"mac_policy_conf *<parameter>conf</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:5143 book.translate.xml:5189 book.translate.xml:5232
#: book.translate.xml:5300 book.translate.xml:5364 book.translate.xml:5406
#: book.translate.xml:5448 book.translate.xml:5490 book.translate.xml:5533
#: book.translate.xml:5591 book.translate.xml:5651 book.translate.xml:5700
#: book.translate.xml:5742 book.translate.xml:5785 book.translate.xml:5836
#: book.translate.xml:5886 book.translate.xml:5929 book.translate.xml:5971
#: book.translate.xml:6015 book.translate.xml:6059 book.translate.xml:6103
#: book.translate.xml:6147 book.translate.xml:6191 book.translate.xml:6235
#: book.translate.xml:6281 book.translate.xml:6331 book.translate.xml:6375
#: book.translate.xml:6419 book.translate.xml:6462 book.translate.xml:6505
#: book.translate.xml:6551 book.translate.xml:6600 book.translate.xml:6649
#: book.translate.xml:6700 book.translate.xml:6777 book.translate.xml:6854
#: book.translate.xml:6931 book.translate.xml:7007 book.translate.xml:7084
#: book.translate.xml:7161 book.translate.xml:7236 book.translate.xml:7311
#: book.translate.xml:7386 book.translate.xml:7461 book.translate.xml:7617
#: book.translate.xml:7696 book.translate.xml:7766 book.translate.xml:7829
#: book.translate.xml:7891 book.translate.xml:7958 book.translate.xml:8041
#: book.translate.xml:8130 book.translate.xml:8196 book.translate.xml:8245
#: book.translate.xml:8311 book.translate.xml:8378 book.translate.xml:8455
#: book.translate.xml:8521 book.translate.xml:8579 book.translate.xml:8640
#: book.translate.xml:8706 book.translate.xml:8771 book.translate.xml:8837
#: book.translate.xml:8902 book.translate.xml:8972 book.translate.xml:9030
#: book.translate.xml:9087 book.translate.xml:9153 book.translate.xml:9219
#: book.translate.xml:9285 book.translate.xml:9353 book.translate.xml:9421
#: book.translate.xml:9488 book.translate.xml:9557 book.translate.xml:9637
#: book.translate.xml:9706 book.translate.xml:9783 book.translate.xml:9850
#: book.translate.xml:9917 book.translate.xml:9973 book.translate.xml:10050
#: book.translate.xml:10113 book.translate.xml:10155 book.translate.xml:10199
#: book.translate.xml:10314 book.translate.xml:10378 book.translate.xml:10421
#: book.translate.xml:10470 book.translate.xml:10518 book.translate.xml:10569
#: book.translate.xml:10622 book.translate.xml:10665 book.translate.xml:10714
#: book.translate.xml:10781 book.translate.xml:10838 book.translate.xml:10897
#: book.translate.xml:10960 book.translate.xml:11018 book.translate.xml:11077
#: book.translate.xml:11139 book.translate.xml:11208 book.translate.xml:11266
#: book.translate.xml:11322 book.translate.xml:11383 book.translate.xml:11439
#: book.translate.xml:11504 book.translate.xml:11565 book.translate.xml:11620
#: book.translate.xml:11685 book.translate.xml:11750 book.translate.xml:11811
#: book.translate.xml:11881 book.translate.xml:11943 book.translate.xml:12005
#: book.translate.xml:12087 book.translate.xml:12174 book.translate.xml:12243
#: book.translate.xml:12308 book.translate.xml:12381 book.translate.xml:12467
#: book.translate.xml:12543 book.translate.xml:12607 book.translate.xml:12667
#: book.translate.xml:12726 book.translate.xml:12795 book.translate.xml:12877
#: book.translate.xml:12960 book.translate.xml:13020 book.translate.xml:13088
#: book.translate.xml:13151 book.translate.xml:13213 book.translate.xml:13279
#: book.translate.xml:13345 book.translate.xml:13423 book.translate.xml:13509
#: book.translate.xml:13577 book.translate.xml:13646 book.translate.xml:13718
#: book.translate.xml:13788 book.translate.xml:13845 book.translate.xml:13906
#: book.translate.xml:13974 book.translate.xml:14050 book.translate.xml:14123
#: book.translate.xml:14188 book.translate.xml:14242 book.translate.xml:14285
#: book.translate.xml:14333 book.translate.xml:14379 book.translate.xml:14440
msgid "Parameter"
msgstr "参数"

#. (itstool) path: row/entry
#: book.translate.xml:5144 book.translate.xml:5190 book.translate.xml:5233
#: book.translate.xml:5301 book.translate.xml:5365 book.translate.xml:5407
#: book.translate.xml:5449 book.translate.xml:5491 book.translate.xml:5534
#: book.translate.xml:5592 book.translate.xml:5652 book.translate.xml:5701
#: book.translate.xml:5743 book.translate.xml:5786 book.translate.xml:5837
#: book.translate.xml:5887 book.translate.xml:5930 book.translate.xml:5972
#: book.translate.xml:6016 book.translate.xml:6060 book.translate.xml:6104
#: book.translate.xml:6148 book.translate.xml:6192 book.translate.xml:6236
#: book.translate.xml:6282 book.translate.xml:6332 book.translate.xml:6376
#: book.translate.xml:6420 book.translate.xml:6463 book.translate.xml:6506
#: book.translate.xml:6552 book.translate.xml:6601 book.translate.xml:6650
#: book.translate.xml:6701 book.translate.xml:6778 book.translate.xml:6855
#: book.translate.xml:6932 book.translate.xml:7008 book.translate.xml:7085
#: book.translate.xml:7162 book.translate.xml:7237 book.translate.xml:7312
#: book.translate.xml:7387 book.translate.xml:7462 book.translate.xml:7618
#: book.translate.xml:7697 book.translate.xml:7767 book.translate.xml:7830
#: book.translate.xml:7892 book.translate.xml:7959 book.translate.xml:8042
#: book.translate.xml:8131 book.translate.xml:8197 book.translate.xml:8246
#: book.translate.xml:8312 book.translate.xml:8379 book.translate.xml:8456
#: book.translate.xml:8522 book.translate.xml:8580 book.translate.xml:8641
#: book.translate.xml:8707 book.translate.xml:8772 book.translate.xml:8838
#: book.translate.xml:8903 book.translate.xml:8973 book.translate.xml:9031
#: book.translate.xml:9088 book.translate.xml:9154 book.translate.xml:9220
#: book.translate.xml:9286 book.translate.xml:9354 book.translate.xml:9422
#: book.translate.xml:9489 book.translate.xml:9558 book.translate.xml:9638
#: book.translate.xml:9707 book.translate.xml:9784 book.translate.xml:9851
#: book.translate.xml:9918 book.translate.xml:9974 book.translate.xml:10051
#: book.translate.xml:10114 book.translate.xml:10156 book.translate.xml:10200
#: book.translate.xml:10315 book.translate.xml:10379 book.translate.xml:10422
#: book.translate.xml:10471 book.translate.xml:10519 book.translate.xml:10570
#: book.translate.xml:10623 book.translate.xml:10666 book.translate.xml:10715
#: book.translate.xml:10782 book.translate.xml:10839 book.translate.xml:10898
#: book.translate.xml:10961 book.translate.xml:11019 book.translate.xml:11078
#: book.translate.xml:11140 book.translate.xml:11209 book.translate.xml:11267
#: book.translate.xml:11323 book.translate.xml:11384 book.translate.xml:11440
#: book.translate.xml:11505 book.translate.xml:11566 book.translate.xml:11621
#: book.translate.xml:11686 book.translate.xml:11751 book.translate.xml:11812
#: book.translate.xml:11882 book.translate.xml:11944 book.translate.xml:12006
#: book.translate.xml:12088 book.translate.xml:12175 book.translate.xml:12244
#: book.translate.xml:12309 book.translate.xml:12382 book.translate.xml:12468
#: book.translate.xml:12544 book.translate.xml:12608 book.translate.xml:12668
#: book.translate.xml:12727 book.translate.xml:12796 book.translate.xml:12878
#: book.translate.xml:12961 book.translate.xml:13021 book.translate.xml:13089
#: book.translate.xml:13152 book.translate.xml:13214 book.translate.xml:13280
#: book.translate.xml:13346 book.translate.xml:13424 book.translate.xml:13510
#: book.translate.xml:13578 book.translate.xml:13647 book.translate.xml:13719
#: book.translate.xml:13789 book.translate.xml:13846 book.translate.xml:13907
#: book.translate.xml:13975 book.translate.xml:14051 book.translate.xml:14124
#: book.translate.xml:14189 book.translate.xml:14243 book.translate.xml:14286
#: book.translate.xml:14334 book.translate.xml:14380 book.translate.xml:14441
msgid "Description"
msgstr "描述"

#. (itstool) path: row/entry
#: book.translate.xml:5145 book.translate.xml:5191 book.translate.xml:5234
#: book.translate.xml:5302 book.translate.xml:5366 book.translate.xml:5408
#: book.translate.xml:5450 book.translate.xml:5492 book.translate.xml:5535
#: book.translate.xml:5593 book.translate.xml:5653 book.translate.xml:5702
#: book.translate.xml:5744 book.translate.xml:5787 book.translate.xml:5838
#: book.translate.xml:5888 book.translate.xml:5931 book.translate.xml:5973
#: book.translate.xml:6017 book.translate.xml:6061 book.translate.xml:6105
#: book.translate.xml:6149 book.translate.xml:6193 book.translate.xml:6237
#: book.translate.xml:6283 book.translate.xml:6333 book.translate.xml:6377
#: book.translate.xml:6421 book.translate.xml:6464 book.translate.xml:6507
#: book.translate.xml:6553 book.translate.xml:6602 book.translate.xml:6651
#: book.translate.xml:6702 book.translate.xml:6779 book.translate.xml:6856
#: book.translate.xml:6933 book.translate.xml:7009 book.translate.xml:7086
#: book.translate.xml:7163 book.translate.xml:7238 book.translate.xml:7313
#: book.translate.xml:7388 book.translate.xml:7463 book.translate.xml:7619
#: book.translate.xml:7698 book.translate.xml:7768 book.translate.xml:7831
#: book.translate.xml:7893 book.translate.xml:7960 book.translate.xml:8043
#: book.translate.xml:8132 book.translate.xml:8198 book.translate.xml:8247
#: book.translate.xml:8313 book.translate.xml:8380 book.translate.xml:8457
#: book.translate.xml:8523 book.translate.xml:8581 book.translate.xml:8642
#: book.translate.xml:8708 book.translate.xml:8773 book.translate.xml:8839
#: book.translate.xml:8904 book.translate.xml:8974 book.translate.xml:9032
#: book.translate.xml:9089 book.translate.xml:9155 book.translate.xml:9221
#: book.translate.xml:9287 book.translate.xml:9355 book.translate.xml:9423
#: book.translate.xml:9490 book.translate.xml:9559 book.translate.xml:9639
#: book.translate.xml:9708 book.translate.xml:9785 book.translate.xml:9852
#: book.translate.xml:9919 book.translate.xml:9975 book.translate.xml:10052
#: book.translate.xml:10115 book.translate.xml:10157 book.translate.xml:10201
#: book.translate.xml:10316 book.translate.xml:10380 book.translate.xml:10423
#: book.translate.xml:10472 book.translate.xml:10520 book.translate.xml:10571
#: book.translate.xml:10624 book.translate.xml:10667 book.translate.xml:10716
#: book.translate.xml:10783 book.translate.xml:10840 book.translate.xml:10899
#: book.translate.xml:10962 book.translate.xml:11020 book.translate.xml:11079
#: book.translate.xml:11141 book.translate.xml:11210 book.translate.xml:11268
#: book.translate.xml:11324 book.translate.xml:11385 book.translate.xml:11441
#: book.translate.xml:11506 book.translate.xml:11567 book.translate.xml:11622
#: book.translate.xml:11687 book.translate.xml:11752 book.translate.xml:11813
#: book.translate.xml:11883 book.translate.xml:11945 book.translate.xml:12007
#: book.translate.xml:12089 book.translate.xml:12176 book.translate.xml:12245
#: book.translate.xml:12310 book.translate.xml:12383 book.translate.xml:12469
#: book.translate.xml:12545 book.translate.xml:12609 book.translate.xml:12669
#: book.translate.xml:12728 book.translate.xml:12797 book.translate.xml:12879
#: book.translate.xml:12962 book.translate.xml:13022 book.translate.xml:13090
#: book.translate.xml:13153 book.translate.xml:13215 book.translate.xml:13281
#: book.translate.xml:13347 book.translate.xml:13425 book.translate.xml:13511
#: book.translate.xml:13579 book.translate.xml:13648 book.translate.xml:13720
#: book.translate.xml:13790 book.translate.xml:13847 book.translate.xml:13908
#: book.translate.xml:13976 book.translate.xml:14052 book.translate.xml:14125
#: book.translate.xml:14190 book.translate.xml:14244 book.translate.xml:14287
#: book.translate.xml:14335 book.translate.xml:14381 book.translate.xml:14442
msgid "Locking"
msgstr "锁定中"

#. (itstool) path: row/entry
#: book.translate.xml:5152 book.translate.xml:5198
msgid "<parameter>conf</parameter>"
msgstr "<parameter>conf</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:5153 book.translate.xml:5199
msgid "MAC policy definition"
msgstr "MAC 策略定义"

#. (itstool) path: sect3/para
#: book.translate.xml:5159
msgid ""
"Policy load event. The policy list mutex is held, so sleep operations cannot "
"be performed, and calls out to other kernel subsystems must be made with "
"caution. If potentially sleeping memory allocations are required during "
"policy initialization, they should be made using a separate module SYSINIT()."
msgstr ""
"策略加载事件。当前进程正持有策略链表上的互斥锁，因此是非睡眠的，对其他内核子"
"系统的调用也须慎重。如果需要在策略初始化阶段进行可能造成睡眠阻塞的存储分配操"
"作，可以将它们放在一个单独的模块 SYSINIT()过程中集中进行。"

#. (itstool) path: sect3/title
#: book.translate.xml:5168
msgid "<function>mpo_destroy</function>"
msgstr "<function>mpo_destroy</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5171
msgid ""
"<funcdef>void <function>mpo_destroy</function></funcdef> <paramdef>struct "
"mac_policy_conf *<parameter>conf</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_destroy</function></funcdef> <paramdef>struct "
"mac_policy_conf *<parameter>conf</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:5205
msgid ""
"Policy load event. The policy list mutex is held, so caution should be "
"applied."
msgstr "策略加载事件。必须持有策略链表互斥锁，因此需要慎重行事。"

#. (itstool) path: sect3/title
#: book.translate.xml:5210
msgid "<function>mpo_syscall</function>"
msgstr "<function>mpo_syscall</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5213
msgid ""
"<funcdef>int <function>mpo_syscall</function></funcdef> <paramdef>struct "
"thread *<parameter>td</parameter></paramdef> <paramdef>int <parameter>call</"
"parameter></paramdef> <paramdef>void *<parameter>arg</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_syscall</function></funcdef> <paramdef>struct "
"thread *<parameter>td</parameter></paramdef> <paramdef>int <parameter>call</"
"parameter></paramdef> <paramdef>void *<parameter>arg</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:5241 book.translate.xml:5309
msgid "<parameter>td</parameter>"
msgstr "<parameter>td</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:5242
msgid "Calling thread"
msgstr "调用线程"

#. (itstool) path: row/entry
#: book.translate.xml:5246
msgid "<parameter>call</parameter>"
msgstr "<parameter>call</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:5247
msgid "Policy-specific syscall number"
msgstr "策略特有的系统调用编号"

#. (itstool) path: row/entry
#: book.translate.xml:5251
msgid "<parameter>arg</parameter>"
msgstr "<parameter>arg</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:5252
msgid "Pointer to syscall arguments"
msgstr "系统调用参数的指针"

#. (itstool) path: sect3/para
#: book.translate.xml:5258
msgid ""
"This entry point provides a policy-multiplexed system call so that policies "
"may provide additional services to user processes without registering "
"specific system calls. The policy name provided during registration is used "
"to demux calls from userland, and the arguments will be forwarded to this "
"entry point. When implementing new services, security modules should be sure "
"to invoke appropriate access control checks from the MAC framework as "
"needed. For example, if a policy implements an augmented signal "
"functionality, it should call the necessary signal access control checks to "
"invoke the MAC framework and other registered policies."
msgstr ""
"该入口函数提供策略复用的系统调用，这样策略模块不需要为其向用户进程提供的每一"
"个额外服务而注册专用的系统调用。由应用程序提供的策略注册名字来确定提供其所申"
"请服务的特定策略，所有参数将通过该入口函数传递给被调用的策略。当实现新服务"
"时，安全模块必须在必要时通过 MAC 框架调用相应的访问控制检查机制。比方说，假如"
"一个策略实现了某种额外的信号功能，那么它应该调用相关的信号访问控制检查，以接"
"受 MAC 框架中注册的其他策略的检查。"

#. (itstool) path: note/para
#: book.translate.xml:5272
msgid ""
"Modules must currently perform the <function>copyin()</function> of the "
"syscall data on their own."
msgstr ""
"不同的模块需要并发地手动进行<function>copyin()</function>拷贝系统调用数据。"

#. (itstool) path: sect3/title
#: book.translate.xml:5279
msgid "<function>mpo_thread_userret</function>"
msgstr "<function>mpo_thread_userret</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5282
msgid ""
"<funcdef>void <function>mpo_thread_userret</function></funcdef> "
"<paramdef>struct thread *<parameter>td</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_thread_userret</function></funcdef> "
"<paramdef>struct thread *<parameter>td</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:5310
msgid "Returning thread"
msgstr "返回线程"

#. (itstool) path: sect3/para
#: book.translate.xml:5317
msgid ""
"This entry point permits policy modules to perform MAC-related events when a "
"thread returns to user space, via a system call return, trap return, or "
"otherwise. This is required for policies that have floating process labels, "
"as it is not always possible to acquire the process lock at arbitrary points "
"in the stack during system call processing; process labels might represent "
"traditional authentication data, process history information, or other data. "
"To employ this mechanism, intended changes to the process credential label "
"may be stored in the <literal>p_label</literal> protected by a per-policy "
"spin lock, and then set the per-thread <literal>TDF_ASTPENDING</literal> "
"flag and per-process <literal>PS_MACPENDM</literal> flag to schedule a call "
"to the userret entry point. From this entry point, the policy may create a "
"replacement credential with less concern about the locking context. Policy "
"writers are cautioned that event ordering relating to scheduling an AST and "
"the AST being performed may be complex and interlaced in multithreaded "
"applications."
msgstr ""
"使用该入口函数，策略模块能够在线程返回用户空间时（系统调用返回、异常返回等"
"等）进行 MAC 相关的处理工作。使用动态进程标记的策略需要使用该入口函数，因为在"
"处理系统调用的过程中，并不是在任意时刻都能申请到进程锁的；进程的标记可能表示"
"传统的认证信息、进程历史记录或者其他数据。为使用该入口函数，对进程信任状所作"
"的修改可能被存放在 <literal>p_label</literal> ,该域受一个进程级自旋锁的保护；"
"接下来，设置线程级的<literal>TDF_ASTPENDING</literal>标志位和进程级的"
"<literal>PS_MACPENDM</literal>标志位，表明将调度一个对 userret 入口函数的调"
"用。通过该入口函数，策略可以在相对简单的同步上下文中创建信任状的替代品。策略"
"编程人员必须清楚，需要保证与调度一个 AST 相关的事件执行次序，同时所执行的 "
"AST 可能很复杂，而且在处理多线程应用程序时可能被重入。"

#. (itstool) path: sect2/title
#: book.translate.xml:5340
msgid "Label Operations"
msgstr "操作标记"

#. (itstool) path: sect3/title
#: book.translate.xml:5343
msgid "<function>mpo_init_bpfdesc_label</function>"
msgstr "<function>mpo_init_bpfdesc_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5346
msgid ""
"<funcdef>void <function>mpo_init_bpfdesc_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_init_bpfdesc_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:5373 book.translate.xml:5415 book.translate.xml:5457
#: book.translate.xml:5499 book.translate.xml:5542 book.translate.xml:5606
#: book.translate.xml:5709 book.translate.xml:5751 book.translate.xml:5794
#: book.translate.xml:5845 book.translate.xml:5895 book.translate.xml:5938
#: book.translate.xml:5980 book.translate.xml:6024 book.translate.xml:6068
#: book.translate.xml:6112 book.translate.xml:6156 book.translate.xml:6200
#: book.translate.xml:6244 book.translate.xml:6340 book.translate.xml:6428
#: book.translate.xml:6471 book.translate.xml:6514 book.translate.xml:6710
#: book.translate.xml:6787 book.translate.xml:6864 book.translate.xml:6941
#: book.translate.xml:7017 book.translate.xml:7094 book.translate.xml:7171
#: book.translate.xml:7246 book.translate.xml:7321 book.translate.xml:7396
#: book.translate.xml:7471 book.translate.xml:7849 book.translate.xml:8060
#: book.translate.xml:11830 book.translate.xml:12117 book.translate.xml:12195
#: book.translate.xml:12262 book.translate.xml:12327 book.translate.xml:12400
#: book.translate.xml:12497 book.translate.xml:12562 book.translate.xml:12625
#: book.translate.xml:12751 book.translate.xml:12825 book.translate.xml:12907
#: book.translate.xml:13107 book.translate.xml:13232 book.translate.xml:13298
#: book.translate.xml:13364 book.translate.xml:13442 book.translate.xml:13528
#: book.translate.xml:13596 book.translate.xml:13665 book.translate.xml:13737
#: book.translate.xml:13925
msgid "<parameter>label</parameter>"
msgstr "<parameter>label</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:5374 book.translate.xml:5458 book.translate.xml:5500
#: book.translate.xml:5543
msgid "New label to apply"
msgstr "将被应用的新标记"

#. (itstool) path: sect3/para
#: book.translate.xml:5380
msgid ""
"Initialize the label on a newly instantiated bpfdesc (BPF descriptor). "
"Sleeping is permitted."
msgstr "为一个新近实例化的 bpfdesc（BPF 描述子）初始化标记。可以睡眠。"

#. (itstool) path: sect3/title
#: book.translate.xml:5385
msgid "<function>mpo_init_cred_label</function>"
msgstr "<function>mpo_init_cred_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5388
msgid ""
"<funcdef>void <function>mpo_init_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_init_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:5416 book.translate.xml:5795 book.translate.xml:5846
#: book.translate.xml:5896 book.translate.xml:5939
msgid "New label to initialize"
msgstr "初始化新标签"

#. (itstool) path: sect3/para
#: book.translate.xml:5422
msgid ""
"Initialize the label for a newly instantiated user credential. Sleeping is "
"permitted."
msgstr "为一个新近实例化的用户信任状初始化标记。可以睡眠。"

#. (itstool) path: sect3/title
#: book.translate.xml:5427
msgid "<function>mpo_init_devfsdirent_label</function>"
msgstr "<function>mpo_init_devfsdirent_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5430
msgid ""
"<funcdef>void <function>mpo_init_devfsdirent_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_init_devfsdirent_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:5464
msgid ""
"Initialize the label on a newly instantiated devfs entry. Sleeping is "
"permitted."
msgstr "为一个新近实例化的用户信任状初始化标记。可以睡眠。"

#. (itstool) path: sect3/title
#: book.translate.xml:5469
msgid "<function>mpo_init_ifnet_label</function>"
msgstr "<function>mpo_init_ifnet_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5472
msgid ""
"<funcdef>void <function>mpo_init_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_init_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:5506
msgid ""
"Initialize the label on a newly instantiated network interface. Sleeping is "
"permitted."
msgstr "为一个新近实例化的用户信任状初始化标记。可以睡眠。"

#. (itstool) path: sect3/title
#: book.translate.xml:5511
msgid "<function>mpo_init_ipq_label</function>"
msgstr "<function>mpo_init_ipq_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5514
msgid ""
"<funcdef>void <function>mpo_init_ipq_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>flag</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_init_ipq_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>flag</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:5547 book.translate.xml:5600 book.translate.xml:5799
#: book.translate.xml:5850
msgid "<parameter>flag</parameter>"
msgstr "<parameter>flag</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:5548 book.translate.xml:5601
msgid ""
"Sleeping/non-sleeping <citerefentry><refentrytitle>malloc</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>; see below"
msgstr ""
"睡眠/不睡眠 <citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry>; 参见下文"

#. (itstool) path: sect3/para
#: book.translate.xml:5555
msgid ""
"Initialize the label on a newly instantiated IP fragment reassembly queue. "
"The <parameter>flag</parameter> field may be one of <symbol>M_WAITOK</"
"symbol> and <symbol>M_NOWAIT</symbol>, and should be employed to avoid "
"performing a sleeping <citerefentry><refentrytitle>malloc</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> during this "
"initialization call. IP fragment reassembly queue allocation frequently "
"occurs in performance sensitive environments, and the implementation should "
"be careful to avoid sleeping or long-lived operations. This entry point is "
"permitted to fail resulting in the failure to allocate the IP fragment "
"reassembly queue."
msgstr ""
"为一个新近实例化的 IP 分片重组队列初始化标记。其中的<parameter>flag</"
"parameter>域可能取<symbol>M_WAITOK</symbol>或<symbol>M_NOWAIT</symbol>之一，"
"用来避免在该初始化调用中因为 <citerefentry><refentrytitle>malloc</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> 而进入睡眠。IP 分片重组"
"队列的分配操作通常是在对性能有严格要求的环境下进行的，因此实现代码必须小心地"
"避免睡眠和长时间的操作。IP 分片重组队列分配操作失败时上述入口函数将失败返回。"

#. (itstool) path: sect3/title
#: book.translate.xml:5569
msgid "<function>mpo_init_mbuf_label</function>"
msgstr "<function>mpo_init_mbuf_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5572
msgid ""
"<funcdef>void <function>mpo_init_mbuf_label</function></funcdef> "
"<paramdef>int <parameter>flag</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_init_mbuf_label</function></funcdef> "
"<paramdef>int <parameter>flag</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:5607
msgid "Policy label to initialize"
msgstr "将被初始化的策略标记"

#. (itstool) path: sect3/para
#: book.translate.xml:5613
msgid ""
"Initialize the label on a newly instantiated mbuf packet header "
"(<parameter>mbuf</parameter>). The <parameter>flag</parameter> field may be "
"one of <symbol>M_WAITOK</symbol> and <symbol>M_NOWAIT</symbol>, and should "
"be employed to avoid performing a sleeping "
"<citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> during this initialization call. Mbuf allocation frequently "
"occurs in performance sensitive environments, and the implementation should "
"be careful to avoid sleeping or long-lived operations. This entry point is "
"permitted to fail resulting in the failure to allocate the mbuf header."
msgstr ""
"为一个新近实例化的 mbuf 数据包头部（<parameter>mbuf</parameter>）初始化标记。"
"其中的<parameter>flag</parameter>的值可能取<symbol>M_WAITOK</symbol>和"
"<symbol>M_NOWAIT</symbol>之一，用来避免在该初始化调用中因为 "
"<citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> 而进入睡眠。Mbuf 头部的分配操作常常在对性能有严格要求的环境下被"
"频繁执行，因此实现代码必须小心地避免睡眠和长时间的操作。上述入口函数在 Mbuf "
"头部分配操作失败时将失败返回。"

#. (itstool) path: sect3/title
#: book.translate.xml:5627
msgid "<function>mpo_init_mount_label</function>"
msgstr "<function>mpo_init_mount_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5630
msgid ""
"<funcdef>void <function>mpo_init_mount_label</function></funcdef> "
"<paramdef>struct label *<parameter>mntlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_init_mount_label</function></funcdef> "
"<paramdef>struct label *<parameter>mntlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:5660 book.translate.xml:6290 book.translate.xml:8149
msgid "<parameter>mntlabel</parameter>"
msgstr "<parameter>mntlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:5661
msgid "Policy label to be initialized for the mount itself"
msgstr "将被初始化的 mount 结构策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:5666 book.translate.xml:6295 book.translate.xml:7631
#: book.translate.xml:7710 book.translate.xml:7780 book.translate.xml:8155
msgid "<parameter>fslabel</parameter>"
msgstr "<parameter>fslabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:5667
msgid "Policy label to be initialized for the file system"
msgstr "将被初始化的文件系统策略标记"

#. (itstool) path: sect3/para
#: book.translate.xml:5674
msgid ""
"Initialize the labels on a newly instantiated mount point. Sleeping is "
"permitted."
msgstr "为一个新近实例化的 mount 点初始化标记。可以睡眠。"

#. (itstool) path: sect3/title
#: book.translate.xml:5679
msgid "<function>mpo_init_mount_fs_label</function>"
msgstr "<function>mpo_init_mount_fs_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5682
msgid ""
"<funcdef>void <function>mpo_init_mount_fs_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_init_mount_fs_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:5710
msgid "Label to be initialized"
msgstr "将被初始化的标记"

#. (itstool) path: sect3/para
#: book.translate.xml:5716
msgid ""
"Initialize the label on a newly mounted file system. Sleeping is permitted"
msgstr "为一个新近加载的文件系统初始化标记。可以睡眠"

#. (itstool) path: sect3/title
#: book.translate.xml:5721
msgid "<function>mpo_init_pipe_label</function>"
msgstr "<function>mpo_init_pipe_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5724
msgid ""
"<funcdef>void <function>mpo_init_pipe_label</function></funcdef> "
"<paramdef>struct label*<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_init_pipe_label</function></funcdef> "
"<paramdef>struct label*<parameter>label</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:5752 book.translate.xml:7172 book.translate.xml:7247
#: book.translate.xml:7322 book.translate.xml:7397 book.translate.xml:7472
msgid "Label to be filled in"
msgstr "将被填写的标记"

#. (itstool) path: sect3/para
#: book.translate.xml:5758
msgid ""
"Initialize a label for a newly instantiated pipe. Sleeping is permitted."
msgstr "为一个刚刚实例化的管道初始化安全标记。可以睡眠。"

#. (itstool) path: sect3/title
#: book.translate.xml:5763
msgid "<function>mpo_init_socket_label</function>"
msgstr "<function>mpo_init_socket_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5766
msgid ""
"<funcdef>void <function>mpo_init_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>flag</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_init_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>flag</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:5800 book.translate.xml:5851
msgid ""
"<citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> flags"
msgstr ""
"<citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> flags"

#. (itstool) path: sect3/para
#: book.translate.xml:5806
msgid ""
"Initialize a label for a newly instantiated socket. The <parameter>flag</"
"parameter> field may be one of <symbol>M_WAITOK</symbol> and "
"<symbol>M_NOWAIT</symbol>, and should be employed to avoid performing a "
"sleeping <citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> during this initialization call."
msgstr ""
"为一个刚刚实例化的套接字初始化安全标记。其中的 <parameter>flag</parameter> 域"
"的值必须被指定为<symbol>M_WAITOK</symbol>和<symbol>M_NOWAIT</symbol>之一，以"
"避免在该初始化程中使用可能睡眠的<citerefentry><refentrytitle>malloc</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> 。"

#. (itstool) path: sect3/title
#: book.translate.xml:5814
msgid "<function>mpo_init_socket_peer_label</function>"
msgstr "<function>mpo_init_socket_peer_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5817
msgid ""
"<funcdef>void <function>mpo_init_socket_peer_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>flag</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_init_socket_peer_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>flag</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:5857
msgid ""
"Initialize the peer label for a newly instantiated socket. The "
"<parameter>flag</parameter> field may be one of <symbol>M_WAITOK</symbol> "
"and <symbol>M_NOWAIT</symbol>, and should be employed to avoid performing a "
"sleeping <citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> during this initialization call."
msgstr ""
"为刚刚实例化的套接字对等体进行标记的初始化。其中的 <parameter>flag</"
"parameter> 域的值必须被指定为<symbol>M_WAITOK</symbol> 和 <symbol>M_NOWAIT</"
"symbol> 之一，以避免在该初始化程中使用可能睡眠的"
"<citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry>。"

#. (itstool) path: sect3/title
#: book.translate.xml:5865
msgid "<function>mpo_init_proc_label</function>"
msgstr "<function>mpo_init_proc_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5868
msgid ""
"<funcdef>void <function>mpo_init_proc_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_init_proc_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:5902
msgid ""
"Initialize the label for a newly instantiated process. Sleeping is permitted."
msgstr "为一个刚刚实例化的进程初始化安全标记。可以睡眠。"

#. (itstool) path: sect3/title
#: book.translate.xml:5908
msgid "<function>mpo_init_vnode_label</function>"
msgstr "<function>mpo_init_vnode_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5911
msgid ""
"<funcdef>void <function>mpo_init_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_init_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:5945
msgid ""
"Initialize the label on a newly instantiated vnode. Sleeping is permitted."
msgstr "为一个刚刚实例化的 vnode 初始化安全标记。可以睡眠。"

#. (itstool) path: sect3/title
#: book.translate.xml:5950
msgid "<function>mpo_destroy_bpfdesc_label</function>"
msgstr "<function>mpo_destroy_bpfdesc_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5953
msgid ""
"<funcdef>void <function>mpo_destroy_bpfdesc_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_destroy_bpfdesc_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:5981
msgid "bpfdesc label"
msgstr "bpfdesc 标记"

#. (itstool) path: sect3/para
#: book.translate.xml:5987
msgid ""
"Destroy the label on a BPF descriptor. In this entry point a policy should "
"free any internal storage associated with <parameter>label</parameter> so "
"that it may be destroyed."
msgstr ""
"销毁一个 BPF 描述子上的标记。在该入口函数中，策略应当释放所有在内部分配与 "
"<parameter>label</parameter>相关联的存储空间，以便销毁该标记。"

#. (itstool) path: sect3/title
#: book.translate.xml:5994
msgid "<function>mpo_destroy_cred_label</function>"
msgstr "<function>mpo_destroy_cred_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5997
msgid ""
"<funcdef>void <function>mpo_destroy_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_destroy_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:6025 book.translate.xml:6069 book.translate.xml:6113
#: book.translate.xml:6157 book.translate.xml:6201
msgid "Label being destroyed"
msgstr "将被销毁的标记"

#. (itstool) path: sect3/para
#: book.translate.xml:6031
msgid ""
"Destroy the label on a credential. In this entry point, a policy module "
"should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"销毁一个信任状上的标记。在该入口函数中，策略应当释放所有在内部分配的与 "
"<parameter>label</parameter>相关联的存储空间，以便销毁该标记。"

#. (itstool) path: sect3/title
#: book.translate.xml:6038
msgid "<function>mpo_destroy_devfsdirent_label</function>"
msgstr "<function>mpo_destroy_devfsdirent_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6041
msgid ""
"<funcdef>void <function>mpo_destroy_devfsdirent_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_destroy_devfsdirent_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:6075
msgid ""
"Destroy the label on a devfs entry. In this entry point, a policy module "
"should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"销毁一个 devfs 表项上的标记。在该入口函数中，策略应当释放所有在内部分配的与 "
"<parameter>label</parameter>相关联的存储空间，以便销毁该标记。"

#. (itstool) path: sect3/title
#: book.translate.xml:6082
msgid "<function>mpo_destroy_ifnet_label</function>"
msgstr "<function>mpo_destroy_ifnet_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6085
msgid ""
"<funcdef>void <function>mpo_destroy_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_destroy_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:6119
msgid ""
"Destroy the label on a removed interface. In this entry point, a policy "
"module should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"销毁与一个已删除接口相关联的标记。在该入口函数中，策略应当释放所有在内部分配"
"的与 <parameter>label</parameter>相关联的存储空间，以便销毁该标记。"

#. (itstool) path: sect3/title
#: book.translate.xml:6126
msgid "<function>mpo_destroy_ipq_label</function>"
msgstr "<function>mpo_destroy_ipq_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6129
msgid ""
"<funcdef>void <function>mpo_destroy_ipq_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_destroy_ipq_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:6163
msgid ""
"Destroy the label on an IP fragment queue. In this entry point, a policy "
"module should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"销毁与一个 IP 分片队列相关联的标记。在该入口函数中，策略应当释放所有在内部分"
"配的与 <parameter>label</parameter>\n"
"          相关联的存储空间，以便销毁该标记。"

#. (itstool) path: sect3/title
#: book.translate.xml:6170
msgid "<function>mpo_destroy_mbuf_label</function>"
msgstr "<function>mpo_destroy_mbuf_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6173
msgid ""
"<funcdef>void <function>mpo_destroy_mbuf_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_destroy_mbuf_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:6207
msgid ""
"Destroy the label on an mbuf header. In this entry point, a policy module "
"should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"销毁与一个 Mbuf 相关联的标记。在该入口函数中，策略应当释放所有在内部分配的与 "
"<parameter>label</parameter>相关联的存储空间，以便销毁该标记。"

#. (itstool) path: sect3/title
#: book.translate.xml:6214 book.translate.xml:6258
msgid "<function>mpo_destroy_mount_label</function>"
msgstr "<function>mpo_destroy_mount_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6217
msgid ""
"<funcdef>void <function>mpo_destroy_mount_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_destroy_mount_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:6245 book.translate.xml:6291
msgid "Mount point label being destroyed"
msgstr "将被销毁的 Mount 点标记"

#. (itstool) path: sect3/para
#: book.translate.xml:6251
msgid ""
"Destroy the labels on a mount point. In this entry point, a policy module "
"should free the internal storage associated with <parameter>mntlabel</"
"parameter> so that they may be destroyed."
msgstr ""
"销毁与一个 mount 点相关联的标记。在该入口函数中，策略应当释放所有在内部分配的"
"与 <parameter>mntlabel</parameter>相关联的存储空间，以便销毁该标记。"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6261
msgid ""
"<funcdef>void <function>mpo_destroy_mount_label</function></funcdef> "
"<paramdef>struct label *<parameter>mntlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_destroy_mount_label</function></funcdef> "
"<paramdef>struct label *<parameter>mntlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:6296
msgid "File system label being destroyed&gt;"
msgstr "将被销毁的 Mount 点标记&gt;"

#. (itstool) path: sect3/para
#: book.translate.xml:6302
msgid ""
"Destroy the labels on a mount point. In this entry point, a policy module "
"should free the internal storage associated with <parameter>mntlabel</"
"parameter> and <parameter>fslabel</parameter> so that they may be destroyed."
msgstr ""
"销毁与一个 mount 点相关联的标记。在该入口函数中，策略应当释放所有在内部分配"
"的，与 <parameter>mntlabel</parameter>和<parameter>fslabel</parameter> 相关联"
"的存储空间，以便销毁该标记。"

#. (itstool) path: sect3/title
#: book.translate.xml:6310
msgid "<function>mpo_destroy_socket_label</function>"
msgstr "<function>mpo_destroy_socket_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6313
msgid ""
"<funcdef>void <function>mpo_destroy_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_destroy_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:6341
msgid "Socket label being destroyed"
msgstr "将被销毁的套接字标记"

#. (itstool) path: sect3/para
#: book.translate.xml:6347
msgid ""
"Destroy the label on a socket. In this entry point, a policy module should "
"free any internal storage associated with <parameter>label</parameter> so "
"that it may be destroyed."
msgstr ""
"销毁与一个套接字相关联的标记。在该入口函数中，策略应当释放所有在内部分配的，"
"与 <parameter>label</parameter>相关联的存储空间，以便销毁该标记。"

#. (itstool) path: sect3/title
#: book.translate.xml:6354
msgid "<function>mpo_destroy_socket_peer_label</function>"
msgstr "<function>mpo_destroy_socket_peer_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6357
msgid ""
"<funcdef>void <function>mpo_destroy_socket_peer_label</function></funcdef> "
"<paramdef>struct label *<parameter>peerlabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_destroy_socket_peer_label</function></funcdef> "
"<paramdef>struct label *<parameter>peerlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:6384
msgid "<parameter>peerlabel</parameter>"
msgstr "<parameter>peerlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:6385
msgid "Socket peer label being destroyed"
msgstr "将被销毁的套接字对等实体标记"

#. (itstool) path: sect3/para
#: book.translate.xml:6391
msgid ""
"Destroy the peer label on a socket. In this entry point, a policy module "
"should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"销毁与一个套接字相关联的对等实体标记。在该入口函数中，策略应当释放所有在内部"
"分配的，与 <parameter>label</parameter>相关联的存储空间，以便销毁该标记。"

#. (itstool) path: sect3/title
#: book.translate.xml:6398
msgid "<function>mpo_destroy_pipe_label</function>"
msgstr "<function>mpo_destroy_pipe_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6401
msgid ""
"<funcdef>void <function>mpo_destroy_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_destroy_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:6429
msgid "Pipe label"
msgstr "管道标记"

#. (itstool) path: sect3/para
#: book.translate.xml:6435
msgid ""
"Destroy the label on a pipe. In this entry point, a policy module should "
"free any internal storage associated with <parameter>label</parameter> so "
"that it may be destroyed."
msgstr ""
"销毁一个管道的标记。在该入口函数中，策略应当释放所有在内部分配的，与 "
"<parameter>label</parameter>相关联的存储空间，以便销毁该标记。"

#. (itstool) path: sect3/title
#: book.translate.xml:6442
msgid "<function>mpo_destroy_proc_label</function>"
msgstr "<function>mpo_destroy_proc_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6445
msgid ""
"<funcdef>void <function>mpo_destroy_proc_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_destroy_proc_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:6472 book.translate.xml:6515
msgid "Process label"
msgstr "进程标记"

#. (itstool) path: sect3/para
#: book.translate.xml:6478
msgid ""
"Destroy the label on a process. In this entry point, a policy module should "
"free any internal storage associated with <parameter>label</parameter> so "
"that it may be destroyed."
msgstr ""
"销毁一个进程的标记。在该入口函数中，策略应当释放所有在内部分配的，与 "
"<parameter>label</parameter>相关联的存储空间，以便销毁该标记。"

#. (itstool) path: sect3/title
#: book.translate.xml:6485
msgid "<function>mpo_destroy_vnode_label</function>"
msgstr "<function>mpo_destroy_vnode_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6488
msgid ""
"<funcdef>void <function>mpo_destroy_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_destroy_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:6521
msgid ""
"Destroy the label on a vnode. In this entry point, a policy module should "
"free any internal storage associated with <parameter>label</parameter> so "
"that it may be destroyed."
msgstr ""
"销毁一个 vnode 的标记。在该入口函数中，策略应当释放所有在内部分配的，与 "
"<parameter>label</parameter>相关联的存储空间，以便销毁该标记。"

#. (itstool) path: sect3/title
#: book.translate.xml:6528
msgid "<function>mpo_copy_mbuf_label</function>"
msgstr "<function>mpo_copy_mbuf_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6531
msgid ""
"<funcdef>void <function>mpo_copy_mbuf_label</function></funcdef> "
"<paramdef>struct label *<parameter>src</parameter></paramdef> "
"<paramdef>struct label *<parameter>dest</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_copy_mbuf_label</function></funcdef> "
"<paramdef>struct label *<parameter>src</parameter></paramdef> "
"<paramdef>struct label *<parameter>dest</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:6560 book.translate.xml:6609 book.translate.xml:6658
msgid "<parameter>src</parameter>"
msgstr "<parameter>src</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:6561 book.translate.xml:6610 book.translate.xml:6659
msgid "Source label"
msgstr "源标记"

#. (itstool) path: row/entry
#: book.translate.xml:6565 book.translate.xml:6614 book.translate.xml:6663
msgid "<parameter>dest</parameter>"
msgstr "<parameter>dest</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:6566 book.translate.xml:6615 book.translate.xml:6664
msgid "Destination label"
msgstr "目标标记"

#. (itstool) path: sect3/para
#: book.translate.xml:6572 book.translate.xml:6621 book.translate.xml:6670
msgid ""
"Copy the label information in <parameter>src</parameter> into "
"<parameter>dest</parameter>."
msgstr ""
"将 <parameter>src</parameter> 中的标记信息拷贝到 <parameter>dest</parameter>"
"中。"

#. (itstool) path: sect3/title
#: book.translate.xml:6577
msgid "<function>mpo_copy_pipe_label</function>"
msgstr "<function>mpo_copy_pipe_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6580
msgid ""
"<funcdef>void <function>mpo_copy_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>src</parameter></paramdef> "
"<paramdef>struct label *<parameter>dest</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_copy_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>src</parameter></paramdef> "
"<paramdef>struct label *<parameter>dest</parameter></paramdef>"

#. (itstool) path: sect3/title
#: book.translate.xml:6626
msgid "<function>mpo_copy_vnode_label</function>"
msgstr "<function>mpo_copy_vnode_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6629
msgid ""
"<funcdef>void <function>mpo_copy_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>src</parameter></paramdef> "
"<paramdef>struct label *<parameter>dest</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_copy_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>src</parameter></paramdef> "
"<paramdef>struct label *<parameter>dest</parameter></paramdef>"

#. (itstool) path: sect3/title
#: book.translate.xml:6675
msgid "<function>mpo_externalize_cred_label</function>"
msgstr "<function>mpo_externalize_cred_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6678
msgid ""
"<funcdef>int <function>mpo_externalize_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_externalize_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:6711 book.translate.xml:6788 book.translate.xml:6865
#: book.translate.xml:6942 book.translate.xml:7018 book.translate.xml:7095
msgid "Label to be externalized"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:6715 book.translate.xml:6792 book.translate.xml:6869
#: book.translate.xml:6946 book.translate.xml:7022 book.translate.xml:7099
#: book.translate.xml:7176 book.translate.xml:7251 book.translate.xml:7326
#: book.translate.xml:7401 book.translate.xml:7476
msgid "<parameter>element_name</parameter>"
msgstr "<parameter>element_name</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:6716 book.translate.xml:6793 book.translate.xml:6870
#: book.translate.xml:6947 book.translate.xml:7023 book.translate.xml:7100
msgid "Name of the policy whose label should be externalized"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:6720 book.translate.xml:6797 book.translate.xml:6874
#: book.translate.xml:6951 book.translate.xml:7027 book.translate.xml:7104
msgid "<parameter>sb</parameter>"
msgstr "<parameter>sb</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:6721 book.translate.xml:6798 book.translate.xml:6875
#: book.translate.xml:6952 book.translate.xml:7028 book.translate.xml:7105
msgid "String buffer to be filled with a text representation of label"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:6726 book.translate.xml:6803 book.translate.xml:6880
#: book.translate.xml:6957 book.translate.xml:7033 book.translate.xml:7110
#: book.translate.xml:7186 book.translate.xml:7261 book.translate.xml:7336
#: book.translate.xml:7411 book.translate.xml:7486
msgid "<parameter>claimed</parameter>"
msgstr "<parameter>claimed</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:6727 book.translate.xml:6804 book.translate.xml:6881
#: book.translate.xml:6958 book.translate.xml:7034 book.translate.xml:7111
msgid ""
"Should be incremented when <parameter>element_data</parameter> can be filled "
"in."
msgstr ""

#. (itstool) path: sect3/para
#: book.translate.xml:6736 book.translate.xml:6813 book.translate.xml:6890
#: book.translate.xml:6967 book.translate.xml:7043 book.translate.xml:7120
msgid ""
"Produce an externalized label based on the label structure passed. An "
"externalized label consists of a text representation of the label contents "
"that can be used with userland applications and read by the user. Currently, "
"all policies' <function>externalize</function> entry points will be called, "
"so the implementation should check the contents of <parameter>element_name</"
"parameter> before attempting to fill in <parameter>sb</parameter>. If "
"<parameter>element_name</parameter> does not match the name of your policy, "
"simply return <returnvalue>0</returnvalue>. Only return nonzero if an error "
"occurs while externalizing the label data. Once the policy fills in "
"<parameter>element_data</parameter>, <varname>*claimed</varname> should be "
"incremented."
msgstr ""

#. (itstool) path: sect3/title
#: book.translate.xml:6752
msgid "<function>mpo_externalize_ifnet_label</function>"
msgstr "<function>mpo_externalize_ifnet_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6755
msgid ""
"<funcdef>int <function>mpo_externalize_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_externalize_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"

#. (itstool) path: sect3/title
#: book.translate.xml:6829
msgid "<function>mpo_externalize_pipe_label</function>"
msgstr "<function>mpo_externalize_pipe_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6832
msgid ""
"<funcdef>int <function>mpo_externalize_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_externalize_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"

#. (itstool) path: sect3/title
#: book.translate.xml:6906
msgid "<function>mpo_externalize_socket_label</function>"
msgstr "<function>mpo_externalize_socket_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6909
msgid ""
"<funcdef>int <function>mpo_externalize_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_externalize_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"

#. (itstool) path: sect3/title
#: book.translate.xml:6983
msgid "<function>mpo_externalize_socket_peer_label</function>"
msgstr "<function>mpo_externalize_socket_peer_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6986
msgid ""
"<funcdef>int <function>mpo_externalize_socket_peer_label</function></"
"funcdef> <paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_externalize_socket_peer_label</function></"
"funcdef> <paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"

#. (itstool) path: sect3/title
#: book.translate.xml:7059
msgid "<function>mpo_externalize_vnode_label</function>"
msgstr "<function>mpo_externalize_vnode_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7062
msgid ""
"<funcdef>int <function>mpo_externalize_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_externalize_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"

#. (itstool) path: sect3/title
#: book.translate.xml:7136
msgid "<function>mpo_internalize_cred_label</function>"
msgstr "<function>mpo_internalize_cred_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7139
msgid ""
"<funcdef>int <function>mpo_internalize_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_internalize_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:7177 book.translate.xml:7252 book.translate.xml:7327
#: book.translate.xml:7402 book.translate.xml:7477
msgid "Name of the policy whose label should be internalized"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:7181 book.translate.xml:7256 book.translate.xml:7331
#: book.translate.xml:7406 book.translate.xml:7481
msgid "<parameter>element_data</parameter>"
msgstr "<parameter>element_data</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:7182 book.translate.xml:7257 book.translate.xml:7332
#: book.translate.xml:7407 book.translate.xml:7482
msgid "Text data to be internalized"
msgstr ""

#. (itstool) path: row/entry
#: book.translate.xml:7187 book.translate.xml:7262 book.translate.xml:7337
#: book.translate.xml:7412 book.translate.xml:7487
msgid "Should be incremented when data can be successfully internalized."
msgstr ""

#. (itstool) path: sect3/para
#: book.translate.xml:7196 book.translate.xml:7271 book.translate.xml:7346
#: book.translate.xml:7421 book.translate.xml:7496
msgid ""
"Produce an internal label structure based on externalized label data in text "
"format. Currently, all policies' <function>internalize</function> entry "
"points are called when internalization is requested, so the implementation "
"should compare the contents of <parameter>element_name</parameter> to its "
"own name in order to be sure it should be internalizing the data in "
"<parameter>element_data</parameter>. Just as in the <function>externalize</"
"function> entry points, the entry point should return <returnvalue>0</"
"returnvalue> if <parameter>element_name</parameter> does not match its own "
"name, or when data can successfully be internalized, in which case "
"<varname>*claimed</varname> should be incremented."
msgstr ""

#. (itstool) path: sect3/title
#: book.translate.xml:7211
msgid "<function>mpo_internalize_ifnet_label</function>"
msgstr "<function>mpo_internalize_ifnet_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7214
msgid ""
"<funcdef>int <function>mpo_internalize_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_internalize_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"

#. (itstool) path: sect3/title
#: book.translate.xml:7286
msgid "<function>mpo_internalize_pipe_label</function>"
msgstr "<function>mpo_internalize_pipe_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7289
msgid ""
"<funcdef>int <function>mpo_internalize_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_internalize_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"

#. (itstool) path: sect3/title
#: book.translate.xml:7361
msgid "<function>mpo_internalize_socket_label</function>"
msgstr "<function>mpo_internalize_socket_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7364
msgid ""
"<funcdef>int <function>mpo_internalize_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_internalize_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"

#. (itstool) path: sect3/title
#: book.translate.xml:7436
msgid "<function>mpo_internalize_vnode_label</function>"
msgstr "<function>mpo_internalize_vnode_label</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7439
msgid ""
"<funcdef>int <function>mpo_internalize_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_internalize_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"

#. (itstool) path: sect2/title
#: book.translate.xml:7512
msgid "Label Events"
msgstr "标记事件"

#. (itstool) path: sect2/para
#: book.translate.xml:7514
msgid ""
"This class of entry points is used by the MAC framework to permit policies "
"to maintain label information on kernel objects. For each labeled kernel "
"object of interest to a MAC policy, entry points may be registered for "
"relevant life cycle events. All objects implement initialization, creation, "
"and destruction hooks. Some objects will also implement relabeling, allowing "
"user processes to change the labels on objects. Some objects will also "
"implement object-specific events, such as label events associated with IP "
"reassembly. A typical labeled object will have the following life cycle of "
"entry points:"
msgstr ""
"策略模块使用MAC 框架提供的“标记事件”类入口函数，对内核对象的标记进行操作。策"
"略模块将感兴趣的被标记内核对象的相关生命周期事件注册在恰当的入口点上。对象的"
"初始化、创建和销毁事件均提供了钩子点。在某些对象上还可以实现重新标记，即，允"
"许用户进程改变对象上的标记值。对某些对象可以实现其特定的对象事件，比如与 IP "
"重组相关的标记事件。一个典型的被标记对象在其生命周期中将拥有下列入口函数："

#. (itstool) path: sect2/programlisting
#: book.translate.xml:7526
#, no-wrap
msgid ""
"Label initialization          o\n"
"(object-specific wait)         \\\n"
"Label creation                  o\n"
"                                 \\\n"
"Relabel events,                   o--&lt;--.\n"
"Various object-specific,          |     |\n"
"Access control events             ~--&gt;--o\n"
"                                         \\\n"
"Label destruction                         o"
msgstr ""
"Label initialization          o\n"
"(object-specific wait)         \\\n"
"Label creation                  o\n"
"                                 \\\n"
"Relabel events,                   o--&lt;--.\n"
"Various object-specific,          |     |\n"
"Access control events             ~--&gt;--o\n"
"                                         \\\n"
"Label destruction                         o"

#. (itstool) path: sect2/para
#: book.translate.xml:7536
msgid ""
"Label initialization permits policies to allocate memory and set initial "
"values for labels without context for the use of the object. The label slot "
"allocated to a policy will be zeroed by default, so some policies may not "
"need to perform initialization."
msgstr ""

#. (itstool) path: sect2/para
#: book.translate.xml:7542
msgid ""
"Label creation occurs when the kernel structure is associated with an actual "
"kernel object. For example, Mbufs may be allocated and remain unused in a "
"pool until they are required. mbuf allocation causes label initialization on "
"the mbuf to take place, but mbuf creation occurs when the mbuf is associated "
"with a datagram. Typically, context will be provided for a creation event, "
"including the circumstances of the creation, and labels of other relevant "
"objects in the creation process. For example, when an mbuf is created from a "
"socket, the socket and its label will be presented to registered policies in "
"addition to the new mbuf and its label. Memory allocation in creation events "
"is discouraged, as it may occur in performance sensitive ports of the "
"kernel; in addition, creation calls are not permitted to fail so a failure "
"to allocate memory cannot be reported."
msgstr ""

#. (itstool) path: sect2/para
#: book.translate.xml:7558
msgid ""
"Object specific events do not generally fall into the other broad classes of "
"label events, but will generally provide an opportunity to modify or update "
"the label on an object based on additional context. For example, the label "
"on an IP fragment reassembly queue may be updated during the "
"<symbol>MAC_UPDATE_IPQ</symbol> entry point as a result of the acceptance of "
"an additional mbuf to that queue."
msgstr ""
"对象特有的事件一般不会引发其他的标记事件，但是在对象上下文发生改变时，策略使"
"用它们可以对相关标记进行修改或更新操作。例如，在<symbol>MAC_UPDATE_IPQ</"
"symbol> 入口函数之内，某个 IP 分片重组队列的标记可能会因为队列中接收了新的 "
"mbuf 而被更新。"

#. (itstool) path: sect2/para
#: book.translate.xml:7566
msgid "Access control events are discussed in detail in the following section."
msgstr "访问控制事件将在后续章节中详细讨论。"

#. (itstool) path: sect2/para
#: book.translate.xml:7569
msgid ""
"Label destruction permits policies to release storage or state associated "
"with a label during its association with an object so that the kernel data "
"structures supporting the object may be reused or released."
msgstr ""

#. (itstool) path: sect2/para
#: book.translate.xml:7574
msgid ""
"In addition to labels associated with specific kernel objects, an additional "
"class of labels exists: temporary labels. These labels are used to store "
"update information submitted by user processes. These labels are initialized "
"and destroyed as with other label types, but the creation event is "
"<symbol>MAC_INTERNALIZE</symbol>, which accepts a user label to be converted "
"to an in-kernel representation."
msgstr ""
"除了与特定内核对象绑定的普通标记之外，还有一种额外的标记类型：临时标记。这些"
"标记用于存放由用户进程提交的更新信息。它们的初始化和销毁操作与其他标记一样，"
"只是创建事件，<symbol>MAC_INTERNALIZE</symbol>，略有不同：该函数接受用户提交"
"的标记，负责将其转化为内核表示形式。"

#. (itstool) path: sect3/title
#: book.translate.xml:7583
msgid "File System Object Labeling Event Operations"
msgstr "文件系统对象标记事件操作"

#. (itstool) path: sect4/title
#: book.translate.xml:7586
msgid "<function>mpo_associate_vnode_devfs</function>"
msgstr "<function>mpo_associate_vnode_devfs</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7589
msgid ""
"<funcdef>void <function>mpo_associate_vnode_devfs</function></funcdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef> "
"<paramdef>struct devfs_dirent *<parameter>de</parameter></paramdef> "
"<paramdef>struct label *<parameter>delabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_associate_vnode_devfs</function></funcdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef> "
"<paramdef>struct devfs_dirent *<parameter>de</parameter></paramdef> "
"<paramdef>struct label *<parameter>delabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:7626 book.translate.xml:7705 book.translate.xml:7775
#: book.translate.xml:7972 book.translate.xml:8144 book.translate.xml:11699
msgid "<parameter>mp</parameter>"
msgstr "<parameter>mp</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:7627 book.translate.xml:7973
msgid "Devfs mount point"
msgstr "Devfs 挂载点"

#. (itstool) path: row/entry
#: book.translate.xml:7632
msgid "Devfs file system label (<varname>mp-&gt;mnt_fslabel</varname>)"
msgstr "Devfs 文件系统标记(<varname>mp-&gt;mnt_fslabel</varname>)"

#. (itstool) path: row/entry
#: book.translate.xml:7637 book.translate.xml:7988
msgid "<parameter>de</parameter>"
msgstr "<parameter>de</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:7638
msgid "Devfs directory entry"
msgstr "Devfs 目录项"

#. (itstool) path: row/entry
#: book.translate.xml:7642 book.translate.xml:7993
msgid "<parameter>delabel</parameter>"
msgstr "<parameter>delabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:7643
msgid "Policy label associated with <parameter>de</parameter>"
msgstr "与 <parameter>de</parameter> 相关联的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:7648 book.translate.xml:7715 book.translate.xml:7785
#: book.translate.xml:8076 book.translate.xml:8259 book.translate.xml:8325
#: book.translate.xml:8399 book.translate.xml:9993 book.translate.xml:10066
#: book.translate.xml:10583 book.translate.xml:11635 book.translate.xml:11825
#: book.translate.xml:12112 book.translate.xml:12189 book.translate.xml:12257
#: book.translate.xml:12322 book.translate.xml:12395 book.translate.xml:12492
#: book.translate.xml:12557 book.translate.xml:12621 book.translate.xml:12681
#: book.translate.xml:12746 book.translate.xml:12820 book.translate.xml:12902
#: book.translate.xml:13102 book.translate.xml:13227 book.translate.xml:13293
#: book.translate.xml:13359 book.translate.xml:13437 book.translate.xml:13523
#: book.translate.xml:13591 book.translate.xml:13660 book.translate.xml:13732
#: book.translate.xml:13920 book.translate.xml:14202 book.translate.xml:14393
msgid "<parameter>vp</parameter>"
msgstr "<parameter>vp</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:7649
msgid "vnode associated with <parameter>de</parameter>"
msgstr "与 <parameter>de</parameter> 相关联的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:7654 book.translate.xml:7720 book.translate.xml:7790
#: book.translate.xml:8081 book.translate.xml:8331 book.translate.xml:10588
#: book.translate.xml:14207 book.translate.xml:14398
msgid "<parameter>vlabel</parameter>"
msgstr "<parameter>vlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:7655 book.translate.xml:7721 book.translate.xml:7791
#: book.translate.xml:8082 book.translate.xml:8332 book.translate.xml:12498
#: book.translate.xml:12563 book.translate.xml:12752 book.translate.xml:12826
#: book.translate.xml:12908
msgid "Policy label associated with <parameter>vp</parameter>"
msgstr "与 <parameter>vp</parameter> 相关联的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:7662
msgid ""
"Fill in the label (<parameter>vlabel</parameter>) for a newly created devfs "
"vnode based on the devfs directory entry passed in <parameter>de</parameter> "
"and its label."
msgstr ""

#. (itstool) path: sect4/title
#: book.translate.xml:7669
msgid "<function>mpo_associate_vnode_extattr</function>"
msgstr "<function>mpo_associate_vnode_extattr</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7672
msgid ""
"<funcdef>int <function>mpo_associate_vnode_extattr</function></funcdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_associate_vnode_extattr</function></funcdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:7706 book.translate.xml:7776 book.translate.xml:8056
msgid "File system mount point"
msgstr "文件系统挂载点"

#. (itstool) path: row/entry
#: book.translate.xml:7711 book.translate.xml:7781 book.translate.xml:8061
msgid "File system label"
msgstr "文件系统标记"

#. (itstool) path: row/entry
#: book.translate.xml:7716 book.translate.xml:7786
msgid "Vnode to label"
msgstr "将被标记的 vnode"

#. (itstool) path: sect4/para
#: book.translate.xml:7728
msgid ""
"Attempt to retrieve the label for <parameter>vp</parameter> from the file "
"system extended attributes. Upon success, the value <literal>0</literal> is "
"returned. Should extended attribute retrieval not be supported, an accepted "
"fallback is to copy <parameter>fslabel</parameter> into <parameter>vlabel</"
"parameter>. In the event of an error, an appropriate value for "
"<varname>errno</varname> should be returned."
msgstr ""
"从文件系统扩展属性中读取 <parameter>vp</parameter> 的标记。成功，返回 "
"<literal>0</literal>。不成功，则在 <varname>errno</varname> 指定的相应的错误"
"编码。如果文件系统不支持扩展属性的读取操作，则可以考虑将 <parameter>fslabel</"
"parameter> 拷贝至 <parameter>vlabel</parameter>。"

#. (itstool) path: sect4/title
#: book.translate.xml:7740
msgid "<function>mpo_associate_vnode_singlelabel</function>"
msgstr "<function>mpo_associate_vnode_singlelabel</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7743
msgid ""
"<funcdef>void <function>mpo_associate_vnode_singlelabel</function></funcdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_associate_vnode_singlelabel</function></funcdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"

#. (itstool) path: sect4/para
#: book.translate.xml:7798
msgid ""
"On non-multilabel file systems, this entry point is called to set the policy "
"label for <parameter>vp</parameter> based on the file system label, "
"<parameter>fslabel</parameter>."
msgstr ""
"在非多重标记文件系统上，使用该入口函数，根据文件系统标记，"
"<parameter>fslabel</parameter>，为 <parameter>vp</parameter> 设置策略标记。"

#. (itstool) path: sect4/title
#: book.translate.xml:7805
msgid "<function>mpo_create_devfs_device</function>"
msgstr "<function>mpo_create_devfs_device</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7808
msgid ""
"<funcdef>void <function>mpo_create_devfs_device</function></funcdef> "
"<paramdef>dev_t <parameter>dev</parameter></paramdef> <paramdef>struct "
"devfs_dirent *<parameter>devfs_dirent</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_devfs_device</function></funcdef> "
"<paramdef>dev_t <parameter>dev</parameter></paramdef> <paramdef>struct "
"devfs_dirent *<parameter>devfs_dirent</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:7838
msgid "<parameter>dev</parameter>"
msgstr "<parameter>dev</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:7839
msgid "Device corresponding with <parameter>devfs_dirent</parameter>"
msgstr "<parameter>devfs_dirent</parameter> 对应的设备"

#. (itstool) path: row/entry
#: book.translate.xml:7844 book.translate.xml:7911 book.translate.xml:8387
msgid "<parameter>devfs_dirent</parameter>"
msgstr "<parameter>devfs_dirent</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:7845
msgid "Devfs directory entry to be labeled."
msgstr "将被标记的 Devfs 目录项。"

#. (itstool) path: row/entry
#: book.translate.xml:7850
msgid "Label for <parameter>devfs_dirent</parameter> to be filled in."
msgstr "将被填写的 <parameter>devfs_dirent</parameter> 标记。"

#. (itstool) path: sect4/para
#: book.translate.xml:7857
msgid ""
"Fill out the label on a devfs_dirent being created for the passed device. "
"This call will be made when the device file system is mounted, regenerated, "
"or a new device is made available."
msgstr ""
"为传入设备新建的 devfs_dirent 填写标记。该函数将在设备文件系统加载、重构或添"
"加新设备时被调用。"

#. (itstool) path: sect4/title
#: book.translate.xml:7864
msgid "<function>mpo_create_devfs_directory</function>"
msgstr "<function>mpo_create_devfs_directory</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7867
msgid ""
"<funcdef>void <function>mpo_create_devfs_directory</function></funcdef> "
"<paramdef>char *<parameter>dirname</parameter></paramdef> <paramdef>int "
"<parameter>dirnamelen</parameter></paramdef> <paramdef>struct devfs_dirent "
"*<parameter>devfs_dirent</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_devfs_directory</function></funcdef> "
"<paramdef>char *<parameter>dirname</parameter></paramdef> <paramdef>int "
"<parameter>dirnamelen</parameter></paramdef> <paramdef>struct devfs_dirent "
"*<parameter>devfs_dirent</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:7900
msgid "<parameter>dirname</parameter>"
msgstr "<parameter>dirname</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:7901
msgid "Name of directory being created"
msgstr "新建目录的名字"

#. (itstool) path: row/entry
#: book.translate.xml:7905 book.translate.xml:14459
msgid "<parameter>namelen</parameter>"
msgstr "<parameter>namelen</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:7906
msgid "Length of string <parameter>dirname</parameter>"
msgstr "字符串 <parameter>dirname</parameter> 的长度"

#. (itstool) path: row/entry
#: book.translate.xml:7912
msgid "Devfs directory entry for directory being created."
msgstr "新建目录在 Devfs 中对应的目录项。"

#. (itstool) path: sect4/para
#: book.translate.xml:7919
msgid ""
"Fill out the label on a devfs_dirent being created for the passed directory. "
"This call will be made when the device file system is mounted, regenerated, "
"or a new device requiring a specific directory hierarchy is made available."
msgstr ""
"为传入目录参数的新建 devfs_dirent 填写标记。该函数将在加载、重构设备文件系"
"统，或者添加一个需要指定目录结构的新设备时被调用。"

#. (itstool) path: sect4/title
#: book.translate.xml:7927
msgid "<function>mpo_create_devfs_symlink</function>"
msgstr "<function>mpo_create_devfs_symlink</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7930
msgid ""
"<funcdef>void <function>mpo_create_devfs_symlink</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct devfs_dirent *<parameter>dd</parameter></paramdef> "
"<paramdef>struct label *<parameter>ddlabel</parameter></paramdef> "
"<paramdef>struct devfs_dirent *<parameter>de</parameter></paramdef> "
"<paramdef>struct label *<parameter>delabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_devfs_symlink</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct devfs_dirent *<parameter>dd</parameter></paramdef> "
"<paramdef>struct label *<parameter>ddlabel</parameter></paramdef> "
"<paramdef>struct devfs_dirent *<parameter>de</parameter></paramdef> "
"<paramdef>struct label *<parameter>delabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:7967 book.translate.xml:8050 book.translate.xml:8139
#: book.translate.xml:8254 book.translate.xml:8320 book.translate.xml:8530
#: book.translate.xml:8588 book.translate.xml:8715 book.translate.xml:8780
#: book.translate.xml:8981 book.translate.xml:9792 book.translate.xml:10122
#: book.translate.xml:10164 book.translate.xml:10208 book.translate.xml:10387
#: book.translate.xml:10430 book.translate.xml:10479 book.translate.xml:10527
#: book.translate.xml:10578 book.translate.xml:10631 book.translate.xml:10674
#: book.translate.xml:10723 book.translate.xml:10790 book.translate.xml:10847
#: book.translate.xml:10906 book.translate.xml:10969 book.translate.xml:11027
#: book.translate.xml:11086 book.translate.xml:11148 book.translate.xml:11217
#: book.translate.xml:11275 book.translate.xml:11392 book.translate.xml:11448
#: book.translate.xml:11513 book.translate.xml:11574 book.translate.xml:11629
#: book.translate.xml:11694 book.translate.xml:11759 book.translate.xml:11820
#: book.translate.xml:11890 book.translate.xml:11952 book.translate.xml:12014
#: book.translate.xml:12096 book.translate.xml:12183 book.translate.xml:12252
#: book.translate.xml:12317 book.translate.xml:12390 book.translate.xml:12476
#: book.translate.xml:12552 book.translate.xml:12616 book.translate.xml:12676
#: book.translate.xml:12804 book.translate.xml:12886 book.translate.xml:12969
#: book.translate.xml:13029 book.translate.xml:13097 book.translate.xml:13160
#: book.translate.xml:13222 book.translate.xml:13288 book.translate.xml:13354
#: book.translate.xml:13432 book.translate.xml:13518 book.translate.xml:13586
#: book.translate.xml:13655 book.translate.xml:13727 book.translate.xml:13797
#: book.translate.xml:13854 book.translate.xml:13915 book.translate.xml:13983
#: book.translate.xml:14059 book.translate.xml:14132 book.translate.xml:14251
#: book.translate.xml:14294 book.translate.xml:14342 book.translate.xml:14388
#: book.translate.xml:14449
msgid "<parameter>cred</parameter>"
msgstr "<parameter>cred</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:7968 book.translate.xml:8051 book.translate.xml:8140
#: book.translate.xml:8255 book.translate.xml:8321 book.translate.xml:8531
#: book.translate.xml:8589 book.translate.xml:8716 book.translate.xml:8781
#: book.translate.xml:8982 book.translate.xml:9793 book.translate.xml:10209
#: book.translate.xml:10388 book.translate.xml:10431 book.translate.xml:10480
#: book.translate.xml:10528 book.translate.xml:10579 book.translate.xml:10632
#: book.translate.xml:10675 book.translate.xml:10724 book.translate.xml:10791
#: book.translate.xml:10848 book.translate.xml:10907 book.translate.xml:10970
#: book.translate.xml:11028 book.translate.xml:11087 book.translate.xml:11149
#: book.translate.xml:11218 book.translate.xml:11276 book.translate.xml:11332
#: book.translate.xml:11393 book.translate.xml:11449 book.translate.xml:11514
#: book.translate.xml:11575 book.translate.xml:11630 book.translate.xml:11695
#: book.translate.xml:11760 book.translate.xml:11821 book.translate.xml:11891
#: book.translate.xml:11953 book.translate.xml:12015 book.translate.xml:12097
#: book.translate.xml:12184 book.translate.xml:12253 book.translate.xml:12318
#: book.translate.xml:12391 book.translate.xml:12477 book.translate.xml:12553
#: book.translate.xml:12677 book.translate.xml:12736 book.translate.xml:12805
#: book.translate.xml:12887 book.translate.xml:12970 book.translate.xml:13030
#: book.translate.xml:13098 book.translate.xml:13161 book.translate.xml:13223
#: book.translate.xml:13289 book.translate.xml:13355 book.translate.xml:13433
#: book.translate.xml:13519 book.translate.xml:13587 book.translate.xml:13656
#: book.translate.xml:13728 book.translate.xml:13798 book.translate.xml:13855
#: book.translate.xml:13916 book.translate.xml:13984 book.translate.xml:14060
#: book.translate.xml:14133 book.translate.xml:14198 book.translate.xml:14252
#: book.translate.xml:14295 book.translate.xml:14343 book.translate.xml:14389
#: book.translate.xml:14450
msgid "Subject credential"
msgstr "主体信任状"

#. (itstool) path: row/entry
#: book.translate.xml:7977
msgid "<parameter>dd</parameter>"
msgstr "<parameter>dd</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:7978
msgid "Link destination"
msgstr "链接目标"

#. (itstool) path: row/entry
#: book.translate.xml:7982
msgid "<parameter>ddlabel</parameter>"
msgstr "<parameter>ddlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:7983
msgid "Label associated with <parameter>dd</parameter>"
msgstr "与 <parameter>dd</parameter> 相关联的标记"

#. (itstool) path: row/entry
#: book.translate.xml:7989
msgid "Symlink entry"
msgstr "符号链接项"

#. (itstool) path: row/entry
#: book.translate.xml:7994
msgid "Label associated with <parameter>de</parameter>"
msgstr "与 <parameter>de</parameter> 相关联的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:8001
msgid ""
"Fill in the label (<parameter>delabel</parameter>) for a newly created "
"<citerefentry vendor=\"current\"><refentrytitle>devfs</"
"refentrytitle><manvolnum>5</manvolnum></citerefentry> symbolic link entry."
msgstr ""
"为新近创建的 <citerefentry><refentrytitle>devfs</refentrytitle><manvolnum>5</"
"manvolnum></citerefentry> 符号链接项填写标记（<parameter>delabel</"
"parameter>）。"

#. (itstool) path: sect4/title
#: book.translate.xml:8006
msgid "<function>mpo_create_vnode_extattr</function>"
msgstr "<function>mpo_create_vnode_extattr</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8009
msgid ""
"<funcdef>int <function>mpo_create_vnode_extattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef> "
"<paramdef>struct componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_create_vnode_extattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef> "
"<paramdef>struct componentname *<parameter>cnp</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:8055
msgid "<parameter>mount</parameter>"
msgstr "<parameter>mount</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8065 book.translate.xml:11895 book.translate.xml:11957
#: book.translate.xml:12019 book.translate.xml:12101 book.translate.xml:12481
#: book.translate.xml:12809 book.translate.xml:12891 book.translate.xml:13034
#: book.translate.xml:13165
msgid "<parameter>dvp</parameter>"
msgstr "<parameter>dvp</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8066 book.translate.xml:12102
msgid "Parent directory vnode"
msgstr "父目录 vnode"

#. (itstool) path: row/entry
#: book.translate.xml:8070 book.translate.xml:11900 book.translate.xml:11962
#: book.translate.xml:12024 book.translate.xml:12106 book.translate.xml:12486
#: book.translate.xml:12814 book.translate.xml:12896 book.translate.xml:13039
#: book.translate.xml:13170
msgid "<parameter>dlabel</parameter>"
msgstr "<parameter>dlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8071
msgid "Label associated with <parameter>dvp</parameter>"
msgstr "与 <parameter>dvp</parameter> 相关联的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:8077
msgid "Newly created vnode"
msgstr "新创建的 vnode"

#. (itstool) path: row/entry
#: book.translate.xml:8087 book.translate.xml:12030 book.translate.xml:12123
#: book.translate.xml:12503 book.translate.xml:12831 book.translate.xml:12919
#: book.translate.xml:13045
msgid "<parameter>cnp</parameter>"
msgstr "<parameter>cnp</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8088 book.translate.xml:12124 book.translate.xml:12832
msgid "Component name for <parameter>vp</parameter>"
msgstr "<parameter>vp</parameter>中的子域名字"

#. (itstool) path: sect4/para
#: book.translate.xml:8095
msgid ""
"Write out the label for <parameter>vp</parameter> to the appropriate "
"extended attribute. If the write succeeds, fill in <parameter>vlabel</"
"parameter> with the label, and return <returnvalue>0</returnvalue>. "
"Otherwise, return an appropriate error."
msgstr ""
"将 <parameter>vp</parameter> 的标记写入文件扩展属性。成功，将标记填入 "
"<parameter>vlabel</parameter>，并返回 <returnvalue>0</returnvalue>。否则，返"
"回对应的错误编码。"

#. (itstool) path: sect4/title
#: book.translate.xml:8103
msgid "<function>mpo_create_mount</function>"
msgstr "<function>mpo_create_mount</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8106
msgid ""
"<funcdef>void <function>mpo_create_mount</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>mnt</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_mount</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>mnt</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:8145
msgid "Object; file system being mounted"
msgstr "客体；将被挂载的文件系统"

#. (itstool) path: row/entry
#: book.translate.xml:8150
msgid "Policy label to be filled in for <parameter>mp</parameter>"
msgstr "将被填写的 <parameter>mp</parameter> 的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:8156
msgid "Policy label for the file system <parameter>mp</parameter> mounts."
msgstr "将被挂载到 <parameter>mp</parameter> 的文件系统的策略标记。"

#. (itstool) path: sect4/para
#: book.translate.xml:8163
msgid ""
"Fill out the labels on the mount point being created by the passed subject "
"credential. This call will be made when a new file system is mounted."
msgstr ""
"为传入的主体信任状所创建的挂载点填写标记。该函数将在文件系统挂载时被调用。"

#. (itstool) path: sect4/title
#: book.translate.xml:8169
msgid "<function>mpo_create_root_mount</function>"
msgstr "<function>mpo_create_root_mount</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8172
msgid ""
"<funcdef>void <function>mpo_create_root_mount</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>mntlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_root_mount</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>mntlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:8205
msgid "See <xref linkend=\"mac-mpo-create-mount\"/>."
msgstr "请查阅<xref linkend=\"mac-mpo-create-mount\"/>."

#. (itstool) path: sect4/para
#: book.translate.xml:8211
msgid ""
"Fill out the labels on the mount point being created by the passed subject "
"credential. This call will be made when the root file system is mounted, "
"after mpo_create_mount;."
msgstr ""
"为传入的主体信任状所创建的挂载点填写标记。该函数将在挂载根文件系统时，在.mpo;"
"_create_mount; 之后被调用。"

#. (itstool) path: sect4/title
#: book.translate.xml:8218
msgid "<function>mpo_relabel_vnode</function>"
msgstr "<function>mpo_relabel_vnode</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8221
msgid ""
"<funcdef>void <function>mpo_relabel_vnode</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_relabel_vnode</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:8260
msgid "vnode to relabel"
msgstr "将被标记的 vnode"

#. (itstool) path: row/entry
#: book.translate.xml:8264 book.translate.xml:8405 book.translate.xml:9998
#: book.translate.xml:10071 book.translate.xml:11641
msgid "<parameter>vnodelabel</parameter>"
msgstr "<parameter>vnodelabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8265 book.translate.xml:11642
msgid "Existing policy label for <parameter>vp</parameter>"
msgstr "<parameter>vp</parameter>现有的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:8270 book.translate.xml:8731 book.translate.xml:8797
#: book.translate.xml:8861 book.translate.xml:9808 book.translate.xml:10213
#: book.translate.xml:10922 book.translate.xml:11464 book.translate.xml:11529
#: book.translate.xml:11579 book.translate.xml:11647
msgid "<parameter>newlabel</parameter>"
msgstr "<parameter>newlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8271
msgid ""
"New, possibly partial label to replace <parameter>vnodelabel</parameter>"
msgstr "将取代<parameter>vnodelabel</parameter>的新（可能只是部分）标记"

#. (itstool) path: sect4/para
#: book.translate.xml:8278
msgid ""
"Update the label on the passed vnode given the passed update vnode label and "
"the passed subject credential."
msgstr "根据传入的新标记和主体信任状，更新参数 vnode 的标记。"

#. (itstool) path: sect4/title
#: book.translate.xml:8284
msgid "<function>mpo_setlabel_vnode_extattr</function>"
msgstr "<function>mpo_setlabel_vnode_extattr</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8287
msgid ""
"<funcdef>int <function>mpo_setlabel_vnode_extattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>intlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_setlabel_vnode_extattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>intlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:8326
msgid "Vnode for which the label is being written"
msgstr "被写入标记所对应的 vnode"

#. (itstool) path: row/entry
#: book.translate.xml:8337
msgid "<parameter>intlabel</parameter>"
msgstr "<parameter>intlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8338
msgid "Label to write out"
msgstr "将被写入磁盘的标记"

#. (itstool) path: sect4/para
#: book.translate.xml:8344
msgid ""
"Write out the policy from <parameter>intlabel</parameter> to an extended "
"attribute. This is called from <function>vop_stdcreatevnode_ea</function>."
msgstr ""
"将参数 <parameter>intlabel</parameter> 给出的标记信息写入指定 vnode 的扩展属"
"性。该函数被 <function>vop_stdcreatevnode_ea</function> 所调用。"

#. (itstool) path: sect4/title
#: book.translate.xml:8351
msgid "<function>mpo_update_devfsdirent</function>"
msgstr "<function>mpo_update_devfsdirent</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8354
msgid ""
"<funcdef>void <function>mpo_update_devfsdirent</function></funcdef> "
"<paramdef>struct devfs_dirent *<parameter>devfs_dirent</parameter></"
"paramdef> <paramdef>struct label *<parameter>direntlabel</parameter></"
"paramdef> <paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_update_devfsdirent</function></funcdef> "
"<paramdef>struct devfs_dirent *<parameter>devfs_dirent</parameter></"
"paramdef> <paramdef>struct label *<parameter>direntlabel</parameter></"
"paramdef> <paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:8388
msgid "Object; devfs directory entry"
msgstr "客体；devfs 目录项"

#. (itstool) path: row/entry
#: book.translate.xml:8392
msgid "<parameter>direntlabel</parameter>"
msgstr "<parameter>direntlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8393
msgid "Policy label for <parameter>devfs_dirent</parameter> to be updated."
msgstr "将被更新的<parameter>devfs_dirent</parameter>的策略标记。"

#. (itstool) path: row/entry
#: book.translate.xml:8400
msgid "Parent vnode"
msgstr "父 vnode"

#. (itstool) path: row/entry
#: book.translate.xml:8401 book.translate.xml:9994 book.translate.xml:11637
#: book.translate.xml:12191
msgid "Locked"
msgstr "已锁定"

#. (itstool) path: row/entry
#: book.translate.xml:8406 book.translate.xml:9999 book.translate.xml:10072
#: book.translate.xml:11831 book.translate.xml:12118 book.translate.xml:12196
#: book.translate.xml:12263 book.translate.xml:12328 book.translate.xml:12401
#: book.translate.xml:13108 book.translate.xml:13233 book.translate.xml:13299
#: book.translate.xml:13365 book.translate.xml:13443 book.translate.xml:13529
#: book.translate.xml:13597 book.translate.xml:13666 book.translate.xml:13738
#: book.translate.xml:13926
msgid "Policy label for <parameter>vp</parameter>"
msgstr "><parameter>vp</parameter>的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:8413
msgid ""
"Update the <parameter>devfs_dirent</parameter> label from the passed devfs "
"vnode label. This call will be made when a devfs vnode has been successfully "
"relabeled to commit the label change such that it lasts even if the vnode is "
"recycled. It will also be made when a symlink is created in devfs, following "
"a call to <function>mac_vnode_create_from_vnode</function> to initialize the "
"vnode label."
msgstr ""
"根据所传入的 devfs vnode 标记，对 <parameter>devfs_dirent</parameter> 的标记"
"进行更新。重新标记一个 devfs vnode 的操作成功之后，将调用该函数来确认标记的改"
"变，如此，即使相应的 vnode 数据结构被内核回收重用，也不会丢失标记的新状态。另"
"外，在 devfs 中新建一个符号链接时，紧接着"
"<function>mac_vnode_create_from_vnode</function>，也将调用该函数，对 vnode 标"
"记进行初始化操作。"

#. (itstool) path: sect3/title
#: book.translate.xml:8425
msgid "IPC Object Labeling Event Operations"
msgstr "IPC 对象标记事件操作"

#. (itstool) path: sect4/title
#: book.translate.xml:8428
msgid "<function>mpo_create_mbuf_from_socket</function>"
msgstr "<function>mpo_create_mbuf_from_socket</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8431
msgid ""
"<funcdef>void <function>mpo_create_mbuf_from_socket</function></funcdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>m</parameter></paramdef> <paramdef>struct "
"label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_mbuf_from_socket</function></funcdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>m</parameter></paramdef> <paramdef>struct "
"label *<parameter>mbuflabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:8464 book.translate.xml:11091 book.translate.xml:11153
#: book.translate.xml:11397 book.translate.xml:11518 book.translate.xml:12974
msgid "<parameter>socket</parameter>"
msgstr "<parameter>socket</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8465 book.translate.xml:11223 book.translate.xml:11281
msgid "Socket"
msgstr "Socket"

#. (itstool) path: row/entry
#: book.translate.xml:8466
msgid "Socket locking WIP"
msgstr "套接字锁定 WIP（Work In Process）"

#. (itstool) path: row/entry
#: book.translate.xml:8470 book.translate.xml:8599 book.translate.xml:11096
#: book.translate.xml:11158 book.translate.xml:11227 book.translate.xml:11285
#: book.translate.xml:11402 book.translate.xml:11523 book.translate.xml:12979
#: book.translate.xml:14143
msgid "<parameter>socketlabel</parameter>"
msgstr "<parameter>socketlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8471 book.translate.xml:11097 book.translate.xml:11159
#: book.translate.xml:11403 book.translate.xml:12980
msgid "Policy label for <parameter>socket</parameter>"
msgstr "<parameter>socket</parameter> 的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:8476
msgid "<parameter>m</parameter>"
msgstr "<parameter>m</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8477
msgid "Object; mbuf"
msgstr "客体；mbuf"

#. (itstool) path: row/entry
#: book.translate.xml:8481 book.translate.xml:8851 book.translate.xml:9378
#: book.translate.xml:9446 book.translate.xml:9513 book.translate.xml:9864
#: book.translate.xml:14004 book.translate.xml:14080
msgid "<parameter>mbuflabel</parameter>"
msgstr "<parameter>mbuflabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8482
msgid "Policy label to fill in for <parameter>m</parameter>"
msgstr "将被填写的 <parameter>m</parameter> 的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:8489
msgid ""
"Set the label on a newly created mbuf header from the passed socket label. "
"This call is made when a new datagram or message is generated by the socket "
"and stored in the passed mbuf."
msgstr ""
"根据传入的套接字标记为新创建的mbuf头部设置标记。每当套接字产生一个新的数据报"
"或者消息，并将其存储在参数 mbuf 中时，将调用该函数。"

#. (itstool) path: sect4/title
#: book.translate.xml:8496
msgid "<function>mpo_create_pipe</function>"
msgstr "<function>mpo_create_pipe</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8499
msgid ""
"<funcdef>void <function>mpo_create_pipe</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_pipe</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:8535 book.translate.xml:8720 book.translate.xml:10728
#: book.translate.xml:10795 book.translate.xml:10852 book.translate.xml:10911
#: book.translate.xml:10974 book.translate.xml:11032
msgid "<parameter>pipe</parameter>"
msgstr "<parameter>pipe</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8536 book.translate.xml:8721 book.translate.xml:10729
#: book.translate.xml:10796 book.translate.xml:10853 book.translate.xml:10912
#: book.translate.xml:10975 book.translate.xml:11033
msgid "Pipe"
msgstr "管道"

#. (itstool) path: row/entry
#: book.translate.xml:8540 book.translate.xml:10733 book.translate.xml:10800
#: book.translate.xml:10857 book.translate.xml:10916 book.translate.xml:10979
#: book.translate.xml:11037
msgid "<parameter>pipelabel</parameter>"
msgstr "<parameter>pipelabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8541 book.translate.xml:10734 book.translate.xml:10801
#: book.translate.xml:10858 book.translate.xml:10980 book.translate.xml:11038
msgid "Policy label associated with <parameter>pipe</parameter>"
msgstr "<parameter>pipe</parameter> 的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:8548
msgid ""
"Set the label on a newly created pipe from the passed subject credential. "
"This call is made when a new pipe is created."
msgstr ""
"根据传入的主体信任状参数，设置新建管道的标记。每当一个新管道被创建，该函数将"
"被调用。"

#. (itstool) path: sect4/title
#: book.translate.xml:8554
msgid "<function>mpo_create_socket</function>"
msgstr "<function>mpo_create_socket</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8557
msgid ""
"<funcdef>void <function>mpo_create_socket</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_socket</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:8590 book.translate.xml:8782 book.translate.xml:8983
#: book.translate.xml:9984 book.translate.xml:10062 book.translate.xml:11631
#: book.translate.xml:11761 book.translate.xml:12185 book.translate.xml:14134
msgid "Immutable"
msgstr "不可改变"

#. (itstool) path: row/entry
#: book.translate.xml:8594 book.translate.xml:8786 book.translate.xml:11222
#: book.translate.xml:11280 book.translate.xml:14138
msgid "<parameter>so</parameter>"
msgstr "<parameter>so</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8595
msgid "Object; socket to label"
msgstr "客体；将被标记的套接字"

#. (itstool) path: row/entry
#: book.translate.xml:8600
msgid "Label to fill in for <parameter>so</parameter>"
msgstr "将被填写的 <parameter>so</parameter> 的标记"

#. (itstool) path: sect4/para
#: book.translate.xml:8607
msgid ""
"Set the label on a newly created socket from the passed subject credential. "
"This call is made when a socket is created."
msgstr ""
"根据传入的主体信任状参数，设置新建套接字的标记。每当新建一个套接字，该函数将"
"被调用。"

#. (itstool) path: sect4/title
#: book.translate.xml:8613
msgid "<function>mpo_create_socket_from_socket</function>"
msgstr "<function>mpo_create_socket_from_socket</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8616
msgid ""
"<funcdef>void <function>mpo_create_socket_from_socket</function></funcdef> "
"<paramdef>struct socket *<parameter>oldsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldsocketlabel</parameter></paramdef> "
"<paramdef>struct socket *<parameter>newsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>newsocketlabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_socket_from_socket</function></funcdef> "
"<paramdef>struct socket *<parameter>oldsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldsocketlabel</parameter></paramdef> "
"<paramdef>struct socket *<parameter>newsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>newsocketlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:8649 book.translate.xml:8911
msgid "<parameter>oldsocket</parameter>"
msgstr "<parameter>oldsocket</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8650
msgid "Listening socket"
msgstr "监听 Socket"

#. (itstool) path: row/entry
#: book.translate.xml:8654 book.translate.xml:8916
msgid "<parameter>oldsocketlabel</parameter>"
msgstr "<parameter>oldsocketlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8655
msgid "Policy label associated with <parameter>oldsocket</parameter>"
msgstr "<parameter>oldsocket</parameter> 的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:8660 book.translate.xml:8922
msgid "<parameter>newsocket</parameter>"
msgstr "<parameter>newsocket</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8661
msgid "New socket"
msgstr "新 Socket"

#. (itstool) path: row/entry
#: book.translate.xml:8665
msgid "<parameter>newsocketlabel</parameter>"
msgstr "<parameter>newsocketlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8666
msgid "Policy label associated with <parameter>newsocketlabel</parameter>"
msgstr "<parameter>newsocketlabel</parameter> 的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:8673
#, fuzzy
msgid ""
"Label a socket, <parameter>newsocket</parameter>, newly "
"<citerefentry><refentrytitle>accept</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>ed, based on the <citerefentry><refentrytitle>listen</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> socket, "
"<parameter>oldsocket</parameter>."
msgstr ""
"根据 <citerefentry><refentrytitle>listen</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>套接字 <parameter>oldsocket</parameter>，为新建 "
"<citerefentry><refentrytitle>accept</refentrytitle><manvolnum>2</manvolnum> "
"的套接字 <parameter>newsocket</parameter>，设置标记。"

#. (itstool) path: sect4/title
#: book.translate.xml:8679
msgid "<function>mpo_relabel_pipe</function>"
msgstr "<function>mpo_relabel_pipe</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8682
msgid ""
"<funcdef>void <function>mpo_relabel_pipe</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_relabel_pipe</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:8725 book.translate.xml:8791 book.translate.xml:8856
msgid "<parameter>oldlabel</parameter>"
msgstr "<parameter>oldlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8726 book.translate.xml:10917
msgid "Current policy label associated with <parameter>pipe</parameter>"
msgstr "<parameter>pipe</parameter> 的当前策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:8732
msgid "Policy label update to apply to <parameter>pipe</parameter>"
msgstr "将为<parameter>pipe</parameter> 设置的新的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:8739
msgid ""
"Apply a new label, <parameter>newlabel</parameter>, to <parameter>pipe</"
"parameter>."
msgstr ""
"为<parameter>pipe</parameter>设置新标记<parameter>newlabel</parameter>。"

#. (itstool) path: sect4/title
#: book.translate.xml:8744
msgid "<function>mpo_relabel_socket</function>"
msgstr "<function>mpo_relabel_socket</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8747
msgid ""
"<funcdef>void <function>mpo_relabel_socket</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_relabel_socket</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:8787 book.translate.xml:11398 book.translate.xml:11519
#: book.translate.xml:12975 book.translate.xml:14139
msgid "Object; socket"
msgstr "客体；套接字"

#. (itstool) path: row/entry
#: book.translate.xml:8792
msgid "Current label for <parameter>so</parameter>"
msgstr "<parameter>so</parameter> 的当前标记"

#. (itstool) path: row/entry
#: book.translate.xml:8798
msgid "Label update for <parameter>so</parameter>"
msgstr "<parameter>so</parameter> 的更新标记"

#. (itstool) path: sect4/para
#: book.translate.xml:8805
msgid "Update the label on a socket from the passed socket label update."
msgstr "根据传入的标记参数，对套接字的当前标记进行更新。"

#. (itstool) path: sect4/title
#: book.translate.xml:8810
msgid "<function>mpo_set_socket_peer_from_mbuf</function>"
msgstr "<function>mpo_set_socket_peer_from_mbuf</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8813
msgid ""
"<funcdef>void <function>mpo_set_socket_peer_from_mbuf</function></funcdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_set_socket_peer_from_mbuf</function></funcdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:8846 book.translate.xml:9373 book.translate.xml:9441
#: book.translate.xml:9508 book.translate.xml:9859 book.translate.xml:13999
#: book.translate.xml:14075
msgid "<parameter>mbuf</parameter>"
msgstr "<parameter>mbuf</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8847
msgid "First datagram received over socket"
msgstr "从套接字接收到的第一个数据报"

#. (itstool) path: row/entry
#: book.translate.xml:8852
msgid "Label for <parameter>mbuf</parameter>"
msgstr "<parameter>mbuf</parameter> 的标记"

#. (itstool) path: row/entry
#: book.translate.xml:8857
msgid "Current label for the socket"
msgstr "套接字的当前标记"

#. (itstool) path: row/entry
#: book.translate.xml:8862
msgid "Policy label to be filled out for the socket"
msgstr "将为套接字填写的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:8869
msgid ""
"Set the peer label on a stream socket from the passed mbuf label. This call "
"will be made when the first datagram is received by the stream socket, with "
"the exception of Unix domain sockets."
msgstr ""
"根据传入的 mbuf 标记，设置某个 stream 套接字的对等标志。除Unix域的套接字之"
"外，每当一个 stream 套接字接收到第一个数据报时，该函数将被调用。"

#. (itstool) path: sect4/title
#: book.translate.xml:8876
msgid "<function>mpo_set_socket_peer_from_socket</function>"
msgstr "<function>mpo_set_socket_peer_from_socket</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8879
msgid ""
"<funcdef>void <function>mpo_set_socket_peer_from_socket</function></funcdef> "
"<paramdef>struct socket *<parameter>oldsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldsocketlabel</parameter></paramdef> "
"<paramdef>struct socket *<parameter>newsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>newsocketpeerlabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_set_socket_peer_from_socket</function></funcdef> "
"<paramdef>struct socket *<parameter>oldsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldsocketlabel</parameter></paramdef> "
"<paramdef>struct socket *<parameter>newsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>newsocketpeerlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:8912
msgid "Local socket"
msgstr "本地套接字"

#. (itstool) path: row/entry
#: book.translate.xml:8917
msgid "Policy label for <parameter>oldsocket</parameter>"
msgstr "<parameter>oldsocket</parameter> 的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:8923
msgid "Peer socket"
msgstr "对等套接字"

#. (itstool) path: row/entry
#: book.translate.xml:8927
msgid "<parameter>newsocketpeerlabel</parameter>"
msgstr "<parameter>newsocketpeerlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8928
msgid "Policy label to fill in for <parameter>newsocket</parameter>"
msgstr "将为<parameter>newsocket</parameter>填写的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:8936
msgid ""
"Set the peer label on a stream UNIX domain socket from the passed remote "
"socket endpoint. This call will be made when the socket pair is connected, "
"and will be made for both endpoints."
msgstr ""
"根据传入的远程套接字端点，为一个 stream UNIX 与套接字设置对等标记。每当相应的"
"套接字对之间进行连接时，该函数将在两端分别被调用。"

#. (itstool) path: sect3/title
#: book.translate.xml:8944
msgid "Network Object Labeling Event Operations"
msgstr ""

#. (itstool) path: sect4/title
#: book.translate.xml:8947
msgid "<function>mpo_create_bpfdesc</function>"
msgstr "<function>mpo_create_bpfdesc</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8950
msgid ""
"<funcdef>void <function>mpo_create_bpfdesc</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct bpf_d *<parameter>bpf_d</parameter></paramdef> "
"<paramdef>struct label *<parameter>bpflabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_bpfdesc</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct bpf_d *<parameter>bpf_d</parameter></paramdef> "
"<paramdef>struct label *<parameter>bpflabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:8987 book.translate.xml:9430 book.translate.xml:10323
msgid "<parameter>bpf_d</parameter>"
msgstr "<parameter>bpf_d</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8988
msgid "Object; bpf descriptor"
msgstr "客体；bpf 描述子"

#. (itstool) path: row/entry
#: book.translate.xml:8992
msgid "<parameter>bpf</parameter>"
msgstr "<parameter>bpf</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:8993
msgid "Policy label to be filled in for <parameter>bpf_d</parameter>"
msgstr "将为<parameter>bpf_d</parameter>填写的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:9000
msgid ""
"Set the label on a newly created BPF descriptor from the passed subject "
"credential. This call will be made when a BPF device node is opened by a "
"process with the passed subject credential."
msgstr ""
"根据传入的主体信任状参数，为新建的 BPF 描述子设置标记。当进程打开 BPF 设备节"
"点时，该函数将被调用。"

#. (itstool) path: sect4/title
#: book.translate.xml:9007
msgid "<function>mpo_create_ifnet</function>"
msgstr "<function>mpo_create_ifnet</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9010
msgid ""
"<funcdef>void <function>mpo_create_ifnet</function></funcdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_ifnet</function></funcdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:9039 book.translate.xml:9362 book.translate.xml:9497
#: book.translate.xml:9577 book.translate.xml:9797 book.translate.xml:10334
#: book.translate.xml:11453 book.translate.xml:13988 book.translate.xml:14064
msgid "<parameter>ifnet</parameter>"
msgstr "<parameter>ifnet</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:9040 book.translate.xml:9363 book.translate.xml:9498
#: book.translate.xml:9578 book.translate.xml:13989 book.translate.xml:14065
msgid "Network interface"
msgstr "网络接口"

#. (itstool) path: row/entry
#: book.translate.xml:9044 book.translate.xml:9367 book.translate.xml:9502
#: book.translate.xml:9582 book.translate.xml:9802 book.translate.xml:10339
#: book.translate.xml:11458 book.translate.xml:13993 book.translate.xml:14069
msgid "<parameter>ifnetlabel</parameter>"
msgstr "<parameter>ifnetlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:9045
msgid "Policy label to fill in for <parameter>ifnet</parameter>"
msgstr "将为<parameter>ifnet</parameter>填写的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:9052
msgid ""
"Set the label on a newly created interface. This call may be made when a new "
"physical interface becomes available to the system, or when a pseudo-"
"interface is instantiated during the boot or as a result of a user action."
msgstr ""
"为新建的网络接口设置标记。该函数在以下情况下被调用：当一个新的物理接口变为可"
"用时，或者当一个伪接口在引导时或由于某个用户操作而实例化时。"

#. (itstool) path: sect4/title
#: book.translate.xml:9060
msgid "<function>mpo_create_ipq</function>"
msgstr "<function>mpo_create_ipq</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9063
msgid ""
"<funcdef>void <function>mpo_create_ipq</function></funcdef> <paramdef>struct "
"mbuf *<parameter>fragment</parameter></paramdef> <paramdef>struct label "
"*<parameter>fragmentlabel</parameter></paramdef> <paramdef>struct ipq "
"*<parameter>ipq</parameter></paramdef> <paramdef>struct label "
"*<parameter>ipqlabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_ipq</function></funcdef> <paramdef>struct "
"mbuf *<parameter>fragment</parameter></paramdef> <paramdef>struct label "
"*<parameter>fragmentlabel</parameter></paramdef> <paramdef>struct ipq "
"*<parameter>ipq</parameter></paramdef> <paramdef>struct label "
"*<parameter>ipqlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:9096 book.translate.xml:9239 book.translate.xml:9715
msgid "<parameter>fragment</parameter>"
msgstr "<parameter>fragment</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:9097
msgid "First received IP fragment"
msgstr "第一个被接收的 IP 分片"

#. (itstool) path: row/entry
#: book.translate.xml:9101 book.translate.xml:9244 book.translate.xml:9720
msgid "<parameter>fragmentlabel</parameter>"
msgstr "<parameter>fragmentlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:9102 book.translate.xml:9721
msgid "Policy label for <parameter>fragment</parameter>"
msgstr "<parameter>fragment</parameter> 的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:9107 book.translate.xml:9162 book.translate.xml:9726
#: book.translate.xml:9870
msgid "<parameter>ipq</parameter>"
msgstr "<parameter>ipq</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:9108
msgid "IP reassembly queue to be labeled"
msgstr "将被标记的 IP 重组队列"

#. (itstool) path: row/entry
#: book.translate.xml:9112 book.translate.xml:9167 book.translate.xml:9731
#: book.translate.xml:9875
msgid "<parameter>ipqlabel</parameter>"
msgstr "<parameter>ipqlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:9113
msgid "Policy label to be filled in for <parameter>ipq</parameter>"
msgstr "将为<parameter>ipq</parameter>填写的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:9120
msgid ""
"Set the label on a newly created IP fragment reassembly queue from the mbuf "
"header of the first received fragment."
msgstr ""
"根据第一个接收到的分片的 mbuf 头部信息，为新建的 IP 分片重组队列设置标记。"

#. (itstool) path: sect4/title
#: book.translate.xml:9126
msgid "<function>mpo_create_datagram_from_ipq</function>"
msgstr "<function>mpo_create_datagram_from_ipq</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9129
msgid ""
"<funcdef>void <function>mpo_create_create_datagram_from_ipq</function></"
"funcdef> <paramdef>struct ipq *<parameter>ipq</parameter></paramdef> "
"<paramdef>struct label *<parameter>ipqlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>datagram</parameter></paramdef> "
"<paramdef>struct label *<parameter>datagramlabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_create_datagram_from_ipq</function></"
"funcdef> <paramdef>struct ipq *<parameter>ipq</parameter></paramdef> "
"<paramdef>struct label *<parameter>ipqlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>datagram</parameter></paramdef> "
"<paramdef>struct label *<parameter>datagramlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:9163
msgid "IP reassembly queue"
msgstr "IP 重组队列"

#. (itstool) path: row/entry
#: book.translate.xml:9168 book.translate.xml:9732
msgid "Policy label for <parameter>ipq</parameter>"
msgstr "<parameter>ipq</parameter> 的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:9173 book.translate.xml:9228
msgid "<parameter>datagram</parameter>"
msgstr "<parameter>datagram</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:9174
msgid "Datagram to be labeled"
msgstr "将被标记的数据报"

#. (itstool) path: row/entry
#: book.translate.xml:9178 book.translate.xml:9233
msgid "<parameter>datagramlabel</parameter>"
msgstr "<parameter>datagramlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:9179
msgid "Policy label to be filled in for <parameter>datagramlabel</parameter>"
msgstr "将为<parameter>datagramlabel</parameter>填写的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:9186
msgid ""
"Set the label on a newly reassembled IP datagram from the IP fragment "
"reassembly queue from which it was generated."
msgstr "根据 IP 分片重组队列，为刚刚重组完毕的 IP 数据报设置标记。"

#. (itstool) path: sect4/title
#: book.translate.xml:9192
msgid "<function>mpo_create_fragment</function>"
msgstr "<function>mpo_create_fragment</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9195
msgid ""
"<funcdef>void <function>mpo_create_fragment</function></funcdef> "
"<paramdef>struct mbuf *<parameter>datagram</parameter></paramdef> "
"<paramdef>struct label *<parameter>datagramlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>fragment</parameter></paramdef> "
"<paramdef>struct label *<parameter>fragmentlabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_fragment</function></funcdef> "
"<paramdef>struct mbuf *<parameter>datagram</parameter></paramdef> "
"<paramdef>struct label *<parameter>datagramlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>fragment</parameter></paramdef> "
"<paramdef>struct label *<parameter>fragmentlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:9229
msgid "Datagram"
msgstr "数据报"

#. (itstool) path: row/entry
#: book.translate.xml:9234
msgid "Policy label for <parameter>datagram</parameter>"
msgstr "<parameter>datagram</parameter> 的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:9240
msgid "Fragment to be labeled"
msgstr "将被标记的分片"

#. (itstool) path: row/entry
#: book.translate.xml:9245
msgid "Policy label to be filled in for <parameter>datagram</parameter>"
msgstr "将为<parameter>datagram</parameter>填写的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:9252
msgid ""
"Set the label on the mbuf header of a newly created IP fragment from the "
"label on the mbuf header of the datagram it was generate from."
msgstr "根据数据报所对应的 mbuf 头部信息，为其新建的分片的 mbuf 头部设置标记。"

#. (itstool) path: sect4/title
#: book.translate.xml:9258
msgid "<function>mpo_create_mbuf_from_mbuf</function>"
msgstr "<function>mpo_create_mbuf_from_mbuf</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9261
msgid ""
"<funcdef>void <function>mpo_create_mbuf_from_mbuf</function></funcdef> "
"<paramdef>struct mbuf *<parameter>oldmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldmbuflabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>newmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>newmbuflabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_mbuf_from_mbuf</function></funcdef> "
"<paramdef>struct mbuf *<parameter>oldmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldmbuflabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>newmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>newmbuflabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:9294 book.translate.xml:9566 book.translate.xml:9646
msgid "<parameter>oldmbuf</parameter>"
msgstr "<parameter>oldmbuf</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:9295
msgid "Existing (source) mbuf"
msgstr "已有的（源）mbuf"

#. (itstool) path: row/entry
#: book.translate.xml:9299 book.translate.xml:9571 book.translate.xml:9651
msgid "<parameter>oldmbuflabel</parameter>"
msgstr "<parameter>oldmbuflabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:9300 book.translate.xml:9572 book.translate.xml:9652
msgid "Policy label for <parameter>oldmbuf</parameter>"
msgstr "<parameter>oldmbuf</parameter> 的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:9305 book.translate.xml:9588 book.translate.xml:9657
msgid "<parameter>newmbuf</parameter>"
msgstr "<parameter>newmbuf</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:9306 book.translate.xml:9442
msgid "New mbuf to be labeled"
msgstr "New mbuf to be labeled"

#. (itstool) path: row/entry
#: book.translate.xml:9310 book.translate.xml:9594 book.translate.xml:9662
msgid "<parameter>newmbuflabel</parameter>"
msgstr "<parameter>newmbuflabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:9311 book.translate.xml:9595
msgid "Policy label to be filled in for <parameter>newmbuf</parameter>"
msgstr "将为<parameter>newmbuf</parameter>填写的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:9318
msgid ""
"Set the label on the mbuf header of a newly created datagram from the mbuf "
"header of an existing datagram. This call may be made in a number of "
"situations, including when an mbuf is re-allocated for alignment purposes."
msgstr ""
"根据某个现有数据报的 mbuf 头部信息，为新建数据报的 mbuf 头部设置标记。在许多"
"条件下将会调用该函数，比如，由于对齐要求而重新分配某个 mbuf 时。"

#. (itstool) path: sect4/title
#: book.translate.xml:9326
msgid "<function>mpo_create_mbuf_linklayer</function>"
msgstr "<function>mpo_create_mbuf_linklayer</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9329
msgid ""
"<funcdef>void <function>mpo_create_mbuf_linklayer</function></funcdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_mbuf_linklayer</function></funcdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:9368 book.translate.xml:9583 book.translate.xml:9803
#: book.translate.xml:10340 book.translate.xml:13994 book.translate.xml:14070
msgid "Policy label for <parameter>ifnet</parameter>"
msgstr "<parameter>ifnet</parameter> 的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:9374 book.translate.xml:9509
msgid "mbuf header for new datagram"
msgstr "新建数据报的 mbuf 头部"

#. (itstool) path: row/entry
#: book.translate.xml:9379 book.translate.xml:9514
msgid "Policy label to be filled in for <parameter>mbuf</parameter>"
msgstr "将为<parameter>mbuf</parameter>填写的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:9386
msgid ""
"Set the label on the mbuf header of a newly created datagram generated for "
"the purposes of a link layer response for the passed interface. This call "
"may be made in a number of situations, including for ARP or ND6 responses in "
"the IPv4 and IPv6 stacks."
msgstr ""
"为在给定接口上由于某个链路层响应而新建的数据报的mbuf头部设置标记。该函数将在"
"若干条件下被调用，比如当IPv4和IPv6协议栈在响应ARP或者ND6时。"

#. (itstool) path: sect4/title
#: book.translate.xml:9394
msgid "<function>mpo_create_mbuf_from_bpfdesc</function>"
msgstr "<function>mpo_create_mbuf_from_bpfdesc</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9397
msgid ""
"<funcdef>void <function>mpo_create_mbuf_from_bpfdesc</function></funcdef> "
"<paramdef>struct bpf_d *<parameter>bpf_d</parameter></paramdef> "
"<paramdef>struct label *<parameter>bpflabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_mbuf_from_bpfdesc</function></funcdef> "
"<paramdef>struct bpf_d *<parameter>bpf_d</parameter></paramdef> "
"<paramdef>struct label *<parameter>bpflabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:9431
msgid "BPF descriptor"
msgstr "BPF 描述子"

#. (itstool) path: row/entry
#: book.translate.xml:9435 book.translate.xml:10328
msgid "<parameter>bpflabel</parameter>"
msgstr "<parameter>bpflabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:9436
msgid "Policy label for <parameter>bpflabel</parameter>"
msgstr "<parameter>bpflabel</parameter> 的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:9447
msgid "Policy label to fill in for <parameter>mbuf</parameter>"
msgstr "将为 <parameter>mbuf</parameter> 填写的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:9454
msgid ""
"Set the label on the mbuf header of a newly created datagram generated using "
"the passed BPF descriptor. This call is made when a write is performed to "
"the BPF device associated with the passed BPF descriptor."
msgstr ""
"为使用参数 BPF 描述子创建的新数据报的 mbuf 头部设置标记。当对参数 BPF 描述子"
"所关联的 BPF 设备进行写操作时，该函数将被调用。"

#. (itstool) path: sect4/title
#: book.translate.xml:9461
msgid "<function>mpo_create_mbuf_from_ifnet</function>"
msgstr "<function>mpo_create_mbuf_from_ifnet</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9464
msgid ""
"<funcdef>void <function>mpo_create_mbuf_from_ifnet</function></funcdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_mbuf_from_ifnet</function></funcdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:9503
msgid "Policy label for <parameter>ifnetlabel</parameter>"
msgstr "<parameter>ifnetlabel</parameter> 的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:9521
msgid ""
"Set the label on the mbuf header of a newly created datagram generated from "
"the passed network interface."
msgstr "为从网络接口参数创建的数据报的 mbuf 头部设置标记。"

#. (itstool) path: sect4/title
#: book.translate.xml:9527
msgid "<function>mpo_create_mbuf_multicast_encap</function>"
msgstr "<function>mpo_create_mbuf_multicast_encap</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9530
msgid ""
"<funcdef>void <function>mpo_create_mbuf_multicast_encap</function></funcdef> "
"<paramdef>struct mbuf *<parameter>oldmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldmbuflabel</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>newmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>newmbuflabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_mbuf_multicast_encap</function></funcdef> "
"<paramdef>struct mbuf *<parameter>oldmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldmbuflabel</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>newmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>newmbuflabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:9567
msgid "mbuf header for existing datagram"
msgstr "现有数据报的 mbuf 头部"

#. (itstool) path: row/entry
#: book.translate.xml:9589
msgid "mbuf header to be labeled for new datagram"
msgstr "将被标记的新建数据报 mbuf 头部"

#. (itstool) path: sect4/para
#: book.translate.xml:9602
msgid ""
"Set the label on the mbuf header of a newly created datagram generated from "
"the existing passed datagram when it is processed by the passed multicast "
"encapsulation interface. This call is made when an mbuf is to be delivered "
"using the virtual interface."
msgstr ""
"当传入的已有数据报被给定多播封装接口（multicast encapsulation interface）处理"
"时被调用，为新创建的数据报所在 mbuf 头部设置标记。每当使用该虚拟接口传递一个"
"mbuf时，将调用该函数。"

#. (itstool) path: sect4/title
#: book.translate.xml:9610
msgid "<function>mpo_create_mbuf_netlayer</function>"
msgstr "<function>mpo_create_mbuf_netlayer</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9613
msgid ""
"<funcdef>void <function>mpo_create_mbuf_netlayer</function></funcdef> "
"<paramdef>struct mbuf *<parameter>oldmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldmbuflabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>newmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>newmbuflabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_mbuf_netlayer</function></funcdef> "
"<paramdef>struct mbuf *<parameter>oldmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldmbuflabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>newmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>newmbuflabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:9647
msgid "Received datagram"
msgstr "已接收的数据报"

#. (itstool) path: row/entry
#: book.translate.xml:9658
msgid "Newly created datagram"
msgstr "新创建的数据报"

#. (itstool) path: row/entry
#: book.translate.xml:9663
msgid "Policy label for <parameter>newmbuf</parameter>"
msgstr "<parameter>newmbuf</parameter> 的策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:9670
msgid ""
"Set the label on the mbuf header of a newly created datagram generated by "
"the IP stack in response to an existing received datagram "
"(<parameter>oldmbuf</parameter>). This call may be made in a number of "
"situations, including when responding to ICMP request datagrams."
msgstr ""
"为由 IP 堆栈因为响应接收数据报（<parameter>oldmbuf</parameter>）而新建的数据"
"报设置其 mbuf 头部的标记。许多情况下需要调用该函数，比如，响应 ICMP 请求数据"
"报时。"

#. (itstool) path: sect4/title
#: book.translate.xml:9679
msgid "<function>mpo_fragment_match</function>"
msgstr "<function>mpo_fragment_match</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9682
msgid ""
"<funcdef>int <function>mpo_fragment_match</function></funcdef> "
"<paramdef>struct mbuf *<parameter>fragment</parameter></paramdef> "
"<paramdef>struct label *<parameter>fragmentlabel</parameter></paramdef> "
"<paramdef>struct ipq *<parameter>ipq</parameter></paramdef> <paramdef>struct "
"label *<parameter>ipqlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_fragment_match</function></funcdef> "
"<paramdef>struct mbuf *<parameter>fragment</parameter></paramdef> "
"<paramdef>struct label *<parameter>fragmentlabel</parameter></paramdef> "
"<paramdef>struct ipq *<parameter>ipq</parameter></paramdef> <paramdef>struct "
"label *<parameter>ipqlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:9716
msgid "IP datagram fragment"
msgstr "IP 数据报分片"

#. (itstool) path: row/entry
#: book.translate.xml:9727 book.translate.xml:9871
msgid "IP fragment reassembly queue"
msgstr "IP 分片重组队列"

#. (itstool) path: sect4/para
#: book.translate.xml:9739
msgid ""
"Determine whether an mbuf header containing an IP datagram "
"(<parameter>fragment</parameter>) fragment matches the label of the passed "
"IP fragment reassembly queue (<parameter>ipq</parameter>). Return "
"(<returnvalue>1</returnvalue>) for a successful match, or (<returnvalue>0</"
"returnvalue>) for no match. This call is made when the IP stack attempts to "
"find an existing fragment reassembly queue for a newly received fragment; if "
"this fails, a new fragment reassembly queue may be instantiated for the "
"fragment. Policies may use this entry point to prevent the reassembly of "
"otherwise matching IP fragments if policy does not permit them to be "
"reassembled based on the label or other information."
msgstr ""
"根据所传入的 IP 分片重组队列（<parameter>ipq</parameter>）的标记，检查包含一"
"个 IP 数据报（<parameter>fragment</parameter>）的 mbuf 的头部是否符合其要求。"
"符合，则返回<returnvalue>1</returnvalue>。否则，返回<returnvalue>0</"
"returnvalue>。每当 IP 堆栈尝试将一个刚刚接收到的分片放入某个已有的分片重组队"
"列中时，将调用该函数进行安全检查；如果失败，将为分片重新实例化一个新的分片重"
"组队列。策略可以利用该入口函数，根据标记或者其他信息阻止不期望的 IP 分片重"
"组。"

#. (itstool) path: sect4/title
#: book.translate.xml:9756
msgid "<function>mpo_relabel_ifnet</function>"
msgstr "<function>mpo_relabel_ifnet</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9759
msgid ""
"<funcdef>void <function>mpo_relabel_ifnet</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_relabel_ifnet</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:9798
msgid "Object; Network interface"
msgstr "客体；网络接口"

#. (itstool) path: row/entry
#: book.translate.xml:9809
msgid "Label update to apply to <parameter>ifnet</parameter>"
msgstr "将为<parameter>ifnet</parameter>设置的新标记"

#. (itstool) path: sect4/para
#: book.translate.xml:9816
msgid ""
"Update the label of network interface, <parameter>ifnet</parameter>, based "
"on the passed update label, <parameter>newlabel</parameter>, and the passed "
"subject credential, <parameter>cred</parameter>."
msgstr ""
"根据所传入的新标记，<parameter>newlabel</parameter>，以及主体信任状，"
"<parameter>cred</parameter>，对网络接口的标记进行更新。"

#. (itstool) path: sect4/title
#: book.translate.xml:9823
msgid "<function>mpo_update_ipq</function>"
msgstr "<function>mpo_update_ipq</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9826
msgid ""
"<funcdef>void <function>mpo_update_ipq</function></funcdef> <paramdef>struct "
"mbuf *<parameter>fragment</parameter></paramdef> <paramdef>struct label "
"*<parameter>fragmentlabel</parameter></paramdef> <paramdef>struct ipq "
"*<parameter>ipq</parameter></paramdef> <paramdef>struct label "
"*<parameter>ipqlabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_update_ipq</function></funcdef> <paramdef>struct "
"mbuf *<parameter>fragment</parameter></paramdef> <paramdef>struct label "
"*<parameter>fragmentlabel</parameter></paramdef> <paramdef>struct ipq "
"*<parameter>ipq</parameter></paramdef> <paramdef>struct label "
"*<parameter>ipqlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:9860
msgid "IP fragment"
msgstr "IP 分片"

#. (itstool) path: row/entry
#: book.translate.xml:9865 book.translate.xml:14005 book.translate.xml:14081
msgid "Policy label for <parameter>mbuf</parameter>"
msgstr "<parameter>mbuf</parameter> 的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:9876
msgid "Policy label to be updated for <parameter>ipq</parameter>"
msgstr "将被更新的<parameter>ipq</parameter>的当前策略标记"

#. (itstool) path: sect4/para
#: book.translate.xml:9883
msgid ""
"Update the label on an IP fragment reassembly queue (<parameter>ipq</"
"parameter>) based on the acceptance of the passed IP fragment mbuf header "
"(<parameter>mbuf</parameter>)."
msgstr ""
"根据所传入的 IP 分片 mbuf 头部（<parameter>mbuf</parameter>）为接收它的 IP 分"
"片重组队列（<parameter>ipq</parameter>）的标记进行更新。"

#. (itstool) path: sect3/title
#: book.translate.xml:9891
msgid "Process Labeling Event Operations"
msgstr "进程标记事件操作"

#. (itstool) path: sect4/title
#: book.translate.xml:9894
msgid "<function>mpo_create_cred</function>"
msgstr "<function>mpo_create_cred</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9897
msgid ""
"<funcdef>void <function>mpo_create_cred</function></funcdef> "
"<paramdef>struct ucred *<parameter>parent_cred</parameter></paramdef> "
"<paramdef>struct ucred *<parameter>child_cred</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_cred</function></funcdef> "
"<paramdef>struct ucred *<parameter>parent_cred</parameter></paramdef> "
"<paramdef>struct ucred *<parameter>child_cred</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:9926
msgid "<parameter>parent_cred</parameter>"
msgstr "<parameter>parent_cred</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:9927
msgid "Parent subject credential"
msgstr "父主体信任状"

#. (itstool) path: row/entry
#: book.translate.xml:9931
msgid "<parameter>child_cred</parameter>"
msgstr "<parameter>child_cred</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:9932
msgid "Child subject credential"
msgstr "子主体信任状"

#. (itstool) path: sect4/para
#: book.translate.xml:9938
msgid ""
"Set the label of a newly created subject credential from the passed subject "
"credential. This call will be made when <citerefentry><refentrytitle>crcopy</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> is invoked on a newly "
"created <type>struct ucred</type>. This call should not be confused with a "
"process forking or creation event."
msgstr ""
"根据所传入的主体信任状，为新建的主体信任状设置标记。每当为一个新建的 "
"<type>struct ucred</type>调用 <citerefentry><refentrytitle>crcopy</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> 时，将调用此函数。该函"
"数不应与进程复制（forking）或者创建事件混为一谈。"

#. (itstool) path: sect4/title
#: book.translate.xml:9946
msgid "<function>mpo_execve_transition</function>"
msgstr "<function>mpo_execve_transition</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9949
msgid ""
"<funcdef>void <function>mpo_execve_transition</function></funcdef> "
"<paramdef>struct ucred *<parameter>old</parameter></paramdef> "
"<paramdef>struct ucred *<parameter>new</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_execve_transition</function></funcdef> "
"<paramdef>struct ucred *<parameter>old</parameter></paramdef> "
"<paramdef>struct ucred *<parameter>new</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:9982 book.translate.xml:10059 book.translate.xml:14463
msgid "<parameter>old</parameter>"
msgstr "<parameter>old</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:9983
msgid "Existing subject credential"
msgstr "已有的主体信任状"

#. (itstool) path: row/entry
#: book.translate.xml:9988 book.translate.xml:14477
msgid "<parameter>new</parameter>"
msgstr "<parameter>new</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:9989
msgid "New subject credential to be labeled"
msgstr "将被标记的新主体信任状"

#. (itstool) path: row/entry
#: book.translate.xml:9994 book.translate.xml:10067
msgid "File to execute"
msgstr "将被执行的文件"

#. (itstool) path: sect4/para
#: book.translate.xml:10006
msgid ""
"Update the label of a newly created subject credential (<parameter>new</"
"parameter>) from the passed existing subject credential (<parameter>old</"
"parameter>) based on a label transition caused by executing the passed vnode "
"(<parameter>vp</parameter>). This call occurs when a process executes the "
"passed vnode and one of the policies returns a success from the "
"<function>mpo_execve_will_transition</function> entry point. Policies may "
"choose to implement this call simply by invoking <function>mpo_create_cred</"
"function> and passing the two subject credentials so as not to implement a "
"transitioning event. Policies should not leave this entry point "
"unimplemented if they implement <function>mpo_create_cred</function>, even "
"if they do not implement <function>mpo_execve_will_transition</function>."
msgstr ""
"一个拥有信任状<parameter>old</parameter>的主体由于执行(<parameter>vp</"
"parameter>文件而导致标记转换时，该函数根据vnode标记为该主体重新标记为"
"<parameter>new</parameter>。 每当一个进程请求执行vnode文件，而通过入口函数"
"<function>mpo_execve_will_transition</function> 有成功返回的策略时，将调用该"
"函数。策略模块可以通过传入两个主体信任状和简单地调用 "
"<function>mpo_create_cred</function> 来实现该入口函数，so as not to "
"implement a transitioning event，一旦策略实现了<function>mpo_create_cred</"
"function>函数，即使没有实现<function>mpo_execve_will_transition</function>，"
"也应该实现该函数。"

#. (itstool) path: sect4/title
#: book.translate.xml:10025
msgid "<function>mpo_execve_will_transition</function>"
msgstr "<function>mpo_execve_will_transition</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10028
msgid ""
"<funcdef>int <function>mpo_execve_will_transition</function></funcdef> "
"<paramdef>struct ucred *<parameter>old</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_execve_will_transition</function></funcdef> "
"<paramdef>struct ucred *<parameter>old</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:10060
msgid ""
"Subject credential prior to <citerefentry><refentrytitle>execve</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
"在执行<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>之前的主体信任状"

#. (itstool) path: sect4/para
#: book.translate.xml:10079
msgid ""
"Determine whether the policy will want to perform a transition event as a "
"result of the execution of the passed vnode by the passed subject "
"credential. Return <returnvalue>1</returnvalue> if a transition is required, "
"<returnvalue>0</returnvalue> if not. Even if a policy returns "
"<returnvalue>0</returnvalue>, it should behave correctly in the presence of "
"an unexpected invocation of <function>mpo_execve_transition</function>, as "
"that call may happen as a result of another policy requesting a transition."
msgstr ""
"由策略决定，当参数主体信任状执行参数 vnode 时，是否需要进行一个标记转换操作。"
"如果需要，返回<returnvalue>1</returnvalue>；\n"
"            否则，返回<returnvalue>0</returnvalue>。即使一个策略返回"
"<returnvalue>0</returnvalue>，它也必须为自己不期望的对"
"<function>mpo_execve_transition</function>的调用作好准备，因为只要有其他任何"
"一个策略要求转换，就将执行此函数。"

#. (itstool) path: sect4/title
#: book.translate.xml:10092
msgid "<function>mpo_create_proc0</function>"
msgstr "<function>mpo_create_proc0</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10095
msgid ""
"<funcdef>void <function>mpo_create_proc0</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_proc0</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:10123 book.translate.xml:10165
msgid "Subject credential to be filled in"
msgstr "将被填写的主体信任状"

#. (itstool) path: sect4/para
#: book.translate.xml:10129
msgid ""
"Create the subject credential of process 0, the parent of all kernel "
"processes."
msgstr "为进程0，所有内核进程的祖先，创建主体信任状。"

#. (itstool) path: sect4/title
#: book.translate.xml:10134
msgid "<function>mpo_create_proc1</function>"
msgstr "<function>mpo_create_proc1</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10137
msgid ""
"<funcdef>void <function>mpo_create_proc1</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_create_proc1</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"

#. (itstool) path: sect4/para
#: book.translate.xml:10171
msgid ""
"Create the subject credential of process 1, the parent of all user processes."
msgstr "为进程1，所有用户进程的祖先，创建主体信任状。"

#. (itstool) path: sect4/title
#: book.translate.xml:10176
msgid "<function>mpo_relabel_cred</function>"
msgstr "<function>mpo_relabel_cred</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10179
msgid ""
"<funcdef>void <function>mpo_relabel_cred</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_relabel_cred</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:10214
msgid "Label update to apply to <parameter>cred</parameter>"
msgstr "将被应用到 <parameter>cred</parameter> 上的新标记"

#. (itstool) path: sect4/para
#: book.translate.xml:10221
msgid "Update the label on a subject credential from the passed update label."
msgstr "根据传入的新标记，对主体信任状上的标记进行更新。"

#. (itstool) path: sect2/title
#: book.translate.xml:10229
msgid "Access Control Checks"
msgstr "访问控制检查"

#. (itstool) path: sect2/para
#: book.translate.xml:10231
msgid ""
"Access control entry points permit policy modules to influence access "
"control decisions made by the kernel. Generally, although not always, "
"arguments to an access control entry point will include one or more "
"authorizing credentials, information (possibly including a label) for any "
"other objects involved in the operation. An access control entry point may "
"return 0 to permit the operation, or an <citerefentry><refentrytitle>errno</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> error value. The "
"results of invoking the entry point across various registered policy modules "
"will be composed as follows: if all modules permit the operation to succeed, "
"success will be returned. If one or modules returns a failure, a failure "
"will be returned. If more than one module returns a failure, the errno value "
"to return to the user will be selected using the following precedence, "
"implemented by the <function>error_select()</function> function in "
"<filename>kern_mac.c</filename>:"
msgstr ""
"通过访问控制入口函数，策略模块能影响内核的访问控制决策。通常情况下，不是绝"
"对，一个访问控制入口函数的参数有，一个或者若干个授权信任状，和相关操作涉及的"
"其他任何对象的信息（其中可能包含标记）。访问控制入口函数返回0，表示允许该操"
"作；否则，返回一个 <citerefentry><refentrytitle>errno</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> 错误编码。调用该入口函"
"数，将遍历所有系统注册的策略模块，逐一进行策略相关的检查和决策，之后按照下述"
"方法组合不同策略的返回结果：只有当所有的模块均允许该操作时，才成功返回。否"
"则，如果有一个或者若干模块失败返回，则整个检查不通过。如果有多个模块的检查出"
"错返回，将由定义在<filename>kern_mac.c</filename> 中的"
"<function>error_select()</function> 函数从它们返回的错误编码中，选择一个合适"
"的，返回给用户："

#. (itstool) path: row/entry
#: book.translate.xml:10252
msgid "Most precedence"
msgstr "最高优先级"

#. (itstool) path: row/entry
#: book.translate.xml:10253
msgid "<errorcode>EDEADLK</errorcode>"
msgstr "<errorcode>EDEADLK</errorcode>"

#. (itstool) path: row/entry
#: book.translate.xml:10258
msgid "<errorcode>EINVAL</errorcode>"
msgstr "<errorcode>EINVAL</errorcode>"

#. (itstool) path: row/entry
#: book.translate.xml:10263
msgid "<errorcode>ESRCH</errorcode>"
msgstr "<errorcode>ESRCH</errorcode>"

#. (itstool) path: row/entry
#: book.translate.xml:10268
msgid "EACCES"
msgstr "EACCES"

#. (itstool) path: row/entry
#: book.translate.xml:10272
msgid "Least precedence"
msgstr "最低优先级"

#. (itstool) path: row/entry
#: book.translate.xml:10273
msgid "EPERM"
msgstr "EPERM"

#. (itstool) path: sect2/para
#: book.translate.xml:10279
msgid ""
"If none of the error values returned by all modules are listed in the "
"precedence chart then an arbitrarily selected value from the set will be "
"returned. In general, the rules provide precedence to errors in the "
"following order: kernel failures, invalid arguments, object not present, "
"access not permitted, other."
msgstr ""
"如果所有策略模块返回的错误编码均没有出现在上述优先级序列表中，则任意选择一个"
"返回。选择错误编码的一般次序为：内核错误，无效的参数，对象不存在，访问被拒"
"绝，和其他错误。"

#. (itstool) path: sect3/title
#: book.translate.xml:10287
msgid "<function>mpo_check_bpfdesc_receive</function>"
msgstr "<function>mpo_check_bpfdesc_receive</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10290
msgid ""
"<funcdef>int <function>mpo_check_bpfdesc_receive</function></funcdef> "
"<paramdef>struct bpf_d *<parameter>bpf_d</parameter></paramdef> "
"<paramdef>struct label *<parameter>bpflabel</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_bpfdesc_receive</function></funcdef> "
"<paramdef>struct bpf_d *<parameter>bpf_d</parameter></paramdef> "
"<paramdef>struct label *<parameter>bpflabel</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:10324
msgid "Subject; BPF descriptor"
msgstr "主体；BPF 描述子"

#. (itstool) path: row/entry
#: book.translate.xml:10329
msgid "Policy label for <parameter>bpf_d</parameter>"
msgstr "<parameter>bpf_d</parameter> 的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:10335 book.translate.xml:11454
msgid "Object; network interface"
msgstr "客体；网络接口"

#. (itstool) path: sect3/para
#: book.translate.xml:10347
msgid ""
"Determine whether the MAC framework should permit datagrams from the passed "
"interface to be delivered to the buffers of the passed BPF descriptor. "
"Return (<returnvalue>0</returnvalue>) for success, or an <varname>errno</"
"varname> value for failure Suggested failure: <errorcode>EACCES</errorcode> "
"for label mismatches, <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"决定 MAC 框架是否应该允许将由参数接口接收到的数据报传递给由 BPF 描述子所对应"
"的缓冲区。成功，则返回<returnvalue>0</returnvalue>；否则，返回错误编码信息"
"<varname>errno</varname>。建议使用的错误编码有：<errorcode>EACCES</"
"errorcode>，用于标记不符的情况；<errorcode>EPERM</errorcode>，用于缺少特权的"
"情况。"

#. (itstool) path: sect3/title
#: book.translate.xml:10357
msgid "<function>mpo_check_kenv_dump</function>"
msgstr "<function>mpo_check_kenv_dump</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10360
msgid ""
"<funcdef>int <function>mpo_check_kenv_dump</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_kenv_dump</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:10394
msgid ""
"Determine whether the subject should be allowed to retrieve the kernel "
"environment (see <citerefentry><refentrytitle>kenv</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>)."
msgstr ""
"决定相关主体是否应该被允许查询内核环境状态（参考 "
"<citerefentry><refentrytitle>kenv</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>）。"

#. (itstool) path: sect3/title
#: book.translate.xml:10399
msgid "<function>mpo_check_kenv_get</function>"
msgstr "<function>mpo_check_kenv_get</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10402
msgid ""
"<funcdef>int <function>mpo_check_kenv_get</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>char *<parameter>name</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_kenv_get</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>char *<parameter>name</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:10435 book.translate.xml:10484 book.translate.xml:10532
#: book.translate.xml:12411 book.translate.xml:13453 book.translate.xml:14454
msgid "<parameter>name</parameter>"
msgstr "<parameter>name</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:10436 book.translate.xml:10485 book.translate.xml:10533
msgid "Kernel environment variable name"
msgstr "内核的环境变量名字"

#. (itstool) path: sect3/para
#: book.translate.xml:10442
msgid ""
"Determine whether the subject should be allowed to retrieve the value of the "
"specified kernel environment variable."
msgstr "决定相关主体是否可以查询内核中给定环境变量的状态。"

#. (itstool) path: sect3/title
#: book.translate.xml:10448
msgid "<function>mpo_check_kenv_set</function>"
msgstr "<function>mpo_check_kenv_set</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10451
msgid ""
"<funcdef>int <function>mpo_check_kenv_set</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>char *<parameter>name</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_kenv_set</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>char *<parameter>name</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:10491
msgid ""
"Determine whether the subject should be allowed to set the specified kernel "
"environment variable."
msgstr "决定相关主体是否有权设置给定内核环境变量的值。"

#. (itstool) path: sect3/title
#: book.translate.xml:10496
msgid "<function>mpo_check_kenv_unset</function>"
msgstr "<function>mpo_check_kenv_unset</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10499
msgid ""
"<funcdef>int <function>mpo_check_kenv_unset</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>char *<parameter>name</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_kenv_unset</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>char *<parameter>name</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:10539
msgid ""
"Determine whether the subject should be allowed to unset the specified "
"kernel environment variable."
msgstr ""

#. (itstool) path: sect3/title
#: book.translate.xml:10544
msgid "<function>mpo_check_kld_load</function>"
msgstr "<function>mpo_check_kld_load</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10547
msgid ""
"<funcdef>int <function>mpo_check_kld_load</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_kld_load</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:10584
msgid "Kernel module vnode"
msgstr "内核模块的 vnode"

#. (itstool) path: row/entry
#: book.translate.xml:10589 book.translate.xml:14208 book.translate.xml:14399
msgid "Label associated with <parameter>vp</parameter>"
msgstr "与<parameter>vp</parameter>关联的标签"

#. (itstool) path: sect3/para
#: book.translate.xml:10596
msgid ""
"Determine whether the subject should be allowed to load the specified module "
"file."
msgstr "决定相关主体是否有权加载给定的模块文件。"

#. (itstool) path: sect3/title
#: book.translate.xml:10601
msgid "<function>mpo_check_kld_stat</function>"
msgstr "<function>mpo_check_kld_stat</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10604
msgid ""
"<funcdef>int <function>mpo_check_kld_stat</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_kld_stat</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:10638
msgid ""
"Determine whether the subject should be allowed to retrieve a list of loaded "
"kernel module files and associated statistics."
msgstr "决定相关主体是否有权访问内核的加载模块文件链表以及相关的统计数据。"

#. (itstool) path: sect3/title
#: book.translate.xml:10644
msgid "<function>mpo_check_kld_unload</function>"
msgstr "<function>mpo_check_kld_unload</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10647
msgid ""
"<funcdef>int <function>mpo_check_kld_unload</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_kld_unload</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:10681
msgid ""
"Determine whether the subject should be allowed to unload a kernel module."
msgstr "决定相关主体是否有权卸载一个内核模块。"

#. (itstool) path: sect3/title
#: book.translate.xml:10686
msgid "<function>mpo_check_pipe_ioctl</function>"
msgstr "<function>mpo_check_pipe_ioctl</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10689
msgid ""
"<funcdef>int <function>mpo_check_pipe_ioctl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef> "
"<paramdef>unsigned long <parameter>cmd</parameter></paramdef> <paramdef>void "
"*<parameter>data</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_pipe_ioctl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef> "
"<paramdef>unsigned long <parameter>cmd</parameter></paramdef> <paramdef>void "
"*<parameter>data</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:10739
msgid "<parameter>cmd</parameter>"
msgstr "<parameter>cmd</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:10740
msgid ""
"<citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> command"
msgstr ""
"<citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> command"

#. (itstool) path: row/entry
#: book.translate.xml:10744
msgid "<parameter>data</parameter>"
msgstr "<parameter>data</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:10745
msgid ""
"<citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> data"
msgstr ""
"<citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> data"

#. (itstool) path: sect3/para
#: book.translate.xml:10751
msgid ""
"Determine whether the subject should be allowed to make the specified "
"<citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> call."
msgstr ""
"决定相关主体是否有权调用指定的 <citerefentry><refentrytitle>ioctl</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> 系统调用。"

#. (itstool) path: sect3/title
#: book.translate.xml:10756
msgid "<function>mpo_check_pipe_poll</function>"
msgstr "<function>mpo_check_pipe_poll</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10759
msgid ""
"<funcdef>int <function>mpo_check_pipe_poll</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_pipe_poll</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:10808
msgid ""
"Determine whether the subject should be allowed to poll <parameter>pipe</"
"parameter>."
msgstr "决定相关主体是否有权对管道<parameter>pipe</parameter>执行poll操作。"

#. (itstool) path: sect3/title
#: book.translate.xml:10813
msgid "<function>mpo_check_pipe_read</function>"
msgstr "<function>mpo_check_pipe_read</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10816
msgid ""
"<funcdef>int <function>mpo_check_pipe_read</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_pipe_read</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:10865
msgid ""
"Determine whether the subject should be allowed read access to "
"<parameter>pipe</parameter>."
msgstr "决定该主体是否有权读取<parameter>pipe</parameter>。"

#. (itstool) path: sect3/title
#: book.translate.xml:10870
msgid "<function>mpo_check_pipe_relabel</function>"
msgstr "<function>mpo_check_pipe_relabel</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10873
msgid ""
"<funcdef>int <function>mpo_check_pipe_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_pipe_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:10923
msgid "Label update to <parameter>pipelabel</parameter>"
msgstr "将为<parameter>pipelabel</parameter>设置的新标记"

#. (itstool) path: sect3/para
#: book.translate.xml:10930
msgid ""
"Determine whether the subject should be allowed to relabel <parameter>pipe</"
"parameter>."
msgstr "决定该主体是否有权为<parameter>pipe</parameter>重新设置标记。"

#. (itstool) path: sect3/title
#: book.translate.xml:10935
msgid "<function>mpo_check_pipe_stat</function>"
msgstr "<function>mpo_check_pipe_stat</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10938
msgid ""
"<funcdef>int <function>mpo_check_pipe_stat</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_pipe_stat</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:10987
msgid ""
"Determine whether the subject should be allowed to retrieve statistics "
"related to <parameter>pipe</parameter>."
msgstr "决定该主体是否有权查询与<parameter>pipe</parameter>相关的统计信息。"

#. (itstool) path: sect3/title
#: book.translate.xml:10993
msgid "<function>mpo_check_pipe_write</function>"
msgstr "<function>mpo_check_pipe_write</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10996
msgid ""
"<funcdef>int <function>mpo_check_pipe_write</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_pipe_write</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:11045
msgid ""
"Determine whether the subject should be allowed to write to <parameter>pipe</"
"parameter>."
msgstr "决定该主体是否有权写<parameter>pipe</parameter>。"

#. (itstool) path: sect3/title
#: book.translate.xml:11050
msgid "<function>mpo_check_socket_bind</function>"
msgstr "<function>mpo_check_socket_bind</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11053
msgid ""
"<funcdef>int <function>mpo_check_socket_bind</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef> "
"<paramdef>struct sockaddr *<parameter>sockaddr</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_socket_bind</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef> "
"<paramdef>struct sockaddr *<parameter>sockaddr</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:11092
msgid "Socket to be bound"
msgstr "将被绑定的套接字"

#. (itstool) path: row/entry
#: book.translate.xml:11102 book.translate.xml:11164
msgid "<parameter>sockaddr</parameter>"
msgstr "<parameter>sockaddr</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:11103 book.translate.xml:11165
msgid "Address of <parameter>socket</parameter>"
msgstr "<parameter>socket</parameter>的地址"

#. (itstool) path: sect3/title
#: book.translate.xml:11112
msgid "<function>mpo_check_socket_connect</function>"
msgstr "<function>mpo_check_socket_connect</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11115
msgid ""
"<funcdef>int <function>mpo_check_socket_connect</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef> "
"<paramdef>struct sockaddr *<parameter>sockaddr</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_socket_connect</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef> "
"<paramdef>struct sockaddr *<parameter>sockaddr</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:11154
msgid "Socket to be connected"
msgstr "将被连接的套接字"

#. (itstool) path: sect3/para
#: book.translate.xml:11172
msgid ""
"Determine whether the subject credential (<parameter>cred</parameter>) can "
"connect the passed socket (<parameter>socket</parameter>) to the passed "
"socket address (<parameter>sockaddr</parameter>). Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatches, "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"决定该主体（<parameter>cred</parameter>）是否有权将套接字"
"（<parameter>socket</parameter>）绑定到地址<parameter>sockaddr</parameter>。"
"成功，返回<returnvalue>0</returnvalue>，否则返回一个错误编码<varname>errno</"
"varname>。建议采用的错误编码有：<errorcode>EACCES</errorcode>，用于标记不符的"
"情况；<errorcode>EPERM</errorcode>，用于特权不足的情况。"

#. (itstool) path: sect3/title
#: book.translate.xml:11183
msgid "<function>mpo_check_socket_receive</function>"
msgstr "<function>mpo_check_socket_receive</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11186
msgid ""
"<funcdef>int <function>mpo_check_socket_receive</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_socket_receive</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:11228 book.translate.xml:11286
msgid "Policy label associated with <parameter>so</parameter>"
msgstr "<parameter>so</parameter>的策略标记"

#. (itstool) path: sect3/para
#: book.translate.xml:11235
msgid ""
"Determine whether the subject should be allowed to receive information from "
"the socket <parameter>so</parameter>."
msgstr "决定该主体是否有权查询套接字<parameter>so</parameter>的相关信息。"

#. (itstool) path: sect3/title
#: book.translate.xml:11241
msgid "<function>mpo_check_socket_send</function>"
msgstr "<function>mpo_check_socket_send</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11244
msgid ""
"<funcdef>int <function>mpo_check_socket_send</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_socket_send</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:11293
msgid ""
"Determine whether the subject should be allowed to send information across "
"the socket <parameter>so</parameter>."
msgstr "决定该主体是否有权通过套接字<parameter>so</parameter>发送信息。"

#. (itstool) path: sect3/title
#: book.translate.xml:11299
msgid "<function>mpo_check_cred_visible</function>"
msgstr "<function>mpo_check_cred_visible</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11302
msgid ""
"<funcdef>int <function>mpo_check_cred_visible</function></funcdef> "
"<paramdef>struct ucred *<parameter>u1</parameter></paramdef> "
"<paramdef>struct ucred *<parameter>u2</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_cred_visible</function></funcdef> "
"<paramdef>struct ucred *<parameter>u1</parameter></paramdef> "
"<paramdef>struct ucred *<parameter>u2</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:11331
msgid "<parameter>u1</parameter>"
msgstr "<parameter>u1</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:11336
msgid "<parameter>u2</parameter>"
msgstr "<parameter>u2</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:11337
msgid "Object credential"
msgstr "主体信任状"

#. (itstool) path: sect3/para
#: book.translate.xml:11343
msgid ""
"Determine whether the subject credential <parameter>u1</parameter> can "
"<quote>see</quote> other subjects with the passed subject credential "
"<parameter>u2</parameter>. Return <returnvalue>0</returnvalue> for success, "
"or an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatches, <errorcode>EPERM</"
"errorcode> for lack of privilege, or <errorcode>ESRCH</errorcode> to hide "
"visibility. This call may be made in a number of situations, including inter-"
"process status sysctl's used by <command>ps</command>, and in procfs lookups."
msgstr ""
"确定该主体信任状<parameter>u1</parameter>是否有权 <quote>see</quote> 具有信任"
"状<parameter>u2</parameter> 的其他主体。成功，返回<returnvalue>0</"
"returnvalue>；否则，返回错误编码<varname>errno</varname>。建议采用的错误编码"
"有：<errorcode>EACCES</errorcode>，用于标记不符的情况；<errorcode>EPERM</"
"errorcode>，用于特权不足的情况；<errorcode>ESRCH</errorcode>，用来提供不可见"
"性。该函数可在许多环境下使用，包括命令<command>ps</command>所使用的进程间的状"
"态 sysctl，以及通过procfs 的状态查询操作。"

#. (itstool) path: sect3/title
#: book.translate.xml:11358 book.translate.xml:14098
msgid "<function>mpo_check_socket_visible</function>"
msgstr "<function>mpo_check_socket_visible</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11361
msgid ""
"<funcdef>int <function>mpo_check_socket_visible</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_socket_visible</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"

#. (itstool) path: sect3/title
#: book.translate.xml:11412
msgid "<function>mpo_check_ifnet_relabel</function>"
msgstr "<function>mpo_check_ifnet_relabel</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11415
msgid ""
"<funcdef>int <function>mpo_check_ifnet_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_ifnet_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:11459
msgid "Existing policy label for <parameter>ifnet</parameter>"
msgstr "<parameter>ifnet</parameter>现有的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:11465
msgid "Policy label update to later be applied to <parameter>ifnet</parameter>"
msgstr "将被应用到<parameter>ifnet</parameter>上的新的策略标记"

#. (itstool) path: sect3/para
#: book.translate.xml:11472
msgid ""
"Determine whether the subject credential can relabel the passed network "
"interface to the passed label update."
msgstr ""
"决定该主体信任状是否有权使用传入的标记更新参数对给定的网络接口的标记进行重新"
"设置。"

#. (itstool) path: sect3/title
#: book.translate.xml:11477
msgid "<function>mpo_check_socket_relabel</function>"
msgstr "<function>mpo_check_socket_relabel</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11480
msgid ""
"<funcdef>int <function>mpo_check_socket_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_socket_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:11524
msgid "Existing policy label for <parameter>socket</parameter>"
msgstr "<parameter>socket</parameter>现有的策略标记"

#. (itstool) path: row/entry
#: book.translate.xml:11530
msgid "Label update to later be applied to <parameter>socketlabel</parameter>"
msgstr "将被应用到<parameter>socketlabel</parameter>上的更新标记"

#. (itstool) path: sect3/para
#: book.translate.xml:11537
msgid ""
"Determine whether the subject credential can relabel the passed socket to "
"the passed label update."
msgstr "决定该主体信任状是否有权采用传入的标记对套接字参数的标记进行重新设置。"

#. (itstool) path: sect3/title
#: book.translate.xml:11542
msgid "<function>mpo_check_cred_relabel</function>"
msgstr "<function>mpo_check_cred_relabel</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11545
msgid ""
"<funcdef>int <function>mpo_check_cred_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_cred_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:11580
msgid "Label update to later be applied to <parameter>cred</parameter>"
msgstr "将被应用到<parameter>cred</parameter>上的更新标记"

#. (itstool) path: sect3/para
#: book.translate.xml:11587
msgid ""
"Determine whether the subject credential can relabel itself to the passed "
"label update."
msgstr "决定该主体信任状是否有权将自己的标记重新设置为给定的更新标记。"

#. (itstool) path: sect3/title
#: book.translate.xml:11593
msgid "<function>mpo_check_vnode_relabel</function>"
msgstr "<function>mpo_check_vnode_relabel</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11596
msgid ""
"<funcdef>int <function>mpo_check_vnode_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:11636 book.translate.xml:11826 book.translate.xml:12020
#: book.translate.xml:12190 book.translate.xml:12323 book.translate.xml:12396
#: book.translate.xml:13035 book.translate.xml:13103 book.translate.xml:13228
#: book.translate.xml:13294 book.translate.xml:13360 book.translate.xml:13438
#: book.translate.xml:13524 book.translate.xml:13592 book.translate.xml:13661
#: book.translate.xml:13921
msgid "Object; vnode"
msgstr "客体；vnode"

#. (itstool) path: row/entry
#: book.translate.xml:11648
msgid "Policy label update to later be applied to <parameter>vp</parameter>"
msgstr "将被应用到<parameter>vp</parameter>上的策略标记"

#. (itstool) path: sect3/para
#: book.translate.xml:11655
msgid ""
"Determine whether the subject credential can relabel the passed vnode to the "
"passed label update."
msgstr "决定该主体信任状是否有权将参数 vnode 的标记重新设置为指定标记。"

#. (itstool) path: sect3/title
#: book.translate.xml:11660
msgid "<function>mpo_check_mount_stat</function>"
msgstr "<function>mpo_check_mount_stat</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11663
msgid ""
"<funcdef>int <function>mpo_check_mount_stat</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>mountlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_mount_stat</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>mountlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:11700
msgid "Object; file system mount"
msgstr "客体；文件系统挂载"

#. (itstool) path: row/entry
#: book.translate.xml:11704
msgid "<parameter>mountlabel</parameter>"
msgstr "<parameter>mountlabel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:11705
msgid "Policy label for <parameter>mp</parameter>"
msgstr "<parameter>mp</parameter>的策略标记"

#. (itstool) path: sect3/para
#: book.translate.xml:11713
msgid ""
"Determine whether the subject credential can see the results of a statfs "
"performed on the file system. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested "
"failure: <errorcode>EACCES</errorcode> for label mismatches or "
"<errorcode>EPERM</errorcode> for lack of privilege. This call may be made in "
"a number of situations, including during invocations of "
"<citerefentry><refentrytitle>statfs</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> and related calls, as well as to determine what file systems "
"to exclude from listings of file systems, such as when "
"<citerefentry><refentrytitle>getfsstat</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> is invoked."
msgstr ""
"确定相关主体信任状是否有权查看在给定文件系统上执行 statfs 的结果。成功，则返"
"回 <returnvalue>0</returnvalue>；否则，返回一个<varname>errno</varname>值。建"
"议使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹配；"
"<errorcode>EPERM</errorcode>，用于权限不够。该函数可能在下列情况下被调用：在 "
"<citerefentry><refentrytitle>statfs</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> 和其他相关调用期间，或者当需要从文件系统列表中选择排除哪个文件"
"系统时，比如，调用 <citerefentry><refentrytitle>getfsstat</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>时。"

#. (itstool) path: sect3/title
#: book.translate.xml:11727
msgid "<function>mpo_check_proc_debug</function>"
msgstr "<function>mpo_check_proc_debug</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11730
msgid ""
"<funcdef>int <function>mpo_check_proc_debug</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct proc *<parameter>proc</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_proc_debug</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct proc *<parameter>proc</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:11765 book.translate.xml:13802 book.translate.xml:13859
msgid "<parameter>proc</parameter>"
msgstr "<parameter>proc</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:11766 book.translate.xml:13803 book.translate.xml:13860
msgid "Object; process"
msgstr "客体；进程"

#. (itstool) path: sect3/para
#: book.translate.xml:11772
msgid ""
"Determine whether the subject credential can debug the passed process. "
"Return <returnvalue>0</returnvalue> for success, or an <varname>errno</"
"varname> value for failure. Suggested failure: <errorcode>EACCES</errorcode> "
"for label mismatch, <errorcode>EPERM</errorcode> for lack of privilege, or "
"<errorcode>ESRCH</errorcode> to hide visibility of the target. This call may "
"be made in a number of situations, including use of the "
"<citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> and <citerefentry><refentrytitle>ktrace</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> APIs, as well as for "
"some types of procfs operations."
msgstr ""
"确定相关主体信任状是否有权 debug 给定进程。成功，则返回 <returnvalue>0</"
"returnvalue>；否则，返回一个<varname>errno</varname>值。建议使用的错误编码："
"<errorcode>EACCES</errorcode>，用于标记不匹配；<errorcode>EPERM</errorcode>，"
"用于权限不够；<errorcode>ESRCH</errorcode>，用于隐瞒目标的存在。"
"<citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> 和 <citerefentry><refentrytitle>ktrace</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> API，以及某些 procfs 操"
"作将调用该函数。"

#. (itstool) path: sect3/title
#: book.translate.xml:11785
msgid "<function>mpo_check_vnode_access</function>"
msgstr "<function>mpo_check_vnode_access</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11788
msgid ""
"<funcdef>int <function>mpo_check_vnode_access</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>flags</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_access</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>flags</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:11836 book.translate.xml:13534
msgid "<parameter>flags</parameter>"
msgstr "<parameter>flags</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:11837
msgid ""
"<citerefentry><refentrytitle>access</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> flags"
msgstr ""
"<citerefentry><refentrytitle>access</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> flags"

#. (itstool) path: sect3/para
#: book.translate.xml:11843
msgid ""
"Determine how invocations of <citerefentry><refentrytitle>access</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> and related calls by "
"the subject credential should return when performed on the passed vnode "
"using the passed access flags. This should generally be implemented using "
"the same semantics used in <function>mpo_check_vnode_open</function>. Return "
"<returnvalue>0</returnvalue> for success, or an <varname>errno</varname> "
"value for failure. Suggested failure: <errorcode>EACCES</errorcode> for "
"label mismatches or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"根据相关主体信任状决定其对给定 vnode 以给定访问标志执行的 "
"<citerefentry><refentrytitle>access</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>和其他相关调用的返回值。一般，应采用与"
"<function>mpo_check_vnode_open</function>相同的语义来实现该函数。成功，则返"
"回 <returnvalue>0</returnvalue>；否则，返回一个<varname>errno</varname>值。建"
"议使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹配；"
"<errorcode>EPERM</errorcode>，用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:11856
msgid "<function>mpo_check_vnode_chdir</function>"
msgstr "<function>mpo_check_vnode_chdir</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11859
msgid ""
"<funcdef>int <function>mpo_check_vnode_chdir</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_chdir</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:11896
msgid ""
"Object; vnode to <citerefentry><refentrytitle>chdir</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> into"
msgstr ""
"客体；<citerefentry><refentrytitle>chdir</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> 的目的 vnode"

#. (itstool) path: row/entry
#: book.translate.xml:11901 book.translate.xml:12025 book.translate.xml:12107
#: book.translate.xml:13040 book.translate.xml:13171
msgid "Policy label for <parameter>dvp</parameter>"
msgstr "<parameter>dvp</parameter>的策略标记"

#. (itstool) path: sect3/para
#: book.translate.xml:11908
msgid ""
"Determine whether the subject credential can change the process working "
"directory to the passed vnode. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested "
"failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"确定相关主体信任状是否有权将进程工作目录切换到给定 vnode。成功，则返回 "
"<returnvalue>0</returnvalue>；否则，返回一个 <varname>errno</varname>值。建议"
"使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹配；"
"<errorcode>EPERM</errorcode>，用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:11918
msgid "<function>mpo_check_vnode_chroot</function>"
msgstr "<function>mpo_check_vnode_chroot</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11921
msgid ""
"<funcdef>int <function>mpo_check_vnode_chroot</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_chroot</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:11958 book.translate.xml:12482 book.translate.xml:12810
#: book.translate.xml:12892
msgid "Directory vnode"
msgstr "目录 vnode"

#. (itstool) path: row/entry
#: book.translate.xml:11963 book.translate.xml:12487 book.translate.xml:12815
#: book.translate.xml:12897
msgid "Policy label associated with <parameter>dvp</parameter>"
msgstr "与<parameter>dvp</parameter>相关联的策略标记"

#. (itstool) path: sect3/para
#: book.translate.xml:11970
msgid ""
"Determine whether the subject should be allowed to "
"<citerefentry><refentrytitle>chroot</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> into the specified directory (<parameter>dvp</parameter>)."
msgstr ""
"确定相关主体是否有权 <citerefentry><refentrytitle>chroot</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> 到由(<parameter>dvp</"
"parameter>)给定的目录。"

#. (itstool) path: sect3/title
#: book.translate.xml:11976
msgid "<function>mpo_check_vnode_create</function>"
msgstr "<function>mpo_check_vnode_create</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11979
msgid ""
"<funcdef>int <function>mpo_check_vnode_create</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct componentname *<parameter>cnp</parameter></paramdef> "
"<paramdef>struct vattr *<parameter>vap</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_create</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct componentname *<parameter>cnp</parameter></paramdef> "
"<paramdef>struct vattr *<parameter>vap</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:12031
msgid "Component name for <parameter>dvp</parameter>"
msgstr "<parameter>dvp</parameter>中的成员名"

#. (itstool) path: row/entry
#: book.translate.xml:12036
msgid "<parameter>vap</parameter>"
msgstr "<parameter>vap</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:12037
msgid "vnode attributes for <parameter>vap</parameter>"
msgstr "<parameter>vap</parameter>的 vnode 属性"

#. (itstool) path: sect3/para
#: book.translate.xml:12044
msgid ""
"Determine whether the subject credential can create a vnode with the passed "
"parent directory, passed name information, and passed attribute information. "
"Return <returnvalue>0</returnvalue> for success, or an <varname>errno</"
"varname> value for failure. Suggested failure: <errorcode>EACCES</errorcode> "
"for label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege. "
"This call may be made in a number of situations, including as a result of "
"calls to <citerefentry><refentrytitle>open</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> with <symbol>O_CREAT</symbol>, "
"<citerefentry><refentrytitle>mkfifo</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>, and others."
msgstr ""
"确定相关主体信任状是否有权在给定父目录，以给定的名字和属性，常见一个 vnode。"
"成功，则返回 <returnvalue>0</returnvalue>；否则，返回一个<varname>errno</"
"varname>值。建议使用的错误编码：<errorcode>EACCES</errorcode> 来表示用于标记"
"不匹配， 而用<errorcode>EPERM</errorcode>，用于权限不足。以<symbol>O_CREAT</"
"symbol>为参数调用 <citerefentry><refentrytitle>open</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>，或对 "
"<citerefentry><refentrytitle>mknod</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>，<citerefentry><refentrytitle>mkfifo</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>等的调用将导致该函数被调"
"用。"

#. (itstool) path: sect3/title
#: book.translate.xml:12057
msgid "<function>mpo_check_vnode_delete</function>"
msgstr "<function>mpo_check_vnode_delete</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12060
msgid ""
"<funcdef>int <function>mpo_check_vnode_delete</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> <paramdef>void "
"*<parameter>label</parameter></paramdef> <paramdef>struct componentname "
"*<parameter>cnp</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_delete</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> <paramdef>void "
"*<parameter>label</parameter></paramdef> <paramdef>struct componentname "
"*<parameter>cnp</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:12113
msgid "Object; vnode to delete"
msgstr "客体；将被删除的 vnode"

#. (itstool) path: sect3/para
#: book.translate.xml:12131
msgid ""
"Determine whether the subject credential can delete a vnode from the passed "
"parent directory and passed name information. Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege. This call may be made in "
"a number of situations, including as a result of calls to "
"<citerefentry><refentrytitle>unlink</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> and <citerefentry><refentrytitle>rmdir</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>. Policies implementing "
"this entry point should also implement <function>mpo_check_rename_to</"
"function> to authorize deletion of objects as a result of being the target "
"of a rename."
msgstr ""
"确定相关主体信任状是否有权从给定的父目录中，删除给定名字的 vnode。成功，则返"
"回 <returnvalue>0</returnvalue>；否则，返回一个<varname>errno</varname>值。建"
"议使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹配；"
"<errorcode>EPERM</errorcode>，用于权限不够。使用 "
"<citerefentry><refentrytitle>unlink</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> 和 <citerefentry><refentrytitle>rmdir</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>，将导致该函数被调用。提"
"供该入口函数的策略还必须实现一个<function>mpo_check_rename_to</function>，用"
"来授权由于重命名操作导致的目标文件的删除。"

#. (itstool) path: sect3/title
#: book.translate.xml:12147
msgid "<function>mpo_check_vnode_deleteacl</function>"
msgstr "<function>mpo_check_vnode_deleteacl</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12150
msgid ""
"<funcdef>int <function>mpo_check_vnode_deleteacl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>acl_type_t <parameter>type</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_deleteacl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>acl_type_t <parameter>type</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:12201 book.translate.xml:12333 book.translate.xml:13370
msgid "<parameter>type</parameter>"
msgstr "<parameter>type</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:12202 book.translate.xml:12334 book.translate.xml:13371
msgid "ACL type"
msgstr "ACL 类型"

#. (itstool) path: sect3/para
#: book.translate.xml:12208
msgid ""
"Determine whether the subject credential can delete the ACL of passed type "
"from the passed vnode. Return <returnvalue>0</returnvalue> for success, or "
"an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"确定相关主体信任状是否有权删除给定 vnode 的给定类型的 ACL。成功，则返回 "
"<returnvalue>0</returnvalue>；否则，返回一个<varname>errno</varname>值。建议"
"使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹配；"
"<errorcode>EPERM</errorcode>，用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:12218
msgid "<function>mpo_check_vnode_exec</function>"
msgstr "<function>mpo_check_vnode_exec</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12221
msgid ""
"<funcdef>int <function>mpo_check_vnode_exec</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_exec</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:12258
msgid "Object; vnode to execute"
msgstr "客体；将被执行的 vnode"

#. (itstool) path: sect3/para
#: book.translate.xml:12270
msgid ""
"Determine whether the subject credential can execute the passed vnode. "
"Determination of execute privilege is made separately from decisions about "
"any transitioning event. Return <returnvalue>0</returnvalue> for success, or "
"an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"确定相关主体信任状是否有权执行给定 vnode。对于执行特权的决策与任何瞬时事件的"
"决策是严格分开的。成功，则返回 <returnvalue>0</returnvalue>；否则，返回一个"
"<varname>errno</varname>值。建议使用的错误编码：<errorcode>EACCES</"
"errorcode>，用于标记不匹配；<errorcode>EPERM</errorcode>，用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:12281
msgid "<function>mpo_check_vnode_getacl</function>"
msgstr "<function>mpo_check_vnode_getacl</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12284
msgid ""
"<funcdef>int <function>mpo_check_vnode_getacl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>acl_type_t <parameter>type</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_getacl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>acl_type_t <parameter>type</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:12340
msgid ""
"Determine whether the subject credential can retrieve the ACL of passed type "
"from the passed vnode. Return <returnvalue>0</returnvalue> for success, or "
"an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"确定相关主体信任状是否有权查询给定 vnode 上的给定类型的 ACL。成功，则返回 "
"<returnvalue>0</returnvalue>；否则，返回一个<varname>errno</varname>值。建议"
"使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹配；"
"<errorcode>EPERM</errorcode>，用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:12350
msgid "<function>mpo_check_vnode_getextattr</function>"
msgstr "<function>mpo_check_vnode_getextattr</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12353
msgid ""
"<funcdef>int <function>mpo_check_vnode_getextattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>attrnamespace</parameter></paramdef> "
"<paramdef>const char *<parameter>name</parameter></paramdef> "
"<paramdef>struct uio *<parameter>uio</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_getextattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>attrnamespace</parameter></paramdef> "
"<paramdef>const char *<parameter>name</parameter></paramdef> "
"<paramdef>struct uio *<parameter>uio</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:12406 book.translate.xml:13448
msgid "<parameter>attrnamespace</parameter>"
msgstr "<parameter>attrnamespace</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:12407 book.translate.xml:13449
msgid "Extended attribute namespace"
msgstr "扩展属性名字空间"

#. (itstool) path: row/entry
#: book.translate.xml:12412 book.translate.xml:13454
msgid "Extended attribute name"
msgstr "扩展属性名"

#. (itstool) path: row/entry
#: book.translate.xml:12416 book.translate.xml:13458
msgid "<parameter>uio</parameter>"
msgstr "<parameter>uio</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:12417 book.translate.xml:13459
msgid ""
"I/O structure pointer; see <citerefentry><refentrytitle>uio</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""
"I/O 结构指针；参见 <citerefentry><refentrytitle>uio</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"

#. (itstool) path: sect3/para
#: book.translate.xml:12423
msgid ""
"Determine whether the subject credential can retrieve the extended attribute "
"with the passed namespace and name from the passed vnode. Policies "
"implementing labeling using extended attributes may be interested in special "
"handling of operations on those extended attributes. Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"确定相关主体信任状是否有权查询给定 vnode 上给定名字空间和名字的扩展属性。使用"
"扩展属性实现标记存储的策略模块可能会需要对这些扩展属性的操作进行特殊处理。成"
"功，则返回 <returnvalue>0</returnvalue>；否则，返回一个<varname>errno</"
"varname>值。建议使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹"
"配；<errorcode>EPERM</errorcode>，用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:12436
msgid "<function>mpo_check_vnode_link</function>"
msgstr "<function>mpo_check_vnode_link</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12439
msgid ""
"<funcdef>int <function>mpo_check_vnode_link</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>struct componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_link</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>struct componentname *<parameter>cnp</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:12493
msgid "Link destination vnode"
msgstr "链接目的 vnode"

#. (itstool) path: row/entry
#: book.translate.xml:12504
msgid "Component name for the link being created"
msgstr "将被创建的链接对应的成员名"

#. (itstool) path: sect3/para
#: book.translate.xml:12511
msgid ""
"Determine whether the subject should be allowed to create a link to the "
"vnode <parameter>vp</parameter> with the name specified by <parameter>cnp</"
"parameter>."
msgstr ""
"确定相关主体是否有权为参数<parameter>vp</parameter>给定的 vnode创建一个由参数"
"<parameter>cnp</parameter>给定名字的链接。"

#. (itstool) path: sect3/title
#: book.translate.xml:12517
msgid "<function>mpo_check_vnode_mmap</function>"
msgstr "<function>mpo_check_vnode_mmap</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12520
msgid ""
"<funcdef>int <function>mpo_check_vnode_mmap</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>prot</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_mmap</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>prot</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:12558
msgid "Vnode to map"
msgstr "将被映射的 vnode"

#. (itstool) path: row/entry
#: book.translate.xml:12568 book.translate.xml:12629 book.translate.xml:12686
msgid "<parameter>prot</parameter>"
msgstr "<parameter>prot</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:12569
msgid ""
"Mmap protections (see <citerefentry><refentrytitle>mmap</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>)"
msgstr ""
"mmap 保护 (参见<citerefentry><refentrytitle>mmap</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>)"

#. (itstool) path: sect3/para
#: book.translate.xml:12575
msgid ""
"Determine whether the subject should be allowed to map the vnode "
"<parameter>vp</parameter> with the protections specified in <parameter>prot</"
"parameter>."
msgstr ""
"确定相关主体是否有权将给定 vnode <parameter>vp</parameter> 以"
"<parameter>prot</parameter>指定的保护方式进行映射。"

#. (itstool) path: sect3/title
#: book.translate.xml:12581
msgid "<function>mpo_check_vnode_mmap_downgrade</function>"
msgstr "<function>mpo_check_vnode_mmap_downgrade</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12584
msgid ""
"<funcdef>void <function>mpo_check_vnode_mmap_downgrade</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int *<parameter>prot</parameter></paramdef>"
msgstr ""
"<funcdef>void <function>mpo_check_vnode_mmap_downgrade</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int *<parameter>prot</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:12617
msgid "See <xref linkend=\"mac-mpo-check-vnode-mmap\"/>."
msgstr "参见 <xref linkend=\"mac-mpo-check-vnode-mmap\"/>."

#. (itstool) path: row/entry
#: book.translate.xml:12630
msgid "Mmap protections to be downgraded"
msgstr "将被降级的 mmap protections"

#. (itstool) path: sect3/para
#: book.translate.xml:12636
msgid "Downgrade the mmap protections based on the subject and object labels."
msgstr "根据主体和客体标记，降低 mmap protections。"

#. (itstool) path: sect3/title
#: book.translate.xml:12641
msgid "<function>mpo_check_vnode_mprotect</function>"
msgstr "<function>mpo_check_vnode_mprotect</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12644
msgid ""
"<funcdef>int <function>mpo_check_vnode_mprotect</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>prot</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_mprotect</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>prot</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:12682
msgid "Mapped vnode"
msgstr "已映射的 vnode"

#. (itstool) path: row/entry
#: book.translate.xml:12687
msgid "Memory protections"
msgstr "内存保护"

#. (itstool) path: sect3/para
#: book.translate.xml:12693
msgid ""
"Determine whether the subject should be allowed to set the specified memory "
"protections on memory mapped from the vnode <parameter>vp</parameter>."
msgstr ""
"确定相关主体是否有权将给定 vnode<parameter>vp</parameter> 映射内存空间的存储"
"保护参数设置为指定值。"

#. (itstool) path: sect3/title
#: book.translate.xml:12699
msgid "<function>mpo_check_vnode_poll</function>"
msgstr "<function>mpo_check_vnode_poll</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12702
msgid ""
"<funcdef>int <function>mpo_check_vnode_poll</function></funcdef> "
"<paramdef>struct ucred *<parameter>active_cred</parameter></paramdef> "
"<paramdef>struct ucred *<parameter>file_cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_poll</function></funcdef> "
"<paramdef>struct ucred *<parameter>active_cred</parameter></paramdef> "
"<paramdef>struct ucred *<parameter>file_cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:12735
msgid "<parameter>active_cred</parameter>"
msgstr "<parameter>active_cred</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:12740
msgid "<parameter>file_cred</parameter>"
msgstr "<parameter>file_cred</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:12741
msgid "Credential associated with the <type>struct file</type>"
msgstr "与<type>struct file</type>相关联的信任状"

#. (itstool) path: row/entry
#: book.translate.xml:12747
msgid "Polled vnode"
msgstr "将被执行 poll 操作的 vnode"

#. (itstool) path: sect3/para
#: book.translate.xml:12759
msgid ""
"Determine whether the subject should be allowed to poll the vnode "
"<parameter>vp</parameter>."
msgstr ""
"确定相关主体是否有权对给定 vnode <parameter>vp</parameter>执行 poll 操作。"

#. (itstool) path: sect3/title
#: book.translate.xml:12764
msgid "<function>mpo_check_vnode_rename_from</function>"
msgstr "<function>mpo_check_vnode_rename_from</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12767
msgid ""
"<funcdef>int <function>mpo_vnode_rename_from</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>struct componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_vnode_rename_from</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>struct componentname *<parameter>cnp</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:12821
msgid "Vnode to be renamed"
msgstr "将被重命名的 vnode"

#. (itstool) path: sect3/para
#: book.translate.xml:12839
msgid ""
"Determine whether the subject should be allowed to rename the vnode "
"<parameter>vp</parameter> to something else."
msgstr "确定相关主体是否有权重命名给定vnode，<parameter>vp</parameter>。"

#. (itstool) path: sect3/title
#: book.translate.xml:12845
msgid "<function>mpo_check_vnode_rename_to</function>"
msgstr "<function>mpo_check_vnode_rename_to</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12848
msgid ""
"<funcdef>int <function>mpo_check_vnode_rename_to</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>samedir</parameter></paramdef> <paramdef>struct "
"componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_rename_to</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>samedir</parameter></paramdef> <paramdef>struct "
"componentname *<parameter>cnp</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:12903
msgid "Overwritten vnode"
msgstr "被覆盖的 vnode"

#. (itstool) path: row/entry
#: book.translate.xml:12913
msgid "<parameter>samedir</parameter>"
msgstr "<parameter>samedir</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:12914
msgid ""
"Boolean; <literal>1</literal> if the source and destination directories are "
"the same"
msgstr "布尔型变量；如果源和目的目录是相同的，则被置为<literal>1</literal>"

#. (itstool) path: row/entry
#: book.translate.xml:12920
msgid "Destination component name"
msgstr "目标component名"

#. (itstool) path: sect3/para
#: book.translate.xml:12926
msgid ""
"Determine whether the subject should be allowed to rename to the vnode "
"<parameter>vp</parameter>, into the directory <parameter>dvp</parameter>, or "
"to the name represented by <parameter>cnp</parameter>. If there is no "
"existing file to overwrite, <parameter>vp</parameter> and <parameter>label</"
"parameter> will be NULL."
msgstr ""
"确定相关主体是否有权重命名给定 vnode <parameter>vp</parameter>，至指定目录"
"<parameter>dvp</parameter>，或更名为<parameter>cnp</parameter>。如果无需覆盖"
"已有文件，则<parameter>vp</parameter> 和<parameter>label</parameter> 的值将"
"为 NULL。"

#. (itstool) path: sect3/title
#: book.translate.xml:12935
msgid "<function>mpo_check_socket_listen</function>"
msgstr "<function>mpo_check_socket_listen</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12938
msgid ""
"<funcdef>int <function>mpo_check_socket_listen</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_socket_listen</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:12987
msgid ""
"Determine whether the subject credential can listen on the passed socket. "
"Return <returnvalue>0</returnvalue> for success, or an <varname>errno</"
"varname> value for failure. Suggested failure: <errorcode>EACCES</errorcode> "
"for label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"确定相关主体是否有权监听给定套接字。成功，则返回<returnvalue>0</"
"returnvalue>；否则，返回错误编码值<varname>errno</varname>。建议使用的错误编"
"码：<errorcode>EACCES</errorcode>，用于标记不匹配；<errorcode>EPERM</"
"errorcode>，用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:12996
msgid "<function>mpo_check_vnode_lookup</function>"
msgstr "<function>mpo_check_vnode_lookup</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12999
msgid ""
"<funcdef>int <function>mpo_check_vnode_lookup</function></funcdef> "
"<paramdef>struct ucred *<parameter/>cred</paramdef> <paramdef>struct vnode "
"*<parameter/>dvp</paramdef> <paramdef>struct label *<parameter/>dlabel</"
"paramdef> <paramdef>struct componentname *<parameter>cnp</parameter></"
"paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_lookup</function></funcdef> "
"<paramdef>struct ucred *<parameter/>cred</paramdef> <paramdef>struct vnode "
"*<parameter/>dvp</paramdef> <paramdef>struct label *<parameter/>dlabel</"
"paramdef> <paramdef>struct componentname *<parameter>cnp</parameter></"
"paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:13046
msgid "Component name being looked up"
msgstr "被检查的成员名"

#. (itstool) path: sect3/para
#: book.translate.xml:13052
msgid ""
"Determine whether the subject credential can perform a lookup in the passed "
"directory vnode for the passed name. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested "
"failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"确定相关主体信任状是否有权在给定的目录 vnode 中为查找给定名字执行lookup操作。"
"成功，则返回 <returnvalue>0</returnvalue>；否则，返回一个 <varname>errno</"
"varname>值。建议使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹"
"配；<errorcode>EPERM</errorcode>，用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:13062
msgid "<function>mpo_check_vnode_open</function>"
msgstr "<function>mpo_check_vnode_open</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13065
msgid ""
"<funcdef>int <function>mpo_check_vnode_open</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>acc_mode</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_open</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>acc_mode</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:13113
msgid "<parameter>acc_mode</parameter>"
msgstr "<parameter>acc_mode</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:13114
msgid ""
"<citerefentry><refentrytitle>open</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> access mode"
msgstr ""
"<citerefentry><refentrytitle>open</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> access mode"

#. (itstool) path: sect3/para
#: book.translate.xml:13120
msgid ""
"Determine whether the subject credential can perform an open operation on "
"the passed vnode with the passed access mode. Return <returnvalue>0</"
"returnvalue> for success, or an errno value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"确定相关主体信任状是否有权在给定 vnode 上以给定的访问模式执行 open 操作。如果"
"成功，则返回 <returnvalue>0</returnvalue>；否则，返回一个错误编码。建议使用的"
"错误编码：<errorcode>EACCES</errorcode>，用于标记不匹配；<errorcode>EPERM</"
"errorcode>，用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:13129
msgid "<function>mpo_check_vnode_readdir</function>"
msgstr "<function>mpo_check_vnode_readdir</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13132
msgid ""
"<funcdef>int <function>mpo_check_vnode_readdir</function></funcdef> "
"<paramdef>struct ucred *<parameter/>cred</paramdef> <paramdef>struct vnode "
"*<parameter/>dvp</paramdef> <paramdef>struct label *<parameter/>dlabel</"
"paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_readdir</function></funcdef> "
"<paramdef>struct ucred *<parameter/>cred</paramdef> <paramdef>struct vnode "
"*<parameter/>dvp</paramdef> <paramdef>struct label *<parameter/>dlabel</"
"paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:13166
msgid "Object; directory vnode"
msgstr "客体；目录 vnode"

#. (itstool) path: sect3/para
#: book.translate.xml:13178
msgid ""
"Determine whether the subject credential can perform a <function>readdir</"
"function> operation on the passed directory vnode. Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"确定相关主体信任状是否有权在给定的目录 vnode 上执行<function>readdir</"
"function> 操作。成功，则返回 <returnvalue>0</returnvalue>；否则，返回一个错误"
"编码 <varname>errno</varname>。建议使用的错误编码：<errorcode>EACCES</"
"errorcode>，用于标记不匹配；<errorcode>EPERM</errorcode>，用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:13188
msgid "<function>mpo_check_vnode_readlink</function>"
msgstr "<function>mpo_check_vnode_readlink</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13191
msgid ""
"<funcdef>int <function>mpo_check_vnode_readlink</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_readlink</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:13240
msgid ""
"Determine whether the subject credential can perform a <function>readlink</"
"function> operation on the passed symlink vnode. Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege. This call may be made in "
"a number of situations, including an explicit <function>readlink</function> "
"call by the user process, or as a result of an implicit <function>readlink</"
"function> during a name lookup by the process."
msgstr ""
"确定相关主体信任状是否有权在给定符号链接 vnode 上执行<function>readlink</"
"function> 操作。成功，则返回 <returnvalue>0</returnvalue>；否则，返回一个"
"<varname>errno</varname>值。建议使用的错误编码：<errorcode>EACCES</"
"errorcode>，用于标记不匹配；<errorcode>EPERM</errorcode>，用于权限不够。该函"
"数可能在若干环境下被调用，包括由用户进程显式执行的 <function>readlink</"
"function> 调用，或者是在进程执行名字查询时隐式执行的 <function>readlink</"
"function> 。"

#. (itstool) path: sect3/title
#: book.translate.xml:13254
msgid "<function>mpo_check_vnode_revoke</function>"
msgstr "<function>mpo_check_vnode_revoke</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13257
msgid ""
"<funcdef>int <function>mpo_check_vnode_revoke</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_revoke</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:13306
msgid ""
"Determine whether the subject credential can revoke access to the passed "
"vnode. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"确定相关主体信任状是否有权撤销对给定 vnode 的访问。成功，则返回 "
"<returnvalue>0</returnvalue>；否则，返回一个<varname>errno</varname>值。建议"
"使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹配；"
"<errorcode>EPERM</errorcode>，用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:13316
msgid "<function>mpo_check_vnode_setacl</function>"
msgstr "<function>mpo_check_vnode_setacl</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13319
msgid ""
"<funcdef>int <function>mpo_check_vnode_setacl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>acl_type_t <parameter>type</parameter></paramdef> <paramdef>struct "
"acl *<parameter>acl</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_setacl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>acl_type_t <parameter>type</parameter></paramdef> <paramdef>struct "
"acl *<parameter>acl</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:13375
msgid "<parameter>acl</parameter>"
msgstr "<parameter>acl</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:13376
msgid "ACL"
msgstr "ACL"

#. (itstool) path: sect3/para
#: book.translate.xml:13382
msgid ""
"Determine whether the subject credential can set the passed ACL of passed "
"type on the passed vnode. Return <returnvalue>0</returnvalue> for success, "
"or an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"确定相关主体信任状是否有权设置给定 vnode 的给定类型的 ACL。成功，则返回 "
"<returnvalue>0</returnvalue>；否则，返回一个<varname>errno</varname>值。建议"
"使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹配；"
"<errorcode>EPERM</errorcode>，用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:13392
msgid "<function>mpo_check_vnode_setextattr</function>"
msgstr "<function>mpo_check_vnode_setextattr</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13395
msgid ""
"<funcdef>int <function>mpo_check_vnode_setextattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>attrnamespace</parameter></paramdef> "
"<paramdef>const char *<parameter>name</parameter></paramdef> "
"<paramdef>struct uio *<parameter>uio</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_setextattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>attrnamespace</parameter></paramdef> "
"<paramdef>const char *<parameter>name</parameter></paramdef> "
"<paramdef>struct uio *<parameter>uio</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:13465
msgid ""
"Determine whether the subject credential can set the extended attribute of "
"passed name and passed namespace on the passed vnode. Policies implementing "
"security labels backed into extended attributes may want to provide "
"additional protections for those attributes. Additionally, policies should "
"avoid making decisions based on the data referenced from <parameter>uio</"
"parameter>, as there is a potential race condition between this check and "
"the actual operation. The <parameter>uio</parameter> may also be "
"<literal>NULL</literal> if a delete operation is being performed. Return "
"<returnvalue>0</returnvalue> for success, or an <varname>errno</varname> "
"value for failure. Suggested failure: <errorcode>EACCES</errorcode> for "
"label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"确定相关主体信任状是否有权设置给定 vnode 上给定名字空间中给定名字的扩展属性的"
"值。使用扩展属性备份安全标记的策略模块可能需要对其使用的属性实施额外的保护。"
"另外，由于在检查和实际操作时间可能存在的竞争，策略模块应该避免根据来自"
"<parameter>uio</parameter>中的数据做出决策。如果正在执行一个删除操作，则参数 "
"<parameter>uio</parameter> 的值也可能为 <literal>NULL</literal>。成功，则返"
"回 <returnvalue>0</returnvalue>；否则，返回一个<varname>errno</varname>值。建"
"议使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹配；"
"<errorcode>EPERM</errorcode>，用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:13483
msgid "<function>mpo_check_vnode_setflags</function>"
msgstr "<function>mpo_check_vnode_setflags</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13486
msgid ""
"<funcdef>int <function>mpo_check_vnode_setflags</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>u_long <parameter>flags</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_setflags</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>u_long <parameter>flags</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:13535
msgid ""
"File flags; see <citerefentry><refentrytitle>chflags</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
"文件标志；参见 <citerefentry><refentrytitle>chflags</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"

#. (itstool) path: sect3/para
#: book.translate.xml:13541
msgid ""
"Determine whether the subject credential can set the passed flags on the "
"passed vnode. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"确定相关主体信任状是否有权为给定的 vnode 设置给定的标志。成功，则返回 "
"<returnvalue>0</returnvalue>；否则，返回一个<varname>errno</varname>值。建议"
"使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹配；"
"<errorcode>EPERM</errorcode>，用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:13551
msgid "<function>mpo_check_vnode_setmode</function>"
msgstr "<function>mpo_check_vnode_setmode</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13554
msgid ""
"<funcdef>int <function>mpo_check_vnode_setmode</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>mode_t <parameter>mode</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_setmode</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>mode_t <parameter>mode</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:13602
msgid "<parameter>mode</parameter>"
msgstr "<parameter>mode</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:13603
msgid ""
"File mode; see <citerefentry><refentrytitle>chmod</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
"文件模式；参见 <citerefentry><refentrytitle>chmod</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"

#. (itstool) path: sect3/para
#: book.translate.xml:13609
msgid ""
"Determine whether the subject credential can set the passed mode on the "
"passed vnode. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"确定相关主体信任状是否有权将给定 vnode 的模式设置为给定值。成功，则返回 "
"<returnvalue>0</returnvalue>；否则，返回一个<varname>errno</varname>值。建议"
"使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹配；"
"<errorcode>EPERM</errorcode>，用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:13619
msgid "<function>mpo_check_vnode_setowner</function>"
msgstr "<function>mpo_check_vnode_setowner</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13622
msgid ""
"<funcdef>int <function>mpo_check_vnode_setowner</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>uid_t <parameter>uid</parameter></paramdef> <paramdef>gid_t "
"<parameter>gid</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_setowner</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>uid_t <parameter>uid</parameter></paramdef> <paramdef>gid_t "
"<parameter>gid</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:13671
msgid "<parameter>uid</parameter>"
msgstr "<parameter>uid</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:13672
msgid "User ID"
msgstr "用户ID"

#. (itstool) path: row/entry
#: book.translate.xml:13676
msgid "<parameter>gid</parameter>"
msgstr "<parameter>gid</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:13677
msgid "Group ID"
msgstr "组ID"

#. (itstool) path: sect3/para
#: book.translate.xml:13683
msgid ""
"Determine whether the subject credential can set the passed uid and passed "
"gid as file uid and file gid on the passed vnode. The IDs may be set to "
"(<literal>-1</literal>) to request no update. Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"确定相关主体信任状是否有权将给定 vnode 的文件 uid 和文件 gid 设置为给定值。如"
"果无需更新，相关参数值可能被设置为(<literal>-1</literal>)。成功，则返回 "
"<returnvalue>0</returnvalue>；否则，返回一个<varname>errno</varname>值。建议"
"使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹配；"
"<errorcode>EPERM</errorcode>，用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:13694
msgid "<function>mpo_check_vnode_setutimes</function>"
msgstr "<function>mpo_check_vnode_setutimes</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13697
msgid ""
"<funcdef>int <function>mpo_check_vnode_setutimes</function></funcdef> "
"<paramdef>struct ucred *<parameter/>cred</paramdef> <paramdef>struct vnode "
"*<parameter/>vp</paramdef> <paramdef>struct label *<parameter/>label</"
"paramdef> <paramdef>struct timespec <parameter/>atime</paramdef> "
"<paramdef>struct timespec <parameter/>mtime</paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_setutimes</function></funcdef> "
"<paramdef>struct ucred *<parameter/>cred</paramdef> <paramdef>struct vnode "
"*<parameter/>vp</paramdef> <paramdef>struct label *<parameter/>label</"
"paramdef> <paramdef>struct timespec <parameter/>atime</paramdef> "
"<paramdef>struct timespec <parameter/>mtime</paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:13733
msgid "Object; vp"
msgstr "客体；vp"

#. (itstool) path: row/entry
#: book.translate.xml:13743
msgid "<parameter>atime</parameter>"
msgstr "<parameter>atime</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:13744
msgid ""
"Access time; see <citerefentry><refentrytitle>utimes</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
"访问时间；参见 <citerefentry><refentrytitle>utimes</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"

#. (itstool) path: row/entry
#: book.translate.xml:13748
msgid "<parameter>mtime</parameter>"
msgstr "<parameter>mtime</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:13749
msgid ""
"Modification time; see <citerefentry><refentrytitle>utimes</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
"修改时间；参见 <citerefentry><refentrytitle>utimes</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"

#. (itstool) path: sect3/para
#: book.translate.xml:13755
msgid ""
"Determine whether the subject credential can set the passed access "
"timestamps on the passed vnode. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested "
"failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"确定相关主体信任状是否有权将给定 vnode 的访问时间标签设置为给定值。成功，则返"
"回 <returnvalue>0</returnvalue>；否则，返回一个<varname>errno</varname>值。建"
"议使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹配；"
"<errorcode>EPERM</errorcode>，用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:13765
msgid "<function>mpo_check_proc_sched</function>"
msgstr "<function>mpo_check_proc_sched</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13768
msgid ""
"<funcdef>int <function>mpo_check_proc_sched</function></funcdef> "
"<paramdef>struct ucred *<parameter>ucred</parameter></paramdef> "
"<paramdef>struct proc *<parameter>proc</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_proc_sched</function></funcdef> "
"<paramdef>struct ucred *<parameter>ucred</parameter></paramdef> "
"<paramdef>struct proc *<parameter>proc</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:13809
msgid ""
"Determine whether the subject credential can change the scheduling "
"parameters of the passed process. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested "
"failure: <errorcode>EACCES</errorcode> for label mismatch, <errorcode>EPERM</"
"errorcode> for lack of privilege, or <errorcode>ESRCH</errorcode> to limit "
"visibility."
msgstr ""
"确定相关主体信任状是否有权改变给定进程的调度参数。成功，则返回 "
"<returnvalue>0</returnvalue>；否则，返回一个<varname>errno</varname>值。建议"
"使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹配；"
"<errorcode>EPERM</errorcode>，用于权限不够；<errorcode>ESRCH</errorcode>，用"
"于提供不可见性质。"

#. (itstool) path: sect3/para
#: book.translate.xml:13817
msgid ""
"See <citerefentry><refentrytitle>setpriority</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> for more information."
msgstr ""
"参看 <citerefentry><refentrytitle>setpriority</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> 以获取更多信息。"

#. (itstool) path: sect3/title
#: book.translate.xml:13821
msgid "<function>mpo_check_proc_signal</function>"
msgstr "<function>mpo_check_proc_signal</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13824
msgid ""
"<funcdef>int <function>mpo_check_proc_signal</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct proc *<parameter>proc</parameter></paramdef> <paramdef>int "
"<parameter>signal</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_proc_signal</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct proc *<parameter>proc</parameter></paramdef> <paramdef>int "
"<parameter>signal</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:13864
msgid "<parameter>signal</parameter>"
msgstr "<parameter>signal</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:13865
msgid ""
"Signal; see <citerefentry><refentrytitle>kill</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>"
msgstr ""
"信号；参见 <citerefentry><refentrytitle>kill</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>"

#. (itstool) path: sect3/para
#: book.translate.xml:13871
msgid ""
"Determine whether the subject credential can deliver the passed signal to "
"the passed process. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, <errorcode>EPERM</"
"errorcode> for lack of privilege, or <errorcode>ESRCH</errorcode> to limit "
"visibility."
msgstr ""
"确定相关主体信任状是否有权向给定进程发送给定信号。成功，则返回 "
"<returnvalue>0</returnvalue>；否则，返回一个<varname>errno</varname>值。建议"
"使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹配；"
"<errorcode>EPERM</errorcode>，用于权限不够；<errorcode>ESRCH</errorcode>，用"
"于提供不可见性质。"

#. (itstool) path: sect3/title
#: book.translate.xml:13881
msgid "<function>mpo_check_vnode_stat</function>"
msgstr "<function>mpo_check_vnode_stat</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13884
msgid ""
"<funcdef>int <function>mpo_check_vnode_stat</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_vnode_stat</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:13933
msgid ""
"Determine whether the subject credential can <function>stat</function> the "
"passed vnode. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"确定相关主体信任状是否有权在给定 vnode 上执行 <function>stat</function> 操"
"作。成功，则返回 <returnvalue>0</returnvalue>；否则，返回一个<varname>errno</"
"varname>值。建议使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹"
"配；<errorcode>EPERM</errorcode>，用于权限不够。"

#. (itstool) path: sect3/para
#: book.translate.xml:13941
msgid ""
"See <citerefentry><refentrytitle>stat</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> for more information."
msgstr ""
"参考 <citerefentry><refentrytitle>stat</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> 获取更多信息。"

#. (itstool) path: sect3/title
#: book.translate.xml:13945
msgid "<function>mpo_check_ifnet_transmit</function>"
msgstr "<function>mpo_check_ifnet_transmit</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13948
msgid ""
"<funcdef>int <function>mpo_check_ifnet_transmit</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_ifnet_transmit</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:14000
msgid "Object; mbuf to be sent"
msgstr "客体；将被发送的 mbuf"

#. (itstool) path: sect3/para
#: book.translate.xml:14012
msgid ""
"Determine whether the network interface can transmit the passed mbuf. Return "
"<returnvalue>0</returnvalue> for success, or an <varname>errno</varname> "
"value for failure. Suggested failure: <errorcode>EACCES</errorcode> for "
"label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"确定相关网络接口是否有权传送给定的 mbuf。成功，则返回 <returnvalue>0</"
"returnvalue>；否则，返回一个<varname>errno</varname>值。建议使用的错误编码："
"<errorcode>EACCES</errorcode>，用于标记不匹配；<errorcode>EPERM</errorcode>，"
"用于权限不够。"

#. (itstool) path: sect3/title
#: book.translate.xml:14021
msgid "<function>mpo_check_socket_deliver</function>"
msgstr "<function>mpo_check_socket_deliver</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14024
msgid ""
"<funcdef>int <function>mpo_check_socket_deliver</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_socket_deliver</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:14076
msgid "Object; mbuf to be delivered"
msgstr "客体；将被传送的 mbuf"

#. (itstool) path: sect3/para
#: book.translate.xml:14088
msgid ""
"Determine whether the socket may receive the datagram stored in the passed "
"mbuf header. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failures: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"确定相关套接字是否有权从给定的 mbuf 中接收数据报。成功，则返回 "
"<returnvalue>0</returnvalue>；否则，返回一个<varname>errno</varname>值。建议"
"使用的错误编码：<errorcode>EACCES</errorcode>，用于标记不匹配；"
"<errorcode>EPERM</errorcode>，用于权限不够。"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14101
msgid ""
"<funcdef>int <function>mpo_check_socket_visible</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_socket_visible</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:14144
msgid "Policy label for <parameter>so</parameter>"
msgstr "<parameter>so</parameter>的策略标记"

#. (itstool) path: sect3/para
#: book.translate.xml:14151
msgid ""
"Determine whether the subject credential cred can \"see\" the passed socket "
"(<parameter>socket</parameter>) using system monitoring functions, such as "
"those employed by <citerefentry><refentrytitle>netstat</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry> and "
"<citerefentry><refentrytitle>sockstat</refentrytitle><manvolnum>1</"
"manvolnum></citerefentry>. Return <returnvalue>0</returnvalue> for success, "
"or an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatches, <errorcode>EPERM</"
"errorcode> for lack of privilege, or <errorcode>ESRCH</errorcode> to hide "
"visibility."
msgstr ""
"确定相关主体信任状cred 是否有权使用系统监控函数，比如，由"
"<citerefentry><refentrytitle>netstat</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry> 和 <citerefentry><refentrytitle>sockstat</"
"refentrytitle><manvolnum>1</manvolnum></citerefentry>使用的程序来观察给定的套"
"接字(<parameter>socket</parameter>)。成功，则返回 <returnvalue>0</"
"returnvalue>；否则，返回一个<varname>errno</varname>值。建议使用的错误编码："
"<errorcode>EACCES</errorcode>，用于标记不匹配；<errorcode>EPERM</errorcode>，"
"用于权限不够；<errorcode>ESRCH</errorcode>，用于提供不可见性质。"

#. (itstool) path: sect3/title
#: book.translate.xml:14163
msgid "<function>mpo_check_system_acct</function>"
msgstr "<function>mpo_check_system_acct</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14166
msgid ""
"<funcdef>int <function>mpo_check_system_acct</function></funcdef> "
"<paramdef>struct ucred *<parameter>ucred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_system_acct</function></funcdef> "
"<paramdef>struct ucred *<parameter>ucred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:14197
msgid "<parameter>ucred</parameter>"
msgstr "<parameter>ucred</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:14203
msgid ""
"Accounting file; <citerefentry><refentrytitle>acct</"
"refentrytitle><manvolnum>5</manvolnum></citerefentry>"
msgstr ""
"审计文件；<citerefentry><refentrytitle>acct</refentrytitle><manvolnum>5</"
"manvolnum></citerefentry>"

#. (itstool) path: sect3/para
#: book.translate.xml:14215
msgid ""
"Determine whether the subject should be allowed to enable accounting, based "
"on its label and the label of the accounting log file."
msgstr "根据主体标记和审计日志文件的标记，确定该主体是否有权启动审计。"

#. (itstool) path: sect3/title
#: book.translate.xml:14221
msgid "<function>mpo_check_system_nfsd</function>"
msgstr "<function>mpo_check_system_nfsd</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14224
msgid ""
"<funcdef>int <function>mpo_check_system_nfsd</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_system_nfsd</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:14258
msgid ""
"Determine whether the subject should be allowed to call "
"<citerefentry><refentrytitle>nfssvc</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>."
msgstr ""
"确定相关主体是否有权调用<citerefentry><refentrytitle>nfssvc</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>。"

#. (itstool) path: sect3/title
#: book.translate.xml:14263
msgid "<function>mpo_check_system_reboot</function>"
msgstr "<function>mpo_check_system_reboot</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14266
msgid ""
"<funcdef>int <function>mpo_check_system_reboot</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>int "
"<parameter>howto</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_system_reboot</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>int "
"<parameter>howto</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:14299
msgid "<parameter>howto</parameter>"
msgstr "<parameter>howto</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:14300
msgid ""
"<parameter>howto</parameter> parameter from "
"<citerefentry><refentrytitle>reboot</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>"
msgstr ""
"<parameter>howto</parameter> parameter from "
"<citerefentry><refentrytitle>reboot</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>"

#. (itstool) path: sect3/para
#: book.translate.xml:14307
msgid ""
"Determine whether the subject should be allowed to reboot the system in the "
"specified manner."
msgstr "确定相关主体是否有权以指定方式重启系统。"

#. (itstool) path: sect3/title
#: book.translate.xml:14312
msgid "<function>mpo_check_system_settime</function>"
msgstr "<function>mpo_check_system_settime</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14315
msgid ""
"<funcdef>int <function>mpo_check_system_settime</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_system_settime</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"

#. (itstool) path: sect3/para
#: book.translate.xml:14349
msgid "Determine whether the user should be allowed to set the system clock."
msgstr "确定相关用户是否有权设置系统时钟。"

#. (itstool) path: sect3/title
#: book.translate.xml:14354
msgid "<function>mpo_check_system_swapon</function>"
msgstr "<function>mpo_check_system_swapon</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14357
msgid ""
"<funcdef>int <function>mpo_check_system_swapon</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_system_swapon</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:14394
msgid "Swap device"
msgstr "Swap 设备"

#. (itstool) path: sect3/para
#: book.translate.xml:14406
msgid ""
"Determine whether the subject should be allowed to add <parameter>vp</"
"parameter> as a swap device."
msgstr ""
"确定相关主体是否有权增加一个作为swap设备的 <parameter>vp</parameter> 。"

#. (itstool) path: sect3/title
#: book.translate.xml:14411
msgid "<function>mpo_check_system_sysctl</function>"
msgstr "<function>mpo_check_system_sysctl</function>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14414
msgid ""
"<funcdef>int <function>mpo_check_system_sysctl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>int "
"*<parameter>name</parameter></paramdef> <paramdef>u_int *<parameter>namelen</"
"parameter></paramdef> <paramdef>void *<parameter>old</parameter></paramdef> "
"<paramdef>size_t *<parameter>oldlenp</parameter></paramdef> <paramdef>int "
"<parameter>inkernel</parameter></paramdef> <paramdef>void *<parameter>new</"
"parameter></paramdef> <paramdef>size_t <parameter>newlen</parameter></"
"paramdef>"
msgstr ""
"<funcdef>int <function>mpo_check_system_sysctl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>int "
"*<parameter>name</parameter></paramdef> <paramdef>u_int *<parameter>namelen</"
"parameter></paramdef> <paramdef>void *<parameter>old</parameter></paramdef> "
"<paramdef>size_t *<parameter>oldlenp</parameter></paramdef> <paramdef>int "
"<parameter>inkernel</parameter></paramdef> <paramdef>void *<parameter>new</"
"parameter></paramdef> <paramdef>size_t <parameter>newlen</parameter></"
"paramdef>"

#. (itstool) path: row/entry
#: book.translate.xml:14455 book.translate.xml:14478
msgid ""
"See <citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry>"
msgstr ""
"参见 <citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry>"

#. (itstool) path: row/entry
#: book.translate.xml:14467
msgid "<parameter>oldlenp</parameter>"
msgstr "<parameter>oldlenp</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:14471
msgid "<parameter>inkernel</parameter>"
msgstr "<parameter>inkernel</parameter>"

#. (itstool) path: row/entry
#: book.translate.xml:14472
msgid "Boolean; <literal>1</literal> if called from kernel"
msgstr "布尔型变量；如果从内核被调用，其值被置为<literal>1</literal>"

#. (itstool) path: row/entry
#: book.translate.xml:14482
msgid "<parameter>newlen</parameter>"
msgstr "<parameter>newlen</parameter>"

#. (itstool) path: sect3/para
#: book.translate.xml:14488
msgid ""
"Determine whether the subject should be allowed to make the specified "
"<citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry> transaction."
msgstr ""
"确定相关主体是否应该被允许执行指定的 <citerefentry><refentrytitle>sysctl</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>事务。"

#. (itstool) path: sect2/title
#: book.translate.xml:14494
msgid "Label Management Calls"
msgstr "标记管理调用"

#. (itstool) path: sect2/para
#: book.translate.xml:14496
msgid ""
"Relabel events occur when a user process has requested that the label on an "
"object be modified. A two-phase update occurs: first, an access control "
"check will be performed to determine if the update is both valid and "
"permitted, and then the update itself is performed via a separate entry "
"point. Relabel entry points typically accept the object, object label "
"reference, and an update label submitted by the process. Memory allocation "
"during relabel is discouraged, as relabel calls are not permitted to fail "
"(failure should be reported earlier in the relabel check)."
msgstr ""
"当用户进程请求对某个对象的标记进行修改时，将引发重新标记事件。对应的更新操作"
"分两步进行：首先，进行访问控制检查，确认此次更新操作是有效且被允许的；然后，"
"调用另一个独立的入口函数对标记进行修改。重新标记入口函数通常接收由请求进程提"
"交的对象、对象标记指针和请求新标记，作为输入参数。对象重新标记操作的失败将由"
"先期的标记检查报告，所以，不允许在接下来的标记修改过程中报告失败，故而不提倡"
"在此过程中新分配内存。"

#. (itstool) path: sect1/title
#: book.translate.xml:14510
msgid "Userland Architecture"
msgstr "应用层体系结构"

#. (itstool) path: sect1/para
#: book.translate.xml:14512
msgid ""
"The TrustedBSD MAC Framework includes a number of policy-agnostic elements, "
"including MAC library interfaces for abstractly managing labels, "
"modifications to the system credential management and login libraries to "
"support the assignment of MAC labels to users, and a set of tools to monitor "
"and modify labels on processes, files, and network interfaces. More details "
"on the user architecture will be added to this section in the near future."
msgstr ""
"TrustedBSD MAC 框架包含了一组策略无关的组成元素，包括管理抽象标记的 MAC 接口"
"库，对系统信任状管理体系的修改, 为用户分配 MAC 标记提供支持的 login 库函数，"
"以及若干负责维护和更新内核对象(进程、文件和网络接口等)安全标记的工具。不久，"
"将有更多关于应用层体系结构的详细信息被包含进来。"

#. (itstool) path: sect2/title
#: book.translate.xml:14522
msgid "APIs for Policy-Agnostic Label Management"
msgstr ""
".ps.1;，使用这些策略无关的接口查询网络结构、文件和进程的标记信息。\n"
"       这些 API 也被用于支持 MAC 管理工具"

#. (itstool) path: sect2/para
#: book.translate.xml:14524
msgid ""
"The TrustedBSD MAC Framework provides a number of library and system calls "
"permitting applications to manage MAC labels on objects using a policy-"
"agnostic interface. This permits applications to manipulate labels for a "
"variety of policies without being written to support specific policies. "
"These interfaces are used by general-purpose tools such as "
"<citerefentry><refentrytitle>ifconfig</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>, <citerefentry><refentrytitle>ls</"
"refentrytitle><manvolnum>1</manvolnum></citerefentry> and "
"<citerefentry><refentrytitle>ps</refentrytitle><manvolnum>1</manvolnum></"
"citerefentry> to view labels on network interfaces, files, and processes. "
"The APIs also support MAC management tools including "
"<citerefentry><refentrytitle>getfmac</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>, <citerefentry><refentrytitle>getpmac</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>setfmac</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>, <citerefentry><refentrytitle>setfsmac</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>, and "
"<citerefentry><refentrytitle>setpmac</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>. The MAC APIs are documented in "
"<citerefentry><refentrytitle>mac</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>."
msgstr ""
"TrustedBSD MAC 提供的大量库函数和系统调用，允许应用程序使用一种统一的、策略无"
"关的接口来处理对象的 MAC 标记。如此，应用程序可以轻松管理各种策略的标记，无需"
"为增加对某个特定策略的支持而重新编码。许多通用工具，比如"
"<citerefentry><refentrytitle>ifconfig</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>，<citerefentry><refentrytitle>ls</"
"refentrytitle><manvolnum>1</manvolnum></citerefentry> 和 "
"<citerefentry><refentrytitle>ps</refentrytitle><manvolnum>1</manvolnum></"
"citerefentry>，使用这些策略无关的接口查询网络结构、文件和进程的标记信息。这"
"些 API 也被用于支持 MAC 管理工具，比如，"
"<citerefentry><refentrytitle>getfmac</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>，<citerefentry><refentrytitle>getpmac</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>， "
"<citerefentry><refentrytitle>setfmac</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>， <citerefentry><refentrytitle>setfsmac</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>，和 "
"<citerefentry><refentrytitle>setpmac</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>。MAC API的设计细节可参考 "
"<citerefentry><refentrytitle>mac</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>."

#. (itstool) path: sect2/para
#: book.translate.xml:14538
msgid ""
"Applications handle MAC labels in two forms: an internalized form used to "
"return and set labels on processes and objects (<literal>mac_t</literal>), "
"and externalized form based on C strings appropriate for storage in "
"configuration files, display to the user, or input from the user. Each MAC "
"label contains a number of elements, each consisting of a name and value "
"pair. Policy modules in the kernel bind to specific names and interpret the "
"values in policy-specific ways. In the externalized string form, labels are "
"represented by a comma-delimited list of name and value pairs separated by "
"the <literal>/</literal> character. Labels may be directly converted to and "
"from text using provided APIs; when retrieving labels from the kernel, "
"internalized label storage must first be prepared for the desired label "
"element set. Typically, this is done in one of two ways: using "
"<citerefentry><refentrytitle>mac_prepare</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry> and an arbitrary list of desired label elements, "
"or one of the variants of the call that loads a default element set from the "
"<citerefentry><refentrytitle>mac.conf</refentrytitle><manvolnum>5</"
"manvolnum></citerefentry> configuration file. Per-object defaults permit "
"application writers to usefully display labels associated with objects "
"without being aware of the policies present in the system."
msgstr ""
"应用程序处理的 MAC 标记有两种存在形式：内部形式，用来返回和设置进程和对象的标"
"记（<literal>mac_t</literal>）； 基于 C 字符串的外部形式，作为标记在配置文件"
"中的存放形式，用于向用户显示或者由用户输入。 每一个 MAC 标记由一组标记元素组"
"成，其中每个元素是一个形如（名字，值）的二元组。 内核中的每个策略模块分别被指"
"定一个特定的名字，由它们对标记中与该名字对应的值采用其策略特有的方式进行解"
"析。 采用外部形式表示的标记，其标记元素表示为名字 <literal>/</literal> 值，元"
"素之间以逗号分隔。 应用程序可以使用 MAC 框架提供的 API 将一个安全标记在内部形"
"式和文本形式之间进行转换。 每当向内核查询某个对象的安全标记时，内部形式的标记"
"必须针对所需的元素集合作好内部标记存储准备。 为此，通常采用下面两种方式之一："
"使用 <citerefentry><refentrytitle>mac_prepare</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry> 和一个包含所需标记元素的任意列表；或者， 使用从"
"<citerefentry><refentrytitle>mac.conf</refentrytitle><manvolnum>5</"
"manvolnum></citerefentry> 配置文件中加载缺省元素集合的某个系统调用。在对象级"
"别设置缺省标记，将允许应用程序在不确定 系统是否采用相关策略的情况下，也能向用"
"户返回与对象相关联的有意义的安全标记。"

#. (itstool) path: note/para
#: book.translate.xml:14563
msgid ""
"Currently, direct manipulation of label elements other than by conversion to "
"a text string, string editing, and conversion back to an internalized label "
"is not supported by the MAC library. Such interfaces may be added in the "
"future if they prove necessary for application writers."
msgstr ""
"目前的 MAC 库不支持直接修改内部形式的标记元素，所有的修改必须按照下列的步骤进"
"行：将内部形式的标记转换成文本字符串，对字符串进行编辑，最后将其转换成内部形"
"式标记。如果应用程序的作者证明确实有需要，可以在将来的版本中加入对内部形式标"
"记进行直接修改的接口。"

#. (itstool) path: sect2/title
#: book.translate.xml:14573
msgid "Binding of Labels to Users"
msgstr "为用户指定标记"

#. (itstool) path: sect2/para
#: book.translate.xml:14575
msgid ""
"The standard user context management interface, "
"<citerefentry><refentrytitle>setusercontext</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry>, has been modified to retrieve MAC labels "
"associated with a user's class from <citerefentry><refentrytitle>login.conf</"
"refentrytitle><manvolnum>5</manvolnum></citerefentry>. These labels are then "
"set along with other user context when either <literal>LOGIN_SETALL</"
"literal> is specified, or when <literal>LOGIN_SETMAC</literal> is explicitly "
"specified."
msgstr ""
"用户上下文管理的标记接口， <citerefentry><refentrytitle>setusercontext</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry> ，的行为已经被修改为，"
"从 <citerefentry><refentrytitle>login.conf</refentrytitle><manvolnum>5</"
"manvolnum></citerefentry> 中查询与某个用户登录类别相关联的 MAC 安全标记。 当 "
"<literal>LOGIN_SETALL</literal> 被设置，或者当 <literal>LOGIN_SETMAC</"
"literal> 被明确指定时，这些安全标记将和其他用户上下文参数一起被设置。"

#. (itstool) path: note/para
#: book.translate.xml:14584
msgid ""
"It is expected that, in a future version of FreeBSD, the MAC label database "
"will be separated from the <filename>login.conf</filename> user class "
"abstraction, and be maintained in a separate database. However, the "
"<citerefentry><refentrytitle>setusercontext</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry> API should remain the same following such a change."
msgstr ""
"可以预期，在今后的某个版本中，FreeBSD 将把 MAC 标记从<filename>login.conf</"
"filename> 的用户类别数据库中抽出，为其维护一个独立的数据库。不过在此前后，"
"<citerefentry><refentrytitle>setusercontext</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry> API应该保持不变。"

#. (itstool) path: sect1/title
#: book.translate.xml:14594
msgid "Conclusion"
msgstr "小结"

#. (itstool) path: sect1/para
#: book.translate.xml:14596
msgid ""
"The TrustedBSD MAC framework permits kernel modules to augment the system "
"security policy in a highly integrated manner. They may do this based on "
"existing object properties, or based on label data that is maintained with "
"the assistance of the MAC framework. The framework is sufficiently flexible "
"to implement a variety of policy types, including information flow security "
"policies such as MLS and Biba, as well as policies based on existing BSD "
"credentials or file protections. Policy authors may wish to consult this "
"documentation as well as existing security modules when implementing a new "
"security service."
msgstr ""
"TrustedBSD MAC 框架使得内核模块能以一种集中的方式，完善系统的安全策略。它们既"
"可利用现有的内核对象属性，又能使用由 MAC 框架协助维护的安全标记数据，来实施访"
"问控制。框架提供的灵活性使得开发人员可以在其上实现各种策略，如利用 BSD 现有的"
"信任状（credential）与文件保护机制的策略，以及信息流安全策略（如 MLS 和 "
"Biba）。实现新安全服务的策略编程人员，可以参考本文档，以了解现有安全模块的信"
"息。"

#. (itstool) path: info/title
#: book.translate.xml:14619
msgid "Virtual Memory System"
msgstr "虚拟内存系统"

#. (itstool) path: authorgroup/author
#: book.translate.xml:14622
msgid ""
"<personname> <firstname>Matthew</firstname> <surname>Dillon</surname> </"
"personname> <contrib>Contributed by </contrib>"
msgstr ""
"<personname> <firstname>Matthew</firstname> <surname>Dillon</surname> </"
"personname> <contrib>Contributed by </contrib>"

#. (itstool) path: sect1/title
#: book.translate.xml:14633
#, fuzzy
msgid "Management of Physical Memory—<literal>vm_page_t</literal>"
msgstr "物理内存的管理&mdash;<literal>vm_page_t</literal>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14636
msgid "<primary>virtual memory</primary>"
msgstr "<primary>virtual memory(虚拟内存)</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14637
msgid "<primary>physical memory</primary>"
msgstr "<primary>physical memory(物理内存)</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14638
msgid "<primary><literal>vm_page_t</literal> structure</primary>"
msgstr "<primary><literal>vm_page_t</literal>结构体</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:14642
msgid ""
"Physical memory is managed on a page-by-page basis through the "
"<literal>vm_page_t</literal> structure. Pages of physical memory are "
"categorized through the placement of their respective <literal>vm_page_t</"
"literal> structures on one of several paging queues."
msgstr ""
"物理内存通过结构体<literal>vm_page_t</literal>以页为基础进行管理。物理内存的"
"页由它们各自对应的结构体<literal>vm_page_t</literal>所代表，这些结构体存放在"
"若干个页管理队列中的一个里面。"

#. (itstool) path: sect1/para
#: book.translate.xml:14648
msgid ""
"A page can be in a wired, active, inactive, cache, or free state. Except for "
"the wired state, the page is typically placed in a doubly link list queue "
"representing the state that it is in. Wired pages are not placed on any "
"queue."
msgstr ""
"一页可以处于在线(wired)、活动(active)，去活(inactive)、缓存(cache)、自由"
"(free)状态。除了在线状态，页一般被放置在一个双向链表队列里，代表了它所处的状"
"态。在线页不放置在任何队列里。"

#. (itstool) path: sect1/para
#: book.translate.xml:14653
msgid ""
"FreeBSD implements a more involved paging queue for cached and free pages in "
"order to implement page coloring. Each of these states involves multiple "
"queues arranged according to the size of the processor's L1 and L2 caches. "
"When a new page needs to be allocated, FreeBSD attempts to obtain one that "
"is reasonably well aligned from the point of view of the L1 and L2 caches "
"relative to the VM object the page is being allocated for."
msgstr ""
"FreeBSD为缓存页和自由页实现了一个更为复杂的页队列机制，以实现对页的分类管理。"
"每一种状态都对应着多个队列，队列的安排对应着处理器的一级、二级缓存。当需要分"
"配一个新页时，FreeBSD会试图把一个按一级、二级缓存对齐的页面分配给虚拟内存对"
"象。"

#. (itstool) path: sect1/para
#: book.translate.xml:14662
msgid ""
"Additionally, a page may be held with a reference count or locked with a "
"busy count. The VM system also implements an <quote>ultimate locked</quote> "
"state for a page using the PG_BUSY bit in the page's flags."
msgstr ""
"此外，一个页可以有一个引用计数，可以被一个忙计数锁定。虚拟内存系统也实现了"
"<quote>终极锁定</quote>(ultimate locked)状态，一个页可以用页标志PG_BUSY表示这"
"一状态。"

#. (itstool) path: sect1/para
#: book.translate.xml:14667
msgid ""
"In general terms, each of the paging queues operates in a LRU fashion. A "
"page is typically placed in a wired or active state initially. When wired, "
"the page is usually associated with a page table somewhere. The VM system "
"ages the page by scanning pages in a more active paging queue (LRU) in order "
"to move them to a less-active paging queue. Pages that get moved into the "
"cache are still associated with a VM object but are candidates for immediate "
"reuse. Pages in the free queue are truly free. FreeBSD attempts to minimize "
"the number of pages in the free queue, but a certain minimum number of truly "
"free pages must be maintained in order to accommodate page allocation at "
"interrupt time."
msgstr ""
"总之，每个页队列都按照LRU(Least-Recently Used)的原则工作。<tip><title>译者注"
"</title><para>短语Least-Recently Used有两种理解方式：1.将“least-recently”理解"
"为反向比较级，意义为“最早”，整个短语理解为“最近的使用时间最早”；2."
"将“least”和“recently”理解为副词，都修饰“used”，整个短语理解为“最近最少使用”。"
"这两种理解方式的实际意义基本相同。</para></tip>一个页常常最初处于在线或活动状"
"态。在线时，页常常关联于某处的页表。虚拟内存系统通过扫描在一个较活跃的页队列"
"(LRU)确定页的年龄，以便将他们移到一个较不活跃的页队列中。移动到缓存中的页依然"
"与一个VM对象关联，但被作为立即再用的候选。在自由对列中的页是真正未被使用的。"
"FreeBSD尽量不将页放在自由队列中，但是必须保持一定数量的自由页，以便响应中断时"
"分配。"

#. (itstool) path: sect1/para
#: book.translate.xml:14680
msgid ""
"If a process attempts to access a page that does not exist in its page table "
"but does exist in one of the paging queues (such as the inactive or cache "
"queues), a relatively inexpensive page reactivation fault occurs which "
"causes the page to be reactivated. If the page does not exist in system "
"memory at all, the process must block while the page is brought in from disk."
msgstr ""
"如果一个进程试图访问一个不在页表中而在某一队列中的页(例如去活队列或缓存队"
"列)，一个相对耗费资源少的页错误发生，导致页被重激活。如果页根本不存在于系统内"
"存之中，进程必须被阻塞，此时页被从磁盘中载入。<tip><title>译者注</"
"title><para>Intel等厂商的CPU工作在保护模式时，可用来实现虚拟内存。当寻址的地"
"址空间对应着真实内存时，则正常读写；当寻址的地址空间没有对应的真实内存时，CPU"
"会产生一个“错误”，通知操作系统与磁盘等设备进行交换，读寻址则调入存储内容，写"
"寻址则写出存储内容。这个“错误”并非操作系统或应用程序开发人员犯下的错误，尽管"
"在CPU硬件实现中这与应用程序或操作系统内核崩溃的错误的发生机制相同。参见Intel"
"的CPU保护模式开发手册。</para></tip>。"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14688
msgid "<primary>paging queues</primary>"
msgstr "<primary>paging queues(页队列)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:14690
msgid ""
"FreeBSD dynamically tunes its paging queues and attempts to maintain "
"reasonable ratios of pages in the various queues as well as attempts to "
"maintain a reasonable breakdown of clean versus dirty pages. The amount of "
"rebalancing that occurs depends on the system's memory load. This "
"rebalancing is implemented by the pageout daemon and involves laundering "
"dirty pages (syncing them with their backing store), noticing when pages are "
"activity referenced (resetting their position in the LRU queues or moving "
"them between queues), migrating pages between queues when the queues are out "
"of balance, and so forth. FreeBSD's VM system is willing to take a "
"reasonable number of reactivation page faults to determine how active or how "
"idle a page actually is. This leads to better decisions being made as to "
"when to launder or swap-out a page."
msgstr ""
"FreeBSD动态的调整页队列，试图将各个队列中的页数维护在一个适当的比例上，同时管"
"理程序崩溃的已清理和未清理页。重新平衡的比例数值决定于系统内存的负担。这种重"
"新平衡由pageout守护进程实现，包括清理未清理页(与他们的后备存储同步)、监视页被"
"引用的活跃程度(重置它们在LRU队列中的位置或在不同活跃程度的页队列间移动)、当比"
"例不平衡时在队列间迁移页，如此等等。FreeBSD的VM系统会将重激活页而产生的错误频"
"率调低到一个合理的数值，由此确定某一页活跃/闲置的实际程度。这可以为更好的决定"
"何时清理/分配一个页做出决策。"

#. (itstool) path: sect1/title
#: book.translate.xml:14707
#, fuzzy
msgid "The Unified Buffer Cache—<literal>vm_object_t</literal>"
msgstr "统一的缓存信息结构体&mdash;<literal>vm_object_t</literal>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14710
msgid "<primary>unified buffer cache</primary>"
msgstr "<primary>unified buffer cache(统一缓存)</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14711
msgid "<primary><literal>vm_object_t</literal> structure</primary>"
msgstr "<primary><literal>vm_object_t</literal>结构体</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:14715
#, fuzzy
msgid ""
"FreeBSD implements the idea of a generic <quote>VM object</quote>. VM "
"objects can be associated with backing store of various types—unbacked, swap-"
"backed, physical device-backed, or file-backed storage. Since the filesystem "
"uses the same VM objects to manage in-core data relating to files, the "
"result is a unified buffer cache."
msgstr ""
"FreeBSD实现了统一的<quote>虚拟内存对象</quote>(VM对象)的设计思想。VM对象可以"
"与各种类型的内存使用方式相结合&mdash;直接使用(unbacked)、交换(swap)、物理设"
"备、文件。由于文件系统使用相同的VM对象管理核内数据&mdash;文件的缓存，所以这些"
"缓存的结构也是统一的。"

#. (itstool) path: sect1/para
#: book.translate.xml:14722
msgid ""
"VM objects can be <emphasis>shadowed</emphasis>. That is, they can be "
"stacked on top of each other. For example, you might have a swap-backed VM "
"object stacked on top of a file-backed VM object in order to implement a "
"MAP_PRIVATE mmap()ing. This stacking is also used to implement various "
"sharing properties, including copy-on-write, for forked address spaces."
msgstr ""
"VM对象可以被<emphasis>影复制</emphasis>(shadowed)。它们可以被堆放到其它类别VM"
"对象堆栈的顶端。例如，可以有一个交换VM对象，放置在文件VM对象堆栈的顶端，以实"
"现MAP_PRIVATE的mmap()操作。这样的入栈操作也可以用来实现各种各样的共享特性，包"
"括写入时复制(copy-on-write，用于日志文件系统)，以派生出地址空间。"

#. (itstool) path: sect1/para
#: book.translate.xml:14730
msgid ""
"It should be noted that a <literal>vm_page_t</literal> can only be "
"associated with one VM object at a time. The VM object shadowing implements "
"the perceived sharing of the same page across multiple instances."
msgstr ""
"应当注意，一个<literal>vm_page_t</literal>结构体在任一个时刻只能与一个VM对象"
"相关联。VM对象影复本可以实现跨实例的共享相同的页。"

#. (itstool) path: sect1/title
#: book.translate.xml:14737
#, fuzzy
msgid "Filesystem I/O—<literal>struct buf</literal>"
msgstr "文件系统输入/输出&mdash;<literal>buf</literal>结构体"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14739
msgid "<primary>vnode</primary>"
msgstr "<primary>vnode</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:14740
msgid ""
"vnode-backed VM objects, such as file-backed objects, generally need to "
"maintain their own clean/dirty info independent from the VM system's idea of "
"clean/dirty. For example, when the VM system decides to synchronize a "
"physical page to its backing store, the VM system needs to mark the page "
"clean before the page is actually written to its backing store. "
"Additionally, filesystems need to be able to map portions of a file or file "
"metadata into KVM in order to operate on it."
msgstr ""
"vnode VM对象，比如文件VM对象，一般需要维护它们自己的清理(clean)/未清理(dirty)"
"信息，而不依赖于文件系统的清理/未清理维护。例如，当VM系统要同步一个物理页和其"
"对应的实际存储器，VM系统就需要在写入到实际存储器前将该页标记为已清理。另外，"
"文件系统要能够将文件或文件元数据的各部分映射到内核虚拟内存(KVM)中以便操作。"

#. (itstool) path: sect1/para
#: book.translate.xml:14749
msgid ""
"The entities used to manage this are known as filesystem buffers, "
"<literal>struct buf</literal>'s, or <literal>bp</literal>'s. When a "
"filesystem needs to operate on a portion of a VM object, it typically maps "
"part of the object into a struct buf and then maps the pages in the struct "
"buf into KVM. In the same manner, disk I/O is typically issued by mapping "
"portions of objects into buffer structures and then issuing the I/O on the "
"buffer structures. The underlying vm_page_t's are typically busied for the "
"duration of the I/O. Filesystem buffers also have their own notion of being "
"busy, which is useful to filesystem driver code which would rather operate "
"on filesystem buffers instead of hard VM pages."
msgstr ""
"用来进行这些管理的实体就是众所周知的文件系统缓存，<literal>struct buf</"
"literal>或<literal>bp</literal>。当文件系统需要对一个VM对象的一部分操作时，它"
"常会将这个对象的这部分映射到struct buf，并且将struct buf中页映射到内核虚拟内"
"存(KVM)中。同样的，磁盘输入/输出通常要先将VM对象的各部分映射到buf结构体中，然"
"后对buf结构体进行输入/输出操作。下层的vm_page_t在输入/输出期间通常被标记"
"为“忙”。文件系统缓存也会“忙”，这对于文件系统驱动程序非常有用，对文件系统缓存"
"操作比对VM真实页(hard)操作更好。"

#. (itstool) path: sect1/para
#: book.translate.xml:14762
msgid ""
"FreeBSD reserves a limited amount of KVM to hold mappings from struct bufs, "
"but it should be made clear that this KVM is used solely to hold mappings "
"and does not limit the ability to cache data. Physical data caching is "
"strictly a function of <literal>vm_page_t</literal>'s, not filesystem "
"buffers. However, since filesystem buffers are used to placehold I/O, they "
"do inherently limit the amount of concurrent I/O possible. However, as there "
"are usually a few thousand filesystem buffers available, this is not usually "
"a problem."
msgstr ""
"FreeBSD保留一定数量的内核虚拟内存来存放struct buf的映射，但是这些buf结构体应"
"该是被清理过的。这些内核虚拟内存仅用来存放映射，并不限制缓存数据的能力。严格"
"的说，物理数据缓存是<literal>vm_page_t</literal>的一个功能，不是文件系统缓存"
"的功能。然而，由于文件系统缓存被用来处理输入/输出，他们固有的限制了同时进行输"
"入/输出可能的数量。但是，由于通常有数千文件系统缓存可供使用，所以这并不会造成"
"问题。"

#. (itstool) path: sect1/title
#: book.translate.xml:14774
#, fuzzy
msgid "Mapping Page Tables—<literal>vm_map_t, vm_entry_t</literal>"
msgstr "映射页表&mdash;<literal>vm_map_t, vm_entry_t</literal>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14777
msgid "<primary>page tables</primary>"
msgstr "<primary>page tables(页表)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:14778
msgid ""
"FreeBSD separates the physical page table topology from the VM system. All "
"hard per-process page tables can be reconstructed on the fly and are usually "
"considered throwaway. Special page tables such as those managing KVM are "
"typically permanently preallocated. These page tables are not throwaway."
msgstr ""
"FreeBSD将物理页表结构从VM系统中分离了出来。各进程的所有页表可以脱离进程(on "
"the fly)重建，并且通常被认为是一次性的。特殊的页表，如内核虚拟内存(KVM)，常常"
"是被永久性预分配的；这些页表不是一次性的。"

#. (itstool) path: sect1/para
#: book.translate.xml:14785
msgid ""
"FreeBSD associates portions of vm_objects with address ranges in virtual "
"memory through <literal>vm_map_t</literal> and <literal>vm_entry_t</literal> "
"structures. Page tables are directly synthesized from the <literal>vm_map_t</"
"literal>/<literal>vm_entry_t</literal>/ <literal>vm_object_t</literal> "
"hierarchy. Recall that I mentioned that physical pages are only directly "
"associated with a <literal>vm_object</literal>; that is not quite true. "
"<literal>vm_page_t</literal>'s are also linked into page tables that they "
"are actively associated with. One <literal>vm_page_t</literal> can be linked "
"into several <emphasis>pmaps</emphasis>, as page tables are called. However, "
"the hierarchical association holds, so all references to the same page in "
"the same object reference the same <literal>vm_page_t</literal> and thus "
"give us buffer cache unification across the board."
msgstr ""
"FreeBSD通过<literal>vm_map_t</literal>和<literal>vm_entry_t</literal>结构将虚"
"拟内存中<literal>vm_objects</literal>的各地址范围部分关联起来。页表被直接的从"
"<literal>vm_map_t</literal>/<literal>vm_entry_t</literal>/"
"<literal>vm_object_t</literal>中有层次的合成出来。这里需要重申一下，我曾提到"
"的“物理页仅直接与<literal>vm_object</literal>相关联”并不很正确。"
"<literal>vm_page_t</literal>也被会被链接到正在与之相关联的页表中。当页表被调"
"用时，一个<literal>vm_page_t</literal>结构体可以被链接到几个<emphasis>pmaps</"
"emphasis>。然而，由于有了层次的关联，因此在对象中所有对同一页的引用会引用同一"
"<literal>vm_page_t</literal>结构体，这样就实现了跨区域(board)的缓存的统一。"

#. (itstool) path: sect1/title
#: book.translate.xml:14804
msgid "KVM Memory Mapping"
msgstr "KVM存储映射"

#. (itstool) path: sect1/para
#: book.translate.xml:14806
msgid ""
"FreeBSD uses KVM to hold various kernel structures. The single largest "
"entity held in KVM is the filesystem buffer cache. That is, mappings "
"relating to <literal>struct buf</literal> entities."
msgstr ""
"FreeBSD使用KVM存放各种各样的内核结构体。在KVM中最大的单个实体是文件系统缓存。"
"那是与<literal>struct buf</literal>实体有关的映射。"

#. (itstool) path: sect1/para
#: book.translate.xml:14811
msgid ""
"Unlike Linux, FreeBSD does <emphasis>not</emphasis> map all of physical "
"memory into KVM. This means that FreeBSD can handle memory configurations up "
"to 4G on 32 bit platforms. In fact, if the mmu were capable of it, FreeBSD "
"could theoretically handle memory configurations up to 8TB on a 32 bit "
"platform. However, since most 32 bit platforms are only capable of mapping "
"4GB of ram, this is a moot point."
msgstr ""
"不像Linux，FreeBSD<emphasis>不</emphasis>将所有的物理内存映射到KVM中。这意味"
"着FreeBSD可以在32位平台上管理超过4GB的内存配置。事实上，如果mmu(译者注：可能"
"是指“内存管理单元”，“Memory Management Unit”)有足够的能力，FreeBSD理论上可以"
"在32位平台上管理最多8TB的内存配置。然而，大多数32平台只能映射4GB内存，这只能"
"是一个争论点。"

#. (itstool) path: sect1/para
#: book.translate.xml:14819
msgid ""
"KVM is managed through several mechanisms. The main mechanism used to manage "
"KVM is the <emphasis>zone allocator</emphasis>. The zone allocator takes a "
"chunk of KVM and splits it up into constant-sized blocks of memory in order "
"to allocate a specific type of structure. You can use <command>vmstat -m</"
"command> to get an overview of current KVM utilization broken down by zone."
msgstr ""
"有几种机制可以管理KVM。管理KVM的主要机制是<emphasis>区域分配器</"
"emphasis>(zone allocator)。区域分配器管理着KVM的大块，再将大块切分为恒定大小"
"的小块，以便按照某一种类型的结构体分配。你可以使用命令<command>vmstat -m</"
"command>一览当前KVM分区使用情况。"

#. (itstool) path: sect1/title
#: book.translate.xml:14829
msgid "Tuning the FreeBSD VM System"
msgstr "调整FreeBSD的虚拟内存系统"

#. (itstool) path: sect1/para
#: book.translate.xml:14831
msgid ""
"A concerted effort has been made to make the FreeBSD kernel dynamically tune "
"itself. Typically you do not need to mess with anything beyond the "
"<option>maxusers</option> and <option>NMBCLUSTERS</option> kernel config "
"options. That is, kernel compilation options specified in (typically) "
"<filename>/usr/src/sys/i386/conf/<replaceable>CONFIG_FILE</replaceable></"
"filename>. A description of all available kernel configuration options can "
"be found in <filename>/usr/src/sys/i386/conf/LINT</filename>."
msgstr ""
"开发者的协同努力使得FreeBSD可以自行动态调整内核。一般来说，除了内核配置选项"
"<option>maxusers</option>和<option>NMBCLUSTERS</option>，你不需要做任何杂乱的"
"事情。这些内核编译配置选项(一般)被指定在<filename>/usr/src/sys/i386/conf/"
"CONFIG_FILE</filename>之中。所有可用内核配置选项的描述可在<filename>/usr/src/"
"sys/i386/conf/LINT</filename>中找到。"

#. (itstool) path: sect1/para
#: book.translate.xml:14841
msgid ""
"In a large system configuration you may wish to increase <option>maxusers</"
"option>. Values typically range from 10 to 128. Note that raising "
"<option>maxusers</option> too high can cause the system to overflow "
"available KVM resulting in unpredictable operation. It is better to leave "
"<option>maxusers</option> at some reasonable number and add other options, "
"such as <option>NMBCLUSTERS</option>, to increase specific resources."
msgstr ""
"在一个大系统的配置中，你可能需要增加<option>maxusers</option>的值。数值范围通"
"常在10到128。注意，过度增加<option>maxusers</option>的值可能导致系统从实际可"
"用的KVM中溢出，从而引起无法预知的操作。最好将<option>maxusers</option>设为一"
"个合理的数值，并且添加其它选项，如<option>NMBCLUSTERS</option>，来增加特定的"
"资源。"

#. (itstool) path: sect1/para
#: book.translate.xml:14850
msgid ""
"If your system is going to use the network heavily, you may want to increase "
"<option>NMBCLUSTERS</option>. Typical values range from 1024 to 4096."
msgstr ""
"如果你的系统要被重负荷的使用网络，你需要增加<option>NMBCLUSTERS</option>的"
"值。数值范围通常在1024到4096。"

#. (itstool) path: sect1/para
#: book.translate.xml:14854
msgid ""
"The <literal>NBUF</literal> parameter is also traditionally used to scale "
"the system. This parameter determines the amount of KVA the system can use "
"to map filesystem buffers for I/O. Note that this parameter has nothing "
"whatsoever to do with the unified buffer cache! This parameter is "
"dynamically tuned in 3.0-CURRENT and later kernels and should generally not "
"be adjusted manually. We recommend that you <emphasis>not</emphasis> try to "
"specify an <literal>NBUF</literal> parameter. Let the system pick it. Too "
"small a value can result in extremely inefficient filesystem operation while "
"too large a value can starve the page queues by causing too many pages to "
"become wired down."
msgstr ""
"<literal>NBUF</literal>也是传统的规划系统的参数。这个参数决定系统可用来映射文"
"件系统输入/输出缓存的KVM的数量。注意：这个参数与统一的缓存没有任何关系。这个"
"参数可在3.0-CURRENT和以后的内核中被动态的调节，通常不应当被手动的调节。我们推"
"荐你<emphasis>不要</emphasis>指定<literal>NBUF</literal>。让系统自行确定它。"
"太小的值会导致非常低效的文件系统操作；太大的值会使用页队列中缺少页面，而大量"
"的页处于在线状态。"

#. (itstool) path: sect1/para
#: book.translate.xml:14867
msgid ""
"By default, FreeBSD kernels are not optimized. You can set debugging and "
"optimization flags with the <literal>makeoptions</literal> directive in the "
"kernel configuration. Note that you should not use <option>-g</option> "
"unless you can accommodate the large (typically 7 MB+) kernels that result."
msgstr ""
"缺省情况下，FreeBSD内核编译时是不被优化的。你可以在内核配置文件中用"
"<literal>makeoptions</literal>指定排错(debugging)和优化标志。注意，你一般不应"
"使用<option>-g</option>，除非你能够应付由此产生的大内核(典型的是7MB或更多)。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:14874
#, no-wrap
msgid ""
"makeoptions      DEBUG=\"-g\"\n"
"makeoptions      COPTFLAGS=\"-O -pipe\""
msgstr ""
"makeoptions      DEBUG=\"-g\"\n"
"makeoptions      COPTFLAGS=\"-O -pipe\""

#. (itstool) path: sect1/para
#: book.translate.xml:14877
msgid ""
"Sysctl provides a way to tune kernel parameters at run-time. You typically "
"do not need to mess with any of the sysctl variables, especially the VM "
"related ones."
msgstr ""
"Sysctl提供了在运行时调整内核的方式。你通常不需要指定任何sysctl变量，尤其是与"
"VM相关的那些变量。"

#. (itstool) path: sect1/para
#: book.translate.xml:14881
msgid ""
"Run time VM and system tuning is relatively straightforward. First, use Soft "
"Updates on your UFS/FFS filesystems whenever possible. <filename>/usr/src/"
"sys/ufs/ffs/README.softupdates</filename> contains instructions (and "
"restrictions) on how to configure it."
msgstr ""
"运行时VM和系统调整的影响相对直接一些。首先，应当尽可能在UFS/FFS文件系统上使用"
"Soft Updates。在<filename>/usr/src/sys/ufs/ffs/README.softupdates</filename>"
"里有关于如何配置的指示。"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14888
msgid "<primary>swap partition</primary>"
msgstr "<primary>swap partition(交换分区)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:14889
msgid ""
"Second, configure sufficient swap. You should have a swap partition "
"configured on each physical disk, up to four, even on your <quote>work</"
"quote> disks. You should have at least 2x the swap space as you have main "
"memory, and possibly even more if you do not have a lot of memory. You "
"should also size your swap partition based on the maximum memory "
"configuration you ever intend to put on the machine so you do not have to "
"repartition your disks later on. If you want to be able to accommodate a "
"crash dump, your first swap partition must be at least as large as main "
"memory and <filename>/var/crash</filename> must have sufficient free space "
"to hold the dump."
msgstr ""
"其次，应当配置足够多的交换空间。你应当在每个物理磁盘上配置一个交换分区，最多4"
"个，甚至在你的<quote>工作</quote>磁盘上。你应当有至少2倍于主内存的交换空间；"
"假如你没有足够内存的话，交换分区还应更多。你也应当按照你期望中的最大内存配置"
"决定交换分区的大小，这样以后就不再需要重新给磁盘分区了。如果你处理系统崩溃后"
"的内存倾倒(crash dump)，第一个交换分区必须至少与主内存一样大，<filename>/var/"
"crash</filename>必须有足够的空间来承装倾倒。"

#. (itstool) path: sect1/para
#: book.translate.xml:14901
msgid ""
"NFS-based swap is perfectly acceptable on 4.X or later systems, but you must "
"be aware that the NFS server will take the brunt of the paging load."
msgstr ""
"NFS上的交换分区可以很好的被4.X或后来的系统使用，但是你必须明白NFS服务器将要经"
"受页装载操作很强的冲击。"

#. (itstool) path: info/title
#: book.translate.xml:14915
msgid "SMPng Design Document"
msgstr "SMPng 设计文档"

#. (itstool) path: authorgroup/author
#: book.translate.xml:14917
msgid ""
"<personname><firstname>John</firstname><surname>Baldwin</surname></"
"personname><contrib>Written by </contrib>"
msgstr ""
"<personname><firstname>John</firstname><surname>Baldwin</surname></"
"personname><contrib>Written by </contrib>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:14918
msgid ""
"<personname><firstname>Robert</firstname><surname>Watson</surname></"
"personname>"
msgstr ""
"<personname><firstname>Robert</firstname><surname>Watson</surname></"
"personname>"

#. (itstool) path: info/copyright
#: book.translate.xml:14921
msgid ""
"<year>2002</year> <year>2004</year> <year>2005</year> <holder>John Baldwin</"
"holder> <holder>Robert Watson</holder>"
msgstr ""
"<year>2002</year> <year>2004</year> <year>2005</year> <holder>John Baldwin</"
"holder> <holder>Robert Watson</holder>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14935
msgid "<primary>SMP Next Generation</primary>"
msgstr "<primary>SMP Next Generation Project(下一代对称多处理工程)</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14936
msgid "<primary>kernel synchronization</primary>"
msgstr "<primary>kernel synchronization(内核同步)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:14938
msgid ""
"This document presents the current design and implementation of the SMPng "
"Architecture. First, the basic primitives and tools are introduced. Next, a "
"general architecture for the FreeBSD kernel's synchronization and execution "
"model is laid out. Then, locking strategies for specific subsystems are "
"discussed, documenting the approaches taken to introduce fine-grained "
"synchronization and parallelism for each subsystem. Finally, detailed "
"implementation notes are provided to motivate design choices, and make the "
"reader aware of important implications involving the use of specific "
"primitives."
msgstr ""
"这份文档对目前 SMPng 架构的设计与实现进行了介绍。它首先介绍了基本的原语和相关"
"工具， 其后是关于FreeBSD 内核的同步与执行模型， 接下来讨论了具体系统中的锁策"
"略，并描述了在各个子系统中引入细粒度的同步和实现并行化的步骤，最后是详细的实"
"现说明， 用以解释最初做出某些设计决策的动机，并使读者了解使用特定的原语所可能"
"产生的重大影响。"

#. (itstool) path: sect1/para
#: book.translate.xml:14949
msgid ""
"This document is a work-in-progress, and will be updated to reflect on-going "
"design and implementation activities associated with the SMPng Project. Many "
"sections currently exist only in outline form, but will be fleshed out as "
"work proceeds. Updates or suggestions regarding the document may be directed "
"to the document editors."
msgstr ""
"这份文档仍在撰写当中， 并将不断更新以反映与 SMPng项目有关的最新设计与实现的情"
"况。 其中有许多小节目前还只是提纲，但我们会逐渐为其充实内容。 关于这份文档的"
"更新和建议，请发给文档编辑。"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14956
msgid "<primary>concurrency</primary>"
msgstr "<primary>concurrency(并发)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:14957
msgid ""
"The goal of SMPng is to allow concurrency in the kernel. The kernel is "
"basically one rather large and complex program. To make the kernel multi-"
"threaded we use some of the same tools used to make other programs multi-"
"threaded. These include mutexes, shared/exclusive locks, semaphores, and "
"condition variables. For the definitions of these and other SMP-related "
"terms, please see the <xref linkend=\"smp-glossary\"/> section of this "
"article."
msgstr ""
"SMPng 的目标是使内核能够并发执行。 基本上，内核是一个很大而复杂的程序。 要让"
"内核能够多线程地执行，我们需要使用某些其它多线程程序在实现时所用到的工具，这"
"包括互斥体(mutex)、 共享/排他锁(shared/exclusive lock)、信号量(semaphores) 和"
"条件变量(condition variable)。如果希望了解它们以及其它 SMP 术语，请参阅本文"
"的 <xref linkend=\"smp-glossary\"/> 一节。"

#. (itstool) path: sect1/title
#: book.translate.xml:14967
msgid "Basic Tools and Locking Fundamentals"
msgstr "基本工具与上锁的基础知识"

#. (itstool) path: sect2/title
#: book.translate.xml:14970
msgid "Atomic Instructions and Memory Barriers"
msgstr "原子操作指令和内存栅"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:14972
msgid "<primary>atomic instructions</primary>"
msgstr "<primary>atomic instructions(原子操作指令)</primary>"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:14973
msgid "<primary>memory barriers</primary>"
msgstr "<primary>memory barriers(内存栅)</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:14975
msgid ""
"There are several existing treatments of memory barriers and atomic "
"instructions, so this section will not include a lot of detail. To put it "
"simply, one can not go around reading variables without a lock if a lock is "
"used to protect writes to that variable. This becomes obvious when you "
"consider that memory barriers simply determine relative order of memory "
"operations; they do not make any guarantee about timing of memory "
"operations. That is, a memory barrier does not force the contents of a CPU's "
"local cache or store buffer to flush. Instead, the memory barrier at lock "
"release simply ensures that all writes to the protected data will be visible "
"to other CPU's or devices if the write to release the lock is visible. The "
"CPU is free to keep that data in its cache or store buffer as long as it "
"wants. However, if another CPU performs an atomic instruction on the same "
"datum, the first CPU must guarantee that the updated value is made visible "
"to the second CPU along with any other operations that memory barriers may "
"require."
msgstr ""
"关于内存栅和原子操作指令已经有很多介绍材料，因此这一节并不打算对其进行详尽的"
"介绍。 简而言之， 如果有对某一变量上写锁，就不能在不获得相应的锁时对其进行读"
"取操作。 也就是说，内存栅的作用在于保证内存操作的相对顺序， 但并不保证内存操"
"作的严格时序。换言之， 内存栅并不保证 CPU 将本地快取缓存或存储缓冲的内容刷写"
"回内存，而是在锁释放时确保其所保护的数据， 对于能看到刚释放的那个锁的 CPU或设"
"备可见。 持有内存栅的 CPU可以在其快取缓存或存储缓冲中将数据保持其所希望的、 "
"任意长的时间，但如果其它 CPU 在同一数据元上执行原子操作， 则第一个 CPU 必须保"
"证，其所更新的数据值， 以及内存栅所要求的任何其它操作， 对第二个 CPU 可见。"

#. (itstool) path: sect2/para
#: book.translate.xml:14994
msgid ""
"For example, assuming a simple model where data is considered visible when "
"it is in main memory (or a global cache), when an atomic instruction is "
"triggered on one CPU, other CPU's store buffers and caches must flush any "
"writes to that same cache line along with any pending operations behind a "
"memory barrier."
msgstr ""
"例如， 假设在一简单模型中， 认为在主存 (或某一全局快取缓存)中的数据是可见"
"的， 当某一 CPU 上触发原子操作时， 其它 CPU的存储缓冲和快取缓存就必须对同一快"
"取缓存线上的全部写操作，以及内存栅之后的全部未完成操作进行刷写。"

#. (itstool) path: sect2/para
#: book.translate.xml:15001
msgid ""
"This requires one to take special care when using an item protected by "
"atomic instructions. For example, in the sleep mutex implementation, we have "
"to use an <function>atomic_cmpset</function> rather than an "
"<function>atomic_set</function> to turn on the <constant>MTX_CONTESTED</"
"constant> bit. The reason is that we read the value of <varname remap="
"\"structfield\">mtx_lock</varname> into a variable and then make a decision "
"based on that read. However, the value we read may be stale, or it may "
"change while we are making our decision. Thus, when the "
"<function>atomic_set</function> executed, it may end up setting the bit on "
"another value than the one we made the decision on. Thus, we have to use an "
"<function>atomic_cmpset</function> to set the value only if the value we "
"made the decision on is up-to-date and valid."
msgstr ""
"这样一来， 在使用由原子操作保护的内存单元时就需要特别小心。例如， 在实现 "
"sleep mutex 时， 我们就必须使用<function>atomic_cmpset</function> 而不是"
"<function>atomic_set</function> 来打开<constant>MTX_CONTESTED</constant> "
"位。 这样做的原因是，我们需要把 <varname remap=\"structfield\">mtx_lock</"
"varname> 的值读到某个变量，并据此进行决策。 然而， 我们读到的值可能是过时的，"
"也可能在我们进行决策的过程中发生变化。 因此， 当执行<function>atomic_set</"
"function> 时， 最终可能会对另一值进行置位，而不是我们进行决策的那一个。 这就"
"必须通过<function>atomic_cmpset</function> 来保证只有在我们的决策依据是最新的"
"时，才对相应的变量进行置位。"

#. (itstool) path: sect2/para
#: book.translate.xml:15018
msgid ""
"Finally, atomic instructions only allow one item to be updated or read. If "
"one needs to atomically update several items, then a lock must be used "
"instead. For example, if two counters must be read and have values that are "
"consistent relative to each other, then those counters must be protected by "
"a lock rather than by separate atomic instructions."
msgstr ""
"最后， 原子操作只允许一次更新或读一个内存单元。需要原子地更新多个单元时， 就"
"必须使用锁来代替它了。例如， 如果需要更新两个相互关联的计数器时，就必须使用"
"锁， 而不是两次单独的原子操作了。"

#. (itstool) path: sect2/title
#: book.translate.xml:15027
msgid "Read Locks Versus Write Locks"
msgstr "读锁与写锁"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15029
msgid "<primary>read locks</primary>"
msgstr "<primary>read locks</primary>"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15030
msgid "<primary>write locks</primary>"
msgstr "<primary>write locks(写锁)</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:15031
msgid ""
"Read locks do not need to be as strong as write locks. Both types of locks "
"need to ensure that the data they are accessing is not stale. However, only "
"write access requires exclusive access. Multiple threads can safely read a "
"value. Using different types of locks for reads and writes can be "
"implemented in a number of ways."
msgstr ""
"读锁并不需要像写锁那样强。 这两种类型的锁，都需要确保通过它们访问的不是过时的"
"数据。 然而，只有写操作必须是排他的， 而多个线程则可以安全地读同一变量的值。"
"使用不同类型的锁用于读和写操作有许多各自不同的实现方式。"

#. (itstool) path: sect2/para
#: book.translate.xml:15038
msgid ""
"First, sx locks can be used in this manner by using an exclusive lock when "
"writing and a shared lock when reading. This method is quite straightforward."
msgstr ""
"第一种方法是用 sx 锁， 它可以用于实现写时使用的排他锁，而读时则作为共享锁。 "
"这种方法十分简单明了。"

#. (itstool) path: sect2/para
#: book.translate.xml:15042
msgid ""
"A second method is a bit more obscure. You can protect a datum with multiple "
"locks. Then for reading that data you simply need to have a read lock of one "
"of the locks. However, to write to the data, you need to have a write lock "
"of all of the locks. This can make writing rather expensive but can be "
"useful when data is accessed in various ways. For example, the parent "
"process pointer is protected by both the <varname>proctree_lock</varname> sx "
"lock and the per-process mutex. Sometimes the proc lock is easier as we are "
"just checking to see who a parent of a process is that we already have "
"locked. However, other places such as <function>inferior</function> need to "
"walk the tree of processes via parent pointers and locking each process "
"would be prohibitive as well as a pain to guarantee that the condition you "
"are checking remains valid for both the check and the actions taken as a "
"result of the check."
msgstr ""
"第二种方法则略显晦涩。 可以用多个锁来保护同一数据元。读时， 只需锁其中的一个"
"读锁即可。 然而， 如果要写数据的话，则需要首先上所有的写锁。 这会大大提高写操"
"作的代价，但当可能以多种方式访问数据时却可能非常有用。 例如，父进程指针是同时"
"受<varname>proctree_lock</varname> sx 锁和进程 mutex 保护的。在只希望检查已锁"
"进程的父进程时， 用 proc 锁更为方便。但是， 其它一些地方， 例如"
"<function>inferior</function> 这类需要通过父指针在进程树上进行搜索，并对每个"
"进程上锁的地方就不能这样做了，否则， 将无法保证在对我们所获得的结果执行操作"
"时，之前检查时的状况依旧有效。"

#. (itstool) path: sect2/title
#: book.translate.xml:15061
msgid "Locking Conditions and Results"
msgstr "上锁状态和结果"

#. (itstool) path: sect2/para
#: book.translate.xml:15063
msgid ""
"If you need a lock to check the state of a variable so that you can take an "
"action based on the state you read, you can not just hold the lock while "
"reading the variable and then drop the lock before you act on the value you "
"read. Once you drop the lock, the variable can change rendering your "
"decision invalid. Thus, you must hold the lock both while reading the "
"variable and while performing the action as a result of the test."
msgstr ""
"如果您需要使用锁来保持所检查变量的状态， 并据此执行某些操作时，是不能仅仅在读"
"变量之前对其上锁， 并在执行操作之前解锁的。过早解锁将使变量再次可变， 这可能"
"会导致之前所做的决策失效。因此， 在所做检测引发的动作结束之前， 必须继续保持"
"上锁状态。"

#. (itstool) path: sect1/title
#: book.translate.xml:15075
msgid "General Architecture and Design"
msgstr "架构与设计概览"

#. (itstool) path: sect2/title
#: book.translate.xml:15078
msgid "Interrupt Handling"
msgstr "对中断的处理"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15080
msgid "<primary>interrupt handling</primary>"
msgstr "<primary>interrupt handling(中断处理)</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:15082
#, fuzzy
msgid ""
"Following the pattern of several other multi-threaded <trademark class="
"\"registered\">UNIX</trademark> kernels, FreeBSD deals with interrupt "
"handlers by giving them their own thread context. Providing a context for "
"interrupt handlers allows them to block on locks. To help avoid latency, "
"however, interrupt threads run at real-time kernel priority. Thus, interrupt "
"handlers should not execute for very long to avoid starving other kernel "
"threads. In addition, since multiple handlers may share an interrupt thread, "
"interrupt handlers should not sleep or use a sleepable lock to avoid "
"starving another interrupt handler."
msgstr ""
"与许多其它多线程 &unix; 内核所采取的模式类似， FreeBSD会赋予中断处理程序独立"
"的线程上下文，这样做能够让中断线程在遇到锁时阻塞。 但为了避免不必要的延迟，中"
"断线程在内核中， 是以实时线程的优先级运行的。 因此，中断处理程序不应执行过"
"久， 以免饿死其它内核线程。 此外，由于多个处理程序可以分享同一中断线程， 中断"
"处理程序不应休眠，或使用可能导致休眠的锁， 以避免将其它中断处理程序饿死。"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15093
msgid "<primary>interrupt threads</primary>"
msgstr "<primary>interrupt threads</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:15095
msgid ""
"The interrupt threads currently in FreeBSD are referred to as heavyweight "
"interrupt threads. They are called this because switching to an interrupt "
"thread involves a full context switch. In the initial implementation, the "
"kernel was not preemptive and thus interrupts that interrupted a kernel "
"thread would have to wait until the kernel thread blocked or returned to "
"userland before they would have an opportunity to run."
msgstr ""
"目前在 FreeBSD 中的中断线程是指重量级中断线程。这样称呼它们的原因在于， 转到"
"中断线程需要执行一次完整的上下文切换操作。在最初的实现中， 内核不允许抢占， "
"因此中断在打断内核线程之前，必须等待内核线程阻塞或返回用户态之后才能执行。"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15104
msgid "<primary>latency</primary>"
msgstr "<primary>latency(响应时间)</primary>"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15105
msgid "<primary>preemption</primary>"
msgstr "<primary>preemption(抢占)</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:15107
msgid ""
"To deal with the latency problems, the kernel in FreeBSD has been made "
"preemptive. Currently, we only preempt a kernel thread when we release a "
"sleep mutex or when an interrupt comes in. However, the plan is to make the "
"FreeBSD kernel fully preemptive as described below."
msgstr ""
"为了解决响应时间问题， FreeBSD 内核现在采用了抢占式调度策略。目前， 只有释放"
"休眠 mutex 或发生中断时才能抢断内核线程，但最终目标是在 FreeBSD 上实现下面所"
"描述的全抢占式调度策略。"

#. (itstool) path: sect2/para
#: book.translate.xml:15113
msgid ""
"Not all interrupt handlers execute in a thread context. Instead, some "
"handlers execute directly in primary interrupt context. These interrupt "
"handlers are currently misnamed <quote>fast</quote> interrupt handlers since "
"the <constant>INTR_FAST</constant> flag used in earlier versions of the "
"kernel is used to mark these handlers. The only interrupts which currently "
"use these types of interrupt handlers are clock interrupts and serial I/O "
"device interrupts. Since these handlers do not have their own context, they "
"may not acquire blocking locks and thus may only use spin mutexes."
msgstr ""
"并非所有的中断处理程序都在独立的线程上下文中执行。相反， 某些处理程序会直接在"
"主中断上下文中执行。 这些中断处理程序，现在被错误地命名为<quote>快速</quote> "
"中断处理程序， 因为早期版本的内核中使用了<constant>INTR_FAST</constant> 标志"
"来标记这些处理程序。目前只有时钟中断和串口 I/O 设备中断采用这一类型。由于这些"
"处理程序没有独立的上下文， 因而它们都不能获得阻塞性锁，因此也就只能使用自旋 "
"mutex。"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15125
msgid "<primary>context switches</primary>"
msgstr ""
"<primary>context switches(上下文切换，现场切换，CPU运行环境切换)</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:15127
msgid ""
"Finally, there is one optional optimization that can be added in MD code "
"called lightweight context switches. Since an interrupt thread executes in a "
"kernel context, it can borrow the vmspace of any process. Thus, in a "
"lightweight context switch, the switch to the interrupt thread does not "
"switch vmspaces but borrows the vmspace of the interrupted thread. In order "
"to ensure that the vmspace of the interrupted thread does not disappear out "
"from under us, the interrupted thread is not allowed to execute until the "
"interrupt thread is no longer borrowing its vmspace. This can happen when "
"the interrupt thread either blocks or finishes. If an interrupt thread "
"blocks, then it will use its own context when it is made runnable again. "
"Thus, it can release the interrupted thread."
msgstr ""
"最后， 还有一种称为轻量级上下文切换的优化，可以在 MD 代码中使用。 因为中断线"
"程都是在内核上下文中执行的，所以它可以借用任意进程的 vmspace (虚拟内存地址空"
"间)。 因此，在轻量级上下文切换中， 切换到中断线程并不切换对应的 vmspace，而是"
"借用被中断线程的 vmspace。 为确保被中断线程的 vmspace不在中断处理过程中消"
"失， 被中断线程在中断线程不再借用其 vmspace之前是不允许执行的。 刚才提到的情"
"况可能在中断线程阻塞或完成时发生。如果中断线程发生阻塞， 则它再次进入可运行状"
"态时将使用自己的上下文，这样一来， 就可以释放被中断的线程了。"

#. (itstool) path: sect2/para
#: book.translate.xml:15142
msgid ""
"The cons of this optimization are that they are very machine specific and "
"complex and thus only worth the effort if their is a large performance "
"improvement. At this point it is probably too early to tell, and in fact, "
"will probably hurt performance as almost all interrupt handlers will "
"immediately block on Giant and require a thread fix-up when they block. "
"Also, an alternative method of interrupt handling has been proposed by Mike "
"Smith that works like so:"
msgstr ""
"这种优化的坏处在于它们和硬件紧密相关， 而且实现比较复杂，因此只有在这样做能带"
"来大幅性能改善时才应采用。目前这样说可能还为时过早， 而且事实上可能会反而导致"
"性能下降，因为几乎所有的中断处理程序都会立即被全局锁 (Giant) 阻塞，而这种阻塞"
"将进而需要线程修正。 另外， Mike Smith提议采用另一种方式来处理中断线程："

#. (itstool) path: listitem/para
#: book.translate.xml:15153
msgid ""
"Each interrupt handler has two parts: a predicate which runs in primary "
"interrupt context and a handler which runs in its own thread context."
msgstr ""
"每个中断处理程序分为两部分， 一个在主中断上下文中运行的主体(predicate) 和一个"
"在自己的线程上下文中执行的处理程序 (handler)。"

#. (itstool) path: listitem/para
#: book.translate.xml:15159
msgid ""
"If an interrupt handler has a predicate, then when an interrupt is "
"triggered, the predicate is run. If the predicate returns true then the "
"interrupt is assumed to be fully handled and the kernel returns from the "
"interrupt. If the predicate returns false or there is no predicate, then the "
"threaded handler is scheduled to run."
msgstr ""
"如果中断处理程序拥有主体， 则当触发中断时， 执行该主体。如果主体返回真， 则认"
"为该中断被处理完毕， 内核从中断返回。如果主体返回假， 或者中断没有主体， 则调"
"度运行线程式处理程序。"

#. (itstool) path: sect2/para
#: book.translate.xml:15168
msgid ""
"Fitting light weight context switches into this scheme might prove rather "
"complicated. Since we may want to change to this scheme at some point in the "
"future, it is probably best to defer work on light weight context switches "
"until we have settled on the final interrupt handling architecture and "
"determined how light weight context switches might or might not fit into it."
msgstr ""
"在这一模式中适当地采用轻量级上下文切换可能是非常复杂的。因为我们可能会希望在"
"未来改变这一模式， 因此现在最好的方案，应该是暂时推迟在轻量级上下文切换之上的"
"工作，以便进一步完善中断处理架构， 随后再考察轻量级上下文切换是否适用。"

#. (itstool) path: sect2/title
#: book.translate.xml:15178
msgid "Kernel Preemption and Critical Sections"
msgstr "内核抢占与临界区"

#. (itstool) path: sect3/title
#: book.translate.xml:15181
msgid "Kernel Preemption in a Nutshell"
msgstr "内核抢占简介"

#. (itstool) path: sect3/para
#: book.translate.xml:15183
msgid ""
"Kernel preemption is fairly simple. The basic idea is that a CPU should "
"always be doing the highest priority work available. Well, that is the ideal "
"at least. There are a couple of cases where the expense of achieving the "
"ideal is not worth being perfect."
msgstr ""
"内核抢占的概念很简单， 其基本思想是 CPU 总应执行优先级最高的工作。当然， 至少"
"在理想情况下是这样。 有些时候，达成这一理想的代价会十分高昂， 以至于在这些情"
"况下抢占会得不偿失。"

#. (itstool) path: sect3/para
#: book.translate.xml:15189
msgid ""
"Implementing full kernel preemption is very straightforward: when you "
"schedule a thread to be executed by putting it on a run queue, you check to "
"see if its priority is higher than the currently executing thread. If so, "
"you initiate a context switch to that thread."
msgstr ""
"实现完全的内核抢占十分简单： 在调度将要执行的线程并放入运行队列时，检查它的优"
"先级是否高于目前正在执行的线程。 如果是这样的话，执行一次上下文切换并立即开始"
"执行该线程。"

#. (itstool) path: sect3/para
#: book.translate.xml:15195
msgid ""
"While locks can protect most data in the case of a preemption, not all of "
"the kernel is preemption safe. For example, if a thread holding a spin mutex "
"preempted and the new thread attempts to grab the same spin mutex, the new "
"thread may spin forever as the interrupted thread may never get a chance to "
"execute. Also, some code such as the code to assign an address space number "
"for a process during <function>exec</function> on the Alpha needs to not be "
"preempted as it supports the actual context switch code. Preemption is "
"disabled for these code sections by using a critical section."
msgstr ""
"尽管锁能够在抢占时保护多数数据， 但内核并不是可以安全地处处抢占的。例如， 如"
"果持有自旋 mutex 的线程被抢占， 而新线程也尝试获得同一自旋mutex， 新线程就可"
"能一直自旋下去，因为被中断的线程可能永远没有机会运行了。 此外， 某些代码， 例"
"如在 Alpha 上的<function>exec</function> 对进程地址空间编号进行赋值的代码也不"
"能被抢断，因为它被用来支持实际的上下文切换操作。 在这些代码段中，会通过使用临"
"界区来临时禁用抢占。"

#. (itstool) path: sect3/title
#: book.translate.xml:15209
msgid "Critical Sections"
msgstr "临界区"

#. (itstool) path: sect3/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:15211 book.translate.xml:15333
msgid "<primary>critical sections</primary>"
msgstr "<primary>critical sections(临界区)</primary>"

#. (itstool) path: sect3/para
#: book.translate.xml:15213
msgid ""
"The responsibility of the critical section API is to prevent context "
"switches inside of a critical section. With a fully preemptive kernel, every "
"<function>setrunqueue</function> of a thread other than the current thread "
"is a preemption point. One implementation is for <function>critical_enter</"
"function> to set a per-thread flag that is cleared by its counterpart. If "
"<function>setrunqueue</function> is called with this flag set, it does not "
"preempt regardless of the priority of the new thread relative to the current "
"thread. However, since critical sections are used in spin mutexes to prevent "
"context switches and multiple spin mutexes can be acquired, the critical "
"section API must support nesting. For this reason the current implementation "
"uses a nesting count instead of a single per-thread flag."
msgstr ""
"临界区 API 的责任是避免在临界区内发生上下文切换。对于完全抢占式内核而言， 除"
"了当前线程之外的其它线程的每个<function>setrunqueue</function> 都是抢断点。"
"<function>critical_enter</function> 的一种实现方式是设置一线程私有标记，并由"
"其对应方清除。 如果调用<function>setrunqueue</function> 时设置了这个标志，则"
"无论新线程和当前线程相比其优先级高低， 都不会发生抢占。然而， 由于临界区会在"
"自旋 mutex 中用于避免上下文切换，而且能够同时获得多个自旋 mutex， 因此临界区 "
"API 必须支持嵌套。由于这个原因， 目前的实现中采用了嵌套计数，而不仅仅是单个的"
"线程标志。"

#. (itstool) path: sect3/para
#: book.translate.xml:15229
msgid ""
"In order to minimize latency, preemptions inside of a critical section are "
"deferred rather than dropped. If a thread that would normally be preempted "
"to is made runnable while the current thread is in a critical section, then "
"a per-thread flag is set to indicate that there is a pending preemption. "
"When the outermost critical section is exited, the flag is checked. If the "
"flag is set, then the current thread is preempted to allow the higher "
"priority thread to run."
msgstr ""
"为了尽可能缩短响应时间， 在临界区中的抢占被推迟，而不是直接丢弃。 如果线程应"
"被抢断， 并被置为可运行，而当前线程处于临界区， 则会设置一线程私有标志，表示"
"有一个尚未进行的抢断操作。 当最外层临界区退出时，会检查这一标志， 如果它被置"
"位， 则当前线程会被抢断，以允许更高优先级的线程开始运行。"

#. (itstool) path: sect3/indexterm
#: book.translate.xml:15239
msgid "<primary>spin mutexes</primary>"
msgstr "<primary>spin mutexes(自旋 mutex)</primary>"

#. (itstool) path: sect3/indexterm
#: book.translate.xml:15240
msgid "<primary>mutexes</primary><secondary>spin</secondary>"
msgstr ""
"<primary>mutexes(同时/独占, mutual exclusion)</primary><secondary>spin(自"
"旋)</secondary>"

#. (itstool) path: sect3/para
#: book.translate.xml:15241
msgid ""
"Interrupts pose a problem with regards to spin mutexes. If a low-level "
"interrupt handler needs a lock, it needs to not interrupt any code needing "
"that lock to avoid possible data structure corruption. Currently, providing "
"this mechanism is piggybacked onto critical section API by means of the "
"<function>cpu_critical_enter</function> and <function>cpu_critical_exit</"
"function> functions. Currently this API disables and re-enables interrupts "
"on all of FreeBSD's current platforms. This approach may not be purely "
"optimal, but it is simple to understand and simple to get right. "
"Theoretically, this second API need only be used for spin mutexes that are "
"used in primary interrupt context. However, to make the code simpler, it is "
"used for all spin mutexes and even all critical sections. It may be "
"desirable to split out the MD API from the MI API and only use it in "
"conjunction with the MI API in the spin mutex implementation. If this "
"approach is taken, then the MD API likely would need a rename to show that "
"it is a separate API."
msgstr ""
"中断会引发一个和自旋 mutex 有关的问题。如果低级中断处理程序需要锁， 它就不能"
"中断任何需要该锁的代码，以避免可能发生的损坏数据结构的情况。 目前，这一机制是"
"透过临界区 API以 <function>cpu_critical_enter</function> 和"
"<function>cpu_critical_exit</function> 函数的形式实现的。目前这一 API 会在所"
"有 FreeBSD所支持的平台上禁用和重新启用中断。 这种方法并不是最优的，但它更易理"
"解， 也更容易正确地实现。 理论上， 这一辅助 API只需要配合在主中断上下文中的自"
"旋 mutex 使用。 然而，为了让代码更为简单， 它被用在了全部自旋 mutex，甚至包括"
"所有临界区上。 将其从 MI API 中剥离出来放入 MD API，并只在需要使用它的 MI "
"API 的自旋 mutex 实现中使用可能会有更好的效果。如果我们最终采用了这种实现方"
"式， 则 MD API可能需要改名， 以彰显其为一单独 API 这一事实。"

#. (itstool) path: sect3/title
#: book.translate.xml:15263
msgid "Design Tradeoffs"
msgstr "设计折衷"

#. (itstool) path: sect3/para
#: book.translate.xml:15265
msgid ""
"As mentioned earlier, a couple of trade-offs have been made to sacrifice "
"cases where perfect preemption may not always provide the best performance."
msgstr ""
"如前面提到的， 当完全抢占并非总能提供最佳性能时，采取了一些折衷的措施。"

#. (itstool) path: sect3/para
#: book.translate.xml:15269
msgid ""
"The first trade-off is that the preemption code does not take other CPUs "
"into account. Suppose we have a two CPU's A and B with the priority of A's "
"thread as 4 and the priority of B's thread as 2. If CPU B makes a thread "
"with priority 1 runnable, then in theory, we want CPU A to switch to the new "
"thread so that we will be running the two highest priority runnable threads. "
"However, the cost of determining which CPU to enforce a preemption on as "
"well as actually signaling that CPU via an IPI along with the "
"synchronization that would be required would be enormous. Thus, the current "
"code would instead force CPU B to switch to the higher priority thread. Note "
"that this still puts the system in a better position as CPU B is executing a "
"thread of priority 1 rather than a thread of priority 2."
msgstr ""
"第一处折衷是， 抢占代码并不考虑其它 CPU 的存在。假设我们有两个 CPU， A和 B， "
"其中 A 上线程的优先级为 4，而 B 上线程的优先级是 2。 如果 CPU B 令一优先级为 "
"1的线程进入可运行状态， 则理论上， 我们希望 CPU A 切换至这一新线程，这样就有"
"两个优先级最高的线程在运行了。 然而， 确定哪个CPU 在抢占时更合适， 并通过 "
"IPI 向那个 CPU 发出信号，并完成相关的同步工作的代价十分高昂。 因此， 目前的代"
"码会强制 CPU B切换至更高优先级的线程。 请注意这样做仍会让系统进入更好的状态，"
"因为 CPU B 会去执行优先级为 1 而不是 2 的那个线程。"

#. (itstool) path: sect3/para
#: book.translate.xml:15284
msgid ""
"The second trade-off limits immediate kernel preemption to real-time "
"priority kernel threads. In the simple case of preemption defined above, a "
"thread is always preempted immediately (or as soon as a critical section is "
"exited) if a higher priority thread is made runnable. However, many threads "
"executing in the kernel only execute in a kernel context for a short time "
"before either blocking or returning to userland. Thus, if the kernel "
"preempts these threads to run another non-realtime kernel thread, the kernel "
"may switch out the executing thread just before it is about to sleep or "
"execute. The cache on the CPU must then adjust to the new thread. When the "
"kernel returns to the preempted thread, it must refill all the cache "
"information that was lost. In addition, two extra context switches are "
"performed that could be avoided if the kernel deferred the preemption until "
"the first thread blocked or returned to userland. Thus, by default, the "
"preemption code will only preempt immediately if the higher priority thread "
"is a real-time priority thread."
msgstr ""
"第二处折衷是限制对于实时优先级的内核线程的立即抢占。在前面所定义的抢占操作的"
"简单情形中， 低优先级总会被立即抢断(或在其退出临界区后被抢断)。 然而， 许多在"
"内核中执行的线程，有很多只会执行很短的时间就会阻塞或返回用户态。 因此，如果内"
"核抢断这些线程并执行其它非实时的内核线程，则内核可能会在这些线程马上要休眠或"
"执行完毕之前切换出去。这样一来， CPU 就必须调整快取缓存以配合新线程的执行。当"
"内核返回到被抢断的线程时， 它又需要重新填充之前丢失的快取缓存信息。此外， 如"
"果内核能够将对将阻塞或返回用户态的那个线程的抢断延迟到这之后的话，还能够免去"
"两次额外的上下文切换。 因此， 默认情况下，只有在优先级较高的线程是实时线程"
"时， 抢占代码才会立即执行抢断操作。"

#. (itstool) path: sect3/para
#: book.translate.xml:15304
msgid ""
"Turning on full kernel preemption for all kernel threads has value as a "
"debugging aid since it exposes more race conditions. It is especially useful "
"on UP systems were many races are hard to simulate otherwise. Thus, there is "
"a kernel option <literal>FULL_PREEMPTION</literal> to enable preemption for "
"all kernel threads that can be used for debugging purposes."
msgstr ""
"启用针对所有内核线程的完全抢占对于调试非常有帮助，因为它会暴露出更多的竞态条"
"件 (race conditions)。在难以模拟这些竞态条件的单处理器系统中， 这显得尤其有"
"用。因此， 我们提供了内核选项 <literal>FULL_PREEMPTION</literal>来启用针对所"
"有内核线程的抢占， 这一选项主要用于调试目的。"

#. (itstool) path: sect2/title
#: book.translate.xml:15315
msgid "Thread Migration"
msgstr "线程迁移"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15317
msgid "<primary>thread migration</primary>"
msgstr "<primary>thread migration(线程迁移)</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:15319
msgid ""
"Simply put, a thread migrates when it moves from one CPU to another. In a "
"non-preemptive kernel this can only happen at well-defined points such as "
"when calling <function>msleep</function> or returning to userland. However, "
"in the preemptive kernel, an interrupt can force a preemption and possible "
"migration at any time. This can have negative affects on per-CPU data since "
"with the exception of <varname>curthread</varname> and <varname>curpcb</"
"varname> the data can change whenever you migrate. Since you can potentially "
"migrate at any time this renders unprotected per-CPU data access rather "
"useless. Thus it is desirable to be able to disable migration for sections "
"of code that need per-CPU data to be stable."
msgstr ""
"简单地说， 线程从一个 CPU 移动到另一个上的过程称作迁移。在非抢占式内核中， 这"
"只会在明确定义的点， 例如调用<function>msleep</function> 或返回至用户态时才会"
"发生。但是， 在抢占式内核中， 中断可能会在任何时候强制抢断，并导致迁移。 对"
"于 CPU 私有的数据而言这可能会带来一些负面影响， 因为除<varname>curthread</"
"varname> 和 <varname>curpcb</varname>以外的数据都可能在迁移过程中发生变化。 "
"由于存在潜在的线程迁移，使得未受保护的 CPU 私有数据访问变得无用。 这就需要在"
"某些代码段禁止迁移，以获得稳定的 CPU 私有数据。"

#. (itstool) path: sect2/para
#: book.translate.xml:15335
msgid ""
"Critical sections currently prevent migration since they do not allow "
"context switches. However, this may be too strong of a requirement to "
"enforce in some cases since a critical section also effectively blocks "
"interrupt threads on the current processor. As a result, another API has "
"been provided to allow the current thread to indicate that if it preempted "
"it should not migrate to another CPU."
msgstr ""
"目前我们采用临界区来避免迁移， 因为它们能够阻止上下文切换。但是， 这有时可能"
"是一种过于严厉的限制，因为临界区实际上会阻止当前处理器上的中断线程。 因而，提"
"供了另一个 API， 用以指示当前进程在被抢断时，不应迁移到另一 CPU。"

#. (itstool) path: sect2/para
#: book.translate.xml:15343
msgid ""
"This API is known as thread pinning and is provided by the scheduler. The "
"API consists of two functions: <function>sched_pin</function> and "
"<function>sched_unpin</function>. These functions manage a per-thread "
"nesting count <varname>td_pinned</varname>. A thread is pinned when its "
"nesting count is greater than zero and a thread starts off unpinned with a "
"nesting count of zero. Each scheduler implementation is required to ensure "
"that pinned threads are only executed on the CPU that they were executing on "
"when the <function>sched_pin</function> was first called. Since the nesting "
"count is only written to by the thread itself and is only read by other "
"threads when the pinned thread is not executing but while "
"<varname>sched_lock</varname> is held, then <varname>td_pinned</varname> "
"does not need any locking. The <function>sched_pin</function> function "
"increments the nesting count and <function>sched_unpin</function> decrements "
"the nesting count. Note that these functions only operate on the current "
"thread and bind the current thread to the CPU it is executing on at the "
"time. To bind an arbitrary thread to a specific CPU, the "
"<function>sched_bind</function> and <function>sched_unbind</function> "
"functions should be used instead."
msgstr ""
"这组 API 也叫线程牵制， 它由调度器提供。 这组 API 包括两个函数："
"<function>sched_pin</function> 和<function>sched_unpin</function>。 这两个函"
"数用于管理线程私有的计数<varname>td_pinned</varname>。 如果嵌套计数大于零， "
"则线程将被锁住，而线程开始运行时其嵌套计数为零， 表示处于未牵制状态。 所有的"
"调度器实现中，都要求保证牵制线程只在它们首次调用 <function>sched_pin</"
"function>时所在的 CPU 上运行。 由于只有线程自己会写嵌套计数，而只有其它线程在"
"受牵制线程没有执行， 且持有<varname>sched_lock</varname> 锁时才会读嵌套计"
"数， 因此访问<varname>td_pinned</varname> 不必上锁。<function>sched_pin</"
"function> 函数会使嵌套计数递增，而 <function>sched_unpin</function> 则使其递"
"减。注意， 这些函数只操作当前线程， 并将其绑定到其执行它时所处的 CPU 上。要将"
"任意线程绑定到指定的 CPU 上， 则应使用 <function>sched_bind</function> 和"
"<function>sched_unbind</function>。"

#. (itstool) path: sect2/title
#: book.translate.xml:15369
msgid "Callouts"
msgstr "调出 (Callout)"

#. (itstool) path: sect2/para
#: book.translate.xml:15371
msgid ""
"The <function>timeout</function> kernel facility permits kernel services to "
"register functions for execution as part of the <function>softclock</"
"function> software interrupt. Events are scheduled based on a desired number "
"of clock ticks, and callbacks to the consumer-provided function will occur "
"at approximately the right time."
msgstr ""
"内核机制 <function>timeout</function> 允许内核服务注册函数，以作为 "
"<function>softclock</function> 软件中断的一部分来执行。事件将基于所希望的时钟"
"嘀嗒的数目进行， 并在大约指定的时间回调用户提供的函数。"

#. (itstool) path: sect2/para
#: book.translate.xml:15378
msgid ""
"The global list of pending timeout events is protected by a global spin "
"mutex, <varname>callout_lock</varname>; all access to the timeout list must "
"be performed with this mutex held. When <function>softclock</function> is "
"woken up, it scans the list of pending timeouts for those that should fire. "
"In order to avoid lock order reversal, the <function>softclock</function> "
"thread will release the <varname>callout_lock</varname> mutex when invoking "
"the provided <function>timeout</function> callback function. If the "
"<constant>CALLOUT_MPSAFE</constant> flag was not set during registration, "
"then Giant will be grabbed before invoking the callout, and then released "
"afterwards. The <varname>callout_lock</varname> mutex will be re-grabbed "
"before proceeding. The <function>softclock</function> code is careful to "
"leave the list in a consistent state while releasing the mutex. If "
"<constant>DIAGNOSTIC</constant> is enabled, then the time taken to execute "
"each function is measured, and a warning is generated if it exceeds a "
"threshold."
msgstr ""
"未决 timeout (超时) 事件的全局表是由一全局 mutex，<varname>callout_lock</"
"varname> 保护的； 所有对 timeout 表的访问，都必须首先拿到这个 mutex。 当 "
"<function>softclock</function>唤醒时， 它会扫描未决超时表， 并找出应启动的那"
"些。 为避免锁逆序，<function>softclock</function> 线程会在调用所提供的"
"<function>timeout</function> 回调函数时首先释放<varname>callout_lock</"
"varname> mutex。如果在注册时没有设置 <constant>CALLOUT_MPSAFE</constant> 标"
"志，则在调用调出函数之前， 还会抓取全局锁， 并在之后释放。 其后，"
"<varname>callout_lock</varname> mutex 会在继续处理前再次获得。"
"<function>softclock</function> 代码在释放这个 mutex时会非常小心地保持表的一致"
"状态。 如果启用了 <constant>DIAGNOSTIC</constant>，则每个函数的执行时间会被记"
"录， 如果超过了某一阈值， 则会产生警告。"

#. (itstool) path: sect1/title
#: book.translate.xml:15401
msgid "Specific Locking Strategies"
msgstr "特定数据的锁策略"

#. (itstool) path: sect2/title
#: book.translate.xml:15404
msgid "Credentials"
msgstr "凭据（Credentials）"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15406
msgid "<primary>credentials</primary>"
msgstr "<primary>credentials(凭据)</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:15408
msgid ""
"<varname remap=\"structname\">struct ucred</varname> is the kernel's "
"internal credential structure, and is generally used as the basis for "
"process-driven access control within the kernel. BSD-derived systems use a "
"<quote>copy-on-write</quote> model for credential data: multiple references "
"may exist for a credential structure, and when a change needs to be made, "
"the structure is duplicated, modified, and then the reference replaced. Due "
"to wide-spread caching of the credential to implement access control on "
"open, this results in substantial memory savings. With a move to fine-"
"grained SMP, this model also saves substantially on locking operations by "
"requiring that modification only occur on an unshared credential, avoiding "
"the need for explicit synchronization when consuming a known-shared "
"credential."
msgstr ""
"<varname remap=\"structname\">struct ucred</varname> 是内核内部的凭据结构体，"
"它通常作为内核中以进程为导向的访问控制的依据。BSD-派生的系统采用一种 <quote>"
"写时复制</quote> 的模型来处理凭据数据：同一凭据结构体可能存在多个引用， 如果"
"需要对其进行修改，则这个结构体将被复制、 修改， 然后替换该引用。由于在打开时"
"用于实现访问控制的凭据快取缓存广泛存在，这种做法会极大地节省内存。 在迁移到细"
"粒度的 SMP 时，这一模型也省去了大量的锁操作， 因为只有未共享的凭据才能实施修"
"改，因而避免了在使用共享凭据时额外的同步操作。"

#. (itstool) path: sect2/para
#: book.translate.xml:15423
msgid ""
"Credential structures with a single reference are considered mutable; shared "
"credential structures must not be modified or a race condition is risked. A "
"mutex, <varname remap=\"structfield\">cr_mtxp</varname> protects the "
"reference count of <varname remap=\"structname\">struct ucred</varname> so "
"as to maintain consistency. Any use of the structure requires a valid "
"reference for the duration of the use, or the structure may be released out "
"from under the illegitimate consumer."
msgstr ""
"凭据结构体只有一个引用时， 被认为是可变的；不允许改变共享的凭据结构体， 否则"
"将可能导致发生竞态条件。<varname remap=\"structfield\">cr_mtxp</varname> "
"mutex 用于保护<varname remap=\"structname\">struct ucred</varname> 的引用计"
"数，以维护其一致性。 使用凭据结构体时， 必须在使用过程中保持有效的引用，否则"
"它就可能在这个不合理的消费者使用过程中被释放。"

#. (itstool) path: sect2/para
#: book.translate.xml:15433
msgid ""
"The <varname remap=\"structname\">struct ucred</varname> mutex is a leaf "
"mutex and is implemented via a mutex pool for performance reasons."
msgstr ""
"<varname remap=\"structname\">struct ucred</varname> mutex 是一种叶mutex， 出"
"于性能考虑， 它通过 mutex 池实现。"

#. (itstool) path: sect2/para
#: book.translate.xml:15437
msgid ""
"Usually, credentials are used in a read-only manner for access control "
"decisions, and in this case <varname remap=\"structfield\">td_ucred</"
"varname> is generally preferred because it requires no locking. When a "
"process' credential is updated the <literal>proc</literal> lock must be held "
"across the check and update operations thus avoid races. The process "
"credential <varname remap=\"structfield\">p_ucred</varname> must be used for "
"check and update operations to prevent time-of-check, time-of-use races."
msgstr ""
"由于多用于访问控制决策， 凭据通常情况下是以只读方式访问的， 此时一般应使用"
"<varname remap=\"structfield\">td_ucred</varname>， 因为它不需要上锁。当更新"
"进程凭据时， 检查和更新过程中必须持有 <literal>proc</literal>锁。 检查和更新"
"操作必须使用 <varname remap=\"structfield\">p_ucred</varname>，以避免检查时和"
"使用时的竞态条件。"

#. (itstool) path: sect2/para
#: book.translate.xml:15447
msgid ""
"If system call invocations will perform access control after an update to "
"the process credential, the value of <varname remap=\"structfield"
"\">td_ucred</varname> must also be refreshed to the current process value. "
"This will prevent use of a stale credential following a change. The kernel "
"automatically refreshes the <varname remap=\"structfield\">td_ucred</"
"varname> pointer in the thread structure from the process <varname remap="
"\"structfield\">p_ucred</varname> whenever a process enters the kernel, "
"permitting use of a fresh credential for kernel access control."
msgstr ""
"如果所调系统调用将在更新进程凭据之后进行访问控制检查， 则<varname remap="
"\"structfield\">td_ucred</varname> 也必须刷新为当前进程的值。这样做能够避免修"
"改后使用过时的凭据。 内核会自动在进程进入内核时，将线程结构体的 <varname "
"remap=\"structfield\">td_ucred</varname> 指针刷新为进程的<varname remap="
"\"structfield\">p_ucred</varname>， 以保证内核访问控制能用到新的凭据。"

#. (itstool) path: sect2/title
#: book.translate.xml:15460
msgid "File Descriptors and File Descriptor Tables"
msgstr "文件描述符和文件描述符表"

#. (itstool) path: sect2/para
#: book.translate.xml:15462
msgid "Details to follow."
msgstr "详细内容将在稍后增加。"

#. (itstool) path: sect2/title
#: book.translate.xml:15466
msgid "Jail Structures"
msgstr "Jail 结构体"

#. (itstool) path: sect2/para
#: book.translate.xml:15470
msgid ""
"<varname remap=\"structname\">struct prison</varname> stores administrative "
"details pertinent to the maintenance of jails created using the "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> API. This includes the per-jail hostname, IP address, and "
"related settings. This structure is reference-counted since pointers to "
"instances of the structure are shared by many credential structures. A "
"single mutex, <varname remap=\"structfield\">pr_mtx</varname> protects read "
"and write access to the reference count and all mutable variables inside the "
"struct jail. Some variables are set only when the jail is created, and a "
"valid reference to the <varname remap=\"structname\">struct prison</varname> "
"is sufficient to read these values. The precise locking of each entry is "
"documented via comments in <filename>sys/jail.h</filename>."
msgstr ""
"<varname remap=\"structname\">struct prison</varname> 保存了用于维护那些通过"
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> API 创建的 jail 所用到的管理信息。 这包括 jail的主机名、 IP 地"
"址， 以及一些相关的设置。 这个结构体包含引用计数，因为指向这一结构体实例的指"
"针会在多种凭据结构之间共享。用了一个 mutex， <varname remap=\"structfield"
"\">pr_mtx</varname>来保护对引用计数以及所有 jail 结构体中可变变量的读写访问。"
"有一些变量只会在创建 jail 的时刻发生变化， 只需持有有效的<varname remap="
"\"structname\">struct prison</varname> 就可以开始读这些值了。关于每个项目具体"
"的上锁操作的文档，可以在 <filename>sys/jail.h</filename> 的注释中找到。"

#. (itstool) path: sect2/title
#: book.translate.xml:15486
msgid "MAC Framework"
msgstr "MAC 框架"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15488
msgid "<primary>MAC</primary>"
msgstr "<primary>MAC</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:15490
msgid ""
"The TrustedBSD MAC Framework maintains data in a variety of kernel objects, "
"in the form of <varname remap=\"structname\">struct label</varname>. In "
"general, labels in kernel objects are protected by the same lock as the "
"remainder of the kernel object. For example, the <varname remap=\"structfield"
"\">v_label</varname> label in <varname remap=\"structname\">struct vnode</"
"varname> is protected by the vnode lock on the vnode."
msgstr ""
"TrustedBSD MAC 框架会以 <varname remap=\"structname\">structlabel</varname> "
"的形式维护一系列内核对象的数据。一般来说， 内核中的 label (标签) 是由与其对应"
"的内核对象同样的锁保护的。例如， <varname remap=\"structname\">struct vnode</"
"varname> 上的<varname remap=\"structfield\">v_label</varname> 标签是由其所在 "
"vnode 上的vnode 锁保护的。"

#. (itstool) path: sect2/para
#: book.translate.xml:15498
msgid ""
"In addition to labels maintained in standard kernel objects, the MAC "
"Framework also maintains a list of registered and active policies. The "
"policy list is protected by a global mutex (<varname>mac_policy_list_lock</"
"varname>) and a busy count (also protected by the mutex). Since many access "
"control checks may occur in parallel, entry to the framework for a read-only "
"access to the policy list requires holding the mutex while incrementing (and "
"later decrementing) the busy count. The mutex need not be held for the "
"duration of the MAC entry operation--some operations, such as label "
"operations on file system objects--are long-lived. To modify the policy "
"list, such as during policy registration and de-registration, the mutex must "
"be held and the reference count must be zero, to prevent modification of the "
"list while it is in use."
msgstr ""
"除了嵌入到标准内核对象中的标签之外， MAC框架也需要维护一组包含已注册的和激活"
"策略的列表。 策略表和忙计数由一个全局mutex (<varname>mac_policy_list_lock</"
"varname>) 保护。由于能够同时并行地进行许多访问控制检查， 对策略表的只读访问，"
"在增减忙计数时， 框架的入口处需要首先持有这个 mutex。MAC 入口操作的过程中并不"
"需要长时间持有此 mutex -- 有些操作，例如文件系统对象上的标签操作 -- 是持久"
"的。 要修改策略表，例如在注册和解除注册策略时， 需要持有此 mutex， 而且要求引"
"用计数为零，以避免在用表时对其进行修改。"

#. (itstool) path: sect2/para
#: book.translate.xml:15513
msgid ""
"A condition variable, <varname>mac_policy_list_not_busy</varname>, is "
"available to threads that need to wait for the list to become unbusy, but "
"this condition variable must only be waited on if the caller is holding no "
"other locks, or a lock order violation may be possible. The busy count, in "
"effect, acts as a form of shared/exclusive lock over access to the "
"framework: the difference is that, unlike with an sx lock, consumers waiting "
"for the list to become unbusy may be starved, rather than permitting lock "
"order problems with regards to the busy count and other locks that may be "
"held on entry to (or inside) the MAC Framework."
msgstr ""
"对于需要等待表进入闲置状态的线程， 提供了一个条件变量"
"<varname>mac_policy_list_not_busy</varname>，但这一条件变量只能在调用者没有持"
"有其它锁时才能使用，否则可能会引发锁逆序问题。 忙计数在整个框架中事实上还扮演"
"了某种形式的共享/排他 锁的作用： 与 sx 锁不同的地方在于，等待列表进入闲置状态"
"的线程可以饿死， 而不是允许忙计数和其它在 MAC框架入口 (或内部) 的锁之间的逆序"
"情况。"

#. (itstool) path: sect2/title
#: book.translate.xml:15527
msgid "Modules"
msgstr "模块"

#. (itstool) path: sect2/para
#: book.translate.xml:15531
msgid ""
"For the module subsystem there exists a single lock that is used to protect "
"the shared data. This lock is a shared/exclusive (SX) lock and has a good "
"chance of needing to be acquired (shared or exclusively), therefore there "
"are a few macros that have been added to make access to the lock more easy. "
"These macros can be located in <filename>sys/module.h</filename> and are "
"quite basic in terms of usage. The main structures protected under this lock "
"are the <varname remap=\"structname\">module_t</varname> structures (when "
"shared) and the global <varname remap=\"structname\">modulelist_t</varname> "
"structure, modules. One should review the related source code in "
"<filename>kern/kern_module.c</filename> to further understand the locking "
"strategy."
msgstr ""
"对于模块子系统， 用于保护共享数据使用了一个单独的锁， 它是一个 共享/排他(SX) "
"锁， 许多情况需要获得它 (以共享或排他的方式)，因此我们提供了几个方便使用的宏"
"来简化对这个锁的访问，这些宏可以在 <filename>sys/module.h</filename> 中找到，"
"其用法都非常简单明了。 这个锁保护的主要是<varname remap=\"structname"
"\">module_t</varname> (当以共享方式上锁)和全局的 <varname remap=\"structname"
"\">modulelist_t</varname> 这两个结构体，以及模块。 要更进一步理解这些锁策"
"略， 需要仔细阅读<filename>kern/kern_module.c</filename> 的源代码。"

#. (itstool) path: sect2/title
#: book.translate.xml:15546
msgid "Newbus Device Tree"
msgstr "Newbus 设备树"

#. (itstool) path: sect2/indexterm
#. (itstool) path: sect1/indexterm
#: book.translate.xml:15548 book.translate.xml:22541
msgid "<primary>Newbus</primary>"
msgstr "<primary>Newbus</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:15550
msgid ""
"The newbus system will have one sx lock. Readers will hold a shared (read) "
"lock (<citerefentry><refentrytitle>sx_slock</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry>) and writers will hold an exclusive (write) lock "
"(<citerefentry><refentrytitle>sx_xlock</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry>). Internal functions will not do locking at all. "
"Externally visible ones will lock as needed. Those items that do not matter "
"if the race is won or lost will not be locked, since they tend to be read "
"all over the place (e.g., <citerefentry><refentrytitle>device_get_softc</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>). There will be "
"relatively few changes to the newbus data structures, so a single lock "
"should be sufficient and not impose a performance penalty."
msgstr ""
"newbus 系统使用了一个 sx 锁。 读的一方应持有共享 (读) 锁 "
"(<citerefentry><refentrytitle>sx_slock</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry>) 而写的一方则应持有排他 (写) 锁 "
"(<citerefentry><refentrytitle>sx_xlock</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry>)。 内部函数一般不需要进行上锁， 而外部可见的则应根"
"据需要上锁。 有些项目不需上锁， 因为这些项目在全程是只读的， (例如 "
"<citerefentry><refentrytitle>device_get_softc</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry>)， 因而并不会产生竞态条件。 针对 newbus 数据结构的"
"修改相对而言非常少， 因此单个的锁已经足够使用， 而不致造成性能折损。"

#. (itstool) path: sect2/title
#: book.translate.xml:15563
msgid "Pipes"
msgstr "管道"

#. (itstool) path: sect2/para
#: book.translate.xml:15565 book.translate.xml:15598
msgid "..."
msgstr "..."

#. (itstool) path: sect2/title
#: book.translate.xml:15569
msgid "Processes and Threads"
msgstr "进程和线程"

#. (itstool) path: sect2/para
#: book.translate.xml:15571
msgid "- process hierarchy"
msgstr "- 进程层次结构"

#. (itstool) path: sect2/para
#: book.translate.xml:15572
msgid "- proc locks, references"
msgstr "- proc 锁及其参考"

#. (itstool) path: sect2/para
#: book.translate.xml:15573
msgid ""
"- thread-specific copies of proc entries to freeze during system calls, "
"including td_ucred"
msgstr "- 在系统调用过程中线程私有的 proc 项副本，包括 td_ucred"

#. (itstool) path: sect2/para
#: book.translate.xml:15575
msgid "- inter-process operations"
msgstr "- 进程间操作"

#. (itstool) path: sect2/para
#: book.translate.xml:15576
msgid "- process groups and sessions"
msgstr "- 进程组和会话"

#. (itstool) path: sect2/title
#: book.translate.xml:15580
msgid "Scheduler"
msgstr "调度"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15582
msgid "<primary>scheduler</primary>"
msgstr "<primary>scheduler(调度器)</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:15584
msgid ""
"Lots of references to <varname>sched_lock</varname> and notes pointing at "
"specific primitives and related magic elsewhere in the document."
msgstr ""
"本文在其它地方已经提供了很多关于 <varname>sched_lock</varname>的参考和注释。"

#. (itstool) path: sect2/title
#: book.translate.xml:15590
msgid "Select and Poll"
msgstr "Select 和 Poll"

#. (itstool) path: sect2/para
#: book.translate.xml:15592
msgid ""
"The <function>select</function> and <function>poll</function> functions "
"permit threads to block waiting on events on file descriptors--most "
"frequently, whether or not the file descriptors are readable or writable."
msgstr ""
"<function>select</function> 和<function>poll</function> 这两个函数允许线程阻"
"塞并等待文件描述符上的事件 --最常见的情况是文件描述符是否可读或可写。"

#. (itstool) path: sect2/title
#: book.translate.xml:15602
msgid "SIGIO"
msgstr "SIGIO"

#. (itstool) path: sect2/para
#: book.translate.xml:15604
msgid ""
"The SIGIO service permits processes to request the delivery of a SIGIO "
"signal to its process group when the read/write status of specified file "
"descriptors changes. At most one process or process group is permitted to "
"register for SIGIO from any given kernel object, and that process or group "
"is referred to as the owner. Each object supporting SIGIO registration "
"contains pointer field that is <constant>NULL</constant> if the object is "
"not registered, or points to a <varname remap=\"structname\">struct sigio</"
"varname> describing the registration. This field is protected by a global "
"mutex, <varname>sigio_lock</varname>. Callers to SIGIO maintenance functions "
"must pass in this field <quote>by reference</quote> so that local register "
"copies of the field are not made when unprotected by the lock."
msgstr ""
"SIGIO 服务允许进程请求在特定文件描述符的读/写状态发生变化时，将 SIGIO 信号群"
"发给其进程组。 任意给定内核对象上，只允许一进程或进程组注册 SIGIO， 这个进程"
"或进程组称为属主 (owner)。每一支持 SIGIO 注册的对象， 都包含一指针字段， 如果"
"对象未注册则为<constant>NULL</constant>，否则是一指向描述这一注册的 <varname "
"remap=\"structname\">struct sigio</varname> 的指针。这一字段由一全局 mutex，"
"<varname>sigio_lock</varname> 保护。 调用 SIGIO 维护函数时，必须以 <quote>传"
"引用</quote> 方式传递这一字段，以确保本地注册副本的中这个字段不脱离锁的保护。"

#. (itstool) path: sect2/para
#: book.translate.xml:15619
msgid ""
"One <varname remap=\"structname\">struct sigio</varname> is allocated for "
"each registered object associated with any process or process group, and "
"contains back-pointers to the object, owner, signal information, a "
"credential, and the general disposition of the registration. Each process or "
"progress group contains a list of registered <varname remap=\"structname"
"\">struct sigio</varname> structures, <varname remap=\"structfield"
"\">p_sigiolst</varname> for processes, and <varname remap=\"structfield"
"\">pg_sigiolst</varname> for process groups. These lists are protected by "
"the process or process group locks respectively. Most fields in each "
"<varname remap=\"structname\">struct sigio</varname> are constant for the "
"duration of the registration, with the exception of the <varname remap="
"\"structfield\">sio_pgsigio</varname> field which links the <varname remap="
"\"structname\">struct sigio</varname> into the process or process group "
"list. Developers implementing new kernel objects supporting SIGIO will, in "
"general, want to avoid holding structure locks while invoking SIGIO "
"supporting functions, such as <function>fsetown</function> or "
"<function>funsetown</function> to avoid defining a lock order between "
"structure locks and the global SIGIO lock. This is generally possible "
"through use of an elevated reference count on the structure, such as "
"reliance on a file descriptor reference to a pipe during a pipe operation."
msgstr ""
"每个关联到进程或进程组的注册对象， 都会分配一<varname remap=\"structname"
"\">struct sigio</varname> 结构， 并包括指回该对象的指针、属主、 信号信息、 凭"
"据， 以及关于这一注册的一般信息。每个进程或进程组都包含一个已注册 <varname "
"remap=\"structname\">struct sigio</varname>结构体的列表， 对进程来说是"
"<varname remap=\"structfield\">p_sigiolst</varname>， 而对进程组则是<varname "
"remap=\"structfield\">pg_sigiolst</varname>。 这些表由相应的进程或进程组锁保"
"护。除了用以将<varname remap=\"structname\">struct sigio</varname> 连接到进程"
"组上的<varname remap=\"structfield\">sio_pgsigio</varname> 字段之外， 在 "
"<varname remap=\"structname\">structsigio</varname> 中的多数字段在注册过程中"
"都是不变量。一般而言， 开发人员在实现新的支持 SIGIO 的内核对象时，会希望避免"
"在调用 SIGIO 支持函数， 例如 <function>fsetown</function>或 "
"<function>funsetown</function> 持有结构体锁，以免去需要在结构体锁和全局 "
"SIGIO 锁之间定义锁序。通常可以通过提高结构体上的引用计数来达到这样的目的，例"
"如， 在进行管道操作时， 使用引用某个管道的文件描述符这样的操作，就可以照此办"
"理。"

#. (itstool) path: sect2/title
#: book.translate.xml:15646
msgid "Sysctl"
msgstr "Sysctl"

#. (itstool) path: sect2/para
#: book.translate.xml:15648
msgid ""
"The <function>sysctl</function> MIB service is invoked from both within the "
"kernel and from userland applications using a system call. At least two "
"issues are raised in locking: first, the protection of the structures "
"maintaining the namespace, and second, interactions with kernel variables "
"and functions that are accessed by the sysctl interface. Since sysctl "
"permits the direct export (and modification) of kernel statistics and "
"configuration parameters, the sysctl mechanism must become aware of "
"appropriate locking semantics for those variables. Currently, sysctl makes "
"use of a single global sx lock to serialize use of <function>sysctl</"
"function>; however, it is assumed to operate under Giant and other "
"protections are not provided. The remainder of this section speculates on "
"locking and semantic changes to sysctl."
msgstr ""
"<function>sysctl</function> MIB 服务会从内核内部，以及用户态的应用程序以系统"
"调用的方式触发。这会引发至少两个和锁有关的问题： 其一是对维持命名空间的数据结"
"构的保护，其二是与那些通过 sysctl 接口访问的内核变量和函数之间的交互。由于 "
"sysctl 允许直接导出 (甚至修改) 内核统计数据以及配置参数， sysctl机制必须知道"
"这些变量相应的上锁语义。 目前， sysctl 使用一个全局 sx锁来实现对 "
"<function>sysctl</function> 操作的串行化；然而， 这些是假定用全局锁保护的， "
"并且没有提供其它保护机制。这一节的其余部分将详细介绍上锁和 sysctl 相关变动的"
"语义。"

#. (itstool) path: sect2/para
#: book.translate.xml:15664
msgid ""
"- Need to change the order of operations for sysctl's that update values "
"from read old, copyin and copyout, write new to copyin, lock, read old and "
"write new, unlock, copyout. Normal sysctl's that just copyout the old value "
"and set a new value that they copyin may still be able to follow the old "
"model. However, it may be cleaner to use the second model for all of the "
"sysctl handlers to avoid lock operations."
msgstr ""
"- 需要将 sysctl 更新值所进行的操作的顺序， 从原先的读旧值、copyin 和 "
"copyout、 写新值， 改为 copyin、 上锁、 读旧值、 写新值、解锁、 copyout。 一"
"般的 sysctl 只是 copyout 旧值并设置它们 copyin所得到的新值， 仍然可以采用旧式"
"的模型。 然而，对所有 sysctl 处理程序采用第二种模型并避免锁操作方面，第二种方"
"式可能更规矩一些。"

#. (itstool) path: sect2/para
#: book.translate.xml:15672
msgid ""
"- To allow for the common case, a sysctl could embed a pointer to a mutex in "
"the SYSCTL_FOO macros and in the struct. This would work for most sysctl's. "
"For values protected by sx locks, spin mutexes, or other locking strategies "
"besides a single sleep mutex, SYSCTL_PROC nodes could be used to get the "
"locking right."
msgstr ""
"- 对于通常的情况， sysctl 可以内嵌一个 mutex 指针到 SYSCTL_FOO宏和结构体中。 "
"这对多数 sysctl 都是有效的。 对于使用 sx锁、 自旋 mutex， 或其它除单一休眠 "
"mutex 之外的锁策略，可以用 SYSCTL_PROC 节点来完成正确的上锁。"

#. (itstool) path: sect2/title
#: book.translate.xml:15681
msgid "Taskqueue"
msgstr "任务队列 (Taskqueue)"

#. (itstool) path: sect2/para
#: book.translate.xml:15683
msgid ""
"The taskqueue's interface has two basic locks associated with it in order to "
"protect the related shared data. The <varname>taskqueue_queues_mutex</"
"varname> is meant to serve as a lock to protect the "
"<varname>taskqueue_queues</varname> TAILQ. The other mutex lock associated "
"with this system is the one in the <varname remap=\"structname\">struct "
"taskqueue</varname> data structure. The use of the synchronization primitive "
"here is to protect the integrity of the data in the <varname remap="
"\"structname\">struct taskqueue</varname>. It should be noted that there are "
"no separate macros to assist the user in locking down his/her own work since "
"these locks are most likely not going to be used outside of <filename>kern/"
"subr_taskqueue.c</filename>."
msgstr ""
"任务队列 (taskqueue) 的接口包括两个与之关联的用于保护相关数据的锁。"
"<varname>taskqueue_queues_mutex</varname> 是用于保护"
"<varname>taskqueue_queues</varname> TAILQ 的锁。与这个系统关联的另一个 mutex "
"锁是位于<varname remap=\"structname\">struct taskqueue</varname> 结构体上。在"
"此处使用同步原语的目的在于保护 <varname remap=\"structname"
"\">structtaskqueue</varname> 中数据的完整性。 应注意的是，并没有单独的、 帮助"
"用户对其自身的工作进行锁的细化用的宏，因为这些锁基本上不会在<filename>kern/"
"subr_taskqueue.c</filename> 以外的地方用到。"

#. (itstool) path: sect1/title
#: book.translate.xml:15699
msgid "Implementation Notes"
msgstr "实现说明"

#. (itstool) path: sect2/title
#: book.translate.xml:15702
msgid "Sleep Queues"
msgstr "休眠队列"

#. (itstool) path: sect2/para
#: book.translate.xml:15704
msgid ""
"A sleep queue is a structure that holds the list of threads asleep on a wait "
"channel. Each thread that is not asleep on a wait channel carries a sleep "
"queue structure around with it. When a thread blocks on a wait channel, it "
"donates its sleep queue structure to that wait channel. Sleep queues "
"associated with a wait channel are stored in a hash table."
msgstr ""
"休眠队列是一种用于保存同处一个等待通道 (wait channel)上休眠线程列表的数据结"
"构。 在等待通道上，每个处于非睡眠状态的线程都会携带一个休眠队列结构。当线程在"
"等待通道上发生阻塞时， 它会将休眠队列结构体送给那个等待通道。与等待通道关联的"
"休眠队列则保存在一个散列表中。"

#. (itstool) path: sect2/para
#: book.translate.xml:15712
msgid ""
"The sleep queue hash table holds sleep queues for wait channels that have at "
"least one blocked thread. Each entry in the hash table is called a "
"sleepqueue chain. The chain contains a linked list of sleep queues and a "
"spin mutex. The spin mutex protects the list of sleep queues as well as the "
"contents of the sleep queue structures on the list. Only one sleep queue is "
"associated with a given wait channel. If multiple threads block on a wait "
"channel than the sleep queues associated with all but the first thread are "
"stored on a list of free sleep queues in the master sleep queue. When a "
"thread is removed from the sleep queue it is given one of the sleep queue "
"structures from the master queue's free list if it is not the only thread "
"asleep on the queue. The last thread is given the master sleep queue when it "
"is resumed. Since threads may be removed from the sleep queue in a different "
"order than they are added, a thread may depart from a sleep queue with a "
"different sleep queue structure than the one it arrived with."
msgstr ""
"休眠队列散列表中保存了包含至少一个阻塞线程的等待通道上的休眠队列。这个散列表"
"上的项称作 sleepqueue (休眠队列) 链。 它包含了一个休眠队列的链表，以及一个自"
"旋 mutex。 此处的自旋 mutex 用于保护休眠队列表，以及其上休眠队列结构的内容。 "
"一个等待通道上只会关联一个休眠队列。如果有多个线程在同一等待通道上阻塞，则休"
"眠队列中将关联除第一个线程之外的全部线程。 当从休眠队列中删除线程时，如果它不"
"是唯一的阻塞的休眠线程， 则会获得主休眠队列的空闲表上的休眠队列结构。最后一个"
"线程会在恢复运行时获得主休眠队列。由于线程有可能以和加入休眠队列不同的次序从"
"其中删除，因此， 线程离开队列时可能会携带与其进入时不同的休眠队列。"

#. (itstool) path: sect2/para
#: book.translate.xml:15731
msgid ""
"The <function>sleepq_lock</function> function locks the spin mutex of the "
"sleep queue chain that maps to a specific wait channel. The "
"<function>sleepq_lookup</function> function looks in the hash table for the "
"master sleep queue associated with a given wait channel. If no master sleep "
"queue is found, it returns <constant>NULL</constant>. The "
"<function>sleepq_release</function> function unlocks the spin mutex "
"associated with a given wait channel."
msgstr ""
"<function>sleepq_lock</function> 函数会锁住指定等待通道上休眠队列链的自旋"
"mutex。 <function>sleepq_lookup</function>函数会在主休眠队列散列表中查找给定"
"的等待通道。 如果没有找到主休眠队列，它会返回 <constant>NULL</constant>。"
"<function>sleepq_release</function> 函数会对给定等待通道所关联的自旋mutex 进"
"行解锁。"

#. (itstool) path: sect2/para
#: book.translate.xml:15740
msgid ""
"A thread is added to a sleep queue via the <function>sleepq_add</function>. "
"This function accepts the wait channel, a pointer to the mutex that protects "
"the wait channel, a wait message description string, and a mask of flags. "
"The sleep queue chain should be locked via <function>sleepq_lock</function> "
"before this function is called. If no mutex protects the wait channel (or it "
"is protected by Giant), then the mutex pointer argument should be "
"<constant>NULL</constant>. The flags argument contains a type field that "
"indicates the kind of sleep queue that the thread is being added to and a "
"flag to indicate if the sleep is interruptible "
"(<constant>SLEEPQ_INTERRUPTIBLE</constant>). Currently there are only two "
"types of sleep queues: traditional sleep queues managed via the "
"<function>msleep</function> and <function>wakeup</function> functions "
"(<constant>SLEEPQ_MSLEEP</constant>) and condition variable sleep queues "
"(<constant>SLEEPQ_CONDVAR</constant>). The sleep queue type and lock pointer "
"argument are used solely for internal assertion checking. Code that calls "
"<function>sleepq_add</function> should explicitly unlock any interlock "
"protecting the wait channel after the associated sleepqueue chain has been "
"locked via <function>sleepq_lock</function> and before blocking on the sleep "
"queue via one of the waiting functions."
msgstr ""
"将线程加入休眠队列是通过<function>sleepq_add</function> 来完成的。这个函数的"
"参数包括等待通道、 指向保护等待通道的 mutex 的指针、等待消息描述串， 以及一个"
"标志掩码。 调用此函数之前， 应通过<function>sleepq_lock</function> 为休眠队列"
"链上锁。如果等待通道不是通过 mutex 保护的 (或者它由全局锁保护)，则应将 mutex "
"指针设置为<constant>NULL</constant>。 而 flags (标志) 参数则包括了一个类型字"
"段，用以表示线程即将加入到的休眠队列的类型，以及休眠是否是可中断的 "
"(<constant>SLEEPQ_INTERRUPTIBLE</constant>)。目前只有两种类型的休眠队列： 通"
"过<function>msleep</function> 和 <function>wakeup</function>函数管理的传统休"
"眠队列 (<constant>SLEEPQ_MSLEEP</constant>)，以及基于条件变量的休眠队列 "
"(<constant>SLEEPQ_CONDVAR</constant>)。休眠队列类型和锁指针这两个参数完全是用"
"于内部的断言检查。 调用<function>sleepq_add</function> 的代码， 应明示地在关"
"联的 sleepqueue 链透过<function>sleepq_lock</function> 进行上锁之后， 并使用"
"等待函数在休眠队列上阻塞之前解锁所有用于保护等待通道的interlock。"

#. (itstool) path: sect2/para
#: book.translate.xml:15765
msgid ""
"A timeout for a sleep is set by invoking <function>sleepq_set_timeout</"
"function>. The function accepts the wait channel and the timeout time as a "
"relative tick count as its arguments. If a sleep should be interrupted by "
"arriving signals, the <function>sleepq_catch_signals</function> function "
"should be called as well. This function accepts the wait channel as its only "
"parameter. If there is already a signal pending for this thread, then "
"<function>sleepq_catch_signals</function> will return a signal number; "
"otherwise, it will return 0."
msgstr ""
"通过使用<function>sleepq_set_timeout</function> 可以为休眠设置超时。这个函数"
"的参数包括等待通道， 以及以相对时钟嘀嗒数为单位的超时时间。如果休眠应被某个到"
"来的信号打断， 则还应调用<function>sleepq_catch_signals</function> 函数，这个"
"函数唯一的参数就是等待通道。 如果此线程已经有未决信号，则 "
"<function>sleepq_catch_signals</function> 将返回信号编号；其它情况下， 其返回"
"值则是 0。"

#. (itstool) path: sect2/para
#: book.translate.xml:15776
msgid ""
"Once a thread has been added to a sleep queue, it blocks using one of the "
"<function>sleepq_wait</function> functions. There are four wait functions "
"depending on whether or not the caller wishes to use a timeout or have the "
"sleep aborted by caught signals or an interrupt from the userland thread "
"scheduler. The <function>sleepq_wait</function> function simply waits until "
"the current thread is explicitly resumed by one of the wakeup functions. The "
"<function>sleepq_timedwait</function> function waits until either the thread "
"is explicitly resumed or the timeout set by an earlier call to "
"<function>sleepq_set_timeout</function> expires. The "
"<function>sleepq_wait_sig</function> function waits until either the thread "
"is explicitly resumed or its sleep is aborted. The "
"<function>sleepq_timedwait_sig</function> function waits until either the "
"thread is explicitly resumed, the timeout set by an earlier call to "
"<function>sleepq_set_timeout</function> expires, or the thread's sleep is "
"aborted. All of the wait functions accept the wait channel as their first "
"parameter. In addition, the <function>sleepq_timedwait_sig</function> "
"function accepts a second boolean parameter to indicate if the earlier call "
"to <function>sleepq_catch_signals</function> found a pending signal."
msgstr ""
"一旦将线程加入到休眠队列中，就可以使用 <function>sleepq_wait</function> 函数"
"族之一将其阻塞了。目前总共提供了四个等待函数， 使用哪个取决于调用这是否希望允"
"许使用超时、收到信号， 或用户态线程调度器打断休眠状态。其中， "
"<function>sleepq_wait</function> 函数简单地等待，直到当前线程通过某个唤醒 "
"(wakeup) 函数显式地恢复运行；<function>sleepq_timedwait</function> 函数则等"
"待，直到当前线程被显式地唤醒， 或者达到早前使用 "
"<function>sleepq_set_timeout</function>设置的超时； "
"<function>sleepq_wait_sig</function> 函数会等待显式地唤醒，或者其休眠被中"
"断； 而<function>sleepq_timedwait_sig</function> 函数则等待显式地唤醒、达到"
"用 <function>sleepq_set_timeout</function>设置的超时， 或线程的休眠被中断这三"
"种条件之一。所有这些等待函数的第一个参数都是等待通道。除此之外， "
"<function>sleepq_timedwait_sig</function>的第二个参数是一个布尔值， 表示之前"
"调用 <function>sleepq_catch_signals</function>时是否有发现未决信号。"

#. (itstool) path: sect2/para
#: book.translate.xml:15800
msgid ""
"If the thread is explicitly resumed or is aborted by a signal, then a value "
"of zero is returned by the wait function to indicate a successful sleep. If "
"the thread is resumed by either a timeout or an interrupt from the userland "
"thread scheduler then an appropriate errno value is returned instead. Note "
"that since <function>sleepq_wait</function> can only return 0 it does not "
"return anything and the caller should assume a successful sleep. Also, if a "
"thread's sleep times out and is aborted simultaneously then "
"<function>sleepq_timedwait_sig</function> will return an error indicating "
"that a timeout occurred. If an error value of 0 is returned and either "
"<function>sleepq_wait_sig</function> or <function>sleepq_timedwait_sig</"
"function> was used to block, then the function "
"<function>sleepq_calc_signal_retval</function> should be called to check for "
"any pending signals and calculate an appropriate return value if any are "
"found. The signal number returned by the earlier call to "
"<function>sleepq_catch_signals</function> should be passed as the sole "
"argument to <function>sleepq_calc_signal_retval</function>."
msgstr ""
"如果线程被显式地恢复运行， 或其休眠被信号终止，则等待函数会返回零， 表示休眠"
"成功。如果线程的休眠被超时或用户态线程调度器打断， 则会返回相应的 errno 数"
"值。需要注意的是， 因为 <function>sleepq_wait</function> 只能返回 0，因此调用"
"者不能指望它返回什么有用信息， 而应假定它完成了一次成功的休眠。同时， 如果线"
"程的休眠时间超时， 并同时被终止， 则<function>sleepq_timedwait_sig</"
"function> 将返回一个表示发生超时的错误代码。如果返回错误代码是0 而且使用 "
"<function>sleepq_wait_sig</function>或 <function>sleepq_timedwait_sig</"
"function> 来执行阻塞， 则应调用<function>sleepq_calc_signal_retval</"
"function> 来检查是否有未决信号，并据此选择合适的返回值。 较早前调用"
"<function>sleepq_catch_signals</function> 得到的信号编号，应作为参数传给"
"<function>sleepq_calc_signal_retval</function>。"

#. (itstool) path: sect2/para
#: book.translate.xml:15822
msgid ""
"Threads asleep on a wait channel are explicitly resumed by the "
"<function>sleepq_broadcast</function> and <function>sleepq_signal</function> "
"functions. Both functions accept the wait channel from which to resume "
"threads, a priority to raise resumed threads to, and a flags argument to "
"indicate which type of sleep queue is being resumed. The priority argument "
"is treated as a minimum priority. If a thread being resumed already has a "
"higher priority (numerically lower) than the priority argument then its "
"priority is not adjusted. The flags argument is used for internal assertions "
"to ensure that sleep queues are not being treated as the wrong type. For "
"example, the condition variable functions should not resume threads on a "
"traditional sleep queue. The <function>sleepq_broadcast</function> function "
"resumes all threads that are blocked on the specified wait channel while "
"<function>sleepq_signal</function> only resumes the highest priority thread "
"blocked on the wait channel. The sleep queue chain should first be locked "
"via the <function>sleepq_lock</function> function before calling these "
"functions."
msgstr ""
"在同一休眠通道上休眠的线程，可以由 <function>sleepq_broadcast</function> 或"
"<function>sleepq_signal</function> 函数来显式地唤醒。这两个函数的参数均包括希"
"望唤醒的等待通道、将唤醒线程的优先级 (priority) 提高到多少，以及一个标志 "
"(flags) 参数表示将要恢复运行的休眠队列类型。优先级参数将作为最低优先级， 如果"
"将恢复的线程的优先级比此参数更高(数值更低) 则其优先级不会调整。 标志参数主要"
"用于函数内部的断言，用以确认休眠队列没有被当做错误的类型对待。 例如，条件变量"
"函数不应恢复传统休眠队列的执行。 <function>sleepq_broadcast</function>函数将"
"恢复所有指定休眠通道上的阻塞线程，而 <function>sleepq_signal</function> 则只"
"恢复在等待通道上优先级最高的阻塞线程。在调用这些函数之前， 应首先使用"
"<function>sleepq_lock</function> 对休眠队列上锁。"

#. (itstool) path: sect2/para
#: book.translate.xml:15843
msgid ""
"A sleeping thread may have its sleep interrupted by calling the "
"<function>sleepq_abort</function> function. This function must be called "
"with <varname>sched_lock</varname> held and the thread must be queued on a "
"sleep queue. A thread may also be removed from a specific sleep queue via "
"the <function>sleepq_remove</function> function. This function accepts both "
"a thread and a wait channel as an argument and only awakens the thread if it "
"is on the sleep queue for the specified wait channel. If the thread is not "
"on a sleep queue or it is on a sleep queue for a different wait channel, "
"then this function does nothing."
msgstr ""
"休眠线程也可以通过调用 <function>sleepq_abort</function> 函数来中断其休眠状"
"态。这个函数只有在持有 <varname>sched_lock</varname> 时才能调用，而且线程必须"
"处于休眠队列之上。 线程也可以通过使用<function>sleepq_remove</function> 函数"
"从指定的休眠队列中删除。这个函数包括两个参数， 即休眠通道和线程，它只在线程处"
"于指定休眠通道的休眠队列之上时才将其唤醒。如果线程不在那个休眠队列之上， 或同"
"时处于另一等待通道的休眠队列上，则这个函数将什么都不做而直接返回。"

#. (itstool) path: sect2/title
#: book.translate.xml:15857
msgid "Turnstiles"
msgstr "十字转门 (turnstile)"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15859
msgid "<primary>turnstiles</primary>"
msgstr "<primary>turnstiles(十字转门)</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:15861
msgid "- Compare/contrast with sleep queues."
msgstr "- 与休眠队列的比较和不同。"

#. (itstool) path: sect2/para
#: book.translate.xml:15863
msgid "- Lookup/wait/release. - Describe TDF_TSNOBLOCK race."
msgstr ""
"- 查询/等待/释放 (lookup/wait/release)。- 介绍 TDF_TSNOBLOCK 竞态条件。"

#. (itstool) path: sect2/para
#: book.translate.xml:15866
msgid "- Priority propagation."
msgstr "- 优先级传播。"

#. (itstool) path: sect2/title
#: book.translate.xml:15870
msgid "Details of the Mutex Implementation"
msgstr "关于 mutex 实现的一些细节"

#. (itstool) path: sect2/para
#: book.translate.xml:15872
msgid ""
"- Should we require mutexes to be owned for mtx_destroy() since we can not "
"safely assert that they are unowned by anyone else otherwise?"
msgstr ""
"- 我们是否应要求  mtx_destroy() 持有 mutex，因为无法安全地断言它们没有被其它"
"对象持有？"

#. (itstool) path: sect3/title
#: book.translate.xml:15877
msgid "Spin Mutexes"
msgstr "自旋 mutex"

#. (itstool) path: sect3/indexterm
#: book.translate.xml:15879
msgid "<primary>mutex</primary><secondary>spin</secondary>"
msgstr ""
"<primary>mutex(同时/独占, mutual exclusion)</primary><secondary>sleep(休眠)</"
"secondary>"

#. (itstool) path: sect3/para
#: book.translate.xml:15881
msgid "- Use a critical section..."
msgstr "- 使用一临界区..."

#. (itstool) path: sect3/title
#: book.translate.xml:15885
msgid "Sleep Mutexes"
msgstr "休眠 mutex"

#. (itstool) path: sect3/indexterm
#: book.translate.xml:15887
msgid "<primary>mutex</primary><secondary>sleep</secondary>"
msgstr ""
"<primary>mutex(同时/独占, mutual exclusion)</primary><secondary>sleep(休眠)</"
"secondary>"

#. (itstool) path: sect3/para
#: book.translate.xml:15888
msgid "- Describe the races with contested mutexes"
msgstr "- 描述 mutex 冲突时的竞态条件"

#. (itstool) path: sect3/para
#: book.translate.xml:15890
msgid ""
"- Why it is safe to read mtx_lock of a contested mutex when holding the "
"turnstile chain lock."
msgstr "- 为何在持有十字转门链锁时， 可以安全地读冲突 mutex 的 mtx_lock。"

#. (itstool) path: sect2/title
#: book.translate.xml:15896
msgid "Witness"
msgstr "Witness"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15898
msgid "<primary>witness</primary>"
msgstr "<primary>witness</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:15900
msgid "- What does it do"
msgstr "- 它能做什么"

#. (itstool) path: sect2/para
#: book.translate.xml:15902
msgid "- How does it work"
msgstr "- 它如何工作"

#. (itstool) path: sect1/title
#: book.translate.xml:15907
msgid "Miscellaneous Topics"
msgstr "其它话题"

#. (itstool) path: sect2/title
#: book.translate.xml:15910
msgid "Interrupt Source and ICU Abstractions"
msgstr "中断源和 ICU 抽象"

#. (itstool) path: sect2/para
#: book.translate.xml:15912
msgid "- struct isrc"
msgstr "- struct isrc"

#. (itstool) path: sect2/para
#: book.translate.xml:15914
msgid "- pic drivers"
msgstr "- pic 驱动"

#. (itstool) path: sect2/title
#: book.translate.xml:15918
msgid "Other Random Questions/Topics"
msgstr "其它问题/话题"

#. (itstool) path: sect2/para
#: book.translate.xml:15920
msgid "- Should we pass an interlock into <function>sema_wait</function>?"
msgstr "- 是否应提供非休眠式 sx 锁？"

#. (itstool) path: sect2/para
#: book.translate.xml:15923
msgid "- Should we have non-sleepable sx locks?"
msgstr "- 增加一些关于正确使用引用计数的介绍？"

#. (itstool) path: sect2/para
#: book.translate.xml:15925
msgid "- Add some info about proper use of reference counts."
msgstr "- 增加一些关于正确使用引用计数的介绍。"

#. (itstool) path: glossary/title
#: book.translate.xml:15930
msgid "Glossary"
msgstr "术语表"

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15933
msgid "atomic"
msgstr "原子"

#. (itstool) path: glossdef/para
#: book.translate.xml:15935
msgid ""
"An operation is atomic if all of its effects are visible to other CPUs "
"together when the proper access protocol is followed. In the degenerate case "
"are atomic instructions provided directly by machine architectures. At a "
"higher level, if several members of a structure are protected by a lock, "
"then a set of operations are atomic if they are all performed while holding "
"the lock without releasing the lock in between any of the operations."
msgstr ""
"当遵循适当的访问协议时， 如果一操作的效果对其它所有 CPU均可见， 则称其为原子"
"操作。 狭义的原子操作是机器直接提供的。就更高的抽象层次而言， 如果结构体的多"
"个成员由一个锁保护，则如果对它们的操作都是在上锁后、 解锁前进行的，也可以称其"
"为原子操作。"

#. (itstool) path: glossdef/glossseealso
#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15944 book.translate.xml:15995
msgid "operation"
msgstr "操作"

#. (itstool) path: glossentry/glossterm
#. (itstool) path: glossdef/glossseealso
#: book.translate.xml:15949 book.translate.xml:16027
msgid "block"
msgstr "阻塞块"

#. (itstool) path: glossdef/para
#: book.translate.xml:15951
msgid ""
"A thread is blocked when it is waiting on a lock, resource, or condition. "
"Unfortunately this term is a bit overloaded as a result."
msgstr "线程等待锁、 资源或条件时被阻塞。这一术语也因此被赋予了太多的意涵。"

#. (itstool) path: glossdef/glossseealso
#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15955 book.translate.xml:16021 book.translate.xml:16040
msgid "sleep"
msgstr "睡眠"

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15960
msgid "critical section"
msgstr "临界区"

#. (itstool) path: glossdef/para
#: book.translate.xml:15962
msgid ""
"A section of code that is not allowed to be preempted. A critical section is "
"entered and exited using the <citerefentry><refentrytitle>critical_enter</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> API."
msgstr ""
"不允许发生抢占的代码段。 使用 <citerefentry><refentrytitle>critical_enter</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> API 来表示进入和退出临"
"界区。"

#. (itstool) path: glossentry/glossterm
#. (itstool) path: glossdef/glossseealso
#: book.translate.xml:15969 book.translate.xml:15990
msgid "MD"
msgstr "MD (Machine dependent)"

#. (itstool) path: glossdef/para
#: book.translate.xml:15971
msgid "Machine dependent."
msgstr "表示与机器/平台有关。"

#. (itstool) path: glossdef/glossseealso
#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15973 book.translate.xml:15986
msgid "MI"
msgstr "MI （Machine independent）"

#. (itstool) path: glossentry/glossterm
#. (itstool) path: glossentry/glosssee
#: book.translate.xml:15978 book.translate.xml:15996
msgid "memory operation"
msgstr "内存操作"

#. (itstool) path: glossdef/para
#: book.translate.xml:15980
msgid "A memory operation reads and/or writes to a memory location."
msgstr "内存操作包括读或写内存中的指定位置。"

#. (itstool) path: glossdef/para
#: book.translate.xml:15988
msgid "Machine independent."
msgstr "表示与机器/平台无关。"

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:16000
msgid "primary interrupt context"
msgstr "主中断上下文"

#. (itstool) path: glossdef/para
#: book.translate.xml:16002
msgid ""
"Primary interrupt context refers to the code that runs when an interrupt "
"occurs. This code can either run an interrupt handler directly or schedule "
"an asynchronous interrupt thread to execute the interrupt handlers for a "
"given interrupt source."
msgstr ""
"主中断上下文表示当发生中断时所执行的那段代码。这些代码可以直接运行某个中断处"
"理程序， 或调度一异步终端线程，以便为给定的中断源执行中断处理程序。"

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:16011
msgid "realtime kernel thread"
msgstr "实时内核线程"

#. (itstool) path: glossdef/para
#: book.translate.xml:16013
msgid ""
"A high priority kernel thread. Currently, the only realtime priority kernel "
"threads are interrupt threads."
msgstr "一种高优先级的内核线程。 目前，只有中断线程属于实时优先级的内核线程。"

#. (itstool) path: glossdef/glossseealso
#. (itstool) path: glossentry/glossterm
#: book.translate.xml:16016 book.translate.xml:16045
msgid "thread"
msgstr "线程"

#. (itstool) path: glossdef/para
#: book.translate.xml:16023
msgid ""
"A thread is asleep when it is blocked on a condition variable or a sleep "
"queue via <function>msleep</function> or <function>tsleep</function>."
msgstr ""
"当进程由条件变量或通过 <function>msleep</function> 或<function>tsleep</"
"function> 阻塞并进入休眠队列时， 称其进入休眠状态。"

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:16032
msgid "sleepable lock"
msgstr "可休眠锁"

#. (itstool) path: glossdef/para
#: book.translate.xml:16034
msgid ""
"A sleepable lock is a lock that can be held by a thread which is asleep. "
"Lockmgr locks and sx locks are currently the only sleepable locks in "
"FreeBSD. Eventually, some sx locks such as the allproc and proctree locks "
"may become non-sleepable locks."
msgstr ""
"可休眠锁是一种在进程休眠时仍可持有的锁。锁管理器 (lockmgr) 锁和 sx 锁是目前 "
"FreeBSD 中仅有的可休眠锁。最终， 某些 sx 锁， 例如 allproc (全部进程) 和 "
"proctree (进程树)锁将成为不可休眠锁。"

#. (itstool) path: glossdef/para
#: book.translate.xml:16047
msgid ""
"A kernel thread represented by a struct thread. Threads own locks and hold a "
"single execution context."
msgstr ""
"由 struct thread 所表达的内核线程。 线程可以持有锁，并拥有独立的执行上下文。"

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:16053
msgid "wait channel"
msgstr "等待通道"

#. (itstool) path: glossdef/para
#: book.translate.xml:16055
msgid "A kernel virtual address that threads may sleep on."
msgstr "线程可以在其上休眠的内核虚拟地址。"

#. (itstool) path: part/title
#. (itstool) path: sect1/title
#: book.translate.xml:16065 book.translate.xml:22480
msgid "Device Drivers"
msgstr "设备驱动"

#. (itstool) path: info/title
#: book.translate.xml:16077
msgid "Writing FreeBSD Device Drivers"
msgstr "编写 FreeBSD 设备驱动程序"

#. (itstool) path: authorgroup/author
#: book.translate.xml:16080
msgid ""
"<personname> <firstname>Murray</firstname> <surname>Stokely</surname> </"
"personname> <contrib>Written by </contrib>"
msgstr ""
"<personname> <firstname>Murray</firstname> <surname>Stokely</surname> </"
"personname> <contrib>Written by </contrib>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:16091
msgid ""
"<personname> <firstname>Jörg</firstname> <surname>Wunsch</surname> </"
"personname> <contrib>Based on intro(4) manual page by </contrib>"
msgstr ""
"<personname> <firstname>Jörg</firstname> <surname>Wunsch</surname> </"
"personname> <contrib>Based on intro(4) manual page by </contrib>"

#. (itstool) path: sect1/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:16105 book.translate.xml:22485
msgid "<primary>device driver</primary>"
msgstr "<primary>device driver（设备驱动程序）</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16106
msgid "<primary>pseudo-device</primary>"
msgstr "<primary>pseudo-device（伪设备）</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:16108
msgid ""
"This chapter provides a brief introduction to writing device drivers for "
"FreeBSD. A device in this context is a term used mostly for hardware-related "
"stuff that belongs to the system, like disks, printers, or a graphics "
"display with its keyboard. A device driver is the software component of the "
"operating system that controls a specific device. There are also so-called "
"pseudo-devices where a device driver emulates the behavior of a device in "
"software without any particular underlying hardware. Device drivers can be "
"compiled into the system statically or loaded on demand through the dynamic "
"kernel linker facility `kld'."
msgstr ""
"本章简要介绍了如何为FreeBSD编写设备驱动程序。术语设备在这儿的上下文中多用于指"
"代系统中硬件相关的东西，如磁盘，打印机，图形显式器及其键盘。设备驱动程序是操"
"作系统中用于控制特定设备的软件组件。也有所谓的伪设备，即设备驱动程序用软件模"
"拟设备的行为，而没有特定的底层硬件。设备驱动程序可以被静态地编译进系统，或者"
"通过动态内核链接工具‘kld’在需要时加载。"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16120
msgid "<primary>device nodes</primary>"
msgstr "<primary>device nodes（设备节点）</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:16122
#, fuzzy
msgid ""
"Most devices in a <trademark class=\"registered\">UNIX</trademark>-like "
"operating system are accessed through device-nodes, sometimes also called "
"special files. These files are usually located under the directory "
"<filename>/dev</filename> in the filesystem hierarchy."
msgstr ""
"类&unix;操作系统中的大多数设备都是通过设备节点来访问的，有时也被称为特殊文"
"件。这些文件在文件系统的层次结构中通常位于<filename>/dev</filename>目录下。在"
"FreeBSD 5.0-RELEASE以前的发行版中, 对<citerefentry><refentrytitle>devfs</"
"refentrytitle><manvolnum>5</manvolnum></citerefentry>的支持还没有被集成到"
"FreeBSD中，每个设备节点必须要静态创建，并且独立于相关设备驱动程序的存在。系统"
"中大多数设备节点是通过运行<command>MAKEDEV</command>创建的。"

#. (itstool) path: sect1/para
#: book.translate.xml:16127
msgid ""
"Device drivers can roughly be broken down into two categories; character and "
"network device drivers."
msgstr "设备驱动程序可以粗略地分为两类，字符和网络设备驱动程序。"

#. (itstool) path: sect1/title
#: book.translate.xml:16133
msgid "Dynamic Kernel Linker Facility - KLD"
msgstr "动态内核链接工具 - KLD"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16135
msgid "<primary>kernel linking</primary> <secondary>dynamic</secondary>"
msgstr "<primary>kernel linking</primary> <secondary>dynamic</secondary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16139
msgid "<primary>kernel loadable modules (KLD)</primary>"
msgstr "<primary>kernel loadable modules (KLD, 内核可装载模块)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:16143
msgid ""
"The kld interface allows system administrators to dynamically add and remove "
"functionality from a running system. This allows device driver writers to "
"load their new changes into a running kernel without constantly rebooting to "
"test changes."
msgstr ""
"kld接口允许系统管理员从运行的系统中动态地添加和删除功能。这允许设备驱动程序的"
"编写者将他们的新改动加载到运行的内核中，而不用为了测试新改动而频繁地重启。"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16149
msgid "<primary>kernel modules</primary> <secondary>loading</secondary>"
msgstr ""
"<primary>kernel modules（内核模块）</primary> <secondary>loading（加载）</"
"secondary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16153
msgid "<primary>kernel modules</primary> <secondary>unloading</secondary>"
msgstr "<primary>kernel modules</primary> <secondary>unloading</secondary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16157
msgid "<primary>kernel modules</primary> <secondary>listing</secondary>"
msgstr "<primary>kernel modules</primary> <secondary>listing</secondary>"

#. (itstool) path: sect1/para
#: book.translate.xml:16162
msgid "The kld interface is used through:"
msgstr "kld 接口通过下面的特权命令使用："

#. (itstool) path: listitem/simpara
#: book.translate.xml:16166
#, fuzzy
msgid "<command>kldload</command> - loads a new kernel module"
msgstr "<command>kldload</command> - loads a new kernel module"

#. (itstool) path: listitem/simpara
#: book.translate.xml:16169
msgid "<command>kldunload</command> - unloads a kernel module"
msgstr "<command>kldunload</command> - unloads a kernel module"

#. (itstool) path: listitem/simpara
#: book.translate.xml:16172
#, fuzzy
msgid "<command>kldstat</command> - lists loaded modules"
msgstr "<command>kldstat</command> - lists loaded modules"

#. (itstool) path: sect1/para
#: book.translate.xml:16176
msgid "Skeleton Layout of a kernel module"
msgstr "内核模块的程序框架"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16178
#, no-wrap
msgid ""
"/*\n"
" * KLD Skeleton\n"
" * Inspired by Andrew Reiter's Daemonnews article\n"
" */\n"
"\n"
"#include &lt;sys/types.h&gt;\n"
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/systm.h&gt;  /* uprintf */\n"
"#include &lt;sys/errno.h&gt;\n"
"#include &lt;sys/param.h&gt;  /* defines used in kernel.h */\n"
"#include &lt;sys/kernel.h&gt; /* types used in module initialization */\n"
"\n"
"/*\n"
" * Load handler that deals with the loading and unloading of a KLD.\n"
" */\n"
"\n"
"static int\n"
"skel_loader(struct module *m, int what, void *arg)\n"
"{\n"
"  int err = 0;\n"
"\n"
"  switch (what) {\n"
"  case MOD_LOAD:                /* kldload */\n"
"    uprintf(\"Skeleton KLD loaded.\\n\");\n"
"    break;\n"
"  case MOD_UNLOAD:\n"
"    uprintf(\"Skeleton KLD unloaded.\\n\");\n"
"    break;\n"
"  default:\n"
"    err = EOPNOTSUPP;\n"
"    break;\n"
"  }\n"
"  return(err);\n"
"}\n"
"\n"
"/* Declare this module to the rest of the kernel */\n"
"\n"
"static moduledata_t skel_mod = {\n"
"  \"skel\",\n"
"  skel_loader,\n"
"  NULL\n"
"};\n"
"\n"
"DECLARE_MODULE(skeleton, skel_mod, SI_SUB_KLD, SI_ORDER_ANY);"
msgstr ""
"/*\n"
" * KLD Skeleton\n"
" * Inspired by Andrew Reiter's Daemonnews article\n"
" */\n"
"\n"
"#include &lt;sys/types.h&gt;\n"
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/systm.h&gt;  /* uprintf */\n"
"#include &lt;sys/errno.h&gt;\n"
"#include &lt;sys/param.h&gt;  /* defines used in kernel.h */\n"
"#include &lt;sys/kernel.h&gt; /* types used in module initialization */\n"
"\n"
"/*\n"
" * Load handler that deals with the loading and unloading of a KLD.\n"
" */\n"
"\n"
"static int\n"
"skel_loader(struct module *m, int what, void *arg)\n"
"{\n"
"  int err = 0;\n"
"\n"
"  switch (what) {\n"
"  case MOD_LOAD:                /* kldload */\n"
"    uprintf(\"Skeleton KLD loaded.\\n\");\n"
"    break;\n"
"  case MOD_UNLOAD:\n"
"    uprintf(\"Skeleton KLD unloaded.\\n\");\n"
"    break;\n"
"  default:\n"
"    err = EOPNOTSUPP;\n"
"    break;\n"
"  }\n"
"  return(err);\n"
"}\n"
"\n"
"/* Declare this module to the rest of the kernel */\n"
"\n"
"static moduledata_t skel_mod = {\n"
"  \"skel\",\n"
"  skel_loader,\n"
"  NULL\n"
"};\n"
"\n"
"DECLARE_MODULE(skeleton, skel_mod, SI_SUB_KLD, SI_ORDER_ANY);"

#. (itstool) path: sect2/title
#: book.translate.xml:16225
msgid "Makefile"
msgstr "Makefile"

#. (itstool) path: sect2/para
#: book.translate.xml:16227
msgid ""
"FreeBSD provides a system makefile to simplify compiling a kernel module."
msgstr ""
"FreeBSD提供了一个makefile包含文件，利用它你可以快速地编译你附加到内核的东西。"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:16230
#, no-wrap
msgid ""
"SRCS=skeleton.c\n"
"KMOD=skeleton\n"
"\n"
".include &lt;bsd.kmod.mk&gt;"
msgstr ""
"SRCS=skeleton.c\n"
"KMOD=skeleton\n"
"\n"
".include &lt;bsd.kmod.mk&gt;"

#. (itstool) path: sect2/para
#: book.translate.xml:16235
msgid ""
"Running <command>make</command> with this makefile will create a file "
"<filename>skeleton.ko</filename> that can be loaded into the kernel by "
"typing:"
msgstr ""
"简单地用这个makefile运行<command>make</command>就能够创建文件"
"<filename>skeleton.ko</filename>，键入如下命令可以把它加载到内核："

#. (itstool) path: sect2/screen
#: book.translate.xml:16239
#, no-wrap
msgid "<prompt>#</prompt> <userinput>kldload -v ./skeleton.ko</userinput>"
msgstr "<prompt>#</prompt> <userinput>kldload -v ./skeleton.ko</userinput>"

#. (itstool) path: sect1/title
#. (itstool) path: sect2/title
#: book.translate.xml:16244 book.translate.xml:22524
msgid "Character Devices"
msgstr "字符设备"

#. (itstool) path: sect1/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:16246 book.translate.xml:22526
msgid "<primary>character devices</primary>"
msgstr "<primary>character devices(字符设备)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:16249
msgid ""
"A character device driver is one that transfers data directly to and from a "
"user process. This is the most common type of device driver and there are "
"plenty of simple examples in the source tree."
msgstr ""
"字符设备驱动程序直接从用户进程传输数据，或传输数据到用户进程。这是最普通的一"
"类设备驱动程序，源码树中有大量的简单例子。"

#. (itstool) path: sect1/para
#: book.translate.xml:16254
msgid ""
"This simple example pseudo-device remembers whatever values are written to "
"it and can then echo them back when read."
msgstr ""
"这个简单的伪设备例子会记住你写给它的任何值，并且当你读取它的时候会将这些值返"
"回给你。"

#. (itstool) path: example/title
#: book.translate.xml:16259
#, fuzzy
#| msgid ""
#| "Example of a Sample Echo Pseudo-Device Driver for FreeBSD 10.X - 12.X"
msgid "Example of a Sample Echo Pseudo-Device Driver for FreeBSD 10.X - 12.X"
msgstr "适用于 FreeBSD 10.X - 12.X 的回显伪设备驱动程序实例"

#. (itstool) path: example/programlisting
#: book.translate.xml:16262
#, no-wrap
msgid ""
"/*\n"
" * Simple Echo pseudo-device KLD\n"
" *\n"
" * Murray Stokely\n"
" * Søren (Xride) Straarup\n"
" * Eitan Adler\n"
" */\n"
"\n"
"#include &lt;sys/types.h&gt;\n"
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/systm.h&gt;  /* uprintf */\n"
"#include &lt;sys/param.h&gt;  /* defines used in kernel.h */\n"
"#include &lt;sys/kernel.h&gt; /* types used in module initialization */\n"
"#include &lt;sys/conf.h&gt;   /* cdevsw struct */\n"
"#include &lt;sys/uio.h&gt;    /* uio struct */\n"
"#include &lt;sys/malloc.h&gt;\n"
"\n"
"#define BUFFERSIZE 255\n"
"\n"
"/* Function prototypes */\n"
"static d_open_t      echo_open;\n"
"static d_close_t     echo_close;\n"
"static d_read_t      echo_read;\n"
"static d_write_t     echo_write;\n"
"\n"
"/* Character device entry points */\n"
"static struct cdevsw echo_cdevsw = {\n"
"\t.d_version = D_VERSION,\n"
"\t.d_open = echo_open,\n"
"\t.d_close = echo_close,\n"
"\t.d_read = echo_read,\n"
"\t.d_write = echo_write,\n"
"\t.d_name = \"echo\",\n"
"};\n"
"\n"
"struct s_echo {\n"
"\tchar msg[BUFFERSIZE + 1];\n"
"\tint len;\n"
"};\n"
"\n"
"/* vars */\n"
"static struct cdev *echo_dev;\n"
"static struct s_echo *echomsg;\n"
"\n"
"MALLOC_DECLARE(M_ECHOBUF);\n"
"MALLOC_DEFINE(M_ECHOBUF, \"echobuffer\", \"buffer for echo module\");\n"
"\n"
"/*\n"
" * This function is called by the kld[un]load(2) system calls to\n"
" * determine what actions to take when a module is loaded or unloaded.\n"
" */\n"
"static int\n"
"echo_loader(struct module *m __unused, int what, void *arg __unused)\n"
"{\n"
"\tint error = 0;\n"
"\n"
"\tswitch (what) {\n"
"\tcase MOD_LOAD:                /* kldload */\n"
"\t\terror = make_dev_p(MAKEDEV_CHECKNAME | MAKEDEV_WAITOK,\n"
"\t\t    &amp;echo_dev,\n"
"\t\t    &amp;echo_cdevsw,\n"
"\t\t    0,\n"
"\t\t    UID_ROOT,\n"
"\t\t    GID_WHEEL,\n"
"\t\t    0600,\n"
"\t\t    \"echo\");\n"
"\t\tif (error != 0)\n"
"\t\t\tbreak;\n"
"\n"
"\t\techomsg = malloc(sizeof(*echomsg), M_ECHOBUF, M_WAITOK |\n"
"\t\t    M_ZERO);\n"
"\t\tprintf(\"Echo device loaded.\\n\");\n"
"\t\tbreak;\n"
"\tcase MOD_UNLOAD:\n"
"\t\tdestroy_dev(echo_dev);\n"
"\t\tfree(echomsg, M_ECHOBUF);\n"
"\t\tprintf(\"Echo device unloaded.\\n\");\n"
"\t\tbreak;\n"
"\tdefault:\n"
"\t\terror = EOPNOTSUPP;\n"
"\t\tbreak;\n"
"\t}\n"
"\treturn (error);\n"
"}\n"
"\n"
"static int\n"
"echo_open(struct cdev *dev __unused, int oflags __unused, int devtype __unused,\n"
"    struct thread *td __unused)\n"
"{\n"
"\tint error = 0;\n"
"\n"
"\tuprintf(\"Opened device \\\"echo\\\" successfully.\\n\");\n"
"\treturn (error);\n"
"}\n"
"\n"
"static int\n"
"echo_close(struct cdev *dev __unused, int fflag __unused, int devtype __unused,\n"
"    struct thread *td __unused)\n"
"{\n"
"\n"
"\tuprintf(\"Closing device \\\"echo\\\".\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/*\n"
" * The read function just takes the buf that was saved via\n"
" * echo_write() and returns it to userland for accessing.\n"
" * uio(9)\n"
" */\n"
"static int\n"
"echo_read(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)\n"
"{\n"
"\tsize_t amt;\n"
"\tint error;\n"
"\n"
"\t/*\n"
"\t * How big is this read operation?  Either as big as the user wants,\n"
"\t * or as big as the remaining data.  Note that the 'len' does not\n"
"\t * include the trailing null character.\n"
"\t */\n"
"\tamt = MIN(uio-&gt;uio_resid, uio-&gt;uio_offset &gt;= echomsg-&gt;len + 1 ? 0 :\n"
"\t    echomsg-&gt;len + 1 - uio-&gt;uio_offset);\n"
"\n"
"\tif ((error = uiomove(echomsg-&gt;msg, amt, uio)) != 0)\n"
"\t\tuprintf(\"uiomove failed!\\n\");\n"
"\n"
"\treturn (error);\n"
"}\n"
"\n"
"/*\n"
" * echo_write takes in a character string and saves it\n"
" * to buf for later accessing.\n"
" */\n"
"static int\n"
"echo_write(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)\n"
"{\n"
"\tsize_t amt;\n"
"\tint error;\n"
"\n"
"\t/*\n"
"\t * We either write from the beginning or are appending -- do\n"
"\t * not allow random access.\n"
"\t */\n"
"\tif (uio-&gt;uio_offset != 0 &amp;&amp; (uio-&gt;uio_offset != echomsg-&gt;len))\n"
"\t\treturn (EINVAL);\n"
"\n"
"\t/* This is a new message, reset length */\n"
"\tif (uio-&gt;uio_offset == 0)\n"
"\t\techomsg-&gt;len = 0;\n"
"\n"
"\t/* Copy the string in from user memory to kernel memory */\n"
"\tamt = MIN(uio-&gt;uio_resid, (BUFFERSIZE - echomsg-&gt;len));\n"
"\n"
"\terror = uiomove(echomsg-&gt;msg + uio-&gt;uio_offset, amt, uio);\n"
"\n"
"\t/* Now we need to null terminate and record the length */\n"
"\techomsg-&gt;len = uio-&gt;uio_offset;\n"
"\techomsg-&gt;msg[echomsg-&gt;len] = 0;\n"
"\n"
"\tif (error != 0)\n"
"\t\tuprintf(\"Write failed: bad address!\\n\");\n"
"\treturn (error);\n"
"}\n"
"\n"
"DEV_MODULE(echo, echo_loader, NULL);"
msgstr ""
"/*\n"
" * Simple Echo pseudo-device KLD\n"
" *\n"
" * Murray Stokely\n"
" * Søren (Xride) Straarup\n"
" * Eitan Adler\n"
" */\n"
"\n"
"#include &lt;sys/types.h&gt;\n"
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/systm.h&gt;  /* uprintf */\n"
"#include &lt;sys/param.h&gt;  /* defines used in kernel.h */\n"
"#include &lt;sys/kernel.h&gt; /* types used in module initialization */\n"
"#include &lt;sys/conf.h&gt;   /* cdevsw struct */\n"
"#include &lt;sys/uio.h&gt;    /* uio struct */\n"
"#include &lt;sys/malloc.h&gt;\n"
"\n"
"#define BUFFERSIZE 255\n"
"\n"
"/* Function prototypes */\n"
"static d_open_t      echo_open;\n"
"static d_close_t     echo_close;\n"
"static d_read_t      echo_read;\n"
"static d_write_t     echo_write;\n"
"\n"
"/* Character device entry points */\n"
"static struct cdevsw echo_cdevsw = {\n"
"\t.d_version = D_VERSION,\n"
"\t.d_open = echo_open,\n"
"\t.d_close = echo_close,\n"
"\t.d_read = echo_read,\n"
"\t.d_write = echo_write,\n"
"\t.d_name = \"echo\",\n"
"};\n"
"\n"
"struct s_echo {\n"
"\tchar msg[BUFFERSIZE + 1];\n"
"\tint len;\n"
"};\n"
"\n"
"/* vars */\n"
"static struct cdev *echo_dev;\n"
"static struct s_echo *echomsg;\n"
"\n"
"MALLOC_DECLARE(M_ECHOBUF);\n"
"MALLOC_DEFINE(M_ECHOBUF, \"echobuffer\", \"buffer for echo module\");\n"
"\n"
"/*\n"
" * This function is called by the kld[un]load(2) system calls to\n"
" * determine what actions to take when a module is loaded or unloaded.\n"
" */\n"
"static int\n"
"echo_loader(struct module *m __unused, int what, void *arg __unused)\n"
"{\n"
"\tint error = 0;\n"
"\n"
"\tswitch (what) {\n"
"\tcase MOD_LOAD:                /* kldload */\n"
"\t\terror = make_dev_p(MAKEDEV_CHECKNAME | MAKEDEV_WAITOK,\n"
"\t\t    &amp;echo_dev,\n"
"\t\t    &amp;echo_cdevsw,\n"
"\t\t    0,\n"
"\t\t    UID_ROOT,\n"
"\t\t    GID_WHEEL,\n"
"\t\t    0600,\n"
"\t\t    \"echo\");\n"
"\t\tif (error != 0)\n"
"\t\t\tbreak;\n"
"\n"
"\t\techomsg = malloc(sizeof(*echomsg), M_ECHOBUF, M_WAITOK |\n"
"\t\t    M_ZERO);\n"
"\t\tprintf(\"Echo device loaded.\\n\");\n"
"\t\tbreak;\n"
"\tcase MOD_UNLOAD:\n"
"\t\tdestroy_dev(echo_dev);\n"
"\t\tfree(echomsg, M_ECHOBUF);\n"
"\t\tprintf(\"Echo device unloaded.\\n\");\n"
"\t\tbreak;\n"
"\tdefault:\n"
"\t\terror = EOPNOTSUPP;\n"
"\t\tbreak;\n"
"\t}\n"
"\treturn (error);\n"
"}\n"
"\n"
"static int\n"
"echo_open(struct cdev *dev __unused, int oflags __unused, int devtype __unused,\n"
"    struct thread *td __unused)\n"
"{\n"
"\tint error = 0;\n"
"\n"
"\tuprintf(\"Opened device \\\"echo\\\" successfully.\\n\");\n"
"\treturn (error);\n"
"}\n"
"\n"
"static int\n"
"echo_close(struct cdev *dev __unused, int fflag __unused, int devtype __unused,\n"
"    struct thread *td __unused)\n"
"{\n"
"\n"
"\tuprintf(\"Closing device \\\"echo\\\".\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/*\n"
" * The read function just takes the buf that was saved via\n"
" * echo_write() and returns it to userland for accessing.\n"
" * uio(9)\n"
" */\n"
"static int\n"
"echo_read(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)\n"
"{\n"
"\tsize_t amt;\n"
"\tint error;\n"
"\n"
"\t/*\n"
"\t * How big is this read operation?  Either as big as the user wants,\n"
"\t * or as big as the remaining data.  Note that the 'len' does not\n"
"\t * include the trailing null character.\n"
"\t */\n"
"\tamt = MIN(uio-&gt;uio_resid, uio-&gt;uio_offset &gt;= echomsg-&gt;len + 1 ? 0 :\n"
"\t    echomsg-&gt;len + 1 - uio-&gt;uio_offset);\n"
"\n"
"\tif ((error = uiomove(echomsg-&gt;msg, amt, uio)) != 0)\n"
"\t\tuprintf(\"uiomove failed!\\n\");\n"
"\n"
"\treturn (error);\n"
"}\n"
"\n"
"/*\n"
" * echo_write takes in a character string and saves it\n"
" * to buf for later accessing.\n"
" */\n"
"static int\n"
"echo_write(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)\n"
"{\n"
"\tsize_t amt;\n"
"\tint error;\n"
"\n"
"\t/*\n"
"\t * We either write from the beginning or are appending -- do\n"
"\t * not allow random access.\n"
"\t */\n"
"\tif (uio-&gt;uio_offset != 0 &amp;&amp; (uio-&gt;uio_offset != echomsg-&gt;len))\n"
"\t\treturn (EINVAL);\n"
"\n"
"\t/* This is a new message, reset length */\n"
"\tif (uio-&gt;uio_offset == 0)\n"
"\t\techomsg-&gt;len = 0;\n"
"\n"
"\t/* Copy the string in from user memory to kernel memory */\n"
"\tamt = MIN(uio-&gt;uio_resid, (BUFFERSIZE - echomsg-&gt;len));\n"
"\n"
"\terror = uiomove(echomsg-&gt;msg + uio-&gt;uio_offset, amt, uio);\n"
"\n"
"\t/* Now we need to null terminate and record the length */\n"
"\techomsg-&gt;len = uio-&gt;uio_offset;\n"
"\techomsg-&gt;msg[echomsg-&gt;len] = 0;\n"
"\n"
"\tif (error != 0)\n"
"\t\tuprintf(\"Write failed: bad address!\\n\");\n"
"\treturn (error);\n"
"}\n"
"\n"
"DEV_MODULE(echo, echo_loader, NULL);"

#. (itstool) path: sect1/para
#: book.translate.xml:16429
msgid "With this driver loaded try:"
msgstr "驱动程序被加载后，你应该能够键入一些东西，如："

#. (itstool) path: sect1/screen
#: book.translate.xml:16431
#, no-wrap
msgid ""
"<prompt>#</prompt> <userinput>echo -n \"Test Data\" &gt; /dev/echo</userinput>\n"
"<prompt>#</prompt> <userinput>cat /dev/echo</userinput>\n"
"Opened device \"echo\" successfully.\n"
"Test Data\n"
"Closing device \"echo\"."
msgstr ""
"<prompt>#</prompt> <userinput>echo -n \"Test Data\" &gt; /dev/echo</userinput>\n"
"<prompt>#</prompt> <userinput>cat /dev/echo</userinput>\n"
"Opened device \"echo\" successfully.\n"
"Test Data\n"
"Closing device \"echo\"."

#. (itstool) path: sect1/para
#: book.translate.xml:16437
msgid "Real hardware devices are described in the next chapter."
msgstr "真正的硬件设备在下一章描述。"

#. (itstool) path: sect1/title
#: book.translate.xml:16442
msgid "Block Devices (Are Gone)"
msgstr "块设备（已消亡）"

#. (itstool) path: sect1/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:16444 book.translate.xml:22511
msgid "<primary>block devices</primary>"
msgstr "<primary>block devices(块设备)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:16446
#, fuzzy
msgid ""
"Other <trademark class=\"registered\">UNIX</trademark> systems may support a "
"second type of disk device known as block devices. Block devices are disk "
"devices for which the kernel provides caching. This caching makes block-"
"devices almost unusable, or at least dangerously unreliable. The caching "
"will reorder the sequence of write operations, depriving the application of "
"the ability to know the exact disk contents at any one instant in time."
msgstr ""
"其他&unix;系统支持另一类型的磁盘设备，称为块设备。块设备是内核为它们提供缓冲"
"的磁盘设备。这种缓冲使得块设备几乎没有用，或者说非常不可靠。缓冲会重新安排写"
"操作的次序，使得应用程序丧失了在任何时刻及时知道准确的磁盘内容的能力。这导致"
"对磁盘数据结构（文件系统，数据库等）的可预测的和可靠的崩溃恢复成为不可能。由"
"于写操作被延迟，内核无法向应用程序报告哪个特定的写操作遇到了写错误，这又进一"
"步增加了一致性问题。由于这个原因，真正的应用程序从不依赖于块设备，事实上，几"
"乎所有访问磁盘的应用程序都尽力指定总是使用字符（或<quote>raw</quote>）设备。"
"由于实现将每个磁盘（分区）同具有不同语义的两个设备混为一谈，从而致使相关内核"
"代码极大地复杂化，作为推进磁盘I/O基础结构现代化的一部分，&os;抛弃了对带缓冲的"
"磁盘设备的支持。"

#. (itstool) path: sect1/para
#: book.translate.xml:16454
msgid ""
"This makes predictable and reliable crash recovery of on-disk data "
"structures (filesystems, databases, etc.) impossible. Since writes may be "
"delayed, there is no way the kernel can report to the application which "
"particular write operation encountered a write error, this further compounds "
"the consistency problem."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:16461
msgid ""
"For this reason, no serious applications rely on block devices, and in fact, "
"almost all applications which access disks directly take great pains to "
"specify that character (or <quote>raw</quote>) devices should always be "
"used. Because the implementation of the aliasing of each disk (partition) to "
"two devices with different semantics significantly complicated the relevant "
"kernel code FreeBSD dropped support for cached disk devices as part of the "
"modernization of the disk I/O infrastructure."
msgstr ""

#. (itstool) path: sect1/title
#: book.translate.xml:16473
msgid "Network Drivers"
msgstr "网络设备驱动程序"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16475
msgid "<primary>network devices</primary>"
msgstr "<primary>network devices（网络设备）</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:16478
msgid ""
"Drivers for network devices do not use device nodes in order to be accessed. "
"Their selection is based on other decisions made inside the kernel and "
"instead of calling open(), use of a network device is generally introduced "
"by using the system call socket(2)."
msgstr ""
"访问网络设备的驱动程序不需要使用设备节点。选择哪个驱动程序是基于内核内部的其"
"他决定而不是调用open()，对网络设备的使用通常由系统调用socket(2)引入。"

#. (itstool) path: sect1/para
#: book.translate.xml:16484
msgid ""
"For more information see ifnet(9), the source of the loopback device, and "
"Bill Paul's network drivers."
msgstr ""
"更多细节， 请参见 ifnet(9) 联机手册、 回环设备的源代码，以及 Bill Paul 撰写的"
"网络驱动程序。"

#. (itstool) path: info/title
#: book.translate.xml:16496
msgid "ISA Device Drivers"
msgstr "ISA 设备驱动"

#. (itstool) path: authorgroup/author
#: book.translate.xml:16498 book.translate.xml:19470
msgid ""
"<personname><firstname>Sergey</firstname><surname>Babkin</surname></"
"personname><contrib>Written by </contrib>"
msgstr ""
"<personname><firstname>Sergey</firstname><surname>Babkin</surname></"
"personname><contrib>Written by </contrib>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:16501 book.translate.xml:19473
msgid ""
"<personname><firstname>Murray</firstname><surname>Stokely</surname></"
"personname><contrib>Modifications for Handbook made by </contrib>"
msgstr ""
"<personname><firstname>Murray</firstname><surname>Stokely</surname></"
"personname><contrib>Modifications for Handbook made by </contrib>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:16502
msgid ""
"<personname><firstname>Valentino</firstname><surname>Vaschetto</surname></"
"personname>"
msgstr ""
"<personname><firstname>Valentino</firstname><surname>Vaschetto</surname></"
"personname>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:16503
msgid ""
"<personname><firstname>Wylie</firstname><surname>Stilwell</surname></"
"personname>"
msgstr ""
"<personname><firstname>Wylie</firstname><surname>Stilwell</surname></"
"personname>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16512
msgid "<primary>ISA</primary>"
msgstr "<primary>ISA(Industry Standard Architecture, 工业标准结构)</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16513
msgid "<primary>device driver</primary><secondary>ISA</secondary>"
msgstr ""
"<primary>device driver(设备驱动程序)</primary><secondary>ISA(Industry "
"Standard Architecture, 工业标准结构)</secondary>"

#. (itstool) path: sect1/para
#: book.translate.xml:16515
msgid ""
"This chapter introduces the issues relevant to writing a driver for an ISA "
"device. The pseudo-code presented here is rather detailed and reminiscent of "
"the real code but is still only pseudo-code. It avoids the details "
"irrelevant to the subject of the discussion. The real-life examples can be "
"found in the source code of real drivers. In particular the drivers "
"<literal>ep</literal> and <literal>aha</literal> are good sources of "
"information."
msgstr ""
"本章介绍了编写ISA设备驱动程序相关的一些问题。这儿展示的伪代码相当详细，很容易"
"让人联想到真正的代码，不过这依然仅仅是伪代码。它避免了与所讨论的主题无关的细"
"节。真实的例子可以在实际驱动程序的源代码中找到。<literal>ep</literal>和"
"<literal>aha</literal>更是信息的好来源。"

#. (itstool) path: sect1/title
#: book.translate.xml:16525
msgid "Basic Information"
msgstr "基本信息"

#. (itstool) path: sect1/para
#: book.translate.xml:16527
msgid "A typical ISA driver would need the following include files:"
msgstr "典型的ISA驱动程序需要以下包含文件："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16530
#, no-wrap
msgid ""
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/bus.h&gt;\n"
"#include &lt;machine/bus.h&gt;\n"
"#include &lt;machine/resource.h&gt;\n"
"#include &lt;sys/rman.h&gt;\n"
"\n"
"#include &lt;isa/isavar.h&gt;\n"
"#include &lt;isa/pnpvar.h&gt;"
msgstr ""
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/bus.h&gt;\n"
"#include &lt;machine/bus.h&gt;\n"
"#include &lt;machine/resource.h&gt;\n"
"#include &lt;sys/rman.h&gt;\n"
"\n"
"#include &lt;isa/isavar.h&gt;\n"
"#include &lt;isa/pnpvar.h&gt;"

#. (itstool) path: sect1/para
#: book.translate.xml:16539
msgid "They describe the things specific to the ISA and generic bus subsystem."
msgstr "它们描述了针对ISA和通用总线子系统的东西。"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16542
msgid "<primary>object-oriented</primary>"
msgstr "<primary>object-oriented(面向对象)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:16543
msgid ""
"The bus subsystem is implemented in an object-oriented fashion, its main "
"structures are accessed by associated method functions."
msgstr ""
"总线子系统是以面向对象的方式实现的，其主要结构通过相关联的方法函数来访问。"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16547
msgid "<primary>bus methods</primary>"
msgstr "<primary>bus methods(总线方法)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:16548
msgid ""
"The list of bus methods implemented by an ISA driver is like one for any "
"other bus. For a hypothetical driver named <quote>xxx</quote> they would be:"
msgstr ""
"ISA驱动程序实现的总线方法的列表与任何其他总线的很相似。对于名字为“xxx”的假想"
"驱动程序，它们将是："

#. (itstool) path: listitem/para
#: book.translate.xml:16554
msgid ""
"<function>static void xxx_isa_identify (driver_t *, device_t);</function> "
"Normally used for bus drivers, not device drivers. But for ISA devices this "
"method may have special use: if the device provides some device-specific "
"(non-PnP) way to auto-detect devices this routine may implement it."
msgstr ""
"<function>static void xxx_isa_identify (driver_t *,device_t);</function> 通常"
"用于总线驱动程序而不是设备驱动程序。但对于ISA设备，这个方法有特殊用途：如果设"
"备提供某些设备特定的（非PnP）方法自动侦测设备，这个例程可以实现它。"

#. (itstool) path: listitem/para
#: book.translate.xml:16563
msgid ""
"<function>static int xxx_isa_probe (device_t dev);</function> Probe for a "
"device at a known (or PnP) location. This routine can also accommodate "
"device-specific auto-detection of parameters for partially configured "
"devices."
msgstr ""
"<function>static int xxx_isa_probe (device_tdev);</function> 在已知（或PnP）"
"位置探测设备。对于已经部分配置的设备，这个例程也能够提供设备特定的对某些参数"
"的自动侦测。"

#. (itstool) path: listitem/para
#: book.translate.xml:16571
msgid ""
"<function>static int xxx_isa_attach (device_t dev);</function> Attach and "
"initialize device."
msgstr ""
"<function>static int xxx_isa_attach (device_tdev);</function> 挂接和初始化设"
"备。"

#. (itstool) path: listitem/para
#: book.translate.xml:16576
msgid ""
"<function>static int xxx_isa_detach (device_t dev);</function> Detach device "
"before unloading the driver module."
msgstr ""
"<function>static int xxx_isa_detach (device_tdev);</function> 卸载设备驱动模"
"块前解挂设备。"

#. (itstool) path: listitem/para
#: book.translate.xml:16582
msgid ""
"<function>static int xxx_isa_shutdown (device_t dev);</function> Execute "
"shutdown of the device before system shutdown."
msgstr ""
"<function>static int xxx_isa_shutdown (device_tdev);</function> 系统关闭前执"
"行设备的关闭。"

#. (itstool) path: listitem/para
#: book.translate.xml:16588
msgid ""
"<function>static int xxx_isa_suspend (device_t dev);</function> Suspend the "
"device before the system goes to the power-save state. May also abort "
"transition to the power-save state."
msgstr ""
"<function>static int xxx_isa_suspend (device_tdev);</function> 系统进入节能状"
"态前挂起设备。也可以中止切换到节能状态。"

#. (itstool) path: listitem/para
#: book.translate.xml:16595
msgid ""
"<function>static int xxx_isa_resume (device_t dev);</function> Resume the "
"device activity after return from power-save state."
msgstr ""
"<function>static int xxx_isa_resume (device_tdev);</function> 从节能状态返回"
"后恢复设备的活动状态。"

#. (itstool) path: sect1/para
#: book.translate.xml:16602
msgid ""
"<function>xxx_isa_probe()</function> and <function>xxx_isa_attach()</"
"function> are mandatory, the rest of the routines are optional, depending on "
"the device's needs."
msgstr ""
"<function>xxx_isa_probe()</function>和<function>xxx_isa_attach()</function>是"
"必须提供的，其余例程根据设备的需要可以有选择地实现。"

#. (itstool) path: sect1/para
#: book.translate.xml:16607
msgid ""
"The driver is linked to the system with the following set of descriptions."
msgstr "使用下面一组描述符将设备驱动链接到系统。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16610
#, no-wrap
msgid ""
"    /* table of supported bus methods */\n"
"    static device_method_t xxx_isa_methods[] = {\n"
"        /* list all the bus method functions supported by the driver */\n"
"        /* omit the unsupported methods */\n"
"        DEVMETHOD(device_identify,  xxx_isa_identify),\n"
"        DEVMETHOD(device_probe,     xxx_isa_probe),\n"
"        DEVMETHOD(device_attach,    xxx_isa_attach),\n"
"        DEVMETHOD(device_detach,    xxx_isa_detach),\n"
"        DEVMETHOD(device_shutdown,  xxx_isa_shutdown),\n"
"        DEVMETHOD(device_suspend,   xxx_isa_suspend),\n"
"        DEVMETHOD(device_resume,    xxx_isa_resume),\n"
"\n"
"\tDEVMETHOD_END\n"
"    };\n"
"\n"
"    static driver_t xxx_isa_driver = {\n"
"        \"xxx\",\n"
"        xxx_isa_methods,\n"
"        sizeof(struct xxx_softc),\n"
"    };\n"
"\n"
"\n"
"    static devclass_t xxx_devclass;\n"
"\n"
"    DRIVER_MODULE(xxx, isa, xxx_isa_driver, xxx_devclass,\n"
"        load_function, load_argument);"
msgstr ""
"    /* table of supported bus methods */\n"
"    static device_method_t xxx_isa_methods[] = {\n"
"        /* list all the bus method functions supported by the driver */\n"
"        /* omit the unsupported methods */\n"
"        DEVMETHOD(device_identify,  xxx_isa_identify),\n"
"        DEVMETHOD(device_probe,     xxx_isa_probe),\n"
"        DEVMETHOD(device_attach,    xxx_isa_attach),\n"
"        DEVMETHOD(device_detach,    xxx_isa_detach),\n"
"        DEVMETHOD(device_shutdown,  xxx_isa_shutdown),\n"
"        DEVMETHOD(device_suspend,   xxx_isa_suspend),\n"
"        DEVMETHOD(device_resume,    xxx_isa_resume),\n"
"\n"
"\tDEVMETHOD_END\n"
"    };\n"
"\n"
"    static driver_t xxx_isa_driver = {\n"
"        \"xxx\",\n"
"        xxx_isa_methods,\n"
"        sizeof(struct xxx_softc),\n"
"    };\n"
"\n"
"\n"
"    static devclass_t xxx_devclass;\n"
"\n"
"    DRIVER_MODULE(xxx, isa, xxx_isa_driver, xxx_devclass,\n"
"        load_function, load_argument);"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16637
msgid "<primary>softc</primary>"
msgstr "<primary>softc(硬件设备的软件描述符，相关信息)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:16639
msgid ""
"Here struct <varname remap=\"structname\">xxx_softc</varname> is a device-"
"specific structure that contains private driver data and descriptors for the "
"driver's resources. The bus code automatically allocates one softc "
"descriptor per device as needed."
msgstr ""
"此处的结构<varname remap=\"structname\">xxx_softc</varname>是一个设备特定的结"
"构，它包含私有的驱动程序数据和驱动程序资源的描述符。总线代码会自动按需要为每"
"个设备分配一个softc描述符。"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16645
msgid "<primary>kernel module</primary>"
msgstr "<primary>kernel modules(内核模块)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:16647
msgid ""
"If the driver is implemented as a loadable module then "
"<function>load_function()</function> is called to do driver-specific "
"initialization or clean-up when the driver is loaded or unloaded and "
"load_argument is passed as one of its arguments. If the driver does not "
"support dynamic loading (in other words it must always be linked into the "
"kernel) then these values should be set to 0 and the last definition would "
"look like:"
msgstr ""
"如果驱动程序作为可加载模块实现，当驱动程序被加载或卸载时，会调用"
"<function>load_function()</function>函数进行驱动程序特定的初始化或清理工作，"
"并将load_argument作为函数的一个参量传递进去。如果驱动程序不支持动态加载（换句"
"话说，它必须被链接到内核中），则这些值应当被设置为0，最后的定义将看起来如下所"
"示："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16656
#, no-wrap
msgid ""
" DRIVER_MODULE(xxx, isa, xxx_isa_driver,\n"
"       xxx_devclass, 0, 0);"
msgstr ""
" DRIVER_MODULE(xxx, isa, xxx_isa_driver,\n"
"       xxx_devclass, 0, 0);"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16659
msgid "<primary>PnP</primary>"
msgstr "<primary>PnP(Plug and Play, 即插即用)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:16661
msgid ""
"If the driver is for a device which supports PnP then a table of supported "
"PnP IDs must be defined. The table consists of a list of PnP IDs supported "
"by this driver and human-readable descriptions of the hardware types and "
"models having these IDs. It looks like:"
msgstr ""
"如果驱动程序是为支持PnP的设备而写的，那么就必须定义一个包含所有支持的PnP ID的"
"表。这个表由此驱动程序所支持的PnP ID的列表和以人可读的形式给出的、与这些ID对"
"应的硬件类型和型号的描述组成。看起来如下："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16667
#, no-wrap
msgid ""
"    static struct isa_pnp_id xxx_pnp_ids[] = {\n"
"        /* a line for each supported PnP ID */\n"
"        { 0x12345678,   \"Our device model 1234A\" },\n"
"        { 0x12345679,   \"Our device model 1234B\" },\n"
"        { 0,        NULL }, /* end of table */\n"
"    };"
msgstr ""
"    static struct isa_pnp_id xxx_pnp_ids[] = {\n"
"        /* a line for each supported PnP ID */\n"
"        { 0x12345678,   \"Our device model 1234A\" },\n"
"        { 0x12345679,   \"Our device model 1234B\" },\n"
"        { 0,        NULL }, /* end of table */\n"
"    };"

#. (itstool) path: sect1/para
#: book.translate.xml:16674
msgid ""
"If the driver does not support PnP devices it still needs an empty PnP ID "
"table, like:"
msgstr "如果驱动程序不支持PnP设备，它仍然需要一个空的PnP ID表，如下所示："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16677
#, no-wrap
msgid ""
"    static struct isa_pnp_id xxx_pnp_ids[] = {\n"
"        { 0,        NULL }, /* end of table */\n"
"    };"
msgstr ""
"    static struct isa_pnp_id xxx_pnp_ids[] = {\n"
"        { 0,        NULL }, /* end of table */\n"
"    };"

#. (itstool) path: sect1/title
#: book.translate.xml:16684
msgid "<varname remap=\"structname\">device_t</varname> Pointer"
msgstr "<varname remap=\"structname\">device_t</varname> 指针"

#. (itstool) path: sect1/para
#: book.translate.xml:16686
msgid ""
"<varname remap=\"structname\">device_t</varname> is the pointer type for the "
"device structure. Here we consider only the methods interesting from the "
"device driver writer's standpoint. The methods to manipulate values in the "
"device structure are:"
msgstr ""
"<varname remap=\"structname\">Device_t</varname>是为设备结构而定义的指针类"
"型，这里我们只关心从设备驱动程序编写者的角度看感兴趣的方法。下面的方法用来操"
"纵设备结构中的值："

#. (itstool) path: listitem/para
#: book.translate.xml:16694
msgid ""
"<function>device_t device_get_parent(dev)</function> Get the parent bus of a "
"device."
msgstr ""
"<function>device_t device_get_parent(dev)</function> 获取设备的父总线。"

#. (itstool) path: listitem/para
#: book.translate.xml:16698
msgid ""
"<function>driver_t device_get_driver(dev)</function> Get pointer to its "
"driver structure."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:16702
msgid ""
"<function>char *device_get_name(dev)</function> Get the driver name, such as "
"<literal>\"xxx\"</literal> for our example."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:16706
msgid ""
"<function>int device_get_unit(dev)</function> Get the unit number (units are "
"numbered from 0 for the devices associated with each driver)."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:16710
msgid ""
"<function>char *device_get_nameunit(dev)</function> Get the device name "
"including the unit number, such as <quote>xxx0</quote>, <quote>xxx1</quote> "
"and so on."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:16715
msgid ""
"<function>char *device_get_desc(dev)</function> Get the device description. "
"Normally it describes the exact model of device in human-readable form."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:16720
msgid ""
"<function>device_set_desc(dev, desc)</function> Set the description. This "
"makes the device description point to the string desc which may not be "
"deallocated or changed after that."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:16725
msgid ""
"<function>device_set_desc_copy(dev, desc)</function> Set the description. "
"The description is copied into an internal dynamically allocated buffer, so "
"the string desc may be changed afterwards without adverse effects."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:16731
msgid ""
"<function>void *device_get_softc(dev)</function> Get pointer to the device "
"descriptor (struct <varname remap=\"structname\">xxx_softc</varname>) "
"associated with this device."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:16736
msgid ""
"<function>u_int32_t device_get_flags(dev)</function> Get the flags specified "
"for the device in the configuration file."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:16742
msgid ""
"A convenience function <function>device_printf(dev, fmt, ...)</function> may "
"be used to print the messages from the device driver. It automatically "
"prepends the unitname and colon to the message."
msgstr ""
"可以使用一个很方便的函数<function>device_printf(dev, fmt,...)</function>从设"
"备驱动程序中打印讯息。它自动在讯息前添加单元名和冒号。"

#. (itstool) path: sect1/para
#: book.translate.xml:16747
msgid ""
"The device_t methods are implemented in the file <filename>kern/bus_subr.c</"
"filename>."
msgstr "device_t的这些方法在文件<filename>kern/bus_subr.c</filename>中实现。"

#. (itstool) path: sect1/title
#: book.translate.xml:16753
msgid ""
"Configuration File and the Order of Identifying and Probing During Auto-"
"Configuration"
msgstr "配置文件与自动配置期间识别和探测的顺序"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16756
msgid "<primary>ISA</primary><secondary>probing</secondary>"
msgstr ""
"<primary>ISA(Industry Standard Architecture, 工业标准结构)</"
"primary><secondary>probing(探测)</secondary>"

#. (itstool) path: sect1/para
#: book.translate.xml:16758
msgid "The ISA devices are described in the kernel configuration file like:"
msgstr "ISA设备在内核配置文件中的描述如下："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16761
#, no-wrap
msgid ""
"device xxx0 at isa? port 0x300 irq 10 drq 5\n"
"       iomem 0xd0000 flags 0x1 sensitive"
msgstr ""
"device xxx0 at isa? port 0x300 irq 10 drq 5\n"
"       iomem 0xd0000 flags 0x1 sensitive"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16764
msgid "<primary>IRQ</primary>"
msgstr "<primary>IRQ</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:16766
msgid ""
"The values of port, IRQ and so on are converted to the resource values "
"associated with the device. They are optional, depending on the device's "
"needs and abilities for auto-configuration. For example, some devices do not "
"need DRQ at all and some allow the driver to read the IRQ setting from the "
"device configuration ports. If a machine has multiple ISA buses the exact "
"bus may be specified in the configuration line, like <literal>isa0</literal> "
"or <literal>isa1</literal>, otherwise the device would be searched for on "
"all the ISA buses."
msgstr ""
"端口值、IRQ值和其他值被转换成与设备关联的资源值。根据设备对自动配置需要和支持"
"程度的不同，这些值是可选的。例如，某些设备根本不需要读DRQ，而有些则允许设备从"
"设备配置端口读取IRQ设置。如果机器有多个ISA总线，可以在配置文件中明确指定哪条"
"总线，如<literal>isa0</literal>或<literal>isa1</literal>，否则将在所有ISA总线"
"上搜索设备。"

#. (itstool) path: sect1/para
#: book.translate.xml:16776
msgid ""
"<literal>sensitive</literal> is a resource requesting that this device must "
"be probed before all non-sensitive devices. It is supported but does not "
"seem to be used in any current driver."
msgstr ""
"<literal>敏感(sensitive)</literal>是一种资源请求，它指示必须在所有非敏感设备"
"之前探测设备。此特性虽被支持，但似乎从未在目前的任何驱动程序中使用过。"

#. (itstool) path: para/programlisting
#: book.translate.xml:16785
#, no-wrap
msgid "device xxx0 at isa?"
msgstr "device xxx0 at isa?"

#. (itstool) path: sect1/para
#: book.translate.xml:16780
msgid ""
"For legacy ISA devices in many cases the drivers are still able to detect "
"the configuration parameters. But each device to be configured in the system "
"must have a config line. If two devices of some type are installed in the "
"system but there is only one configuration line for the corresponding "
"driver, ie: <_:programlisting-1/> then only one device will be configured."
msgstr ""
"对于老的ISA设备，很多情况下驱动程序仍然能够侦测配置参数。但是系统中配置的每个"
"设备必须具有一个配置行。如果系统中装有同一类型的两个设备，但对应的驱动程序却"
"只有一个配置行，例如:<programlisting>device xxx0 at isa?</programlisting>那么"
"只有一个设备会被配置。"

#. (itstool) path: sect1/para
#: book.translate.xml:16788
msgid ""
"But for the devices supporting automatic identification by the means of Plug-"
"n-Play or some proprietary protocol one configuration line is enough to "
"configure all the devices in the system, like the one above or just simply:"
msgstr ""
"但对于支持通过PnP或专有协议进行自动识别的设备，一个配置行就足够配置系统中的所"
"有设备，如上面的配置行，或者简单地："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16793
#, no-wrap
msgid "device xxx at isa?"
msgstr "device xxx at isa?"

#. (itstool) path: sect1/para
#: book.translate.xml:16795
msgid ""
"If a driver supports both auto-identified and legacy devices and both kinds "
"are installed at once in one machine then it is enough to describe in the "
"config file the legacy devices only. The auto-identified devices will be "
"added automatically."
msgstr ""
"如果设备驱动程序既支持能自动识别的设备又支持老设备，并且两类设备同时安装在一"
"台机器上，那么只要在配置文件中描述老设备就足够了。自动识别的设备将被自动添"
"加。"

#. (itstool) path: sect1/para
#: book.translate.xml:16801
msgid "When an ISA bus is auto-configured the events happen as follows:"
msgstr "如果ISA设备是自动配置的，发生的事件如下："

#. (itstool) path: sect1/para
#: book.translate.xml:16804
msgid ""
"All the drivers' identify routines (including the PnP identify routine which "
"identifies all the PnP devices) are called in random order. As they identify "
"the devices they add them to the list on the ISA bus. Normally the drivers' "
"identify routines associate their drivers with the new devices. The PnP "
"identify routine does not know about the other drivers yet so it does not "
"associate any with the new devices it adds."
msgstr ""
"所有设备驱动程序的识别例程（包括识别所有PnP设备的PnP识别例程）以随机顺序被调"
"用。他们识别出设备后就把设备添加到ISA总线上的列表中。通常驱动程序的识别例程将"
"新设备与它们的驱动程序关联起来。而PnP识别例程并不知道其他驱动程序，因此不能将"
"驱动程序与它所添加的新设备关联起来。"

#. (itstool) path: sect1/para
#: book.translate.xml:16813
msgid ""
"The PnP devices are put to sleep using the PnP protocol to prevent them from "
"being probed as legacy devices."
msgstr "使用PnP协议让PnP设备进入睡眠，以防止它们被探测为老设备。"

#. (itstool) path: sect1/para
#: book.translate.xml:16816
msgid ""
"The probe routines of non-PnP devices marked as <literal>sensitive</literal> "
"are called. If probe for a device went successfully, the attach routine is "
"called for it."
msgstr ""
"被标记为<literal>敏感(sensitive)</literal>的非PnP设备的探测例程被调用。如果探"
"测设备成功，那么就为其调用挂接(attach)例程。"

#. (itstool) path: sect1/para
#: book.translate.xml:16820
msgid ""
"The probe and attach routines of all non-PNP devices are called likewise."
msgstr "所有非PnP设备的探测和连接例程以同样的方式被调用。"

#. (itstool) path: sect1/para
#: book.translate.xml:16823
msgid ""
"The PnP devices are brought back from the sleep state and assigned the "
"resources they request: I/O and memory address ranges, IRQs and DRQs, all of "
"them not conflicting with the attached legacy devices."
msgstr ""
"PnP设备从睡眠中恢复过来，并给它们分配所请求的资源：I/O、内存地址范围、IRQ和"
"DRQ，所有这些与已连接的老设备不会冲突。"

#. (itstool) path: sect1/para
#: book.translate.xml:16828
msgid ""
"Then for each PnP device the probe routines of all the present ISA drivers "
"are called. The first one that claims the device gets attached. It is "
"possible that multiple drivers would claim the device with different "
"priority; in this case, the highest-priority driver wins. The probe routines "
"must call <function>ISA_PNP_PROBE()</function> to compare the actual PnP ID "
"with the list of the IDs supported by the driver and if the ID is not in the "
"table return failure. That means that absolutely every driver, even the ones "
"not supporting any PnP devices must call <function>ISA_PNP_PROBE()</"
"function>, at least with an empty PnP ID table to return failure on unknown "
"PnP devices."
msgstr ""
"对于每个PnP设备，所有ISA设备驱动程序的探测例程都会被调用。第一个要求此设备的"
"驱动程序将被连接。多个驱动程序以不同的优先权要求一个设备的情况是可能的，这种"
"情况下，具有最高优先权的驱动程序将获胜。探测例程必须调用"
"<function>ISA_PNP_PROBE()</function>将真实的PnP ID和驱动程序支持的ID列表作比"
"较，如果ID不在表中则返回失败。这意味着每个驱动程序，包括不支持任何PnP设备的驱"
"动程序，都必须对未知的PnP设备无条件调用<function>ISA_PNP_PROBE()</function>，"
"对于未知设备， 至少要用一个空的PnP ID表调用并返回失败。"

#. (itstool) path: sect1/para
#: book.translate.xml:16841
msgid ""
"The probe routine returns a positive value (the error code) on error, zero "
"or negative value on success."
msgstr "探测例程遇到错误时会返回一个正值（错误码），成功时返回零或负值。"

#. (itstool) path: sect1/para
#: book.translate.xml:16844
msgid ""
"The negative return values are used when a PnP device supports multiple "
"interfaces. For example, an older compatibility interface and a newer "
"advanced interface which are supported by different drivers. Then both "
"drivers would detect the device. The driver which returns a higher value in "
"the probe routine takes precedence (in other words, the driver returning 0 "
"has highest precedence, returning -1 is next, returning -2 is after it and "
"so on). In result the devices which support only the old interface will be "
"handled by the old driver (which should return -1 from the probe routine) "
"while the devices supporting the new interface as well will be handled by "
"the new driver (which should return 0 from the probe routine). If multiple "
"drivers return the same value then the one called first wins. So if a driver "
"returns value 0 it may be sure that it won the priority arbitration."
msgstr ""
"负的返回值用于PnP设备支持多个接口的情况。例如，老的兼容接口和新的高级接口通过"
"不同的驱动程序来提供支持。两个驱动程序都侦测设备。在探测例程中返回较高值的驱"
"动程序优先（换句话说，返回0的驱动程序具有最高的优先级，返回-1的其次，返回-2的"
"更在其后，如此下去）。如果多个驱动程序返回相同的值，那么最先调用的获胜。因"
"此，如果驱动程序返回0，就基本能够确信它获得优先权仲裁。"

#. (itstool) path: sect1/para
#: book.translate.xml:16860
msgid ""
"The device-specific identify routines can also assign not a driver but a "
"class of drivers to the device. Then all the drivers in the class are probed "
"for this device, like the case with PnP. This feature is not implemented in "
"any existing driver and is not considered further in this document."
msgstr ""
"设备特定的识别例程也能够将一类而不是单个驱动程序指派给设备。就象使用PnP的情况"
"一样，对于某一设备，会探测这一类中所有的驱动程序。由于这个特性在任何现存的驱"
"动程序中总均未实现，故本文档中不再予以考虑。"

#. (itstool) path: sect1/para
#: book.translate.xml:16866
msgid ""
"Because the PnP devices are disabled when probing the legacy devices they "
"will not be attached twice (once as legacy and once as PnP). But in case of "
"device-dependent identify routines it is the responsibility of the driver to "
"make sure that the same device will not be attached by the driver twice: "
"once as legacy user-configured and once as auto-identified."
msgstr ""
"由于探测老设备的时候PnP设备被禁用，它们不会被连接两次（一次作为老设备，一次作"
"为PnP）。但如果识别例程设备相关的，这种情况下设备驱动程序有责任确保同一设备不"
"会被设备驱动程序连接两次：一次作为老的由用户配置的，一次作为自动识别的。"

#. (itstool) path: sect1/para
#: book.translate.xml:16874
msgid ""
"Another practical consequence for the auto-identified devices (both PnP and "
"device-specific) is that the flags can not be passed to them from the kernel "
"configuration file. So they must either not use the flags at all or use the "
"flags from the device unit 0 for all the auto-identified devices or use the "
"sysctl interface instead of flags."
msgstr ""
"对于自动识别的设备（包括PnP和设备特定的）的另一个实践结论是，不能从内核配置文"
"件中向它们传递旗标。因此它们必须要么根本不使用旗标，要么为所有自动识别的设备"
"使用单元号为0的设备的旗标，或者使用sysctl接口而不是旗标。"

#. (itstool) path: sect1/para
#: book.translate.xml:16881
msgid ""
"Other unusual configurations may be accommodated by accessing the "
"configuration resources directly with functions of families "
"<function>resource_query_*()</function> and <function>resource_*_value()</"
"function>. Their implementations are located in <filename>kern/subr_bus.c</"
"filename>. The old IDE disk driver <filename>i386/isa/wd.c</filename> "
"contains examples of such use. But the standard means of configuration must "
"always be preferred. Leave parsing the configuration resources to the bus "
"configuration code."
msgstr ""
"通过使用函数族<function>resource_query_*()</function>和"
"<function>resource_*_value()</function>直接访问配置资源，从而可以提供其他不常"
"用的配置。它们的实现位于<filename>kern/subr_bus.c</filename>。老的IDE磁盘驱动"
"器<filename>i386/isa/wd.c</filename>包含这样使用的例子。但必须优先使用配置的"
"标准方法。将解析配置资源这类事情留给总线配置代码。"

#. (itstool) path: sect1/title
#: book.translate.xml:16894
msgid "Resources"
msgstr "资源"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16896
msgid "<primary>resources</primary>"
msgstr "<primary>resources</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16897
msgid "<primary>device driver</primary><secondary>resources</secondary>"
msgstr "<primary>device driver</primary><secondary>resources</secondary>"

#. (itstool) path: sect1/para
#: book.translate.xml:16899
msgid ""
"The information that a user enters into the kernel configuration file is "
"processed and passed to the kernel as configuration resources. This "
"information is parsed by the bus configuration code and transformed into a "
"value of structure device_t and the bus resources associated with it. The "
"drivers may access the configuration resources directly using functions "
"<function>resource_*</function> for more complex cases of configuration. "
"However, generally this is neither needed nor recommended, so this issue is "
"not discussed further here."
msgstr ""
"用户写入到内核配置文件中的信息被作为配置资源处理，并传递到内核。总线配置代码"
"解析这部分信息并将其转换为结构device_t的值和与之关联的总线资源。对于复杂情况"
"下的配置，驱动程序可以直接使用<function>resource_*</function> 函数访问配置资"
"源。 然而，通常既不需要也不推荐这样做，因此这儿不再进一步讨论这个问题。"

#. (itstool) path: sect1/para
#: book.translate.xml:16909
msgid ""
"The bus resources are associated with each device. They are identified by "
"type and number within the type. For the ISA bus the following types are "
"defined:"
msgstr ""
"总线资源与每个设备相关联。通过类型和类型中的数字标识它们。对于ISA总线，定义了"
"下面的类型："

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16913
msgid "<primary>DMA channel</primary>"
msgstr "<primary>DMA channel(DMA通道)</primary>"

#. (itstool) path: listitem/para
#: book.translate.xml:16917
msgid "<emphasis>SYS_RES_IRQ</emphasis> - interrupt number"
msgstr "<emphasis>SYS_RES_IRQ</emphasis> - 中断号"

#. (itstool) path: listitem/para
#: book.translate.xml:16922
msgid "<emphasis>SYS_RES_DRQ</emphasis> - ISA DMA channel number"
msgstr "<emphasis>SYS_RES_DRQ</emphasis> - ISA DMA通道号"

#. (itstool) path: listitem/para
#: book.translate.xml:16927
msgid ""
"<emphasis>SYS_RES_MEMORY</emphasis> - range of device memory mapped into the "
"system memory space"
msgstr ""
"<emphasis>SYS_RES_MEMORY</emphasis> - 映射到系统内存空间的设备内存的范围"

#. (itstool) path: listitem/para
#: book.translate.xml:16933
msgid "<emphasis>SYS_RES_IOPORT</emphasis> - range of device I/O registers"
msgstr "<emphasis>SYS_RES_IOPORT</emphasis> - 设备I/O寄存器的范围"

#. (itstool) path: sect1/para
#: book.translate.xml:16938
msgid ""
"The enumeration within types starts from 0, so if a device has two memory "
"regions it would have resources of type <literal>SYS_RES_MEMORY</literal> "
"numbered 0 and 1. The resource type has nothing to do with the C language "
"type, all the resource values have the C language type <literal>unsigned "
"long</literal> and must be cast as necessary. The resource numbers do not "
"have to be contiguous, although for ISA they normally would be. The "
"permitted resource numbers for ISA devices are:"
msgstr ""
"类型内的枚举从0开始，因此如果设备有两个内存区域，它的"
"<literal>SYS_RES_MEMORY</literal> 类型的资源编号为0和1。资源类型与C语言的类型"
"无关，所有资源值具有C语言 <literal>unsigned long</literal>类型，并且必要时必"
"须进行类型强制转换 (cast)。资源号不必连续，尽管对于ISA它们一般是连续的。ISA设"
"备允许的资源编号为："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16947
#, no-wrap
msgid ""
"          IRQ: 0-1\n"
"          DRQ: 0-1\n"
"          MEMORY: 0-3\n"
"          IOPORT: 0-7"
msgstr ""
"          IRQ: 0-1\n"
"          DRQ: 0-1\n"
"          MEMORY: 0-3\n"
"          IOPORT: 0-7"

#. (itstool) path: sect1/para
#: book.translate.xml:16952
msgid ""
"All the resources are represented as ranges, with a start value and count. "
"For IRQ and DRQ resources the count would normally be equal to 1. The values "
"for memory refer to the physical addresses."
msgstr ""
"所有资源被表示为带有起始值和计数的范围。对于IRQ和DRQ资源，计数一般等于1。内存"
"的值引用物理地址。"

#. (itstool) path: sect1/para
#: book.translate.xml:16957
msgid "Three types of activities can be performed on resources:"
msgstr "对资源能够执行三种类型的动作："

#. (itstool) path: listitem/para
#: book.translate.xml:16961
msgid "set/get"
msgstr "set/get"

#. (itstool) path: listitem/para
#: book.translate.xml:16962
msgid "allocate/release"
msgstr "allocate/release"

#. (itstool) path: listitem/para
#: book.translate.xml:16963
msgid "activate/deactivate"
msgstr "activate/deactivate"

#. (itstool) path: sect1/para
#: book.translate.xml:16966
msgid ""
"Setting sets the range used by the resource. Allocation reserves the "
"requested range that no other driver would be able to reserve it (and "
"checking that no other driver reserved this range already). Activation makes "
"the resource accessible to the driver by doing whatever is necessary for "
"that (for example, for memory it would be mapping into the kernel virtual "
"address space)."
msgstr ""
"Set设置资源使用的范围。Allocation保留出请求的范围，使得其它设备不能再占用（并"
"检查此范围没有被其它设备占用）。Activation执行必要的动作使得驱动程序可以访问"
"资源（例如，对于内存，它将被映射到内核的虚拟地址空间）。"

#. (itstool) path: sect1/para
#: book.translate.xml:16974
msgid "The functions to manipulate resources are:"
msgstr "操作资源的函数有："

#. (itstool) path: listitem/para
#: book.translate.xml:16978
msgid ""
"<function>int bus_set_resource(device_t dev, int type, int rid, u_long "
"start, u_long count)</function>"
msgstr ""
"<function>int bus_set_resource(device_t dev, int type, int rid, u_long "
"start, u_long count)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:16981
msgid ""
"Set a range for a resource. Returns 0 if successful, error code otherwise. "
"Normally, this function will return an error only if one of <literal>type</"
"literal>, <literal>rid</literal>, <literal>start</literal> or "
"<literal>count</literal> has a value that falls out of the permitted range."
msgstr ""
"为资源设置范围。成功则返回0，否则返回错误码。一般此函数只有在<literal>type</"
"literal>，<literal>rid</literal>，<literal>start</literal>或<literal>count</"
"literal>之一的值超出了允许的范围才会返回错误。"

#. (itstool) path: listitem/para
#: book.translate.xml:16990
msgid "dev - driver's device"
msgstr "dev - 驱动程序的设备"

#. (itstool) path: listitem/para
#: book.translate.xml:16993
msgid "type - type of resource, SYS_RES_*"
msgstr "type - 资源类型，SYS_RES_*"

#. (itstool) path: listitem/para
#: book.translate.xml:16996
msgid "rid - resource number (ID) within type"
msgstr "rid - 类型内部的资源号（ID）"

#. (itstool) path: listitem/para
#: book.translate.xml:16999
msgid "start, count - resource range"
msgstr "start, count - 资源范围"

#. (itstool) path: listitem/para
#: book.translate.xml:17005
msgid ""
"<function>int bus_get_resource(device_t dev, int type, int rid, u_long "
"*startp, u_long *countp)</function>"
msgstr ""
"<function>int bus_get_resource(device_t dev, int type, int rid, u_long "
"*startp, u_long *countp)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17008
msgid ""
"Get the range of resource. Returns 0 if successful, error code if the "
"resource is not defined yet."
msgstr "取得资源范围。成功则返回0，如果资源尚未定义则返回错误码。"

#. (itstool) path: listitem/para
#: book.translate.xml:17013
msgid ""
"<function>u_long bus_get_resource_start(device_t dev, int type, int rid) "
"u_long bus_get_resource_count (device_t dev, int type, int rid)</function>"
msgstr ""
"<function>u_long bus_get_resource_start(device_t dev, int type, int rid) "
"u_long bus_get_resource_count (device_t dev, int type, int rid)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17017
msgid ""
"Convenience functions to get only the start or count. Return 0 in case of "
"error, so if the resource start has 0 among the legitimate values it would "
"be impossible to tell if the value is 0 or an error occurred. Luckily, no "
"ISA resources for add-on drivers may have a start value equal to 0."
msgstr ""
"便捷函数，只用来获取start或count。出错的情况下返回0，因此如果0是资源的start合"
"法值之一，将无法区分返回的0是否指示错误。幸运的是，对于附加驱动程序，没有ISA"
"资源的start值从0开始。"

#. (itstool) path: listitem/para
#: book.translate.xml:17026
msgid ""
"<function>void bus_delete_resource(device_t dev, int type, int rid)</"
"function>"
msgstr ""
"<function>void bus_delete_resource(device_t dev, int type, int rid)</"
"function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17028
msgid "Delete a resource, make it undefined."
msgstr "删除资源，令其未定义。"

#. (itstool) path: listitem/para
#: book.translate.xml:17032
msgid ""
"<function>struct resource * bus_alloc_resource(device_t dev, int type, int "
"*rid, u_long start, u_long end, u_long count, u_int flags)</function>"
msgstr ""
"<function>struct resource * bus_alloc_resource(device_t dev, int type, int "
"*rid, u_long start, u_long end, u_long count, u_int flags)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17037
msgid ""
"Allocate a resource as a range of count values not allocated by anyone else, "
"somewhere between start and end. Alas, alignment is not supported. If the "
"resource was not set yet it is automatically created. The special values of "
"start 0 and end ~0 (all ones) means that the fixed values previously set by "
"<function>bus_set_resource()</function> must be used instead: start and "
"count as themselves and end=(start+count), in this case if the resource was "
"not defined before then an error is returned. Although rid is passed by "
"reference it is not set anywhere by the resource allocation code of the ISA "
"bus. (The other buses may use a different approach and modify it)."
msgstr ""
"在start和end之间没有被其它设备占用的地方按count值的范围分配一个资源。不过，不"
"支持对齐。如果资源尚未被设置，则自动创建它。start为0，end为~0（全1）的这对特"
"殊值意味着必须使用以前通过<function>bus_set_resource()</function>设置的固定"
"值：start和count就是它们自己，end=(start+count)，这种情况下，如果以前资源没有"
"定义，则返回错误。尽管rid通过引用传递，但它并不被ISA总线的资源分配代码设置"
"（其它总线可能使用不同的方法并可能修改它）。"

#. (itstool) path: sect1/para
#: book.translate.xml:17053
msgid "Flags are a bitmap, the flags interesting for the caller are:"
msgstr "旗标是一个位映射，调用者感兴趣的有："

#. (itstool) path: listitem/para
#: book.translate.xml:17058
msgid ""
"<emphasis>RF_ACTIVE</emphasis> - causes the resource to be automatically "
"activated after allocation."
msgstr "<emphasis>RF_ACTIVE</emphasis> - 使得资源分配后被自动激活。"

#. (itstool) path: listitem/para
#: book.translate.xml:17063
msgid ""
"<emphasis>RF_SHAREABLE</emphasis> - resource may be shared at the same time "
"by multiple drivers."
msgstr "<emphasis>RF_SHAREABLE</emphasis> - 资源可以同时被多个驱动程序共享。"

#. (itstool) path: listitem/para
#: book.translate.xml:17068
msgid ""
"<emphasis>RF_TIMESHARE</emphasis> - resource may be time-shared by multiple "
"drivers, i.e., allocated at the same time by many but activated only by one "
"at any given moment of time."
msgstr ""
"<emphasis>RF_TIMESHARE</emphasis> - 资源可以被多个驱动程序分时共享，也就是"
"说，被多个驱动程序同时分配，但任何给定时间只能被其中一个激活。"

#. (itstool) path: listitem/para
#: book.translate.xml:17075
msgid ""
"Returns 0 on error. The allocated values may be obtained from the returned "
"handle using methods <function>rhand_*()</function>."
msgstr ""
"出错返回0。被分配的值可以使用<function>rhand_*()</function>从返回的句柄获得。"

#. (itstool) path: listitem/para
#: book.translate.xml:17080
msgid ""
"<function>int bus_release_resource(device_t dev, int type, int rid, struct "
"resource *r)</function>"
msgstr ""
"<function>int bus_release_resource(device_t dev, int type, int rid, struct "
"resource *r)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17085
msgid ""
"Release the resource, r is the handle returned by "
"<function>bus_alloc_resource()</function>. Returns 0 on success, error code "
"otherwise."
msgstr ""
"释放资源，r为<function>bus_alloc_resource()</function>返回的句柄。成功则返回"
"0，否则返回错误码。"

#. (itstool) path: listitem/para
#: book.translate.xml:17091
msgid ""
"<function>int bus_activate_resource(device_t dev, int type, int rid, struct "
"resource *r)</function> <function>int bus_deactivate_resource(device_t dev, "
"int type, int rid, struct resource *r)</function>"
msgstr ""
"<function>int bus_activate_resource(device_t dev, int type, int rid, struct "
"resource *r)</function> <function>int bus_deactivate_resource(device_t dev, "
"int type, int rid, struct resource *r)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17098
msgid ""
"Activate or deactivate resource. Return 0 on success, error code otherwise. "
"If the resource is time-shared and currently activated by another driver "
"then <literal>EBUSY</literal> is returned."
msgstr ""
"激活或禁用资源。成功则返回0，否则返回错误码。如果资源被分时共享且当前被另一驱"
"动程序激活，则返回 <literal>EBUSY</literal>。"

#. (itstool) path: listitem/para
#: book.translate.xml:17105
msgid ""
"<function>int bus_setup_intr(device_t dev, struct resource *r, int flags, "
"driver_intr_t *handler, void *arg, void **cookiep)</function> <function>int "
"bus_teardown_intr(device_t dev, struct resource *r, void *cookie)</function>"
msgstr ""
"<function>int bus_setup_intr(device_t dev, struct resource *r, int flags, "
"driver_intr_t *handler, void *arg, void **cookiep)</function> <function>int "
"bus_teardown_intr(device_t dev, struct resource *r, void *cookie)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17113
msgid ""
"Associate or de-associate the interrupt handler with a device. Return 0 on "
"success, error code otherwise."
msgstr "关联/分离中断处理程序与设备。成功则返回0，否则返回错误码。"

#. (itstool) path: listitem/para
#: book.translate.xml:17118
msgid "r - the activated resource handler describing the IRQ"
msgstr "r - 被激活的描述IRQ的资源句柄"

#. (itstool) path: listitem/para
#: book.translate.xml:17120
msgid "flags - the interrupt priority level, one of:"
msgstr "flags - 中断优先级，如下之一："

#. (itstool) path: listitem/para
#: book.translate.xml:17124
msgid ""
"<function>INTR_TYPE_TTY</function> - terminals and other likewise character-"
"type devices. To mask them use <function>spltty()</function>."
msgstr ""
"<function>INTR_TYPE_TTY</function> - 终端和其它类似的字符类型设备。使用"
"<function>spltty()</function>屏蔽它们。"

#. (itstool) path: listitem/para
#: book.translate.xml:17129
msgid ""
"<function>(INTR_TYPE_TTY | INTR_TYPE_FAST)</function> - terminal type "
"devices with small input buffer, critical to the data loss on input (such as "
"the old-fashioned serial ports). To mask them use <function>spltty()</"
"function>."
msgstr ""
"<function>(INTR_TYPE_TTY |INTR_TYPE_FAST)</function> - 输入缓冲较小的终端类型"
"设备，而且输入上的数据丢失很关键（例如老式串口）。使用<function>spltty()</"
"function>屏蔽它们。"

#. (itstool) path: listitem/para
#: book.translate.xml:17136
msgid ""
"<function>INTR_TYPE_BIO</function> - block-type devices, except those on the "
"CAM controllers. To mask them use <function>splbio()</function>."
msgstr ""
"<function>INTR_TYPE_BIO</function> - 块类型设备，不包括CAM控制器上的。使用"
"<function>splbio()</function>屏蔽它们。"

#. (itstool) path: listitem/para
#: book.translate.xml:17141
msgid ""
"<function>INTR_TYPE_CAM</function> - CAM (Common Access Method) bus "
"controllers. To mask them use <function>splcam()</function>."
msgstr ""
"<function>INTR_TYPE_CAM</function> - CAM （通用访问方法Common Access Method）"
"总线控制器。使用<function>splcam()</function>屏蔽它们。"

#. (itstool) path: listitem/para
#: book.translate.xml:17146
msgid ""
"<function>INTR_TYPE_NET</function> - network interface controllers. To mask "
"them use <function>splimp()</function>."
msgstr ""
"<function>INTR_TYPE_NET</function> - 网络接口控制器。使用<function>splimp()</"
"function>屏蔽它们。"

#. (itstool) path: listitem/para
#: book.translate.xml:17151
msgid ""
"<function>INTR_TYPE_MISC</function> - miscellaneous devices. There is no "
"other way to mask them than by <function>splhigh()</function> which masks "
"all interrupts."
msgstr ""
"<function>INTR_TYPE_MISC</function> -各种其它设备。除了通过"
"<function>splhigh()</function>没有其它方法屏蔽它们。<function>splhigh()</"
"function>屏蔽所有中断。"

#. (itstool) path: sect1/para
#: book.translate.xml:17160
msgid ""
"When an interrupt handler executes all the other interrupts matching its "
"priority level will be masked. The only exception is the MISC level for "
"which no other interrupts are masked and which is not masked by any other "
"interrupt."
msgstr ""
"当中断处理程序执行时，匹配其优先级的所有其它中断都被屏蔽，唯一的例外是MISC级"
"别，它不会屏蔽其它中断，也不会被其它中断屏蔽。"

#. (itstool) path: listitem/para
#: book.translate.xml:17168
msgid ""
"<emphasis>handler</emphasis> - pointer to the handler function, the type "
"driver_intr_t is defined as <function>void driver_intr_t(void *)</function>"
msgstr ""
"<emphasis>handler</emphasis> - 指向处理程序的指针，类型driver_intr_t被定义为"
"<function>void driver_intr_t(void *)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17173
msgid ""
"<emphasis>arg</emphasis> - the argument passed to the handler to identify "
"this particular device. It is cast from void* to any real type by the "
"handler. The old convention for the ISA interrupt handlers was to use the "
"unit number as argument, the new (recommended) convention is using a pointer "
"to the device softc structure."
msgstr ""
"<emphasis>arg</emphasis> - 传递给处理程序的参量，标识特定设备。由处理程序将它"
"从void*转换为任何实际类型。ISA中断处理程序的旧约定是使用单元号作为参量，新约"
"定（推荐）使用指向设备softc结构的指针。"

#. (itstool) path: listitem/para
#: book.translate.xml:17181
msgid ""
"<emphasis>cookie[p]</emphasis> - the value received from <function>setup()</"
"function> is used to identify the handler when passed to "
"<function>teardown()</function>"
msgstr ""
"<emphasis>cookie[p]</emphasis> - 从<function>setup()</function>接收的值，当传"
"递给<function>teardown()</function>时用于标识处理程序"

#. (itstool) path: sect1/para
#: book.translate.xml:17188
msgid ""
"A number of methods are defined to operate on the resource handlers (struct "
"resource *). Those of interest to the device driver writers are:"
msgstr ""
"定义了若干方法来操作资源句柄(struct resource *)。设备驱动程序编写者感兴趣的"
"有："

#. (itstool) path: listitem/para
#: book.translate.xml:17194
msgid ""
"<function>u_long rman_get_start(r) u_long rman_get_end(r)</function> Get the "
"start and end of allocated resource range."
msgstr ""
"<function>u_long rman_get_start(r) u_long rman_get_end(r)</function> 取得被分"
"配的资源范围的起始和结束。"

#. (itstool) path: listitem/para
#: book.translate.xml:17199
msgid ""
"<function>void *rman_get_virtual(r)</function> Get the virtual address of "
"activated memory resource."
msgstr ""
"<function>void *rman_get_virtual(r)</function> 取得被激活的内存资源的虚地址。"

#. (itstool) path: sect1/title
#: book.translate.xml:17207
msgid "Bus Memory Mapping"
msgstr "总线内存映射"

#. (itstool) path: sect1/para
#: book.translate.xml:17209
msgid ""
"In many cases data is exchanged between the driver and the device through "
"the memory. Two variants are possible:"
msgstr ""
"很多情况下设备驱动程序和设备之间的数据交换是通过内存进行的。有两种可能的变"
"体："

#. (itstool) path: sect1/para
#: book.translate.xml:17212
msgid "(a) memory is located on the device card"
msgstr "(a) 内存位于设备卡上"

#. (itstool) path: sect1/para
#: book.translate.xml:17213
msgid "(b) memory is the main memory of the computer"
msgstr "(b) 内存为计算机的主内存"

#. (itstool) path: sect1/para
#: book.translate.xml:17215
msgid ""
"In case (a) the driver always copies the data back and forth between the on-"
"card memory and the main memory as necessary. To map the on-card memory into "
"the kernel virtual address space the physical address and length of the on-"
"card memory must be defined as a <literal>SYS_RES_MEMORY</literal> resource. "
"That resource can then be allocated and activated, and its virtual address "
"obtained using <function>rman_get_virtual()</function>. The older drivers "
"used the function <function>pmap_mapdev()</function> for this purpose, which "
"should not be used directly any more. Now it is one of the internal steps of "
"resource activation."
msgstr ""
"情况(a)中，驱动程序可能需要在卡上的内存与主存之间来回拷贝数据。为了将卡上的内"
"存映射到内核的虚地址空间，卡上内存的物理地址和长度必须被定义为      "
"<literal>SYS_RES_MEMORY</literal>资源。然后资源就可以被分配并激活，它的虚地址"
"通过使用<function>rman_get_virtual()</function>获取。较老的驱动程序将函"
"数      <function>pmap_mapdev()</function>用于此目的，现在不应当再直接使用此"
"函数。它已成为资源激活的一个内部步骤。"

#. (itstool) path: sect1/para
#: book.translate.xml:17227
msgid ""
"Most of the ISA cards will have their memory configured for physical "
"location somewhere in range 640KB-1MB. Some of the ISA cards require larger "
"memory ranges which should be placed somewhere under 16MB (because of the 24-"
"bit address limitation on the ISA bus). In that case if the machine has more "
"memory than the start address of the device memory (in other words, they "
"overlap) a memory hole must be configured at the address range used by "
"devices. Many BIOSes allow configuration of a memory hole of 1MB starting at "
"14MB or 15MB. FreeBSD can handle the memory holes properly if the BIOS "
"reports them properly (this feature may be broken on old BIOSes)."
msgstr ""
"大多数ISA卡的内存配置为物理地位于640KB-1MB范围之间的某个位置。某些ISA卡需要更"
"大的内存范围，位于16M以下的某个位置（由于ISA总线上24位地址限制）。这种情况"
"下，如果机器有比设备内存的起始地址更多的内存（换句话说，它们重叠），则必须在"
"被设备使用的内存起始地址处配置一个内存空洞。许多BIOS允许在起始于14MB或15MB处"
"配置1M的内存空洞。如果BIOS正确地报告内存空洞，FreeBSD就能够正确处理它们（此特"
"性在老BIOS上可能会出问题）。"

#. (itstool) path: sect1/para
#: book.translate.xml:17239
msgid ""
"In case (b) just the address of the data is sent to the device, and the "
"device uses DMA to actually access the data in the main memory. Two "
"limitations are present: First, ISA cards can only access memory below 16MB. "
"Second, the contiguous pages in virtual address space may not be contiguous "
"in physical address space, so the device may have to do scatter/gather "
"operations. The bus subsystem provides ready solutions for some of these "
"problems, the rest has to be done by the drivers themselves."
msgstr ""
"情况(b)中，只是数据的地址被发送到设备，设备使用DMA实际访问主存中的数据。存在"
"两个限制：首先，ISA卡只能访问16MB以下的内存。其次，虚地址空间中连续的页面在物"
"理地址空间中可能不连续，设备可能不得不进行分散/收集操作。总线子系统为这些问题"
"提供现成现成的解决办法，剩下的必须由驱动程序自己完成。"

#. (itstool) path: sect1/para
#: book.translate.xml:17249
msgid ""
"Two structures are used for DMA memory allocation, <varname>bus_dma_tag_t</"
"varname> and <varname>bus_dmamap_t</varname>. Tag describes the properties "
"required for the DMA memory. Map represents a memory block allocated "
"according to these properties. Multiple maps may be associated with the same "
"tag."
msgstr ""
"DMA内存分配使用了两个结构， <varname>bus_dma_tag_t</varname>和"
"<varname>bus_dmamap_t</varname>。标签（tag）描述了DMA内存要求的特性。映射"
"（map）表示按照这些特性分配的内存块。多个映射可以与同一标签关联。"

#. (itstool) path: sect1/para
#: book.translate.xml:17255
msgid ""
"Tags are organized into a tree-like hierarchy with inheritance of the "
"properties. A child tag inherits all the requirements of its parent tag, and "
"may make them more strict but never more loose."
msgstr ""
"标签按照对特性的继承而被组织成树型层次结构。子标签继承父标签的所有要求，可以"
"令其更严格，但不允许放宽要求。"

#. (itstool) path: sect1/para
#: book.translate.xml:17260
msgid ""
"Normally one top-level tag (with no parent) is created for each device unit. "
"If multiple memory areas with different requirements are needed for each "
"device then a tag for each of them may be created as a child of the parent "
"tag."
msgstr ""
"一般地，每个设备单元创建一个顶层标签（没有父标签）。如果每个设备需要不同要求"
"的内存区，则为每个内存区都会创建一个标签，这些标签作为父标签的孩子。"

#. (itstool) path: sect1/para
#: book.translate.xml:17265
msgid "The tags can be used to create a map in two ways."
msgstr "使用标签创建映射的方法有两种。"

#. (itstool) path: sect1/para
#: book.translate.xml:17267
msgid ""
"First, a chunk of contiguous memory conformant with the tag requirements may "
"be allocated (and later may be freed). This is normally used to allocate "
"relatively long-living areas of memory for communication with the device. "
"Loading of such memory into a map is trivial: it is always considered as one "
"chunk in the appropriate physical memory range."
msgstr ""
"其一，分配一大块符合标签要求的连续内存（以后可以被释放）。这一般用于分配为了"
"与设备通信而存在相对较长时间的那些内存区。将这样的内存加载到映射中非常容易："
"它总是被看作位于适当物理内存范围的一整块。"

#. (itstool) path: sect1/para
#: book.translate.xml:17275
msgid ""
"Second, an arbitrary area of virtual memory may be loaded into a map. Each "
"page of this memory will be checked for conformance to the map requirement. "
"If it conforms then it is left at its original location. If it is not then a "
"fresh conformant <quote>bounce page</quote> is allocated and used as "
"intermediate storage. When writing the data from the non-conformant original "
"pages they will be copied to their bounce pages first and then transferred "
"from the bounce pages to the device. When reading the data would go from the "
"device to the bounce pages and then copied to their non-conformant original "
"pages. The process of copying between the original and bounce pages is "
"called synchronization. This is normally used on a per-transfer basis: "
"buffer for each transfer would be loaded, transfer done and buffer unloaded."
msgstr ""
"其二，将虚拟内存中的任意区域加载到映射中。这片内存的每一页都被检查，看是否符"
"合映射的要求。如何符合则留在原始位置。如果不符合则分配一个新的符合要求的"
"<quote>反弹页面(bounce page)</quote>，用作中间存储。当从不符合的原始页面写入"
"数据时，数据首先被拷贝到反弹页面，然后从反弹页面传递到设备。当读取时，数据将"
"会从设备到反弹页面，然后被拷贝到它们不符合的原始页面。原始和反弹页面之间的拷"
"贝处理被称作同步。这一般用于单次传输的基础之上：每次传输时加载缓冲区，完成传"
"输，卸载缓冲区。"

#. (itstool) path: sect1/para
#: book.translate.xml:17290
msgid "The functions working on the DMA memory are:"
msgstr "工作在DMA内存上的函数有："

#. (itstool) path: listitem/para
#: book.translate.xml:17294
msgid ""
"<function>int bus_dma_tag_create(bus_dma_tag_t parent, bus_size_t alignment, "
"bus_size_t boundary, bus_addr_t lowaddr, bus_addr_t highaddr, "
"bus_dma_filter_t *filter, void *filterarg, bus_size_t maxsize, int "
"nsegments, bus_size_t maxsegsz, int flags, bus_dma_tag_t *dmat)</function>"
msgstr ""
"<function>int bus_dma_tag_create(bus_dma_tag_t parent, bus_size_t alignment, "
"bus_size_t boundary, bus_addr_t lowaddr, bus_addr_t highaddr, "
"bus_dma_filter_t *filter, void *filterarg, bus_size_t maxsize, int "
"nsegments, bus_size_t maxsegsz, int flags, bus_dma_tag_t *dmat)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17300
msgid "Create a new tag. Returns 0 on success, the error code otherwise."
msgstr "创建新标签。成功则返回0，否则返回错误码。"

#. (itstool) path: listitem/para
#: book.translate.xml:17305
msgid ""
"<emphasis>parent</emphasis> - parent tag, or NULL to create a top-level tag."
msgstr "<emphasis>parent</emphasis> - 父标签或者NULL，NULL用于创建顶层标签。"

#. (itstool) path: listitem/para
#: book.translate.xml:17310
msgid ""
"<emphasis>alignment</emphasis> - required physical alignment of the memory "
"area to be allocated for this tag. Use value 1 for <quote>no specific "
"alignment</quote>. Applies only to the future <function>bus_dmamem_alloc()</"
"function> but not <function>bus_dmamap_create()</function> calls."
msgstr ""
"<emphasis>alignment</emphasis> -对将要分配给标签的内存区的对齐要求。"
"<quote>no specificalignment</quote>时值为1。仅应用于以后的"
"<function>bus_dmamem_alloc()</function>而不是<function>bus_dmamap_create()</"
"function>调用。"

#. (itstool) path: listitem/para
#: book.translate.xml:17319
msgid ""
"<emphasis>boundary</emphasis> - physical address boundary that must not be "
"crossed when allocating the memory. Use value 0 for <quote>no boundary</"
"quote>. Applies only to the future <function>bus_dmamem_alloc()</function> "
"but not <function>bus_dmamap_create()</function> calls. Must be power of 2. "
"If the memory is planned to be used in non-cascaded DMA mode (i.e., the DMA "
"addresses will be supplied not by the device itself but by the ISA DMA "
"controller) then the boundary must be no larger than 64KB (64*1024) due to "
"the limitations of the DMA hardware."
msgstr ""
"<emphasis>boundary</emphasis> - 物理地址边界，分配内存时不能穿过。对于"
"<quote>no boundary</quote>使用0。仅应用于以后的<function>bus_dmamem_alloc()</"
"function>而不是<function>bus_dmamap_create()</function>调用。必须为2的乘方。"
"如果计划以非层叠DMA方式使用内存（也就是说，DMA地址由ISA DMA控制器提供而不是设"
"备自身），则由于DMA硬件限制，边界必须不能大于64KB (64*1024)。"

#. (itstool) path: listitem/para
#: book.translate.xml:17333
msgid ""
"<emphasis>lowaddr, highaddr</emphasis> - the names are slightly misleading; "
"these values are used to limit the permitted range of physical addresses "
"used to allocate the memory. The exact meaning varies depending on the "
"planned future use:"
msgstr ""
"<emphasis>lowaddr, highaddr</emphasis> - 名字稍微有些误导。这些值用于限制可用"
"于内存分配的物理地址的允许范围。其确切含义根据以后不同的使用而有所不同："

#. (itstool) path: listitem/para
#: book.translate.xml:17341
msgid ""
"For <function>bus_dmamem_alloc()</function> all the addresses from 0 to "
"lowaddr-1 are considered permitted, the higher ones are forbidden."
msgstr ""
"对于<function>bus_dmamem_alloc()</function>，从0到lowaddr-1的所有地址被视为允"
"许，更高的地址不允许使用。"

#. (itstool) path: listitem/para
#: book.translate.xml:17347
msgid ""
"For <function>bus_dmamap_create()</function> all the addresses outside the "
"inclusive range [lowaddr; highaddr] are considered accessible. The addresses "
"of pages inside the range are passed to the filter function which decides if "
"they are accessible. If no filter function is supplied then all the range is "
"considered unaccessible."
msgstr ""
"对于<function>bus_dmamap_create()</function>，闭区间[lowaddr; highaddr]之外的"
"所有地址被视为可访问。范围之内的地址页面被传递给过滤函数，由它决定是否可访"
"问。如果没有提供过滤函数，则整个区间被视为不可访问。"

#. (itstool) path: listitem/para
#: book.translate.xml:17357
msgid "For the ISA devices the normal values (with no filter function) are:"
msgstr "对于ISA设备，正常值（没有过滤函数）为："

#. (itstool) path: listitem/para
#: book.translate.xml:17359
msgid "lowaddr = BUS_SPACE_MAXADDR_24BIT"
msgstr "lowaddr = BUS_SPACE_MAXADDR_24BIT"

#. (itstool) path: listitem/para
#: book.translate.xml:17360
msgid "highaddr = BUS_SPACE_MAXADDR"
msgstr "highaddr = BUS_SPACE_MAXADDR"

#. (itstool) path: listitem/para
#: book.translate.xml:17367
msgid ""
"<emphasis>filter, filterarg</emphasis> - the filter function and its "
"argument. If NULL is passed for filter then the whole range [lowaddr, "
"highaddr] is considered unaccessible when doing "
"<function>bus_dmamap_create()</function>. Otherwise the physical address of "
"each attempted page in range [lowaddr; highaddr] is passed to the filter "
"function which decides if it is accessible. The prototype of the filter "
"function is: <function>int filterfunc(void *arg, bus_addr_t paddr)</"
"function>. It must return 0 if the page is accessible, non-zero otherwise."
msgstr ""
"<emphasis>filter, filterarg</emphasis> - 过滤函数及其参数。如果filter为NULL，"
"则当调用<function>bus_dmamap_create()</function>时，整个区间[lowaddr, "
"highaddr]被视为不可访问。否则，区间[lowaddr; highaddr]内的每个被试图访问的页"
"面的物理地址被传递给过滤函数，由它决定是否可访问。过滤函数的原型为："
"<function>int filterfunc(void *arg,bus_addr_t paddr)</function>。当页面可以被"
"访问时它必须返回0，否则返回非零值。"

#. (itstool) path: listitem/para
#: book.translate.xml:17381
msgid ""
"<emphasis>maxsize</emphasis> - the maximal size of memory (in bytes) that "
"may be allocated through this tag. In case it is difficult to estimate or "
"could be arbitrarily big, the value for ISA devices would be "
"<literal>BUS_SPACE_MAXSIZE_24BIT</literal>."
msgstr ""
"<emphasis>maxsize</emphasis> - 通过此标签可以分配的最大内存值（以字节计）。有"
"时这个值很难估算，或者可以任意大，这种情况下，对于ISA设备这个值可以设为"
"<literal>BUS_SPACE_MAXSIZE_24BIT</literal>。"

#. (itstool) path: listitem/para
#: book.translate.xml:17389
msgid ""
"<emphasis>nsegments</emphasis> - maximal number of scatter-gather segments "
"supported by the device. If unrestricted then the value "
"<literal>BUS_SPACE_UNRESTRICTED</literal> should be used. This value is "
"recommended for the parent tags, the actual restrictions would then be "
"specified for the descendant tags. Tags with nsegments equal to "
"<literal>BUS_SPACE_UNRESTRICTED</literal> may not be used to actually load "
"maps, they may be used only as parent tags. The practical limit for "
"nsegments seems to be about 250-300, higher values will cause kernel stack "
"overflow (the hardware can not normally support that many scatter-gather "
"buffers anyway)."
msgstr ""
"<emphasis>nsegments</emphasis> - 设备支持的分散/收集段的最大数目。如果不加限"
"制，则使用应当使用值<literal>BUS_SPACE_UNRESTRICTED</literal>。建议对父标签使"
"用这个值，而为子孙标签指定实际限制。nsegments值等于 "
"<literal>BUS_SPACE_UNRESTRICTED</literal>的标签不能用于实际加载映射，仅可以将"
"它们作为父标签。 nsetments的实际限制大约为250-300，再高的值将导致内核堆栈溢出"
"（硬件无法正常支持那么多的分散/收集缓冲区）。"

#. (itstool) path: listitem/para
#: book.translate.xml:17404
msgid ""
"<emphasis>maxsegsz</emphasis> - maximal size of a scatter-gather segment "
"supported by the device. The maximal value for ISA device would be "
"<literal>BUS_SPACE_MAXSIZE_24BIT</literal>."
msgstr ""
"<emphasis>maxsegsz</emphasis> - 设备支持的分散/收集段的最大尺寸。对于ISA设备"
"的最大值为<literal>BUS_SPACE_MAXSIZE_24BIT</literal>。"

#. (itstool) path: listitem/para
#: book.translate.xml:17411
msgid ""
"<emphasis>flags</emphasis> - a bitmap of flags. The only interesting flags "
"are:"
msgstr "<emphasis>flags</emphasis> - \t旗标的位图。感兴趣的旗标只有："

#. (itstool) path: listitem/para
#: book.translate.xml:17416
msgid ""
"<emphasis>BUS_DMA_ALLOCNOW</emphasis> - requests to allocate all the "
"potentially needed bounce pages when creating the tag."
msgstr ""
"<emphasis>BUS_DMA_ALLOCNOW</emphasis> - 创建标签时请求分配所有可能用到的反射"
"页面。"

#. (itstool) path: listitem/para
#: book.translate.xml:17422
msgid ""
"<emphasis>BUS_DMA_ISA</emphasis> - mysterious flag used only on Alpha "
"machines. It is not defined for the i386 machines. Probably it should be "
"used by all the ISA drivers for Alpha machines but it looks like there are "
"no such drivers yet."
msgstr ""
"<emphasis>BUS_DMA_ISA</emphasis> - 比较神秘的一个标志，仅用于Alpha机器。i386"
"机器没有定义它。Alpha机器的所有ISA设备都应当使用这个标志，但似乎还没有这样的"
"驱动程序。"

#. (itstool) path: listitem/para
#: book.translate.xml:17432
msgid ""
"<emphasis>dmat</emphasis> - pointer to the storage for the new tag to be "
"returned."
msgstr "<emphasis>dmat</emphasis> - 指向返回的新标签的存储的指针。"

#. (itstool) path: listitem/para
#: book.translate.xml:17441
msgid "<function>int bus_dma_tag_destroy(bus_dma_tag_t dmat)</function>"
msgstr "<function>int bus_dma_tag_destroy(bus_dma_tag_t dmat)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17444
msgid "Destroy a tag. Returns 0 on success, the error code otherwise."
msgstr "销毁标签。成功则返回0，否则返回错误码。"

#. (itstool) path: listitem/para
#: book.translate.xml:17447
msgid "dmat - the tag to be destroyed."
msgstr "dmat - 被销毁的标签。"

#. (itstool) path: listitem/para
#: book.translate.xml:17452
msgid ""
"<function>int bus_dmamem_alloc(bus_dma_tag_t dmat, void** vaddr, int flags, "
"bus_dmamap_t *mapp)</function>"
msgstr ""
"<function>int bus_dmamem_alloc(bus_dma_tag_t dmat, void** vaddr, int flags, "
"bus_dmamap_t *mapp)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17456
msgid ""
"Allocate an area of contiguous memory described by the tag. The size of "
"memory to be allocated is tag's maxsize. Returns 0 on success, the error "
"code otherwise. The result still has to be loaded by "
"<function>bus_dmamap_load()</function> before being used to get the physical "
"address of the memory."
msgstr ""
"分配标签所描述的一块连续内存区。被分配的内存的大小为标签的maxsize。成功则返回"
"0，否则返回错误码。调用结果被用于获取内存的物理地址，但在此之前必须用"
"<function>bus_dmamap_load()</function>将其加载。"

#. (itstool) path: listitem/para
#: book.translate.xml:17465 book.translate.xml:17521 book.translate.xml:17552
#: book.translate.xml:17624
msgid "<emphasis>dmat</emphasis> - the tag"
msgstr "<emphasis>dmat</emphasis> - 标签"

#. (itstool) path: listitem/para
#: book.translate.xml:17470
msgid ""
"<emphasis>vaddr</emphasis> - pointer to the storage for the kernel virtual "
"address of the allocated area to be returned."
msgstr ""
"<emphasis>vaddr</emphasis> - 指向存储的指针，该存储空间用于返回的分配区域的内"
"核虚地址。"

#. (itstool) path: listitem/para
#: book.translate.xml:17477
msgid "flags - a bitmap of flags. The only interesting flag is:"
msgstr "flags - 旗标的位图。唯一感兴趣的旗标为："

#. (itstool) path: listitem/para
#: book.translate.xml:17482
msgid ""
"<emphasis>BUS_DMA_NOWAIT</emphasis> - if the memory is not immediately "
"available return the error. If this flag is not set then the routine is "
"allowed to sleep until the memory becomes available."
msgstr ""
"<emphasis>BUS_DMA_NOWAIT</emphasis> - 如果内存不能立即可用则返回错误。如果此"
"标志没有设置，则允许例程睡眠，直到内存可用为止。"

#. (itstool) path: listitem/para
#: book.translate.xml:17493
msgid ""
"<emphasis>mapp</emphasis> - pointer to the storage for the new map to be "
"returned."
msgstr "<emphasis>mapp</emphasis> - 指向返回的新映射的存储的指针。"

#. (itstool) path: listitem/para
#: book.translate.xml:17502
msgid ""
"<function>void bus_dmamem_free(bus_dma_tag_t dmat, void *vaddr, bus_dmamap_t "
"map)</function>"
msgstr ""
"<function>void bus_dmamem_free(bus_dma_tag_t dmat, void *vaddr, bus_dmamap_t "
"map)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17506
msgid ""
"Free the memory allocated by <function>bus_dmamem_alloc()</function>. At "
"present, freeing of the memory allocated with ISA restrictions is not "
"implemented. Because of this the recommended model of use is to keep and re-"
"use the allocated areas for as long as possible. Do not lightly free some "
"area and then shortly allocate it again. That does not mean that "
"<function>bus_dmamem_free()</function> should not be used at all: hopefully "
"it will be properly implemented soon."
msgstr ""
"释放由<function>bus_dmamem_alloc()</function>分配的内存。目前，对分配的带有"
"ISA限制的内存的释放没有实现。因此，建议的使用模型为尽可能长时间地保持和重用分"
"配的区域。不要轻易地释放某些区域，然后再短时间地分配它。这并不意味着不应当使"
"用<function>bus_dmamem_free()</function>：希望很快它就会被完整地实现。"

#. (itstool) path: listitem/para
#: book.translate.xml:17525
msgid "<emphasis>vaddr</emphasis> - the kernel virtual address of the memory"
msgstr "<emphasis>vaddr</emphasis> - 内存的内核虚地址"

#. (itstool) path: listitem/para
#: book.translate.xml:17531
msgid ""
"<emphasis>map</emphasis> - the map of the memory (as returned from "
"<function>bus_dmamem_alloc()</function>)"
msgstr ""
"<emphasis>map</emphasis> - 内存的映射（跟<function>bus_dmamem_alloc()</"
"function>返回的一样）"

#. (itstool) path: listitem/para
#: book.translate.xml:17541
msgid ""
"<function>int bus_dmamap_create(bus_dma_tag_t dmat, int flags, bus_dmamap_t "
"*mapp)</function>"
msgstr ""
"<function>int bus_dmamap_create(bus_dma_tag_t dmat, int flags, bus_dmamap_t "
"*mapp)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17545
msgid ""
"Create a map for the tag, to be used in <function>bus_dmamap_load()</"
"function> later. Returns 0 on success, the error code otherwise."
msgstr ""
"为标签创建映射，以后用于<function>bus_dmamap_load()</function>。成功则返回0，"
"否则返回错误码。"

#. (itstool) path: listitem/para
#: book.translate.xml:17557
msgid ""
"<emphasis>flags</emphasis> - theoretically, a bit map of flags. But no flags "
"are defined yet, so at present it will be always 0."
msgstr ""
"<emphasis>flags</emphasis> - 理论上是旗标的位图。但还从未定义过任何旗标，因此"
"目前总是0。"

#. (itstool) path: listitem/para
#: book.translate.xml:17564
msgid ""
"<emphasis>mapp</emphasis> - pointer to the storage for the new map to be "
"returned"
msgstr "<emphasis>mapp</emphasis> - 指向返回的新映射的存储的指针。"

#. (itstool) path: listitem/para
#: book.translate.xml:17573
msgid ""
"<function>int bus_dmamap_destroy(bus_dma_tag_t dmat, bus_dmamap_t map)</"
"function>"
msgstr ""
"<function>int bus_dmamap_destroy(bus_dma_tag_t dmat, bus_dmamap_t map)</"
"function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17577
msgid "Destroy a map. Returns 0 on success, the error code otherwise."
msgstr "销毁映射。成功则返回0，否则返回错误码。"

#. (itstool) path: listitem/para
#: book.translate.xml:17583
msgid "dmat - the tag to which the map is associated"
msgstr "dmat - 与映射关联的标签"

#. (itstool) path: listitem/para
#: book.translate.xml:17588
msgid "map - the map to be destroyed"
msgstr "map - 将要被销毁的映射"

#. (itstool) path: listitem/para
#: book.translate.xml:17596
msgid ""
"<function>int bus_dmamap_load(bus_dma_tag_t dmat, bus_dmamap_t map, void "
"*buf, bus_size_t buflen, bus_dmamap_callback_t *callback, void "
"*callback_arg, int flags)</function>"
msgstr ""
"<function>int bus_dmamap_load(bus_dma_tag_t dmat, bus_dmamap_t map, void "
"*buf, bus_size_t buflen, bus_dmamap_callback_t *callback, void "
"*callback_arg, int flags)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17602
msgid ""
"Load a buffer into the map (the map must be previously created by "
"<function>bus_dmamap_create()</function> or <function>bus_dmamem_alloc()</"
"function>). All the pages of the buffer are checked for conformance to the "
"tag requirements and for those not conformant the bounce pages are "
"allocated. An array of physical segment descriptors is built and passed to "
"the callback routine. This callback routine is then expected to handle it in "
"some way. The number of bounce buffers in the system is limited, so if the "
"bounce buffers are needed but not immediately available the request will be "
"queued and the callback will be called when the bounce buffers will become "
"available. Returns 0 if the callback was executed immediately or "
"<errorname>EINPROGRESS</errorname> if the request was queued for future "
"execution. In the latter case the synchronization with queued callback "
"routine is the responsibility of the driver."
msgstr ""
"加载缓冲区到映射中(映射必须事先由<function>bus_dmamap_create()</function>或者"
"<function>bus_dmamem_alloc()</function>)创建。缓冲区的所有页面都会被检查，看"
"是否符合标签的要求，并为那些不符合的分配反弹页面。会创建物理段描述符的数组，"
"并将其传递给回调函数。回调函数以某种方式处理这个数组。系统中的反弹缓冲区是受"
"限的，因此如果需要的反弹缓冲区不能立即获得，则将请求入队，当反弹缓冲区可用时"
"再调用回调函数。如果回调函数立即执行则返回0，如果请求被排队，等待将来执行，则"
"返回<errorname>EINPROGRESS</errorname>。后一种情况下，与排队的回调函数之间的"
"同步由驱动程序负责。"

#. (itstool) path: listitem/para
#: book.translate.xml:17629
msgid "<emphasis>map</emphasis> - the map"
msgstr "<emphasis>map</emphasis> - 映射"

#. (itstool) path: listitem/para
#: book.translate.xml:17634
msgid "<emphasis>buf</emphasis> - kernel virtual address of the buffer"
msgstr "<emphasis>buf</emphasis> - 缓冲区的内核虚地址"

#. (itstool) path: listitem/para
#: book.translate.xml:17640
msgid "<emphasis>buflen</emphasis> - length of the buffer"
msgstr "<emphasis>buflen</emphasis> - 缓冲区的长度"

#. (itstool) path: listitem/para
#: book.translate.xml:17645
msgid ""
"<emphasis>callback</emphasis>,<function> callback_arg</function> - the "
"callback function and its argument"
msgstr ""
"<emphasis>callback</emphasis>，<function>callback_arg</function> - 回调函数及"
"其参数"

#. (itstool) path: listitem/para
#: book.translate.xml:17653
msgid "The prototype of callback function is:"
msgstr "回调函数的原型为："

#. (itstool) path: listitem/para
#: book.translate.xml:17656
msgid ""
"<function>void callback(void *arg, bus_dma_segment_t *seg, int nseg, int "
"error)</function>"
msgstr ""
"<function>void callback(void *arg, bus_dma_segment_t *seg, int nseg, int "
"error)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17663
msgid ""
"<emphasis>arg</emphasis> - the same as callback_arg passed to "
"<function>bus_dmamap_load()</function>"
msgstr ""
"<emphasis>arg</emphasis> - 与传递给<function>bus_dmamap_load()</function>的"
"callback_arg相同。"

#. (itstool) path: listitem/para
#: book.translate.xml:17669
msgid "<emphasis>seg</emphasis> - array of the segment descriptors"
msgstr "<emphasis>seg</emphasis> - 段描述符的数组"

#. (itstool) path: listitem/para
#: book.translate.xml:17675
msgid "<emphasis>nseg</emphasis> - number of descriptors in array"
msgstr "<emphasis>nseg</emphasis> - 数组中的描述符个数"

#. (itstool) path: listitem/para
#: book.translate.xml:17681
msgid ""
"<emphasis>error</emphasis> - indication of the segment number overflow: if "
"it is set to <errorname>EFBIG</errorname> then the buffer did not fit into "
"the maximal number of segments permitted by the tag. In this case only the "
"permitted number of descriptors will be in the array. Handling of this "
"situation is up to the driver: depending on the desired semantics it can "
"either consider this an error or split the buffer in two and handle the "
"second part separately"
msgstr ""
"<emphasis>error</emphasis> - 表示段数目溢出：如被设为<errorname>EFBIG</"
"errorname>，则标签允许的最大数目的段无法容纳缓冲区。这种情况下数组中的描述符"
"的数目只有标签许可的那么多。对这种情况的处理由驱动程序决定：根据希望的语义，"
"驱动程序可以视其为错误，或将缓冲区分为两个并单独处理第二个。"

#. (itstool) path: listitem/para
#: book.translate.xml:17695
msgid "Each entry in the segments array contains the fields:"
msgstr "段数组中的每一项包含如下字段："

#. (itstool) path: listitem/para
#: book.translate.xml:17702
msgid "<emphasis>ds_addr</emphasis> - physical bus address of the segment"
msgstr "<emphasis>ds_addr</emphasis> - 段物理地址"

#. (itstool) path: listitem/para
#: book.translate.xml:17708
msgid "<emphasis>ds_len</emphasis> - length of the segment"
msgstr "<emphasis>ds_len</emphasis> - 段长度"

#. (itstool) path: listitem/para
#: book.translate.xml:17717
msgid ""
"<function>void bus_dmamap_unload(bus_dma_tag_t dmat, bus_dmamap_t map)</"
"function>"
msgstr ""
"<function>void bus_dmamap_unload(bus_dma_tag_t dmat, bus_dmamap_t map)</"
"function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17721
msgid "unload the map."
msgstr "卸载映射。"

#. (itstool) path: listitem/para
#: book.translate.xml:17726 book.translate.xml:17755
msgid "<emphasis>dmat</emphasis> - tag"
msgstr "<emphasis>dmat</emphasis> - 标签"

#. (itstool) path: listitem/para
#: book.translate.xml:17731 book.translate.xml:17760
msgid "<emphasis>map</emphasis> - loaded map"
msgstr "<emphasis>map</emphasis> - 已加载的映射"

#. (itstool) path: listitem/para
#: book.translate.xml:17740
msgid ""
"<function>void bus_dmamap_sync (bus_dma_tag_t dmat, bus_dmamap_t map, "
"bus_dmasync_op_t op)</function>"
msgstr ""
"<function>void bus_dmamap_sync (bus_dma_tag_t dmat, bus_dmamap_t map, "
"bus_dmasync_op_t op)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:17744
msgid ""
"Synchronise a loaded buffer with its bounce pages before and after physical "
"transfer to or from device. This is the function that does all the necessary "
"copying of data between the original buffer and its mapped version. The "
"buffers must be synchronized both before and after doing the transfer."
msgstr ""
"与设备进行物理传输前后，将加载的缓冲区与其反弹页面进行同步。此函数完成原始缓"
"冲区与其映射版本之间所有必需的数据拷贝工作。进行传输之前和之后必须对缓冲区进"
"行同步。"

#. (itstool) path: listitem/para
#: book.translate.xml:17765
msgid "<emphasis>op</emphasis> - type of synchronization operation to perform:"
msgstr "<emphasis>op</emphasis> - 要执行的同步操作的类型："

#. (itstool) path: listitem/para
#: book.translate.xml:17774
msgid ""
"<function>BUS_DMASYNC_PREREAD</function> - before reading from device into "
"buffer"
msgstr "<function>BUS_DMASYNC_PREREAD</function> - 从设备到缓冲区的读操作之前"

#. (itstool) path: listitem/para
#: book.translate.xml:17780
msgid ""
"<function>BUS_DMASYNC_POSTREAD</function> - after reading from device into "
"buffer"
msgstr "<function>BUS_DMASYNC_POSTREAD</function> - 从设备到缓冲区的读操作之后"

#. (itstool) path: listitem/para
#: book.translate.xml:17786
msgid ""
"<function>BUS_DMASYNC_PREWRITE</function> - before writing the buffer to "
"device"
msgstr "<function>BUS_DMASYNC_PREWRITE</function> - 从缓冲区到设备的写操作之前"

#. (itstool) path: listitem/para
#: book.translate.xml:17792
msgid ""
"<function>BUS_DMASYNC_POSTWRITE</function> - after writing the buffer to "
"device"
msgstr ""
"<function>BUS_DMASYNC_POSTWRITE</function> - 从缓冲区到设备的写操作之后"

#. (itstool) path: sect1/para
#: book.translate.xml:17803
msgid ""
"As of now PREREAD and POSTWRITE are null operations but that may change in "
"the future, so they must not be ignored in the driver. Synchronization is "
"not needed for the memory obtained from <function>bus_dmamem_alloc()</"
"function>."
msgstr ""
"当前PREREAD和POSTWRITE为空操作，但将来可能会改变，因此驱动程序中不能忽略它"
"们。由<function>bus_dmamem_alloc()</function>获得的内存不需要同步。"

#. (itstool) path: sect1/para
#: book.translate.xml:17809
msgid ""
"Before calling the callback function from <function>bus_dmamap_load()</"
"function> the segment array is stored in the stack. And it gets pre-"
"allocated for the maximal number of segments allowed by the tag. Because of "
"this the practical limit for the number of segments on i386 architecture is "
"about 250-300 (the kernel stack is 4KB minus the size of the user structure, "
"size of a segment array entry is 8 bytes, and some space must be left). "
"Because the array is allocated based on the maximal number this value must "
"not be set higher than really needed. Fortunately, for most of hardware the "
"maximal supported number of segments is much lower. But if the driver wants "
"to handle buffers with a very large number of scatter-gather segments it "
"should do that in portions: load part of the buffer, transfer it to the "
"device, load next part of the buffer, and so on."
msgstr ""
"从<function>bus_dmamap_load()</function>中调用回调函数之前，段数组是存储在栈"
"中的。并且是按标签允许的最大数目的段预先分配好的。这样由于i386体系结构上对段"
"数目的实际限制约为250-300（内核栈为4KB减去用户结构的大小，段数组条目的大小为8"
"字节，和其它必须留出来的空间）。由于数组基于最大数目而分配，因此这个值必须不"
"能设置成超出实际需要。幸运的是，对于大多数硬件而言，所支持的段的最大数目低很"
"多。但如果驱动程序想处理具有非常多分散/收集段的缓冲区，则应当一部分一部分地处"
"理：加载缓冲区的一部分，传输到设备，然后加载缓冲区的下一部分，如此反复。"

#. (itstool) path: sect1/para
#: book.translate.xml:17826
msgid ""
"Another practical consequence is that the number of segments may limit the "
"size of the buffer. If all the pages in the buffer happen to be physically "
"non-contiguous then the maximal supported buffer size for that fragmented "
"case would be (nsegments * page_size). For example, if a maximal number of "
"10 segments is supported then on i386 maximal guaranteed supported buffer "
"size would be 40K. If a higher size is desired then special tricks should be "
"used in the driver."
msgstr ""
"另一个实践结论是段数目可能限制缓冲区的大小。如果缓冲区中的所有页面碰巧物理上"
"不连续，则分片情况下支持的最大缓冲区尺寸为(nsegments * page_size)。例如，如果"
"支持的段的最大数目为10，则在i386上可以确保支持的最大缓冲区大小为40K。如果希望"
"更大的则需要在驱动程序中使用一些特殊技巧。"

#. (itstool) path: sect1/para
#: book.translate.xml:17836
msgid ""
"If the hardware does not support scatter-gather at all or the driver wants "
"to support some buffer size even if it is heavily fragmented then the "
"solution is to allocate a contiguous buffer in the driver and use it as "
"intermediate storage if the original buffer does not fit."
msgstr ""
"如果硬件根本不支持分散/收集，或者驱动程序希望即使在严重分片的情况下仍然支持某"
"种缓冲区大小，则解决办法是：如果无法容纳下原始缓冲区，就在驱动程序中分配一个"
"连续的缓冲区作为中间存储。"

#. (itstool) path: sect1/para
#: book.translate.xml:17843
msgid ""
"Below are the typical call sequences when using a map depend on the use of "
"the map. The characters -&gt; are used to show the flow of time."
msgstr ""
"下面是当使用映射时的典型调用顺序，根据对映射的具体使用而不同。字符-&gt;用于显"
"示时间流。"

#. (itstool) path: sect1/para
#: book.translate.xml:17848
msgid ""
"For a buffer which stays practically fixed during all the time between "
"attachment and detachment of a device:"
msgstr "对于从连接到分离设备，这期间位置一直不变的缓冲区："

#. (itstool) path: sect1/para
#: book.translate.xml:17851
msgid ""
"bus_dmamem_alloc -&gt; bus_dmamap_load -&gt; ...use buffer... -&gt; -&gt; "
"bus_dmamap_unload -&gt; bus_dmamem_free"
msgstr ""
"bus_dmamem_alloc -&gt; bus_dmamap_load -&gt; ...use buffer... -&gt; -&gt; "
"bus_dmamap_unload -&gt; bus_dmamem_free"

#. (itstool) path: para/programlisting
#: book.translate.xml:17860
#, no-wrap
msgid ""
"          bus_dmamap_create -&gt;\n"
"          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do transfer -&gt;\n"
"          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;\n"
"          ...\n"
"          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do transfer -&gt;\n"
"          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;\n"
"          -&gt; bus_dmamap_destroy        "
msgstr ""
"          bus_dmamap_create -&gt;\n"
"          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do transfer -&gt;\n"
"          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;\n"
"          ...\n"
"          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do transfer -&gt;\n"
"          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;\n"
"          -&gt; bus_dmamap_destroy        "

#. (itstool) path: sect1/para
#: book.translate.xml:17856
msgid ""
"For a buffer that changes frequently and is passed from outside the driver: "
"<_:programlisting-1/>"
msgstr ""
"对于从驱动程序外部传递进去，并且经常变化的缓冲区：<_:programlisting-1/>"

#. (itstool) path: sect1/para
#: book.translate.xml:17869
msgid ""
"When loading a map created by <function>bus_dmamem_alloc()</function> the "
"passed address and size of the buffer must be the same as used in "
"<function>bus_dmamem_alloc()</function>. In this case it is guaranteed that "
"the whole buffer will be mapped as one segment (so the callback may be based "
"on this assumption) and the request will be executed immediately "
"(EINPROGRESS will never be returned). All the callback needs to do in this "
"case is to save the physical address."
msgstr ""
"当加载由<function>bus_dmamem_alloc()</function>创建的映射时，传递进去的缓冲区"
"的地址和大小必须和<function>bus_dmamem_alloc()</function>中使用的一样。这种情"
"况下就可以保证整个缓冲区被作为一个段而映射（因而回调可以基于此假设），并且请"
"求被立即执行（永远不会返回EINPROGRESS）。这种情况下回调函数需要作的只是保存物"
"理地址。"

#. (itstool) path: sect1/para
#: book.translate.xml:17880
msgid "A typical example would be:"
msgstr "典型示例如下："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:17884
#, no-wrap
msgid ""
"          static void\n"
"        alloc_callback(void *arg, bus_dma_segment_t *seg, int nseg, int error)\n"
"        {\n"
"          *(bus_addr_t *)arg = seg[0].ds_addr;\n"
"        }\n"
"\n"
"          ...\n"
"          int error;\n"
"          struct somedata {\n"
"            ....\n"
"          };\n"
"          struct somedata *vsomedata; /* virtual address */\n"
"          bus_addr_t psomedata; /* physical bus-relative address */\n"
"          bus_dma_tag_t tag_somedata;\n"
"          bus_dmamap_t map_somedata;\n"
"          ...\n"
"\n"
"          error=bus_dma_tag_create(parent_tag, alignment,\n"
"           boundary, lowaddr, highaddr, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"           /*maxsize*/ sizeof(struct somedata), /*nsegments*/ 1,\n"
"           /*maxsegsz*/ sizeof(struct somedata), /*flags*/ 0,\n"
"           &amp;tag_somedata);\n"
"          if(error)\n"
"          return error;\n"
"\n"
"          error = bus_dmamem_alloc(tag_somedata, &amp;vsomedata, /* flags*/ 0,\n"
"             &amp;map_somedata);\n"
"          if(error)\n"
"             return error;\n"
"\n"
"          bus_dmamap_load(tag_somedata, map_somedata, (void *)vsomedata,\n"
"             sizeof (struct somedata), alloc_callback,\n"
"             (void *) &amp;psomedata, /*flags*/0);        "
msgstr ""
"          static void\n"
"        alloc_callback(void *arg, bus_dma_segment_t *seg, int nseg, int error)\n"
"        {\n"
"          *(bus_addr_t *)arg = seg[0].ds_addr;\n"
"        }\n"
"\n"
"          ...\n"
"          int error;\n"
"          struct somedata {\n"
"            ....\n"
"          };\n"
"          struct somedata *vsomedata; /* virtual address */\n"
"          bus_addr_t psomedata; /* physical bus-relative address */\n"
"          bus_dma_tag_t tag_somedata;\n"
"          bus_dmamap_t map_somedata;\n"
"          ...\n"
"\n"
"          error=bus_dma_tag_create(parent_tag, alignment,\n"
"           boundary, lowaddr, highaddr, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"           /*maxsize*/ sizeof(struct somedata), /*nsegments*/ 1,\n"
"           /*maxsegsz*/ sizeof(struct somedata), /*flags*/ 0,\n"
"           &amp;tag_somedata);\n"
"          if(error)\n"
"          return error;\n"
"\n"
"          error = bus_dmamem_alloc(tag_somedata, &amp;vsomedata, /* flags*/ 0,\n"
"             &amp;map_somedata);\n"
"          if(error)\n"
"             return error;\n"
"\n"
"          bus_dmamap_load(tag_somedata, map_somedata, (void *)vsomedata,\n"
"             sizeof (struct somedata), alloc_callback,\n"
"             (void *) &amp;psomedata, /*flags*/0);        "

#. (itstool) path: sect1/para
#: book.translate.xml:17918
msgid ""
"Looks a bit long and complicated but that is the way to do it. The practical "
"consequence is: if multiple memory areas are allocated always together it "
"would be a really good idea to combine them all into one structure and "
"allocate as one (if the alignment and boundary limitations permit)."
msgstr ""
"代码看起来有点长，也比较复杂，但那是正确的使用方法。实际结果是：如果分配多个"
"内存区域，则总将它们组合成一个结构并作为整体分配（如果对齐和边界限制允许的"
"话）是一个很好的主意。"

#. (itstool) path: sect1/para
#: book.translate.xml:17925
msgid ""
"When loading an arbitrary buffer into the map created by "
"<function>bus_dmamap_create()</function> special measures must be taken to "
"synchronize with the callback in case it would be delayed. The code would "
"look like:"
msgstr ""
"当加载任意缓冲区到由<function>bus_dmamap_create()</function>创建的映射时，由"
"于回调可能被延迟，因此必须采取特殊措施与回调函数进行同步。代码看起来像下面的"
"样子："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:17932
#, no-wrap
msgid ""
"          {\n"
"           int s;\n"
"           int error;\n"
"\n"
"           s = splsoftvm();\n"
"           error = bus_dmamap_load(\n"
"               dmat,\n"
"               dmamap,\n"
"               buffer_ptr,\n"
"               buffer_len,\n"
"               callback,\n"
"               /*callback_arg*/ buffer_descriptor,\n"
"               /*flags*/0);\n"
"           if (error == EINPROGRESS) {\n"
"               /*\n"
"                * Do whatever is needed to ensure synchronization\n"
"                * with callback. Callback is guaranteed not to be started\n"
"                * until we do splx() or tsleep().\n"
"                */\n"
"              }\n"
"           splx(s);\n"
"          }        "
msgstr ""
"          {\n"
"           int s;\n"
"           int error;\n"
"\n"
"           s = splsoftvm();\n"
"           error = bus_dmamap_load(\n"
"               dmat,\n"
"               dmamap,\n"
"               buffer_ptr,\n"
"               buffer_len,\n"
"               callback,\n"
"               /*callback_arg*/ buffer_descriptor,\n"
"               /*flags*/0);\n"
"           if (error == EINPROGRESS) {\n"
"               /*\n"
"                * Do whatever is needed to ensure synchronization\n"
"                * with callback. Callback is guaranteed not to be started\n"
"                * until we do splx() or tsleep().\n"
"                */\n"
"              }\n"
"           splx(s);\n"
"          }        "

#. (itstool) path: sect1/para
#: book.translate.xml:17955
msgid "Two possible approaches for the processing of requests are:"
msgstr "处理请求的两种方法分别是："

#. (itstool) path: sect1/para
#: book.translate.xml:17958
msgid ""
"1. If requests are completed by marking them explicitly as done (such as the "
"CAM requests) then it would be simpler to put all the further processing "
"into the callback driver which would mark the request when it is done. Then "
"not much extra synchronization is needed. For the flow control reasons it "
"may be a good idea to freeze the request queue until this request gets "
"completed."
msgstr ""
"1. 如果通过显式地标记请求已经结束来完成请求（例如CAM请求），则将所有进一步的"
"处理放入回调驱动程序中会比较简单，回调结束后会标记请求。之后不需要太多额外的"
"同步。由于流控制的原因，冻结请求队列直到请求完成才释放可能是个好主意。"

#. (itstool) path: sect1/para
#: book.translate.xml:17967
msgid ""
"2. If requests are completed when the function returns (such as classic read "
"or write requests on character devices) then a synchronization flag should "
"be set in the buffer descriptor and <function>tsleep()</function> called. "
"Later when the callback gets called it will do its processing and check this "
"synchronization flag. If it is set then the callback should issue a wakeup. "
"In this approach the callback function could either do all the needed "
"processing (just like the previous case) or simply save the segments array "
"in the buffer descriptor. Then after callback completes the calling function "
"could use this saved segments array and do all the processing."
msgstr ""
"2. 如果请求是在函数返回时完成（例如字符设备上传统的读写请求），则需要在缓冲区"
"描述符上设置同步标志，并调用<function>tsleep()</function>。后面当回调函数被调"
"用时，它将执行处理并检查同步标志。如果设置了同步标志，它应该发出一个唤醒操"
"作。在这种方法中，回调函数或者进行所由必需的处理（就像前面的情况），或者简单"
"在缓冲区描述符中存储段数组。回调完成后，回调函数就能使用这个存储的段数组并进"
"行所有的处理。"

#. (itstool) path: sect1/title
#. (itstool) path: sect2/title
#: book.translate.xml:17987 book.translate.xml:19414
msgid "DMA"
msgstr "DMA"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:17990
msgid "<primary>Direct Memory Access (DMA)</primary>"
msgstr "<primary>Direct Memory Access (DMA)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:17992
msgid ""
"The Direct Memory Access (DMA) is implemented in the ISA bus through the DMA "
"controller (actually, two of them but that is an irrelevant detail). To make "
"the early ISA devices simple and cheap the logic of the bus control and "
"address generation was concentrated in the DMA controller. Fortunately, "
"FreeBSD provides a set of functions that mostly hide the annoying details of "
"the DMA controller from the device drivers."
msgstr ""
"ISA总线中Direct Memory Access (DMA)是通过DMA控制器（实际上是它们中的两个，但"
"这只是无关细节）实现的。为了使以前的ISA设备简单便宜，总线控制和地址产生的逻辑"
"都集中在DMA控制器中。幸运的是，FreeBSD提供了一套函数，这些函数大多把DMA控制器"
"的繁琐细节对设备驱动程序隐藏了起来。"

#. (itstool) path: sect1/para
#: book.translate.xml:18003
msgid ""
"The simplest case is for the fairly intelligent devices. Like the bus master "
"devices on PCI they can generate the bus cycles and memory addresses all by "
"themselves. The only thing they really need from the DMA controller is bus "
"arbitration. So for this purpose they pretend to be cascaded slave DMA "
"controllers. And the only thing needed from the system DMA controller is to "
"enable the cascaded mode on a DMA channel by calling the following function "
"when attaching the driver:"
msgstr ""
"最简单情况是那些比较智能的设备。就象PCI上的总线主设备一样，它们自己能产生总线"
"周期和内存地址。它们真正从DMA控制器需要的唯一事情是总线仲裁。所以为了此目的，"
"它们假装是级联从DMA控制器。当连接驱动程序时，系统DMA控制器需要做的唯一事情就"
"是通过调用如下函数在一个DMA通道上激活级联模式："

#. (itstool) path: sect1/para
#: book.translate.xml:18015
msgid "<function>void isa_dmacascade(int channel_number)</function>"
msgstr "<function>void isa_dmacascade(int channel_number)</function>"

#. (itstool) path: sect1/para
#: book.translate.xml:18019
msgid ""
"All the further activity is done by programming the device. When detaching "
"the driver no DMA-related functions need to be called."
msgstr ""
"所有进一步的活动通过对设备编程完成。当卸载驱动程序时，不需要调用DMA相关的函"
"数。"

#. (itstool) path: sect1/para
#: book.translate.xml:18025
msgid ""
"For the simpler devices things get more complicated. The functions used are:"
msgstr "对于较简单的设备，事情反而变得复杂。使用的函数包括："

#. (itstool) path: listitem/para
#: book.translate.xml:18033
msgid "<function>int isa_dma_acquire(int chanel_number)</function>"
msgstr "<function>int isa_dma_acquire(int chanel_number)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:18036
msgid ""
"Reserve a DMA channel. Returns 0 on success or EBUSY if the channel was "
"already reserved by this or a different driver. Most of the ISA devices are "
"not able to share DMA channels anyway, so normally this function is called "
"when attaching a device. This reservation was made redundant by the modern "
"interface of bus resources but still must be used in addition to the latter. "
"If not used then later, other DMA routines will panic."
msgstr ""
"保留一个DMA通道。成功则返回0，如果通道已经被保留或被其它驱动程序保留则返回"
"EBUSY。大多数的ISA设备都不能共享DMA通道，因此这个函数通常在连接设备时调用。总"
"线资源的现代接口使得这种保留成为多余，但目前仍必须使用。如果不使用，则后面其"
"它DMA例程将会panic。"

#. (itstool) path: listitem/para
#: book.translate.xml:18050
msgid "<function>int isa_dma_release(int chanel_number)</function>"
msgstr "<function>int isa_dma_release(int chanel_number)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:18053
msgid ""
"Release a previously reserved DMA channel. No transfers must be in progress "
"when the channel is released (in addition the device must not try to "
"initiate transfer after the channel is released)."
msgstr ""
"释放先前保留的DMA通道。释放通道时必须不能有正在进行中的传输（另外，释放通道后"
"设备必须不能再试图发起传输）。"

#. (itstool) path: listitem/para
#: book.translate.xml:18062
msgid "<function>void isa_dmainit(int chan, u_int bouncebufsize)</function>"
msgstr "<function>void isa_dmainit(int chan, u_int bouncebufsize)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:18066
msgid ""
"Allocate a bounce buffer for use with the specified channel. The requested "
"size of the buffer can not exceed 64KB. This bounce buffer will be "
"automatically used later if a transfer buffer happens to be not physically "
"contiguous or outside of the memory accessible by the ISA bus or crossing "
"the 64KB boundary. If the transfers will be always done from buffers which "
"conform to these conditions (such as those allocated by "
"<function>bus_dmamem_alloc()</function> with proper limitations) then "
"<function>isa_dmainit()</function> does not have to be called. But it is "
"quite convenient to transfer arbitrary data using the DMA controller. The "
"bounce buffer will automatically care of the scatter-gather issues."
msgstr ""
"分配由特定通道使用的反弹缓冲区。请求的缓冲区大小不能超过64KB。以后，如果传输"
"缓冲区碰巧不是物理连续的，或超出ISA总线可访问的内存范围，或跨越64KB的边界，则"
"会自动使用反弹缓冲区。如果传输总是使用符合上述条件的缓冲区（例如，由"
"<function>bus_dmamem_alloc()</function>分配的那些），则不需要调用          "
"<function>isa_dmainit()</function>。但使用此函数会让通过DMA控制器传输任意数据"
"变得非常方便。"

#. (itstool) path: listitem/para
#: book.translate.xml:18086
msgid "<emphasis>chan</emphasis> - channel number"
msgstr "<emphasis>chan</emphasis> - 通道号"

#. (itstool) path: listitem/para
#: book.translate.xml:18091
msgid "<emphasis>bouncebufsize</emphasis> - size of the bounce buffer in bytes"
msgstr "<emphasis>bouncebufsize</emphasis> - 以字节计数的反弹缓冲区的大小"

#. (itstool) path: listitem/para
#: book.translate.xml:18102
msgid ""
"<function>void isa_dmastart(int flags, caddr_t addr, u_int nbytes, int "
"chan)</function>"
msgstr ""
"<function>void isa_dmastart(int flags, caddr_t addr, u_int nbytes, int "
"chan)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:18106
msgid ""
"Prepare to start a DMA transfer. This function must be called to set up the "
"DMA controller before actually starting transfer on the device. It checks "
"that the buffer is contiguous and falls into the ISA memory range, if not "
"then the bounce buffer is automatically used. If bounce buffer is required "
"but not set up by <function>isa_dmainit()</function> or too small for the "
"requested transfer size then the system will panic. In case of a write "
"request with bounce buffer the data will be automatically copied to the "
"bounce buffer."
msgstr ""
"准备启动DMA传输。实际启动设备上的传输之前必需调用此函数来设置DMA控制器。它检"
"查缓冲区是否连续的且在ISA内存范围之内，如果不是则自动使用反弹缓冲区。如果需要"
"反弹缓冲区，但反弹缓冲区没有用 <function>isa_dmainit()</function>设置，或对于"
"请求的传输大小来说太小，则系统将panic。写请求且使用反弹缓冲区的情况下，数据将"
"被自动拷贝到反弹缓冲区。"

#. (itstool) path: listitem/para
#: book.translate.xml:18121
msgid ""
"flags - a bitmask determining the type of operation to be done. The "
"direction bits B_READ and B_WRITE are mutually exclusive."
msgstr "flags - 位掩码，决定将要完成的操作的类型。方向位B_READ和B_WRITE互斥。"

#. (itstool) path: listitem/para
#: book.translate.xml:18128
msgid "B_READ - read from the ISA bus into memory"
msgstr "B_READ - 从ISA总线读到内存"

#. (itstool) path: listitem/para
#: book.translate.xml:18133
msgid "B_WRITE - write from the memory to the ISA bus"
msgstr "B_WRITE - 从内存写到ISA总线上"

#. (itstool) path: listitem/para
#: book.translate.xml:18138
msgid ""
"B_RAW - if set then the DMA controller will remember the buffer and after "
"the end of transfer will automatically re-initialize itself to repeat "
"transfer of the same buffer again (of course, the driver may change the data "
"in the buffer before initiating another transfer in the device). If not set "
"then the parameters will work only for one transfer, and "
"<function>isa_dmastart()</function> will have to be called again before "
"initiating the next transfer. Using B_RAW makes sense only if the bounce "
"buffer is not used."
msgstr ""
"B_RAW - 如果设置则DMA控制器将会记住缓冲区，并在传输结束后自动重新初始化它自"
"己，再次重复传输同一缓冲区（当然，驱动程序可能发起设备的另一个传输之前改变缓"
"冲区中的数据）。如果没有设置，参数只对一次传输有效，在发起下一次传输之前必须"
"再次调用<function>isa_dmastart()</function>。只有在不使用反弹缓冲区时使用"
"B_RAW才有意义。"

#. (itstool) path: listitem/para
#: book.translate.xml:18156
msgid "addr - virtual address of the buffer"
msgstr "addr - 缓冲区的虚地址"

#. (itstool) path: listitem/para
#: book.translate.xml:18161
msgid ""
"nbytes - length of the buffer. Must be less or equal to 64KB. Length of 0 is "
"not allowed: the DMA controller will understand it as 64KB while the kernel "
"code will understand it as 0 and that would cause unpredictable effects. For "
"channels number 4 and higher the length must be even because these channels "
"transfer 2 bytes at a time. In case of an odd length the last byte will not "
"be transferred."
msgstr ""
"nbytes - 缓冲区长度。必须小于等于64KB。不允许长度为0：因为DMA控制器将会理解为"
"64KB，而内核代码把它理解为0，那样就会导致不可预测的效果。对于通道号等于和高于"
"4的情况，长度必需为偶数，因为这些通道每次传输2字节。奇数长度情况下，最后一个"
"字节不被传输。"

#. (itstool) path: listitem/para
#: book.translate.xml:18173
msgid "chan - channel number"
msgstr "chan - 通道号"

#. (itstool) path: listitem/para
#: book.translate.xml:18179
msgid ""
"<function>void isa_dmadone(int flags, caddr_t addr, int nbytes, int chan)</"
"function>"
msgstr ""
"<function>void isa_dmadone(int flags, caddr_t addr, int nbytes, int chan)</"
"function>"

#. (itstool) path: listitem/para
#: book.translate.xml:18183
msgid ""
"Synchronize the memory after device reports that transfer is done. If that "
"was a read operation with a bounce buffer then the data will be copied from "
"the bounce buffer to the original buffer. Arguments are the same as for "
"<function>isa_dmastart()</function>. Flag B_RAW is permitted but it does not "
"affect <function>isa_dmadone()</function> in any way."
msgstr ""
"设备报告传输完成后，同步内存。如果是使用反弹缓冲区的读操作，则将数据从反弹缓"
"冲区拷贝到原始缓冲区。参量与<function>isa_dmastart()</function>的相同。允许使"
"用B_RAW标志，但它一点也不会影响<function>isa_dmadone()</function>。"

#. (itstool) path: listitem/para
#: book.translate.xml:18195
msgid "<function>int isa_dmastatus(int channel_number)</function>"
msgstr "<function>int isa_dmastatus(int channel_number)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:18198
msgid ""
"Returns the number of bytes left in the current transfer to be transferred. "
"In case the flag B_READ was set in <function>isa_dmastart()</function> the "
"number returned will never be equal to zero. At the end of transfer it will "
"be automatically reset back to the length of buffer. The normal use is to "
"check the number of bytes left after the device signals that the transfer is "
"completed. If the number of bytes is not 0 then something probably went "
"wrong with that transfer."
msgstr ""
"返回当前传输中剩余的字节数。在<function>isa_dmastart()</function>中设置了"
"B_READ的情况下，返回的数字一定不会等于零。传输结束时它会被自动复位到缓冲区的"
"长度。正式的用法是在设备发信号指示传输已完成时检查剩余的字节数。如果字节数不"
"为0，则此次传输可能有问题。"

#. (itstool) path: listitem/para
#: book.translate.xml:18212
msgid "<function>int isa_dmastop(int channel_number)</function>"
msgstr "<function>int isa_dmastop(int channel_number)</function>"

#. (itstool) path: listitem/para
#: book.translate.xml:18215
msgid ""
"Aborts the current transfer and returns the number of bytes left "
"untransferred."
msgstr "放弃当前的传输并返回剩余未传输的字节数。"

#. (itstool) path: sect1/title
#: book.translate.xml:18224
msgid "xxx_isa_probe"
msgstr "xxx_isa_probe"

#. (itstool) path: sect1/para
#: book.translate.xml:18227
msgid ""
"This function probes if a device is present. If the driver supports auto-"
"detection of some part of device configuration (such as interrupt vector or "
"memory address) this auto-detection must be done in this routine."
msgstr ""
"这个函数探测设备是否存在。如果驱动程序支持自动侦测设备配置的某些部分（如中断"
"向量或内存地址），则自动侦测必须在此例程中完成。"

#. (itstool) path: sect1/para
#: book.translate.xml:18234
msgid ""
"As for any other bus, if the device cannot be detected or is detected but "
"failed the self-test or some other problem happened then it returns a "
"positive value of error. The value <errorname>ENXIO</errorname> must be "
"returned if the device is not present. Other error values may mean other "
"conditions. Zero or negative values mean success. Most of the drivers return "
"zero as success."
msgstr ""
"对于任意其他总线，如果不能侦测到设备，或者侦测到但自检失败，或者发生某些其他"
"问题，则应当返回一个正值的错误。如果设备不存在则必须返回值<errorname>ENXIO</"
"errorname>。其他错误值可能表示其他条件。零或负值意味着成功。大多数驱动程序返"
"回零表示成功。"

#. (itstool) path: sect1/para
#: book.translate.xml:18244
msgid ""
"The negative return values are used when a PnP device supports multiple "
"interfaces. For example, an older compatibility interface and a newer "
"advanced interface which are supported by different drivers. Then both "
"drivers would detect the device. The driver which returns a higher value in "
"the probe routine takes precedence (in other words, the driver returning 0 "
"has highest precedence, one returning -1 is next, one returning -2 is after "
"it and so on). In result the devices which support only the old interface "
"will be handled by the old driver (which should return -1 from the probe "
"routine) while the devices supporting the new interface as well will be "
"handled by the new driver (which should return 0 from the probe routine)."
msgstr ""
"当PnP设备支持多个接口时使用负返回值。例如，不同驱动程序支持老的兼容接口和较新"
"的高级接口。则两个驱动程序都将侦测设备。在探测例程中返回较高值的驱动程序获得"
"优先（换句话说，返回0的驱动程序具有最高的优先级，返回-1的其次，返回-2的更后，"
"等等）。这样，仅支持老接口的设备将被老驱动程序处理（其应当从探测例程中返"
"回-1），而同时也支持新接口的设备将由新驱动程序处理（其应当从探测例程中返回"
"0）。"

#. (itstool) path: sect1/para
#: book.translate.xml:18260
msgid ""
"The device descriptor struct xxx_softc is allocated by the system before "
"calling the probe routine. If the probe routine returns an error the "
"descriptor will be automatically deallocated by the system. So if a probing "
"error occurs the driver must make sure that all the resources it used during "
"probe are deallocated and that nothing keeps the descriptor from being "
"safely deallocated. If the probe completes successfully the descriptor will "
"be preserved by the system and later passed to the routine "
"<function>xxx_isa_attach()</function>. If a driver returns a negative value "
"it can not be sure that it will have the highest priority and its attach "
"routine will be called. So in this case it also must release all the "
"resources before returning and if necessary allocate them again in the "
"attach routine. When <function>xxx_isa_probe()</function> returns 0 "
"releasing the resources before returning is also a good idea and a well-"
"behaved driver should do so. But in cases where there is some problem with "
"releasing the resources the driver is allowed to keep resources between "
"returning 0 from the probe routine and execution of the attach routine."
msgstr ""
"设备描述符结构xxx_softc由系统在调用探测例程之前分配。如果探测例程返回错误，描"
"述符会被系统自动取消分配。因此如果出现探测错误，驱动程序必须保证取消分配探测"
"期间它使用的所有资源，且确保没有什么能够阻止描述符被安全地取消分配。如果探测"
"成功完成，描述符将由系统保存并在以后传递给例程<function>xxx_isa_attach()</"
"function>。如果驱动程序返回负值，就不能保证它将获得最高优先权且其连接例程会被"
"调用。因此这种情况下它也必须在返回前释放所有的资源，并在需要的时候在连接例程"
"中重新分配它们。当<function>xxx_isa_probe()</function>返回0时，在返回前释放资"
"源也是一个好主意，而且中规中矩的驱动程序应当这样做。但在释放资源会存在某些问"
"题的情况下，允许驱动程序在从探测例程返回0和连接例程的执行之间保持资源。"

#. (itstool) path: sect1/para
#: book.translate.xml:18284
msgid ""
"A typical probe routine starts with getting the device descriptor and unit:"
msgstr "典型的探测例程以取得设备描述符和单元号开始："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18289
#, no-wrap
msgid ""
"         struct xxx_softc *sc = device_get_softc(dev);\n"
"          int unit = device_get_unit(dev);\n"
"          int pnperror;\n"
"          int error = 0;\n"
"\n"
"          sc-&gt;dev = dev; /* link it back */\n"
"          sc-&gt;unit = unit;        "
msgstr ""
"         struct xxx_softc *sc = device_get_softc(dev);\n"
"          int unit = device_get_unit(dev);\n"
"          int pnperror;\n"
"          int error = 0;\n"
"\n"
"          sc-&gt;dev = dev; /* link it back */\n"
"          sc-&gt;unit = unit;        "

#. (itstool) path: sect1/para
#: book.translate.xml:18297
msgid ""
"Then check for the PnP devices. The check is carried out by a table "
"containing the list of PnP IDs supported by this driver and human-readable "
"descriptions of the device models corresponding to these IDs."
msgstr ""
"然后检查PnP设备。检查是通过一个包含PnP ID列表的表进行的。此表包含这个驱动程序"
"支持的PnP ID和以人工可读形式给出的对应这些ID的设备型号的描述。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18304
#, no-wrap
msgid ""
"\n"
"        pnperror=ISA_PNP_PROBE(device_get_parent(dev), dev,\n"
"        xxx_pnp_ids); if(pnperror == ENXIO) return ENXIO;\n"
"        "
msgstr ""
"\n"
"        pnperror=ISA_PNP_PROBE(device_get_parent(dev), dev,\n"
"        xxx_pnp_ids); if(pnperror == ENXIO) return ENXIO;\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18309
msgid ""
"The logic of ISA_PNP_PROBE is the following: If this card (device unit) was "
"not detected as PnP then ENOENT will be returned. If it was detected as PnP "
"but its detected ID does not match any of the IDs in the table then ENXIO is "
"returned. Finally, if it has PnP support and it matches on of the IDs in the "
"table, 0 is returned and the appropriate description from the table is set "
"by <function>device_set_desc()</function>."
msgstr ""
"ISA_PNP_PROBE的逻辑如下：如果卡（设备单元）没有被作为PnP侦测到，则返回"
"ENOENT。如果被作为PnP侦测到，但侦测到的ID不匹配表中的任一ID，则返回ENXIO。最"
"后，如果设备能支持PnP且匹配表中的一个ID，则返回0，并且由"
"<function>device_set_desc()</function>从表中取得适当的描述进行设置。"

#. (itstool) path: sect1/para
#: book.translate.xml:18320
msgid ""
"If a driver supports only PnP devices then the condition would look like:"
msgstr "如果设备驱动程序仅支持PnP设备，则情况看起来如下："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18325
#, no-wrap
msgid ""
"          if(pnperror != 0)\n"
"              return pnperror;        "
msgstr ""
"          if(pnperror != 0)\n"
"              return pnperror;        "

#. (itstool) path: sect1/para
#: book.translate.xml:18328
msgid ""
"No special treatment is required for the drivers which do not support PnP "
"because they pass an empty PnP ID table and will always get ENXIO if called "
"on a PnP card."
msgstr ""
"对于不支持PnP的驱动程序不需要特殊处理，因为驱动程序会传递空的PnP ID表，且如果"
"在PnP卡上调用会得到ENXIO。"

#. (itstool) path: sect1/para
#: book.translate.xml:18334
msgid ""
"The probe routine normally needs at least some minimal set of resources, "
"such as I/O port number to find the card and probe it. Depending on the "
"hardware the driver may be able to discover the other necessary resources "
"automatically. The PnP devices have all the resources pre-set by the PnP "
"subsystem, so the driver does not need to discover them by itself."
msgstr ""
"探测例程通常至少需要某些最少量的资源，如I/O端口号，来发现并探测卡。对于不同的"
"硬件，驱动程序可能会自动发现其他必需的资源。PnP设备的所有资源由PnP子系统预先"
"设置，因此驱动程序不需要自己发现它们。"

#. (itstool) path: sect1/para
#: book.translate.xml:18344
msgid ""
"Typically the minimal information required to get access to the device is "
"the I/O port number. Then some devices allow to get the rest of information "
"from the device configuration registers (though not all devices do that). So "
"first we try to get the port start value:"
msgstr ""
"通常访问设备所需要的最少信息就是端口号。然后某些设备允许从设备配置寄存器中取"
"得其余信息（尽管不是所有的设备都这样）。因此首先我们尝试取得端口起始值："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18352
#, no-wrap
msgid ""
" sc-&gt;port0 = bus_get_resource_start(dev,\n"
"        SYS_RES_IOPORT, 0 /*rid*/); if(sc-&gt;port0 == 0) return ENXIO;\n"
"        "
msgstr ""
" sc-&gt;port0 = bus_get_resource_start(dev,\n"
"        SYS_RES_IOPORT, 0 /*rid*/); if(sc-&gt;port0 == 0) return ENXIO;\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18356
msgid ""
"The base port address is saved in the structure softc for future use. If it "
"will be used very often then calling the resource function each time would "
"be prohibitively slow. If we do not get a port we just return an error. Some "
"device drivers can instead be clever and try to probe all the possible "
"ports, like this:"
msgstr ""
"基端口地址被保存在softc结构中，以便将来使用。如果需要经常使用端口，则每次都调"
"用资源函数将会慢的无法忍受。如果我们没有得到端口，则返回错误即可。相反，一些"
"设备驱动程序相当聪明，尝试探测所有可能的端口，如下："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18365
#, no-wrap
msgid ""
"\n"
"          /* table of all possible base I/O port addresses for this device */\n"
"          static struct xxx_allports {\n"
"              u_short port; /* port address */\n"
"              short used; /* flag: if this port is already used by some unit */\n"
"          } xxx_allports = {\n"
"              { 0x300, 0 },\n"
"              { 0x320, 0 },\n"
"              { 0x340, 0 },\n"
"              { 0, 0 } /* end of table */\n"
"          };\n"
"\n"
"          ...\n"
"          int port, i;\n"
"          ...\n"
"\n"
"          port =  bus_get_resource_start(dev, SYS_RES_IOPORT, 0 /*rid*/);\n"
"          if(port !=0 ) {\n"
"              for(i=0; xxx_allports[i].port!=0; i++) {\n"
"                  if(xxx_allports[i].used || xxx_allports[i].port != port)\n"
"                      continue;\n"
"\n"
"                  /* found it */\n"
"                  xxx_allports[i].used = 1;\n"
"                  /* do probe on a known port */\n"
"                  return xxx_really_probe(dev, port);\n"
"              }\n"
"              return ENXIO; /* port is unknown or already used */\n"
"          }\n"
"\n"
"          /* we get here only if we need to guess the port */\n"
"          for(i=0; xxx_allports[i].port!=0; i++) {\n"
"              if(xxx_allports[i].used)\n"
"                  continue;\n"
"\n"
"              /* mark as used - even if we find nothing at this port\n"
"               * at least we won't probe it in future\n"
"               */\n"
"               xxx_allports[i].used = 1;\n"
"\n"
"              error = xxx_really_probe(dev, xxx_allports[i].port);\n"
"              if(error == 0) /* found a device at that port */\n"
"                  return 0;\n"
"          }\n"
"          /* probed all possible addresses, none worked */\n"
"          return ENXIO;"
msgstr ""
"\n"
"          /* table of all possible base I/O port addresses for this device */\n"
"          static struct xxx_allports {\n"
"              u_short port; /* port address */\n"
"              short used; /* flag: if this port is already used by some unit */\n"
"          } xxx_allports = {\n"
"              { 0x300, 0 },\n"
"              { 0x320, 0 },\n"
"              { 0x340, 0 },\n"
"              { 0, 0 } /* end of table */\n"
"          };\n"
"\n"
"          ...\n"
"          int port, i;\n"
"          ...\n"
"\n"
"          port =  bus_get_resource_start(dev, SYS_RES_IOPORT, 0 /*rid*/);\n"
"          if(port !=0 ) {\n"
"              for(i=0; xxx_allports[i].port!=0; i++) {\n"
"                  if(xxx_allports[i].used || xxx_allports[i].port != port)\n"
"                      continue;\n"
"\n"
"                  /* found it */\n"
"                  xxx_allports[i].used = 1;\n"
"                  /* do probe on a known port */\n"
"                  return xxx_really_probe(dev, port);\n"
"              }\n"
"              return ENXIO; /* port is unknown or already used */\n"
"          }\n"
"\n"
"          /* we get here only if we need to guess the port */\n"
"          for(i=0; xxx_allports[i].port!=0; i++) {\n"
"              if(xxx_allports[i].used)\n"
"                  continue;\n"
"\n"
"              /* mark as used - even if we find nothing at this port\n"
"               * at least we won't probe it in future\n"
"               */\n"
"               xxx_allports[i].used = 1;\n"
"\n"
"              error = xxx_really_probe(dev, xxx_allports[i].port);\n"
"              if(error == 0) /* found a device at that port */\n"
"                  return 0;\n"
"          }\n"
"          /* probed all possible addresses, none worked */\n"
"          return ENXIO;"

#. (itstool) path: sect1/para
#: book.translate.xml:18412
msgid ""
"Of course, normally the driver's <function>identify()</function> routine "
"should be used for such things. But there may be one valid reason why it may "
"be better to be done in <function>probe()</function>: if this probe would "
"drive some other sensitive device crazy. The probe routines are ordered with "
"consideration of the <literal>sensitive</literal> flag: the sensitive "
"devices get probed first and the rest of the devices later. But the "
"<function>identify()</function> routines are called before any probes, so "
"they show no respect to the sensitive devices and may upset them."
msgstr ""
"当然，做这些事情通常应该使用驱动程序的<function>identify()</function>例程。但"
"可能有一个正当的理由来说明为什么在函数<function>probe()</function>中完成更"
"好：如果这种探测会让一些其他敏感设备发疯。探测例程按旗标<literal>sensitive</"
"literal>排序：敏感设备首先被探测，然后是其他设备。但<function>identify()</"
"function>例程在所有探测之前被调用，因此它们不会考虑敏感设备并可能扰乱这些设"
"备。"

#. (itstool) path: sect1/para
#: book.translate.xml:18426
msgid ""
"Now, after we got the starting port we need to set the port count (except "
"for PnP devices) because the kernel does not have this information in the "
"configuration file."
msgstr ""
"现在，我们得到起始端口以后就需要设置端口数（PnP设备除外），因为内核在配置文件"
"中没有这个信息。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18432
#, no-wrap
msgid ""
"\n"
"         if(pnperror /* only for non-PnP devices */\n"
"         &amp;&amp; bus_set_resource(dev, SYS_RES_IOPORT, 0, sc-&gt;port0,\n"
"         XXX_PORT_COUNT)&lt;0)\n"
"             return ENXIO;"
msgstr ""
"\n"
"         if(pnperror /* only for non-PnP devices */\n"
"         &amp;&amp; bus_set_resource(dev, SYS_RES_IOPORT, 0, sc-&gt;port0,\n"
"         XXX_PORT_COUNT)&lt;0)\n"
"             return ENXIO;"

#. (itstool) path: sect1/para
#: book.translate.xml:18438
msgid ""
"Finally allocate and activate a piece of port address space (special values "
"of start and end mean <quote>use those we set by "
"<function>bus_set_resource()</function></quote>):"
msgstr ""
"最后分配并激活一片端口地址空间（特殊值start和end意思是说<quote>使用我们通过"
"<function>bus_set_resource()</function>设置的那些值</quote>）："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18444
#, no-wrap
msgid ""
"\n"
"          sc-&gt;port0_rid = 0;\n"
"          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,\n"
"          &amp;sc-&gt;port0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;port0_r == NULL)\n"
"              return ENXIO;"
msgstr ""
"\n"
"          sc-&gt;port0_rid = 0;\n"
"          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,\n"
"          &amp;sc-&gt;port0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;port0_r == NULL)\n"
"              return ENXIO;"

#. (itstool) path: sect1/para
#: book.translate.xml:18453
msgid ""
"Now having access to the port-mapped registers we can poke the device in "
"some way and check if it reacts like it is expected to. If it does not then "
"there is probably some other device or no device at all at this address."
msgstr ""
"现在可以访问端口映射的寄存器后，我们就可以以某种方式向设备写入数据并检查设备"
"是否如我们期望的那样作出反应。如果没有，则说明可能其他的设备在这个地址上，或"
"者这个地址上根本没有设备。"

#. (itstool) path: sect1/para
#: book.translate.xml:18460
msgid ""
"Normally drivers do not set up the interrupt handlers until the attach "
"routine. Instead they do probes in the polling mode using the "
"<function>DELAY()</function> function for timeout. The probe routine must "
"never hang forever, all the waits for the device must be done with timeouts. "
"If the device does not respond within the time it is probably broken or "
"misconfigured and the driver must return error. When determining the timeout "
"interval give the device some extra time to be on the safe side: although "
"<function>DELAY()</function> is supposed to delay for the same amount of "
"time on any machine it has some margin of error, depending on the exact CPU."
msgstr ""
"通常驱动程序直到连接例程才会设置中断处理函数。这之前我们替代以轮询模式进行探"
"测，超时则以<function>DELAY()</function>实现。探测例程必须确保不能永久挂起，"
"设备上的所有等待必须在超时内完成。如果设备不在这段时间内响应，则可能设备出故"
"障或配置错误，驱动程序必须返回错误，当确定超时间隔时，给设备一些额外时间以确"
"保可靠：尽管假定<function>DELAY()</function>在任何机器上都延时相同数量的时"
"间，但随具体CPU的不同，此函数还是有一定的误差幅度。"

#. (itstool) path: sect1/para
#: book.translate.xml:18475
msgid ""
"If the probe routine really wants to check that the interrupts really work "
"it may configure and probe the interrupts too. But that is not recommended."
msgstr ""
"如果探测例程真的想检查中断是否真的工作，它可以也配置和探测中断。但不建议这"
"样。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18481
#, no-wrap
msgid ""
"\n"
"          /* implemented in some very device-specific way */\n"
"          if(error = xxx_probe_ports(sc))\n"
"              goto bad; /* will deallocate the resources before returning */\n"
"        "
msgstr ""
"\n"
"          /* implemented in some very device-specific way */\n"
"          if(error = xxx_probe_ports(sc))\n"
"              goto bad; /* will deallocate the resources before returning */\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18487
msgid ""
"The function <function>xxx_probe_ports()</function> may also set the device "
"description depending on the exact model of device it discovers. But if "
"there is only one supported device model this can be as well done in a "
"hardcoded way. Of course, for the PnP devices the PnP support sets the "
"description from the table automatically."
msgstr ""
"依赖于所发现设备的确切型号，函数<function>xxx_probe_ports()</function>也可能"
"设置设备描述。但如果只支持一种设备型号，则也可以硬编码的形式完成。当然，对于"
"PnP设备，PnP支持从表中自动设置描述。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18497
#, no-wrap
msgid ""
"          if(pnperror)\n"
"              device_set_desc(dev, \"Our device model 1234\");\n"
"        "
msgstr ""
"          if(pnperror)\n"
"              device_set_desc(dev, \"Our device model 1234\");\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18501
msgid ""
"Then the probe routine should either discover the ranges of all the "
"resources by reading the device configuration registers or make sure that "
"they were set explicitly by the user. We will consider it with an example of "
"on-board memory. The probe routine should be as non-intrusive as possible, "
"so allocation and check of functionality of the rest of resources (besides "
"the ports) would be better left to the attach routine."
msgstr ""
"探测例程应当或者通过读取设备配置寄存器来发现所有资源的范围，或者确保由用户显"
"式设置。我们将假定一个带板上内存的例子。探测例程应当尽可能是非插入式的，这样"
"分配和检查其余资源功能性的工作就可以更好地留给连接例程来做。"

#. (itstool) path: sect1/para
#: book.translate.xml:18512
msgid ""
"The memory address may be specified in the kernel configuration file or on "
"some devices it may be pre-configured in non-volatile configuration "
"registers. If both sources are available and different, which one should be "
"used? Probably if the user bothered to set the address explicitly in the "
"kernel configuration file they know what they are doing and this one should "
"take precedence. An example of implementation could be:"
msgstr ""
"内存地址可以在内核配置文件中指定，或者对应某些设备可以在非易失性配置寄存器中"
"预先配置。如果两种做法均可用却不同，那么应当用哪个呢？可能用户厌烦在内核配置"
"文件中明确设置地址，但他们知道自己在干什么，则应当优先使用这个。一个实现的例"
"子可能是这样的："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18522
#, no-wrap
msgid ""
"\n"
"          /* try to find out the config address first */\n"
"          sc-&gt;mem0_p = bus_get_resource_start(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"          if(sc-&gt;mem0_p == 0) { /* nope, not specified by user */\n"
"              sc-&gt;mem0_p = xxx_read_mem0_from_device_config(sc);\n"
"\n"
"\n"
"          if(sc-&gt;mem0_p == 0)\n"
"                  /* can't get it from device config registers either */\n"
"                  goto bad;\n"
"          } else {\n"
"              if(xxx_set_mem0_address_on_device(sc) &lt; 0)\n"
"                  goto bad; /* device does not support that address */\n"
"          }\n"
"\n"
"          /* just like the port, set the memory size,\n"
"           * for some devices the memory size would not be constant\n"
"           * but should be read from the device configuration registers instead\n"
"           * to accommodate different models of devices. Another option would\n"
"           * be to let the user set the memory size as \"msize\" configuration\n"
"           * resource which will be automatically handled by the ISA bus.\n"
"           */\n"
"           if(pnperror) { /* only for non-PnP devices */\n"
"              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"              if(sc-&gt;mem0_size == 0) /* not specified by user */\n"
"                  sc-&gt;mem0_size = xxx_read_mem0_size_from_device_config(sc);\n"
"\n"
"              if(sc-&gt;mem0_size == 0) {\n"
"                  /* suppose this is a very old model of device without\n"
"                   * auto-configuration features and the user gave no preference,\n"
"                   * so assume the minimalistic case\n"
"                   * (of course, the real value will vary with the driver)\n"
"                   */\n"
"                  sc-&gt;mem0_size = 8*1024;\n"
"              }\n"
"\n"
"              if(xxx_set_mem0_size_on_device(sc) &lt; 0)\n"
"                  goto bad; /* device does not support that size */\n"
"\n"
"              if(bus_set_resource(dev, SYS_RES_MEMORY, /*rid*/0,\n"
"                      sc-&gt;mem0_p, sc-&gt;mem0_size)&lt;0)\n"
"                  goto bad;\n"
"          } else {\n"
"              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"          }        "
msgstr ""
"\n"
"          /* try to find out the config address first */\n"
"          sc-&gt;mem0_p = bus_get_resource_start(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"          if(sc-&gt;mem0_p == 0) { /* nope, not specified by user */\n"
"              sc-&gt;mem0_p = xxx_read_mem0_from_device_config(sc);\n"
"\n"
"\n"
"          if(sc-&gt;mem0_p == 0)\n"
"                  /* can't get it from device config registers either */\n"
"                  goto bad;\n"
"          } else {\n"
"              if(xxx_set_mem0_address_on_device(sc) &lt; 0)\n"
"                  goto bad; /* device does not support that address */\n"
"          }\n"
"\n"
"          /* just like the port, set the memory size,\n"
"           * for some devices the memory size would not be constant\n"
"           * but should be read from the device configuration registers instead\n"
"           * to accommodate different models of devices. Another option would\n"
"           * be to let the user set the memory size as \"msize\" configuration\n"
"           * resource which will be automatically handled by the ISA bus.\n"
"           */\n"
"           if(pnperror) { /* only for non-PnP devices */\n"
"              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"              if(sc-&gt;mem0_size == 0) /* not specified by user */\n"
"                  sc-&gt;mem0_size = xxx_read_mem0_size_from_device_config(sc);\n"
"\n"
"              if(sc-&gt;mem0_size == 0) {\n"
"                  /* suppose this is a very old model of device without\n"
"                   * auto-configuration features and the user gave no preference,\n"
"                   * so assume the minimalistic case\n"
"                   * (of course, the real value will vary with the driver)\n"
"                   */\n"
"                  sc-&gt;mem0_size = 8*1024;\n"
"              }\n"
"\n"
"              if(xxx_set_mem0_size_on_device(sc) &lt; 0)\n"
"                  goto bad; /* device does not support that size */\n"
"\n"
"              if(bus_set_resource(dev, SYS_RES_MEMORY, /*rid*/0,\n"
"                      sc-&gt;mem0_p, sc-&gt;mem0_size)&lt;0)\n"
"                  goto bad;\n"
"          } else {\n"
"              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"          }        "

#. (itstool) path: sect1/para
#: book.translate.xml:18568
msgid "Resources for IRQ and DRQ are easy to check by analogy."
msgstr "类似, 很容易检查IRQ和DRQ所用的资源。"

#. (itstool) path: sect1/para
#: book.translate.xml:18572
msgid "If all went well then release all the resources and return success."
msgstr "如果一切进行正常，然后就可以释放所有资源并返回成功。"

#. (itstool) path: sect1/programlisting
#. (itstool) path: para/programlisting
#: book.translate.xml:18576 book.translate.xml:18918
#, no-wrap
msgid ""
"          xxx_free_resources(sc);\n"
"          return 0;"
msgstr ""
"          xxx_free_resources(sc);\n"
"          return 0;"

#. (itstool) path: sect1/para
#: book.translate.xml:18579
msgid ""
"Finally, handle the troublesome situations. All the resources should be "
"deallocated before returning. We make use of the fact that before the "
"structure softc is passed to us it gets zeroed out, so we can find out if "
"some resource was allocated: then its descriptor is non-zero."
msgstr ""
"最后，处理棘手情况。所有资源应当在返回前被释放。我们利用这样一个事实：softc结"
"构在传递给我们以前被零化，因此我们能够找出是否分配了某些资源：如果分配则这些"
"资源的描述符非零。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18587
#, no-wrap
msgid ""
"          bad:\n"
"\n"
"          xxx_free_resources(sc);\n"
"          if(error)\n"
"                return error;\n"
"          else /* exact error is unknown */\n"
"              return ENXIO;"
msgstr ""
"          bad:\n"
"\n"
"          xxx_free_resources(sc);\n"
"          if(error)\n"
"                return error;\n"
"          else /* exact error is unknown */\n"
"              return ENXIO;"

#. (itstool) path: sect1/para
#: book.translate.xml:18595
msgid ""
"That would be all for the probe routine. Freeing of resources is done from "
"multiple places, so it is moved to a function which may look like:"
msgstr ""
"这是完整的探测例程。资源的释放从多个地方完成，因此将它挪到一个函数中，看起来"
"可能像下面的样子："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18601
#, no-wrap
msgid ""
"static void\n"
"           xxx_free_resources(sc)\n"
"              struct xxx_softc *sc;\n"
"          {\n"
"              /* check every resource and free if not zero */\n"
"\n"
"              /* interrupt handler */\n"
"              if(sc-&gt;intr_r) {\n"
"                  bus_teardown_intr(sc-&gt;dev, sc-&gt;intr_r, sc-&gt;intr_cookie);\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_IRQ, sc-&gt;intr_rid,\n"
"                      sc-&gt;intr_r);\n"
"                  sc-&gt;intr_r = 0;\n"
"              }\n"
"\n"
"              /* all kinds of memory maps we could have allocated */\n"
"              if(sc-&gt;data_p) {\n"
"                  bus_dmamap_unload(sc-&gt;data_tag, sc-&gt;data_map);\n"
"                  sc-&gt;data_p = 0;\n"
"              }\n"
"               if(sc-&gt;data) { /* sc-&gt;data_map may be legitimately equal to 0 */\n"
"                  /* the map will also be freed */\n"
"                  bus_dmamem_free(sc-&gt;data_tag, sc-&gt;data, sc-&gt;data_map);\n"
"                  sc-&gt;data = 0;\n"
"              }\n"
"              if(sc-&gt;data_tag) {\n"
"                  bus_dma_tag_destroy(sc-&gt;data_tag);\n"
"                  sc-&gt;data_tag = 0;\n"
"              }\n"
"\n"
"              ... free other maps and tags if we have them ...\n"
"\n"
"              if(sc-&gt;parent_tag) {\n"
"                  bus_dma_tag_destroy(sc-&gt;parent_tag);\n"
"                  sc-&gt;parent_tag = 0;\n"
"              }\n"
"\n"
"              /* release all the bus resources */\n"
"              if(sc-&gt;mem0_r) {\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_MEMORY, sc-&gt;mem0_rid,\n"
"                      sc-&gt;mem0_r);\n"
"                  sc-&gt;mem0_r = 0;\n"
"              }\n"
"              ...\n"
"              if(sc-&gt;port0_r) {\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_IOPORT, sc-&gt;port0_rid,\n"
"                      sc-&gt;port0_r);\n"
"                  sc-&gt;port0_r = 0;\n"
"              }\n"
"          }"
msgstr ""
"static void\n"
"           xxx_free_resources(sc)\n"
"              struct xxx_softc *sc;\n"
"          {\n"
"              /* check every resource and free if not zero */\n"
"\n"
"              /* interrupt handler */\n"
"              if(sc-&gt;intr_r) {\n"
"                  bus_teardown_intr(sc-&gt;dev, sc-&gt;intr_r, sc-&gt;intr_cookie);\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_IRQ, sc-&gt;intr_rid,\n"
"                      sc-&gt;intr_r);\n"
"                  sc-&gt;intr_r = 0;\n"
"              }\n"
"\n"
"              /* all kinds of memory maps we could have allocated */\n"
"              if(sc-&gt;data_p) {\n"
"                  bus_dmamap_unload(sc-&gt;data_tag, sc-&gt;data_map);\n"
"                  sc-&gt;data_p = 0;\n"
"              }\n"
"               if(sc-&gt;data) { /* sc-&gt;data_map may be legitimately equal to 0 */\n"
"                  /* the map will also be freed */\n"
"                  bus_dmamem_free(sc-&gt;data_tag, sc-&gt;data, sc-&gt;data_map);\n"
"                  sc-&gt;data = 0;\n"
"              }\n"
"              if(sc-&gt;data_tag) {\n"
"                  bus_dma_tag_destroy(sc-&gt;data_tag);\n"
"                  sc-&gt;data_tag = 0;\n"
"              }\n"
"\n"
"              ... free other maps and tags if we have them ...\n"
"\n"
"              if(sc-&gt;parent_tag) {\n"
"                  bus_dma_tag_destroy(sc-&gt;parent_tag);\n"
"                  sc-&gt;parent_tag = 0;\n"
"              }\n"
"\n"
"              /* release all the bus resources */\n"
"              if(sc-&gt;mem0_r) {\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_MEMORY, sc-&gt;mem0_rid,\n"
"                      sc-&gt;mem0_r);\n"
"                  sc-&gt;mem0_r = 0;\n"
"              }\n"
"              ...\n"
"              if(sc-&gt;port0_r) {\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_IOPORT, sc-&gt;port0_rid,\n"
"                      sc-&gt;port0_r);\n"
"                  sc-&gt;port0_r = 0;\n"
"              }\n"
"          }"

#. (itstool) path: sect1/title
#: book.translate.xml:18654
msgid "xxx_isa_attach"
msgstr "xxx_isa_attach"

#. (itstool) path: sect1/para
#: book.translate.xml:18657
msgid ""
"The attach routine actually connects the driver to the system if the probe "
"routine returned success and the system had chosen to attach that driver. If "
"the probe routine returned 0 then the attach routine may expect to receive "
"the device structure softc intact, as it was set by the probe routine. Also "
"if the probe routine returns 0 it may expect that the attach routine for "
"this device shall be called at some point in the future. If the probe "
"routine returns a negative value then the driver may make none of these "
"assumptions."
msgstr ""
"如果探测例程返回成功并且系统选择连接那个驱动程序，则连接例程负责将驱动程序实"
"际连接到系统。如果探测例程返回0 ，则连接例程期望接收完整的设备结构softc，此结"
"构由探测例程设置。同时，如果探测例程返回0，它可能期望这个设备的连接例程应当在"
"将来的某点被调用。如果探测例程返回负值，则驱动程序可能不会作此假设。"

#. (itstool) path: sect1/para
#: book.translate.xml:18669
msgid ""
"The attach routine returns 0 if it completed successfully or error code "
"otherwise."
msgstr "如果成功完成，连接例程返回0，否则返回错误码。"

#. (itstool) path: sect1/para
#: book.translate.xml:18673
msgid ""
"The attach routine starts just like the probe routine, with getting some "
"frequently used data into more accessible variables."
msgstr ""
"连接例程的启动跟探测例程相似，将一些常用数据取到一些更容易访问的变量中。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18678
#, no-wrap
msgid ""
"          struct xxx_softc *sc = device_get_softc(dev);\n"
"          int unit = device_get_unit(dev);\n"
"          int error = 0;"
msgstr ""
"          struct xxx_softc *sc = device_get_softc(dev);\n"
"          int unit = device_get_unit(dev);\n"
"          int error = 0;"

#. (itstool) path: sect1/para
#: book.translate.xml:18682
msgid ""
"Then allocate and activate all the necessary resources. Because normally the "
"port range will be released before returning from probe, it has to be "
"allocated again. We expect that the probe routine had properly set all the "
"resource ranges, as well as saved them in the structure softc. If the probe "
"routine had left some resource allocated then it does not need to be "
"allocated again (which would be considered an error)."
msgstr ""
"然后分配并激活所需资源。由于端口范围通常在从探测返回前就被释放，因此需要重新"
"分配。我们希望探测例程已经适当地设置了所有的资源范围，并将它们保存在结构softc"
"中。如果探测例程留下了一些被分配的资源，就不需要再次分配（重新分配被视为错"
"误）。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18692
#, no-wrap
msgid ""
"          sc-&gt;port0_rid = 0;\n"
"          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,  &amp;sc-&gt;port0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;port0_r == NULL)\n"
"               return ENXIO;\n"
"\n"
"          /* on-board memory */\n"
"          sc-&gt;mem0_rid = 0;\n"
"          sc-&gt;mem0_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-&gt;mem0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;mem0_r == NULL)\n"
"                goto bad;\n"
"\n"
"          /* get its virtual address */\n"
"          sc-&gt;mem0_v = rman_get_virtual(sc-&gt;mem0_r);"
msgstr ""
"          sc-&gt;port0_rid = 0;\n"
"          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,  &amp;sc-&gt;port0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;port0_r == NULL)\n"
"               return ENXIO;\n"
"\n"
"          /* on-board memory */\n"
"          sc-&gt;mem0_rid = 0;\n"
"          sc-&gt;mem0_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-&gt;mem0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;mem0_r == NULL)\n"
"                goto bad;\n"
"\n"
"          /* get its virtual address */\n"
"          sc-&gt;mem0_v = rman_get_virtual(sc-&gt;mem0_r);"

#. (itstool) path: sect1/para
#: book.translate.xml:18710
msgid ""
"The DMA request channel (DRQ) is allocated likewise. To initialize it use "
"functions of the <function>isa_dma*()</function> family. For example:"
msgstr ""
"DMA请求通道(DRQ)以相似方式被分配。使用<function>isa_dma*()</function>函数族进"
"行初始化。例如："

#. (itstool) path: sect1/para
#: book.translate.xml:18715
msgid "<function>isa_dmacascade(sc-&gt;drq0);</function>"
msgstr "<function>isa_dmacascade(sc-&gt;drq0);</function>"

#. (itstool) path: sect1/para
#: book.translate.xml:18717
msgid ""
"The interrupt request line (IRQ) is a bit special. Besides allocation the "
"driver's interrupt handler should be associated with it. Historically in the "
"old ISA drivers the argument passed by the system to the interrupt handler "
"was the device unit number. But in modern drivers the convention suggests "
"passing the pointer to structure softc. The important reason is that when "
"the structures softc are allocated dynamically then getting the unit number "
"from softc is easy while getting softc from the unit number is difficult. "
"Also this convention makes the drivers for different buses look more uniform "
"and allows them to share the code: each bus gets its own probe, attach, "
"detach and other bus-specific routines while the bulk of the driver code may "
"be shared among them."
msgstr ""
"中断请求线(IRQ)有点特殊。除了分配以外，驱动程序的中断处理函数也应当与它关联。"
"在古老的ISA驱动程序中，由系统传递给中断处理函数的参量是设备单元号。但在现代驱"
"动程序中，按照约定，建议传递指向结构softc的指针。一个很重要的原因在于当结构"
"softc被动态分配后，从softc取得单元号很容易，而从单元号取得softc很困难。同时，"
"这个约定也使得用于不同总线的应用程序看起来统一，并允许它们共享代码：每个总线"
"有其自己的探测，连接，分离和其他总线相关的例程，而它们之间可以共享大块的驱动"
"程序代码。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18733
#, no-wrap
msgid ""
"\n"
"          sc-&gt;intr_rid = 0;\n"
"          sc-&gt;intr_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-&gt;intr_rid,\n"
"                /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;intr_r == NULL)\n"
"              goto bad;\n"
"\n"
"          /*\n"
"           * XXX_INTR_TYPE is supposed to be defined depending on the type of\n"
"           * the driver, for example as INTR_TYPE_CAM for a CAM driver\n"
"           */\n"
"          error = bus_setup_intr(dev, sc-&gt;intr_r, XXX_INTR_TYPE,\n"
"              (driver_intr_t *) xxx_intr, (void *) sc, &amp;sc-&gt;intr_cookie);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"        "
msgstr ""
"\n"
"          sc-&gt;intr_rid = 0;\n"
"          sc-&gt;intr_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-&gt;intr_rid,\n"
"                /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;intr_r == NULL)\n"
"              goto bad;\n"
"\n"
"          /*\n"
"           * XXX_INTR_TYPE is supposed to be defined depending on the type of\n"
"           * the driver, for example as INTR_TYPE_CAM for a CAM driver\n"
"           */\n"
"          error = bus_setup_intr(dev, sc-&gt;intr_r, XXX_INTR_TYPE,\n"
"              (driver_intr_t *) xxx_intr, (void *) sc, &amp;sc-&gt;intr_cookie);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18753
msgid ""
"If the device needs to make DMA to the main memory then this memory should "
"be allocated like described before:"
msgstr "如果驱动程序需要与内存进行DMA，则这块内存应当按前述方式分配："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18757
#, no-wrap
msgid ""
"          error=bus_dma_tag_create(NULL, /*alignment*/ 4,\n"
"              /*boundary*/ 0, /*lowaddr*/ BUS_SPACE_MAXADDR_24BIT,\n"
"              /*highaddr*/ BUS_SPACE_MAXADDR, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"              /*maxsize*/ BUS_SPACE_MAXSIZE_24BIT,\n"
"              /*nsegments*/ BUS_SPACE_UNRESTRICTED,\n"
"              /*maxsegsz*/ BUS_SPACE_MAXSIZE_24BIT, /*flags*/ 0,\n"
"              &amp;sc-&gt;parent_tag);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          /* many things get inherited from the parent tag\n"
"           * sc-&gt;data is supposed to point to the structure with the shared data,\n"
"           * for example for a ring buffer it could be:\n"
"           * struct {\n"
"           *   u_short rd_pos;\n"
"           *   u_short wr_pos;\n"
"           *   char    bf[XXX_RING_BUFFER_SIZE]\n"
"           * } *data;\n"
"           */\n"
"          error=bus_dma_tag_create(sc-&gt;parent_tag, 1,\n"
"              0, BUS_SPACE_MAXADDR, 0, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"              /*maxsize*/ sizeof(* sc-&gt;data), /*nsegments*/ 1,\n"
"              /*maxsegsz*/ sizeof(* sc-&gt;data), /*flags*/ 0,\n"
"              &amp;sc-&gt;data_tag);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          error = bus_dmamem_alloc(sc-&gt;data_tag, &amp;sc-&gt;data, /* flags*/ 0,\n"
"              &amp;sc-&gt;data_map);\n"
"          if(error)\n"
"               goto bad;\n"
"\n"
"          /* xxx_alloc_callback() just saves the physical address at\n"
"           * the pointer passed as its argument, in this case &amp;sc-&gt;data_p.\n"
"           * See details in the section on bus memory mapping.\n"
"           * It can be implemented like:\n"
"           *\n"
"           * static void\n"
"           * xxx_alloc_callback(void *arg, bus_dma_segment_t *seg,\n"
"           *     int nseg, int error)\n"
"           * {\n"
"           *    *(bus_addr_t *)arg = seg[0].ds_addr;\n"
"           * }\n"
"           */\n"
"          bus_dmamap_load(sc-&gt;data_tag, sc-&gt;data_map, (void *)sc-&gt;data,\n"
"              sizeof (* sc-&gt;data), xxx_alloc_callback, (void *) &amp;sc-&gt;data_p,\n"
"              /*flags*/0);"
msgstr ""
"          error=bus_dma_tag_create(NULL, /*alignment*/ 4,\n"
"              /*boundary*/ 0, /*lowaddr*/ BUS_SPACE_MAXADDR_24BIT,\n"
"              /*highaddr*/ BUS_SPACE_MAXADDR, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"              /*maxsize*/ BUS_SPACE_MAXSIZE_24BIT,\n"
"              /*nsegments*/ BUS_SPACE_UNRESTRICTED,\n"
"              /*maxsegsz*/ BUS_SPACE_MAXSIZE_24BIT, /*flags*/ 0,\n"
"              &amp;sc-&gt;parent_tag);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          /* many things get inherited from the parent tag\n"
"           * sc-&gt;data is supposed to point to the structure with the shared data,\n"
"           * for example for a ring buffer it could be:\n"
"           * struct {\n"
"           *   u_short rd_pos;\n"
"           *   u_short wr_pos;\n"
"           *   char    bf[XXX_RING_BUFFER_SIZE]\n"
"           * } *data;\n"
"           */\n"
"          error=bus_dma_tag_create(sc-&gt;parent_tag, 1,\n"
"              0, BUS_SPACE_MAXADDR, 0, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"              /*maxsize*/ sizeof(* sc-&gt;data), /*nsegments*/ 1,\n"
"              /*maxsegsz*/ sizeof(* sc-&gt;data), /*flags*/ 0,\n"
"              &amp;sc-&gt;data_tag);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          error = bus_dmamem_alloc(sc-&gt;data_tag, &amp;sc-&gt;data, /* flags*/ 0,\n"
"              &amp;sc-&gt;data_map);\n"
"          if(error)\n"
"               goto bad;\n"
"\n"
"          /* xxx_alloc_callback() just saves the physical address at\n"
"           * the pointer passed as its argument, in this case &amp;sc-&gt;data_p.\n"
"           * See details in the section on bus memory mapping.\n"
"           * It can be implemented like:\n"
"           *\n"
"           * static void\n"
"           * xxx_alloc_callback(void *arg, bus_dma_segment_t *seg,\n"
"           *     int nseg, int error)\n"
"           * {\n"
"           *    *(bus_addr_t *)arg = seg[0].ds_addr;\n"
"           * }\n"
"           */\n"
"          bus_dmamap_load(sc-&gt;data_tag, sc-&gt;data_map, (void *)sc-&gt;data,\n"
"              sizeof (* sc-&gt;data), xxx_alloc_callback, (void *) &amp;sc-&gt;data_p,\n"
"              /*flags*/0);"

#. (itstool) path: sect1/para
#: book.translate.xml:18806
msgid ""
"After all the necessary resources are allocated the device should be "
"initialized. The initialization may include testing that all the expected "
"features are functional."
msgstr ""
"分配了所有的资源后，设备应当被初始化。初始化可能包括测试所有特性，确保它们起"
"作用。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18810
#, no-wrap
msgid ""
"          if(xxx_initialize(sc) &lt; 0)\n"
"               goto bad;        "
msgstr ""
"          if(xxx_initialize(sc) &lt; 0)\n"
"               goto bad;        "

#. (itstool) path: sect1/para
#: book.translate.xml:18814
msgid ""
"The bus subsystem will automatically print on the console the device "
"description set by probe. But if the driver wants to print some extra "
"information about the device it may do so, for example:"
msgstr ""
"总线子系统将自动在控制台上打印由探测例程设置的设备描述。但如果驱动程序想打印"
"一些关于设备的额外信息，也是可能的，例如："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18819
#, no-wrap
msgid ""
"\n"
"        device_printf(dev, \"has on-card FIFO buffer of %d bytes\\n\", sc-&gt;fifosize);\n"
"        "
msgstr ""
"\n"
"        device_printf(dev, \"has on-card FIFO buffer of %d bytes\\n\", sc-&gt;fifosize);\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18823
msgid ""
"If the initialization routine experiences any problems then printing "
"messages about them before returning error is also recommended."
msgstr "如果初始化例程遇到任何问题，建议返回错误之前打印有关信息。"

#. (itstool) path: sect1/para
#: book.translate.xml:18827
msgid ""
"The final step of the attach routine is attaching the device to its "
"functional subsystem in the kernel. The exact way to do it depends on the "
"type of the driver: a character device, a block device, a network device, a "
"CAM SCSI bus device and so on."
msgstr ""
"连接例程的最后一步是将设备连接到内核中的功能子系统。完成这个步骤的精确方式依"
"赖于驱动程序的类型：字符设备、块设备、网络设备、CAM SCSI总线设备等等。"

#. (itstool) path: sect1/para
#: book.translate.xml:18833
msgid "If all went well then return success."
msgstr "如果所有均工作正常则返回成功。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18835
#, no-wrap
msgid ""
"          error = xxx_attach_subsystem(sc);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          return 0;        "
msgstr ""
"          error = xxx_attach_subsystem(sc);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          return 0;        "

#. (itstool) path: sect1/para
#: book.translate.xml:18841
msgid ""
"Finally, handle the troublesome situations. All the resources should be "
"deallocated before returning an error. We make use of the fact that before "
"the structure softc is passed to us it gets zeroed out, so we can find out "
"if some resource was allocated: then its descriptor is non-zero."
msgstr ""
"最后，处理棘手情况。返回错误前，所有资源应当被取消分配。我们利用这样一个事"
"实：结构softc传递给我们之前被零化，因此我们能找出是否分配了某些资源：如果分配"
"则它们的描述符非零。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18848
#, no-wrap
msgid ""
"          bad:\n"
"\n"
"          xxx_free_resources(sc);\n"
"          if(error)\n"
"              return error;\n"
"          else /* exact error is unknown */\n"
"              return ENXIO;"
msgstr ""
"          bad:\n"
"\n"
"          xxx_free_resources(sc);\n"
"          if(error)\n"
"              return error;\n"
"          else /* exact error is unknown */\n"
"              return ENXIO;"

#. (itstool) path: sect1/para
#: book.translate.xml:18856
msgid "That would be all for the attach routine."
msgstr "这就是连接例程的全部。"

#. (itstool) path: sect1/title
#: book.translate.xml:18862
msgid "xxx_isa_detach"
msgstr "xxx_isa_detach"

#. (itstool) path: sect1/para
#: book.translate.xml:18864
msgid ""
"If this function is present in the driver and the driver is compiled as a "
"loadable module then the driver gets the ability to be unloaded. This is an "
"important feature if the hardware supports hot plug. But the ISA bus does "
"not support hot plug, so this feature is not particularly important for the "
"ISA devices. The ability to unload a driver may be useful when debugging it, "
"but in many cases installation of the new version of the driver would be "
"required only after the old version somehow wedges the system and a reboot "
"will be needed anyway, so the efforts spent on writing the detach routine "
"may not be worth it. Another argument that unloading would allow upgrading "
"the drivers on a production machine seems to be mostly theoretical. "
"Installing a new version of a driver is a dangerous operation which should "
"never be performed on a production machine (and which is not permitted when "
"the system is running in secure mode). Still, the detach routine may be "
"provided for the sake of completeness."
msgstr ""
"如果驱动程序中存在这个函数，且驱动程序被编译为可加载模块，则驱动程序具有被卸"
"载的能力。如果硬件支持热插拔，这是一个很重要的特性。但ISA总线不支持热插拔，因"
"此这个特性对于ISA设备不是特别重要。卸载驱动程序的能力可能在调试时有用，但很多"
"情况下只有在老版本的驱动程序莫名其妙地卡住系统的情况下才需要安装新版本的驱动"
"程序，并且无论如何都需要重启，这样使得花费精力写分离例程有些不值得。另一个宣"
"称卸载允许在用于生产的机器上升级驱动程序的论点看起来似乎更多的只是理论而已。"
"升级驱动程序是一项危险的操作，决不不应当在用于生产的机器上实行（并且当系统运"
"行于安全模式时这也是不被允许的）。然而，出于完整性考虑，还是会提供分离例程。"

#. (itstool) path: sect1/para
#: book.translate.xml:18885
msgid ""
"The detach routine returns 0 if the driver was successfully detached or the "
"error code otherwise."
msgstr "如果驱动程序成功分离，分离例程返回0，否则返回错误码。"

#. (itstool) path: para/programlisting
#: book.translate.xml:18899
#, no-wrap
msgid ""
"          struct xxx_softc *sc = device_get_softc(dev);\n"
"          int error;\n"
"\n"
"          error = xxx_detach_subsystem(sc);\n"
"          if(error)\n"
"              return error;"
msgstr ""
"          struct xxx_softc *sc = device_get_softc(dev);\n"
"          int error;\n"
"\n"
"          error = xxx_detach_subsystem(sc);\n"
"          if(error)\n"
"              return error;"

#. (itstool) path: sect1/para
#: book.translate.xml:18890
msgid ""
"The logic of detach is a mirror of the attach. The first thing to do is to "
"detach the driver from its kernel subsystem. If the device is currently open "
"then the driver has two choices: refuse to be detached or forcibly close and "
"proceed with detach. The choice used depends on the ability of the "
"particular kernel subsystem to do a forced close and on the preferences of "
"the driver's author. Generally the forced close seems to be the preferred "
"alternative. <_:programlisting-1/>"
msgstr ""
"分离逻辑是连接的镜像。要做的第一件事情就是将驱动程序从内核子系统分离。如果设"
"备当前正打开着，驱动程序有两个选择：拒绝分离或者强制关闭并继续进行分离。选用"
"哪种方式取决于特定内核子系统执行强制关闭的能力和驱动程序作者的偏好。通常强制"
"关闭似乎是更好的选择。<_:programlisting-1/>"

#. (itstool) path: sect1/para
#: book.translate.xml:18906
msgid ""
"Next the driver may want to reset the hardware to some consistent state. "
"That includes stopping any ongoing transfers, disabling the DMA channels and "
"interrupts to avoid memory corruption by the device. For most of the drivers "
"this is exactly what the shutdown routine does, so if it is included in the "
"driver we can just call it."
msgstr ""
"下一步，驱动程序可能希望复位硬件到某种一致的状态。包括停止任何将要进行的传"
"输，禁用DMA通道和中断以避免设备破坏内存。对于大多数驱动程序而言，这正是关闭例"
"程所做的，因此如果驱动程序中包括关闭例程，我们只要调用它就可以了。"

#. (itstool) path: sect1/para
#: book.translate.xml:18914
msgid "<function>xxx_isa_shutdown(dev);</function>"
msgstr "<function>xxx_isa_shutdown(dev);</function>"

#. (itstool) path: sect1/para
#: book.translate.xml:18916
msgid ""
"And finally release all the resources and return success. <_:"
"programlisting-1/>"
msgstr "最后释放所有资源并返回成功。<_:programlisting-1/>"

#. (itstool) path: sect1/title
#: book.translate.xml:18925
msgid "xxx_isa_shutdown"
msgstr "xxx_isa_shutdown"

#. (itstool) path: sect1/para
#: book.translate.xml:18927
msgid ""
"This routine is called when the system is about to be shut down. It is "
"expected to bring the hardware to some consistent state. For most of the ISA "
"devices no special action is required, so the function is not really "
"necessary because the device will be re-initialized on reboot anyway. But "
"some devices have to be shut down with a special procedure, to make sure "
"that they will be properly detected after soft reboot (this is especially "
"true for many devices with proprietary identification protocols). In any "
"case disabling DMA and interrupts in the device registers and stopping any "
"ongoing transfers is a good idea. The exact action depends on the hardware, "
"so we do not consider it here in any detail."
msgstr ""
"当系统要关闭的时候调用此例程。通过它使硬件进入某种一致的状态。对于大多数ISA设"
"备而言不需要特殊动作，因此这个函数并非真正必需，因为不管怎样重启动时设备会被"
"重新初始化。但有些设备必须按特定步骤关闭，以确保在软重启后能被正确地检测到"
"（对于很多使用私有识别协议的设备特别有用）。很多情况下，在设备寄存器中禁用DMA"
"和中断，并停止将要进行的传输是个好主意。确切动作取决于硬件，因此我们无法在此"
"详细讨论。"

#. (itstool) path: sect1/title
#: book.translate.xml:18945
msgid "xxx_intr"
msgstr "xxx_intr"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:18947
msgid "<primary>interrupt handler</primary>"
msgstr "<primary>interrupt handler</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:18949
msgid ""
"The interrupt handler is called when an interrupt is received which may be "
"from this particular device. The ISA bus does not support interrupt sharing "
"(except in some special cases) so in practice if the interrupt handler is "
"called then the interrupt almost for sure came from its device. Still, the "
"interrupt handler must poll the device registers and make sure that the "
"interrupt was generated by its device. If not it should just return."
msgstr ""
"当收到来自特定设备的中断时就会调用中断处理函数。ISA总线不支持中断共享（某些特"
"殊情况例外），因此实际上如果中断处理函数被调用，几乎可以确信中断是来自其设"
"备。然而，中断处理函数必须轮询设备寄存器并确保中断是由它的设备产生的。如果不"
"是，中断处理函数应当返回。"

#. (itstool) path: sect1/para
#: book.translate.xml:18960
msgid ""
"The old convention for the ISA drivers was getting the device unit number as "
"an argument. This is obsolete, and the new drivers receive whatever argument "
"was specified for them in the attach routine when calling "
"<function>bus_setup_intr()</function>. By the new convention it should be "
"the pointer to the structure softc. So the interrupt handler commonly starts "
"as:"
msgstr ""
"ISA驱动程序的旧约定是取设备单元号作为参量。现在已经废弃，当调用"
"<function>bus_setup_intr()</function>时新驱动程序接收任何在连接例程中为他们指"
"定的参量。根据新约定，它应当是指向结构softc的指针。因此中断处理函数通常像下面"
"那样开始："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18970
#, no-wrap
msgid ""
"\n"
"          static void\n"
"          xxx_intr(struct xxx_softc *sc)\n"
"          {\n"
"\n"
"        "
msgstr ""
"\n"
"          static void\n"
"          xxx_intr(struct xxx_softc *sc)\n"
"          {\n"
"\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18977
msgid ""
"It runs at the interrupt priority level specified by the interrupt type "
"parameter of <function>bus_setup_intr()</function>. That means that all the "
"other interrupts of the same type as well as all the software interrupts are "
"disabled."
msgstr ""
"它运行在由<function>bus_setup_intr()</function>的中断类型参数指定的中断优先级"
"上。这意味着禁用所有其他同类型的中断和所有软件中断。"

#. (itstool) path: sect1/para
#: book.translate.xml:18985
msgid "To avoid races it is commonly written as a loop:"
msgstr "为了避免竞争，中断处理例程通写成循环形式："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18989
#, no-wrap
msgid ""
"\n"
"          while(xxx_interrupt_pending(sc)) {\n"
"              xxx_process_interrupt(sc);\n"
"              xxx_acknowledge_interrupt(sc);\n"
"          }        "
msgstr ""
"\n"
"          while(xxx_interrupt_pending(sc)) {\n"
"              xxx_process_interrupt(sc);\n"
"              xxx_acknowledge_interrupt(sc);\n"
"          }        "

#. (itstool) path: sect1/para
#: book.translate.xml:18995
msgid ""
"The interrupt handler has to acknowledge interrupt to the device only but "
"not to the interrupt controller, the system takes care of the latter."
msgstr ""
"中断处理函数必须只向设备应答中断，但不能向中断控制器应答，后者由系统负责处"
"理。"

#. (itstool) path: chapter/title
#: book.translate.xml:19011
msgid "PCI Devices"
msgstr "PCI 设备"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:19013
msgid "<primary>PCI bus</primary>"
msgstr "<primary>PCI 总线</primary>"

#. (itstool) path: chapter/para
#: book.translate.xml:19015
msgid ""
"This chapter will talk about the FreeBSD mechanisms for writing a device "
"driver for a device on a PCI bus."
msgstr "本章将讨论FreeBSD为了给PCI总线上的设备编写驱动程序而提供的机制。"

#. (itstool) path: sect1/title
#: book.translate.xml:19019
msgid "Probe and Attach"
msgstr "探测与连接"

#. (itstool) path: sect1/para
#: book.translate.xml:19021
msgid ""
"Information here about how the PCI bus code iterates through the unattached "
"devices and see if a newly loaded kld will attach to any of them."
msgstr ""
"这儿的信息是关于PCI总线代码如何迭代通过未连接的设备，并查看新加载的kld是否会"
"连接其中一个。"

#. (itstool) path: sect2/title
#: book.translate.xml:19026
msgid "Sample Driver Source (<filename>mypci.c</filename>)"
msgstr "示例驱动程序源代码(<filename>mypci.c</filename>)"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19029
#, no-wrap
msgid ""
"/*\n"
" * Simple KLD to play with the PCI functions.\n"
" *\n"
" * Murray Stokely\n"
" */\n"
"\n"
"#include &lt;sys/param.h&gt;\t\t/* defines used in kernel.h */\n"
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/systm.h&gt;\n"
"#include &lt;sys/errno.h&gt;\n"
"#include &lt;sys/kernel.h&gt;\t\t/* types used in module initialization */\n"
"#include &lt;sys/conf.h&gt;\t\t/* cdevsw struct */\n"
"#include &lt;sys/uio.h&gt;\t\t/* uio struct */\n"
"#include &lt;sys/malloc.h&gt;\n"
"#include &lt;sys/bus.h&gt;\t\t/* structs, prototypes for pci bus stuff and DEVMETHOD macros! */\n"
"\n"
"#include &lt;machine/bus.h&gt;\n"
"#include &lt;sys/rman.h&gt;\n"
"#include &lt;machine/resource.h&gt;\n"
"\n"
"#include &lt;dev/pci/pcivar.h&gt;\t/* For pci_get macros! */\n"
"#include &lt;dev/pci/pcireg.h&gt;\n"
"\n"
"/* The softc holds our per-instance data. */\n"
"struct mypci_softc {\n"
"\tdevice_t\tmy_dev;\n"
"\tstruct cdev\t*my_cdev;\n"
"};\n"
"\n"
"/* Function prototypes */\n"
"static d_open_t\t\tmypci_open;\n"
"static d_close_t\tmypci_close;\n"
"static d_read_t\t\tmypci_read;\n"
"static d_write_t\tmypci_write;\n"
"\n"
"/* Character device entry points */\n"
"\n"
"static struct cdevsw mypci_cdevsw = {\n"
"\t.d_version =\tD_VERSION,\n"
"\t.d_open =\tmypci_open,\n"
"\t.d_close =\tmypci_close,\n"
"\t.d_read =\tmypci_read,\n"
"\t.d_write =\tmypci_write,\n"
"\t.d_name =\t\"mypci\",\n"
"};\n"
"\n"
"/*\n"
" * In the cdevsw routines, we find our softc by using the si_drv1 member\n"
" * of struct cdev.  We set this variable to point to our softc in our\n"
" * attach routine when we create the /dev entry.\n"
" */\n"
"\n"
"int\n"
"mypci_open(struct cdev *dev, int oflags, int devtype, struct thread *td)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\t/* Look up our softc. */\n"
"\tsc = dev-&gt;si_drv1;\n"
"\tdevice_printf(sc-&gt;my_dev, \"Opened successfully.\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"int\n"
"mypci_close(struct cdev *dev, int fflag, int devtype, struct thread *td)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\t/* Look up our softc. */\n"
"\tsc = dev-&gt;si_drv1;\n"
"\tdevice_printf(sc-&gt;my_dev, \"Closed.\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"int\n"
"mypci_read(struct cdev *dev, struct uio *uio, int ioflag)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\t/* Look up our softc. */\n"
"\tsc = dev-&gt;si_drv1;\n"
"\tdevice_printf(sc-&gt;my_dev, \"Asked to read %zd bytes.\\n\", uio-&gt;uio_resid);\n"
"\treturn (0);\n"
"}\n"
"\n"
"int\n"
"mypci_write(struct cdev *dev, struct uio *uio, int ioflag)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\t/* Look up our softc. */\n"
"\tsc = dev-&gt;si_drv1;\n"
"\tdevice_printf(sc-&gt;my_dev, \"Asked to write %zd bytes.\\n\", uio-&gt;uio_resid);\n"
"\treturn (0);\n"
"}\n"
"\n"
"/* PCI Support Functions */\n"
"\n"
"/*\n"
" * Compare the device ID of this device against the IDs that this driver\n"
" * supports.  If there is a match, set the description and return success.\n"
" */\n"
"static int\n"
"mypci_probe(device_t dev)\n"
"{\n"
"\n"
"\tdevice_printf(dev, \"MyPCI Probe\\nVendor ID : 0x%x\\nDevice ID : 0x%x\\n\",\n"
"\t    pci_get_vendor(dev), pci_get_device(dev));\n"
"\n"
"\tif (pci_get_vendor(dev) == 0x11c1) {\n"
"\t\tprintf(\"We've got the Winmodem, probe successful!\\n\");\n"
"\t\tdevice_set_desc(dev, \"WinModem\");\n"
"\t\treturn (BUS_PROBE_DEFAULT);\n"
"\t}\n"
"\treturn (ENXIO);\n"
"}\n"
"\n"
"/* Attach function is only called if the probe is successful. */\n"
"\n"
"static int\n"
"mypci_attach(device_t dev)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\tprintf(\"MyPCI Attach for : deviceID : 0x%x\\n\", pci_get_devid(dev));\n"
"\n"
"\t/* Look up our softc and initialize its fields. */\n"
"\tsc = device_get_softc(dev);\n"
"\tsc-&gt;my_dev = dev;\n"
"\n"
"\t/*\n"
"\t * Create a /dev entry for this device.  The kernel will assign us\n"
"\t * a major number automatically.  We use the unit number of this\n"
"\t * device as the minor number and name the character device\n"
"\t * \"mypci&lt;unit&gt;\".\n"
"\t */\n"
"\tsc-&gt;my_cdev = make_dev(<literal>&amp;</literal>mypci_cdevsw, device_get_unit(dev),\n"
"\t    UID_ROOT, GID_WHEEL, 0600, \"mypci%u\", device_get_unit(dev));\n"
"\tsc-&gt;my_cdev-&gt;si_drv1 = sc;\n"
"\tprintf(\"Mypci device loaded.\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/* Detach device. */\n"
"\n"
"static int\n"
"mypci_detach(device_t dev)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\t/* Teardown the state in our softc created in our attach routine. */\n"
"\tsc = device_get_softc(dev);\n"
"\tdestroy_dev(sc-&gt;my_cdev);\n"
"\tprintf(\"Mypci detach!\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/* Called during system shutdown after sync. */\n"
"\n"
"static int\n"
"mypci_shutdown(device_t dev)\n"
"{\n"
"\n"
"\tprintf(\"Mypci shutdown!\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/*\n"
" * Device suspend routine.\n"
" */\n"
"static int\n"
"mypci_suspend(device_t dev)\n"
"{\n"
"\n"
"\tprintf(\"Mypci suspend!\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/*\n"
" * Device resume routine.\n"
" */\n"
"static int\n"
"mypci_resume(device_t dev)\n"
"{\n"
"\n"
"\tprintf(\"Mypci resume!\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"static device_method_t mypci_methods[] = {\n"
"\t/* Device interface */\n"
"\tDEVMETHOD(device_probe,\t\tmypci_probe),\n"
"\tDEVMETHOD(device_attach,\tmypci_attach),\n"
"\tDEVMETHOD(device_detach,\tmypci_detach),\n"
"\tDEVMETHOD(device_shutdown,\tmypci_shutdown),\n"
"\tDEVMETHOD(device_suspend,\tmypci_suspend),\n"
"\tDEVMETHOD(device_resume,\tmypci_resume),\n"
"\n"
"\tDEVMETHOD_END\n"
"};\n"
"\n"
"static devclass_t mypci_devclass;\n"
"\n"
"DEFINE_CLASS_0(mypci, mypci_driver, mypci_methods, sizeof(struct mypci_softc));\n"
"DRIVER_MODULE(mypci, pci, mypci_driver, mypci_devclass, 0, 0);"
msgstr ""

#. (itstool) path: sect2/title
#: book.translate.xml:19237
msgid "<filename>Makefile</filename> for Sample Driver"
msgstr "示例驱动程序的<filename>Makefile</filename>"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19239
#, no-wrap
msgid ""
"# Makefile for mypci driver\n"
"\n"
"KMOD=\tmypci\n"
"SRCS=\tmypci.c\n"
"SRCS+=\tdevice_if.h bus_if.h pci_if.h\n"
"\n"
".include &lt;bsd.kmod.mk&gt;"
msgstr ""
"# Makefile for mypci driver\n"
"\n"
"KMOD=\tmypci\n"
"SRCS=\tmypci.c\n"
"SRCS+=\tdevice_if.h bus_if.h pci_if.h\n"
"\n"
".include &lt;bsd.kmod.mk&gt;"

#. (itstool) path: sect2/para
#: book.translate.xml:19247
msgid ""
"If you place the above source file and <filename>Makefile</filename> into a "
"directory, you may run <command>make</command> to compile the sample driver. "
"Additionally, you may run <command>make load</command> to load the driver "
"into the currently running kernel and <command>make unload</command> to "
"unload the driver after it is loaded."
msgstr ""
"如果你将上面的源文件和<filename>Makefile</filename>放入一个目录，你可以运行"
"<command>make</command>编译示例驱动程序。还有，你可以运行<command>make load</"
"command>将驱动程序装载到当前正在运行的内核中，而<command>makeunload</command>"
"可在装载后卸载驱动程序。"

#. (itstool) path: sect2/title
#: book.translate.xml:19257
msgid "Additional Resources"
msgstr "更多资源"

#. (itstool) path: listitem/simpara
#: book.translate.xml:19261
msgid ""
"<link xlink:href=\"http://www.pcisig.org/\">PCI Special Interest Group</link>"
msgstr ""
"<link xlink:href=\"http://www.pcisig.org/\">PCI Special Interest Group</link>"

#. (itstool) path: listitem/simpara
#: book.translate.xml:19265
msgid "PCI System Architecture, Fourth Edition by Tom Shanley, et al."
msgstr "PCI System Architecture, Fourth Edition by Tom Shanley, et al."

#. (itstool) path: sect1/title
#: book.translate.xml:19273
msgid "Bus Resources"
msgstr "总线资源"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19275
msgid "<primary>PCI bus</primary><secondary>resources</secondary>"
msgstr "<primary>PCI总线</primary><secondary>resources(资源)</secondary>"

#. (itstool) path: sect1/para
#: book.translate.xml:19277
msgid ""
"FreeBSD provides an object-oriented mechanism for requesting resources from "
"a parent bus. Almost all devices will be a child member of some sort of bus "
"(PCI, ISA, USB, SCSI, etc) and these devices need to acquire resources from "
"their parent bus (such as memory segments, interrupt lines, or DMA channels)."
msgstr ""
"FreeBSD为从父总线请求资源提供了一种面向对象的机制。几乎所有设备都是某种类型的"
"总线（PCI, ISA, USB, SCSI等等）的孩子成员，并且这些设备需要从他们的父总线获取"
"资源（例如内存段, 中断线, 或者DMA通道）。"

#. (itstool) path: sect2/title
#: book.translate.xml:19284
msgid "Base Address Registers"
msgstr "基地址寄存器"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:19286
msgid "<primary>PCI bus</primary><secondary>Base Address Registers</secondary>"
msgstr ""
"<primary>PCI bus</primary><secondary>Base Address Registers</secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:19289
msgid ""
"To do anything particularly useful with a PCI device you will need to obtain "
"the <emphasis>Base Address Registers</emphasis> (BARs) from the PCI "
"Configuration space. The PCI-specific details of obtaining the BAR are "
"abstracted in the <function>bus_alloc_resource()</function> function."
msgstr ""
"为了对PCI设备做些有用的事情，你需要从PCI配置空间获取<emphasis>Base Address "
"Registers</emphasis> (BARs)。获取BAR时的PCI特定的细节被抽象在函数"
"<function>bus_alloc_resource()</function>中。"

#. (itstool) path: sect2/para
#: book.translate.xml:19296
msgid ""
"For example, a typical driver might have something similar to this in the "
"<function>attach()</function> function:"
msgstr ""
"例如，一个典型的驱动程序可能在<function>attach()</function>函数中有些类似下面"
"的东西："

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19299
#, no-wrap
msgid ""
"    sc-&gt;bar0id = PCIR_BAR(0);\n"
"    sc-&gt;bar0res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;sc-&gt;bar0id,\n"
"\t\t\t\t  0, ~0, 1, RF_ACTIVE);\n"
"    if (sc-&gt;bar0res == NULL) {\n"
"        printf(\"Memory allocation of PCI base register 0 failed!\\n\");\n"
"        error = ENXIO;\n"
"        goto fail1;\n"
"    }\n"
"\n"
"    sc-&gt;bar1id = PCIR_BAR(1);\n"
"    sc-&gt;bar1res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;sc-&gt;bar1id,\n"
"\t\t\t\t  0, ~0, 1, RF_ACTIVE);\n"
"    if (sc-&gt;bar1res == NULL) {\n"
"        printf(\"Memory allocation of PCI base register 1 failed!\\n\");\n"
"        error =  ENXIO;\n"
"        goto fail2;\n"
"    }\n"
"    sc-&gt;bar0_bt = rman_get_bustag(sc-&gt;bar0res);\n"
"    sc-&gt;bar0_bh = rman_get_bushandle(sc-&gt;bar0res);\n"
"    sc-&gt;bar1_bt = rman_get_bustag(sc-&gt;bar1res);\n"
"    sc-&gt;bar1_bh = rman_get_bushandle(sc-&gt;bar1res);"
msgstr ""
"    sc-&gt;bar0id = PCIR_BAR(0);\n"
"    sc-&gt;bar0res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;sc-&gt;bar0id,\n"
"\t\t\t\t  0, ~0, 1, RF_ACTIVE);\n"
"    if (sc-&gt;bar0res == NULL) {\n"
"        printf(\"Memory allocation of PCI base register 0 failed!\\n\");\n"
"        error = ENXIO;\n"
"        goto fail1;\n"
"    }\n"
"\n"
"    sc-&gt;bar1id = PCIR_BAR(1);\n"
"    sc-&gt;bar1res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;sc-&gt;bar1id,\n"
"\t\t\t\t  0, ~0, 1, RF_ACTIVE);\n"
"    if (sc-&gt;bar1res == NULL) {\n"
"        printf(\"Memory allocation of PCI base register 1 failed!\\n\");\n"
"        error =  ENXIO;\n"
"        goto fail2;\n"
"    }\n"
"    sc-&gt;bar0_bt = rman_get_bustag(sc-&gt;bar0res);\n"
"    sc-&gt;bar0_bh = rman_get_bushandle(sc-&gt;bar0res);\n"
"    sc-&gt;bar1_bt = rman_get_bustag(sc-&gt;bar1res);\n"
"    sc-&gt;bar1_bh = rman_get_bushandle(sc-&gt;bar1res);"

#. (itstool) path: sect2/para
#: book.translate.xml:19321
msgid ""
"Handles for each base address register are kept in the <varname remap="
"\"structname\">softc</varname> structure so that they can be used to write "
"to the device later."
msgstr ""
"每个基址寄存器的句柄被保存在<varname remap=\"structname\">softc</varname>结构"
"中，以便以后可以使用它们向设备写入。"

#. (itstool) path: sect2/para
#: book.translate.xml:19325
msgid ""
"These handles can then be used to read or write from the device registers "
"with the <function>bus_space_*</function> functions. For example, a driver "
"might contain a shorthand function to read from a board specific register "
"like this:"
msgstr ""
"然后就能使用这些句柄与<function>bus_space_*</function>函数一起读写设备寄存"
"器。例如，驱动程序可能包含如下的快捷函数，用来读取板子特定的寄存器："

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19331
#, fuzzy, no-wrap
#| msgid ""
#| "uint16_t\n"
#| "board_read(struct ni_softc *sc, uint16_t address)\n"
#| "{\n"
#| "    return bus_space_read_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address);\n"
#| "}\n"
msgid ""
"uint16_t\n"
"board_read(struct ni_softc *sc, uint16_t address)\n"
"{\n"
"    return bus_space_read_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address);\n"
"}"
msgstr ""
"uint16_t\n"
"board_read(struct ni_softc *sc, uint16_t address)\n"
"{\n"
"    return bus_space_read_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address);\n"
"}\n"

#. (itstool) path: sect2/para
#: book.translate.xml:19337
msgid "Similarly, one could write to the registers with:"
msgstr "类似的，可以用下面的函数写寄存器："

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19339
#, fuzzy, no-wrap
#| msgid ""
#| "void\n"
#| "board_write(struct ni_softc *sc, uint16_t address, uint16_t value)\n"
#| "{\n"
#| "    bus_space_write_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address, value);\n"
#| "}\n"
msgid ""
"void\n"
"board_write(struct ni_softc *sc, uint16_t address, uint16_t value)\n"
"{\n"
"    bus_space_write_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address, value);\n"
"}"
msgstr ""
"void\n"
"board_write(struct ni_softc *sc, uint16_t address, uint16_t value)\n"
"{\n"
"    bus_space_write_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address, value);\n"
"}\n"

#. (itstool) path: sect2/para
#: book.translate.xml:19345
msgid ""
"These functions exist in 8bit, 16bit, and 32bit versions and you should use "
"<function>bus_space_{read|write}_{1|2|4}</function> accordingly."
msgstr ""
"这些函数以8位，16位和32位的版本存在，你应当相应地使用"
"<function>bus_space_{read|write}_{1|2|4}</function>。"

#. (itstool) path: note/para
#: book.translate.xml:19351
msgid ""
"In FreeBSD 7.0 and later, you can use the <function>bus_*</function> "
"functions instead of <function>bus_space_*</function>. The <function>bus_*</"
"function> functions take a <type>struct resource *</type> pointer instead of "
"a bus tag and handle. Thus, you could drop the bus tag and bus handle "
"members from the <varname remap=\"structname\">softc</varname> and rewrite "
"the <function>board_read()</function> function as:"
msgstr ""
"在 FreeBSD 7.0 和更高版本中，可以用<function>bus_*</function> 函数来代替"
"<function>bus_space_*</function>。<function>bus_*</function> 函数使用的参数"
"是 <type>structresource *</type> 指针， 而不是 bus tag 和句柄。这样， 您就可"
"以将 <varname remap=\"structname\">softc</varname>中的 bus tag 和 bus 句柄这"
"两个成员变量去掉， 并将<function>board_read()</function> 函数改写为："

#. (itstool) path: note/programlisting
#: book.translate.xml:19360
#, fuzzy, no-wrap
#| msgid ""
#| "uint16_t\n"
#| "board_read(struct ni_softc *sc, uint16_t address)\n"
#| "{\n"
#| "\treturn (bus_read(sc-&gt;bar1res, address));\n"
#| "}\n"
msgid ""
"uint16_t\n"
"board_read(struct ni_softc *sc, uint16_t address)\n"
"{\n"
"\treturn (bus_read(sc-&gt;bar1res, address));\n"
"}"
msgstr ""
"uint16_t\n"
"board_read(struct ni_softc *sc, uint16_t address)\n"
"{\n"
"\treturn (bus_read(sc-&gt;bar1res, address));\n"
"}\n"

#. (itstool) path: sect2/title
#. (itstool) path: sect1/title
#: book.translate.xml:19369 book.translate.xml:21178
msgid "Interrupts"
msgstr "中断"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:19371
msgid "<primary>PCI bus</primary><secondary>interrupts</secondary>"
msgstr "<primary>PCI bus</primary><secondary>interrupts</secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:19374
msgid ""
"Interrupts are allocated from the object-oriented bus code in a way similar "
"to the memory resources. First an IRQ resource must be allocated from the "
"parent bus, and then the interrupt handler must be set up to deal with this "
"IRQ."
msgstr ""
"中断按照和分配内存资源相似的方式从面向对象的总线代码分配。首先，必须从父总线"
"分配IRQ资源，然后必须设置中断处理函数来处理这个IRQ。"

#. (itstool) path: sect2/para
#: book.translate.xml:19379
msgid ""
"Again, a sample from a device <function>attach()</function> function says "
"more than words."
msgstr ""
"再一次，来自设备<function>attach()</function>函数的例子比文字更具说明性。"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19383
#, fuzzy, no-wrap
#| msgid ""
#| "/* Get the IRQ resource */\n"
#| "\n"
#| "    sc-&gt;irqid = 0x0;\n"
#| "    sc-&gt;irqres = bus_alloc_resource(dev, SYS_RES_IRQ, &amp;(sc-&gt;irqid),\n"
#| "\t\t\t\t  0, ~0, 1, RF_SHAREABLE | RF_ACTIVE);\n"
#| "    if (sc-&gt;irqres == NULL) {\n"
#| "\tprintf(\"IRQ allocation failed!\\n\");\n"
#| "\terror = ENXIO;\n"
#| "\tgoto fail3;\n"
#| "    }\n"
#| "\n"
#| "    /* Now we should set up the interrupt handler */\n"
#| "\n"
#| "    error = bus_setup_intr(dev, sc-&gt;irqres, INTR_TYPE_MISC,\n"
#| "\t\t\t   my_handler, sc, &amp;(sc-&gt;handler));\n"
#| "    if (error) {\n"
#| "\tprintf(\"Couldn't set up irq\\n\");\n"
#| "\tgoto fail4;\n"
#| "    }\n"
msgid ""
"/* Get the IRQ resource */\n"
"\n"
"    sc-&gt;irqid = 0x0;\n"
"    sc-&gt;irqres = bus_alloc_resource(dev, SYS_RES_IRQ, &amp;(sc-&gt;irqid),\n"
"\t\t\t\t  0, ~0, 1, RF_SHAREABLE | RF_ACTIVE);\n"
"    if (sc-&gt;irqres == NULL) {\n"
"\tprintf(\"IRQ allocation failed!\\n\");\n"
"\terror = ENXIO;\n"
"\tgoto fail3;\n"
"    }\n"
"\n"
"    /* Now we should set up the interrupt handler */\n"
"\n"
"    error = bus_setup_intr(dev, sc-&gt;irqres, INTR_TYPE_MISC,\n"
"\t\t\t   my_handler, sc, &amp;(sc-&gt;handler));\n"
"    if (error) {\n"
"\tprintf(\"Couldn't set up irq\\n\");\n"
"\tgoto fail4;\n"
"    }"
msgstr ""
"/* Get the IRQ resource */\n"
"\n"
"    sc-&gt;irqid = 0x0;\n"
"    sc-&gt;irqres = bus_alloc_resource(dev, SYS_RES_IRQ, &amp;(sc-&gt;irqid),\n"
"\t\t\t\t  0, ~0, 1, RF_SHAREABLE | RF_ACTIVE);\n"
"    if (sc-&gt;irqres == NULL) {\n"
"\tprintf(\"IRQ allocation failed!\\n\");\n"
"\terror = ENXIO;\n"
"\tgoto fail3;\n"
"    }\n"
"\n"
"    /* Now we should set up the interrupt handler */\n"
"\n"
"    error = bus_setup_intr(dev, sc-&gt;irqres, INTR_TYPE_MISC,\n"
"\t\t\t   my_handler, sc, &amp;(sc-&gt;handler));\n"
"    if (error) {\n"
"\tprintf(\"Couldn't set up irq\\n\");\n"
"\tgoto fail4;\n"
"    }\n"

#. (itstool) path: sect2/para
#: book.translate.xml:19403
msgid ""
"Some care must be taken in the detach routine of the driver. You must "
"quiesce the device's interrupt stream, and remove the interrupt handler. "
"Once <function>bus_teardown_intr()</function> has returned, you know that "
"your interrupt handler will no longer be called and that all threads that "
"might have been executing this interrupt handler have returned. Since this "
"function can sleep, you must not hold any mutexes when calling this function."
msgstr ""
"在设备的分离例程中必须注意一些问题。你必须停顿设备的中断流，并移除中断处理函"
"数。一旦<function>bus_teardown_intr()</function>返回，你知道你的中断处理函数"
"不会再被调用，并且所有可能已经执行了这个中断处理函数的线程都已经返回。由于此"
"函数可以睡眠，调用此函数时你必须不能拥有任何互斥体。"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:19416
msgid "<primary>PCI bus</primary><secondary>DMA</secondary>"
msgstr "<primary>PCI bus</primary><secondary>DMA</secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:19419
msgid ""
"This section is obsolete, and present only for historical reasons. The "
"proper methods for dealing with these issues is to use the "
"<function>bus_space_dma*()</function> functions instead. This paragraph can "
"be removed when this section is updated to reflect that usage. However, at "
"the moment, the API is in a bit of flux, so once that settles down, it would "
"be good to update this section to reflect that."
msgstr ""

#. (itstool) path: sect2/para
#: book.translate.xml:19427
msgid ""
"On the PC, peripherals that want to do bus-mastering DMA must deal with "
"physical addresses. This is a problem since FreeBSD uses virtual memory and "
"deals almost exclusively with virtual addresses. Fortunately, there is a "
"function, <function>vtophys()</function> to help."
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19433
#, fuzzy, no-wrap
#| msgid ""
#| "#include &lt;vm/vm.h&gt;\n"
#| "#include &lt;vm/pmap.h&gt;\n"
#| "\n"
#| "#define vtophys(virtual_address) (...)\n"
msgid ""
"#include &lt;vm/vm.h&gt;\n"
"#include &lt;vm/pmap.h&gt;\n"
"\n"
"#define vtophys(virtual_address) (...)"
msgstr ""
"#include &lt;vm/vm.h&gt;\n"
"#include &lt;vm/pmap.h&gt;\n"
"\n"
"#define vtophys(virtual_address) (...)\n"

#. (itstool) path: sect2/para
#: book.translate.xml:19438
msgid ""
"The solution is a bit different on the alpha however, and what we really "
"want is a function called <function>vtobus()</function>."
msgstr ""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19442
#, fuzzy, no-wrap
#| msgid ""
#| "#if defined(__alpha__)\n"
#| "#define vtobus(va)      alpha_XXX_dmamap((vm_offset_t)va)\n"
#| "#else\n"
#| "#define vtobus(va)      vtophys(va)\n"
#| "#endif\n"
msgid ""
"#if defined(__alpha__)\n"
"#define vtobus(va)      alpha_XXX_dmamap((vm_offset_t)va)\n"
"#else\n"
"#define vtobus(va)      vtophys(va)\n"
"#endif"
msgstr ""
"#if defined(__alpha__)\n"
"#define vtobus(va)      alpha_XXX_dmamap((vm_offset_t)va)\n"
"#else\n"
"#define vtobus(va)      vtophys(va)\n"
"#endif\n"

#. (itstool) path: sect2/title
#: book.translate.xml:19450
msgid "Deallocating Resources"
msgstr "取消分配资源"

#. (itstool) path: sect2/para
#: book.translate.xml:19452
msgid ""
"It is very important to deallocate all of the resources that were allocated "
"during <function>attach()</function>. Care must be taken to deallocate the "
"correct stuff even on a failure condition so that the system will remain "
"usable while your driver dies."
msgstr ""
"取消<function>attach()</function>期间分配的所有资源非常重要。必须小心谨慎，即"
"使在失败的条件下也要保证取消分配那些正确的东西，这样当你的驱动程序去掉后系统"
"仍然可以使用。"

#. (itstool) path: info/title
#: book.translate.xml:19468
msgid "Common Access Method SCSI Controllers"
msgstr "通用访问方法SCSI控制器"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19482
msgid "<primary>SCSI</primary>"
msgstr "<primary>SCSI</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:19483
msgid ""
"This document assumes that the reader has a general understanding of device "
"drivers in FreeBSD and of the SCSI protocol. Much of the information in this "
"document was extracted from the drivers:"
msgstr ""
"本文档假定读者对FreeBSD的设备驱动程序和SCSI协议有大致了解，本文档中很多信息是"
"从以下驱动程序中："

#. (itstool) path: listitem/para
#: book.translate.xml:19490
msgid ""
"ncr (<filename>/sys/pci/ncr.c</filename>) by Wolfgang Stanglmeier and Stefan "
"Esser"
msgstr ""
"ncr (<filename>/sys/pci/ncr.c</filename>) by Wolfgang Stanglmeier and Stefan "
"Esser"

#. (itstool) path: listitem/para
#: book.translate.xml:19494
msgid "sym (<filename>/sys/dev/sym/sym_hipd.c</filename>) by Gerard Roudier"
msgstr "sym (<filename>/sys/dev/sym/sym_hipd.c</filename>) by Gerard Roudier"

#. (itstool) path: listitem/para
#: book.translate.xml:19499
msgid ""
"aic7xxx (<filename>/sys/dev/aic7xxx/aic7xxx.c</filename>) by Justin T. Gibbs"
msgstr ""
"aic7xxx (<filename>/sys/dev/aic7xxx/aic7xxx.c</filename>) by Justin T. Gibbs"

#. (itstool) path: sect1/para
#: book.translate.xml:19505
msgid ""
"and from the CAM code itself (by Justin T. Gibbs, see <filename>/sys/cam/*</"
"filename>). When some solution looked the most logical and was essentially "
"verbatim extracted from the code by Justin T. Gibbs, I marked it as "
"<quote>recommended</quote>."
msgstr ""
"和从CAM的代码本身（作者 Justin T. Gibbs，见<filename>/sys/cam/*</filename>）"
"中摘录。当一些解决方法看起来极具逻辑性，并且基本上是从 Justin T. Gibbs 的代码"
"中一字不差地摘录时，我将其标记为<quote>recommended</quote>。"

#. (itstool) path: sect1/para
#: book.translate.xml:19511
msgid ""
"The document is illustrated with examples in pseudo-code. Although sometimes "
"the examples have many details and look like real code, it is still pseudo-"
"code. It was written to demonstrate the concepts in an understandable way. "
"For a real driver other approaches may be more modular and efficient. It "
"also abstracts from the hardware details, as well as issues that would cloud "
"the demonstrated concepts or that are supposed to be described in the other "
"chapters of the developers handbook. Such details are commonly shown as "
"calls to functions with descriptive names, comments or pseudo-statements. "
"Fortunately real life full-size examples with all the details can be found "
"in the real drivers."
msgstr ""
"本文档以伪代码例子进行说明。尽管有时例子中包含很多细节，并且看起来很像真正代"
"码，但它仍然只是伪代码。这样写是为了以一种可理解的方式来展示概念。对于真正的"
"驱动程序，其它方法可能更模块化，并且更加高效。文档也对硬件细节进行抽象，对于"
"那些会模糊我们所要展示的概念的问题，或被认为在开发者手册的其他章节中已有描述"
"的问题也做同样处理。这些细节通常以调用具有描述性名字的函数、注释或伪语句的形"
"式展现。幸运的是，具有实际价值的完整例子，包括所有细节，可以在真正的驱动程序"
"中找到。"

#. (itstool) path: sect1/title
#: book.translate.xml:19526
msgid "General Architecture"
msgstr "通用基础结构"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19528
msgid "<primary>Common Access Method (CAM)</primary>"
msgstr "<primary>Common Access Method (CAM)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:19532
msgid ""
"CAM stands for Common Access Method. It is a generic way to address the I/O "
"buses in a SCSI-like way. This allows a separation of the generic device "
"drivers from the drivers controlling the I/O bus: for example the disk "
"driver becomes able to control disks on both SCSI, IDE, and/or any other bus "
"so the disk driver portion does not have to be rewritten (or copied and "
"modified) for every new I/O bus. Thus the two most important active entities "
"are:"
msgstr ""
"CAM代表通用访问方法（Common Access Method）。它以类SCSI方式寻址I/O总线。这就"
"允许将通用设备驱动程序和控制I/O总线的驱动程序分离开来：例如磁盘驱动程序能同时"
"控制SCSI、IDE、且/或任何其他总线上的磁盘，这样磁盘驱动程序部分不必为每种新的"
"I/O总线而重写（或拷贝修改）。这样，两个最重要的活动实体是："

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19541
msgid "<primary>CD-ROM</primary>"
msgstr "<primary>CD-ROM</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19542
msgid "<primary>tape</primary>"
msgstr "<primary>tape（磁带）</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19543
msgid "<primary>IDE</primary>"
msgstr "<primary>IDE</primary>"

#. (itstool) path: listitem/para
#: book.translate.xml:19546
msgid ""
"<emphasis>Peripheral Modules</emphasis> - a driver for peripheral devices "
"(disk, tape, CD-ROM, etc.)"
msgstr ""
"<emphasis>外围设备模块</emphasis> - 外围设备（磁盘，磁带， CD-ROM等）的驱动程"
"序"

#. (itstool) path: listitem/para
#: book.translate.xml:19552
msgid ""
"<emphasis>SCSI Interface Modules </emphasis>(SIM) - a Host Bus Adapter "
"drivers for connecting to an I/O bus such as SCSI or IDE."
msgstr ""
"<emphasis>SCSI接口模块</emphasis>(SIM)- 连接到I/O总线，如SCSI或IDE，的主机总"
"线适配器驱动程序。"

#. (itstool) path: sect1/para
#: book.translate.xml:19558
msgid ""
"A peripheral driver receives requests from the OS, converts them to a "
"sequence of SCSI commands and passes these SCSI commands to a SCSI Interface "
"Module. The SCSI Interface Module is responsible for passing these commands "
"to the actual hardware (or if the actual hardware is not SCSI but, for "
"example, IDE then also converting the SCSI commands to the native commands "
"of the hardware)."
msgstr ""
"外围设备驱动程序从OS接收请求，将它们转换为SCSI命令序列并将这些SCSI命令传递到"
"SCSI接口模块。SCSI接口模块负责将这些命令传递给实际硬件（或者如果实际硬件不是"
"SCSI，而是例如IDE，则也要将这些SCSI命令转换为硬件的native命令）。"

#. (itstool) path: sect1/para
#: book.translate.xml:19566
msgid ""
"Because we are interested in writing a SCSI adapter driver here, from this "
"point on we will consider everything from the SIM standpoint."
msgstr ""
"由于这儿我们感兴趣的是编写SCSI适配器驱动程序，从此处开始我们将从SIM的角度考虑"
"所有的事情。"

#. (itstool) path: sect1/para
#: book.translate.xml:19570
msgid ""
"A typical SIM driver needs to include the following CAM-related header files:"
msgstr "典型的SIM驱动程序需要包括如下的CAM相关的头文件："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19573
#, no-wrap
msgid ""
"#include &lt;cam/cam.h&gt;\n"
"#include &lt;cam/cam_ccb.h&gt;\n"
"#include &lt;cam/cam_sim.h&gt;\n"
"#include &lt;cam/cam_xpt_sim.h&gt;\n"
"#include &lt;cam/cam_debug.h&gt;\n"
"#include &lt;cam/scsi/scsi_all.h&gt;"
msgstr ""
"#include &lt;cam/cam.h&gt;\n"
"#include &lt;cam/cam_ccb.h&gt;\n"
"#include &lt;cam/cam_sim.h&gt;\n"
"#include &lt;cam/cam_xpt_sim.h&gt;\n"
"#include &lt;cam/cam_debug.h&gt;\n"
"#include &lt;cam/scsi/scsi_all.h&gt;"

#. (itstool) path: sect1/para
#: book.translate.xml:19580
msgid ""
"The first thing each SIM driver must do is register itself with the CAM "
"subsystem. This is done during the driver's <function>xxx_attach()</"
"function> function (here and further xxx_ is used to denote the unique "
"driver name prefix). The <function>xxx_attach()</function> function itself "
"is called by the system bus auto-configuration code which we do not describe "
"here."
msgstr ""
"每个SIM驱动程序必须做的第一件事情是向CAM子系统注册它自己。这在驱动程序的"
"<function>xxx_attach()</function>函数（此处和以后的xxx_用于指带唯一的驱动程序"
"名字前缀）期间完成。<function>xxx_attach()</function>函数自身由系统总线自动配"
"置代码调用，我们在此不描述这部分代码。"

#. (itstool) path: sect1/para
#: book.translate.xml:19588
msgid ""
"This is achieved in multiple steps: first it is necessary to allocate the "
"queue of requests associated with this SIM:"
msgstr "这需要好几步来完成：首先需要分配与SIM关联的请求队列："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19591
#, no-wrap
msgid ""
"    struct cam_devq *devq;\n"
"\n"
"    if(( devq = cam_simq_alloc(SIZE) )==NULL) {\n"
"        error; /* some code to handle the error */\n"
"    }"
msgstr ""
"    struct cam_devq *devq;\n"
"\n"
"    if(( devq = cam_simq_alloc(SIZE) )==NULL) {\n"
"        error; /* some code to handle the error */\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:19597
msgid ""
"Here <literal>SIZE</literal> is the size of the queue to be allocated, "
"maximal number of requests it could contain. It is the number of requests "
"that the SIM driver can handle in parallel on one SCSI card. Commonly it can "
"be calculated as:"
msgstr ""
"此处 <literal>SIZE</literal> 为要分配的队列的大小，它能包含的最大请求数目。 "
"它是 SIM驱动程序在 SCSI 卡上能够并行处理的请求的数目。一般可以如下估算："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19603
#, no-wrap
msgid "SIZE = NUMBER_OF_SUPPORTED_TARGETS * MAX_SIMULTANEOUS_COMMANDS_PER_TARGET"
msgstr "SIZE = NUMBER_OF_SUPPORTED_TARGETS * MAX_SIMULTANEOUS_COMMANDS_PER_TARGET"

#. (itstool) path: sect1/para
#: book.translate.xml:19605
msgid "Next we create a descriptor of our SIM:"
msgstr "下一步为我们的SIM创建描述符："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19607
#, no-wrap
msgid ""
"    struct cam_sim *sim;\n"
"\n"
"    if(( sim = cam_sim_alloc(action_func, poll_func, driver_name,\n"
"            softc, unit, mtx, max_dev_transactions,\n"
"            max_tagged_dev_transactions, devq) )==NULL) {\n"
"        cam_simq_free(devq);\n"
"        error; /* some code to handle the error */\n"
"    }"
msgstr ""
"    struct cam_sim *sim;\n"
"\n"
"    if(( sim = cam_sim_alloc(action_func, poll_func, driver_name,\n"
"            softc, unit, mtx, max_dev_transactions,\n"
"            max_tagged_dev_transactions, devq) )==NULL) {\n"
"        cam_simq_free(devq);\n"
"        error; /* some code to handle the error */\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:19616
msgid ""
"Note that if we are not able to create a SIM descriptor we free the <varname "
"remap=\"structname\">devq</varname> also because we can do nothing else with "
"it and we want to conserve memory."
msgstr ""
"注意如果我们不能创建SIM描述符，我们也释放<varname remap=\"structname\">devq</"
"varname>，因为我们对其无法做任何其他事情，而且我们想节约内存。"

#. (itstool) path: para/indexterm
#: book.translate.xml:19621
msgid "<primary>SCSI</primary><secondary>bus</secondary>"
msgstr "<primary>SCSI</primary><secondary>bus</secondary>"

#. (itstool) path: sect1/para
#: book.translate.xml:19620
msgid ""
"If a SCSI card has multiple SCSI buses<_:indexterm-1/> on it then each bus "
"requires its own <varname remap=\"structname\">cam_sim</varname> structure."
msgstr ""
"如果SCSI卡上有多条SCSI总线，则每条总线需要它自己的<varname remap=\"structname"
"\">cam_sim</varname> 结构。"

#. (itstool) path: sect1/para
#: book.translate.xml:19625
msgid ""
"An interesting question is what to do if a SCSI card has more than one SCSI "
"bus, do we need one <varname remap=\"structname\">devq</varname> structure "
"per card or per SCSI bus? The answer given in the comments to the CAM code "
"is: either way, as the driver's author prefers."
msgstr ""
"一个有趣的问题是，如果SCSI卡有不只一条SCSI总线我们该怎么做，每个卡需要一个"
"<varname remap=\"structname\">devq</varname>结构还是每条SCSI总线？在CAM代码的"
"注释中给出的答案是：任一方式均可，由驱动程序的作者选择。"

#. (itstool) path: sect1/para
#: book.translate.xml:19631
msgid "The arguments are:"
msgstr "参量为："

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:19638 book.translate.xml:19828
msgid ""
"<funcdef>static void <function>xxx_action</function> </funcdef> <paramdef> "
"<parameter>struct cam_sim *sim</parameter>, <parameter>union ccb *ccb</"
"parameter> </paramdef>"
msgstr ""
"<funcdef>static void <function>xxx_action</function> </funcdef> <paramdef> "
"<parameter>struct cam_sim *sim</parameter>, <parameter>union ccb *ccb</"
"parameter> </paramdef>"

#. (itstool) path: listitem/para
#: book.translate.xml:19635
msgid ""
"<function>action_func</function> - pointer to the driver's "
"<function>xxx_action</function> function. <_:funcsynopsis-1/>"
msgstr ""
"<function>action_func</function> - 指向驱动程序 <function>xxx_action</"
"function> function. <_:funcsynopsis-1/>"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:19654 book.translate.xml:21079
msgid ""
"<funcdef>static void <function>xxx_poll</function> </funcdef> <paramdef> "
"<parameter>struct cam_sim *sim</parameter> </paramdef>"
msgstr ""
"<funcdef>static void <function>xxx_poll</function> </funcdef> <paramdef> "
"<parameter>struct cam_sim *sim</parameter> </paramdef>"

#. (itstool) path: listitem/para
#: book.translate.xml:19651
msgid ""
"<function>poll_func</function> - pointer to the driver's "
"<function>xxx_poll()</function> <_:funcsynopsis-1/>"
msgstr ""
"<function>poll_func</function> - pointer to the driver's "
"<function>xxx_poll()</function> <_:funcsynopsis-1/>"

#. (itstool) path: listitem/para
#: book.translate.xml:19666
msgid ""
"driver_name - the name of the actual driver, such as <quote>ncr</quote> or "
"<quote>wds</quote>."
msgstr ""
"driver_name - 实际驱动程序的名字，例如<quote>ncr</quote>或<quote>wds</"
"quote>。"

#. (itstool) path: listitem/para
#: book.translate.xml:19672
msgid ""
"<varname remap=\"structname\">softc</varname> - pointer to the driver's "
"internal descriptor for this SCSI card. This pointer will be used by the "
"driver in future to get private data."
msgstr ""
"<varname remap=\"structname\">softc</varname> - 指向这个SCSI卡驱动程序的内部"
"描述符的指针。这个指针以后被驱动程序用来获取私有数据。"

#. (itstool) path: listitem/para
#: book.translate.xml:19679
msgid ""
"unit - the controller unit number, for example for controller <quote>mps0</"
"quote> this number will be 0"
msgstr "unit - 控制器单元号，例如对于控制器<quote>wds0</quote>的此数字将为0。"

#. (itstool) path: listitem/para
#: book.translate.xml:19685
msgid ""
"mtx - Lock associated with this SIM. For SIMs that don't know about locking, "
"pass in Giant. For SIMs that do, pass in the lock used to guard this SIM's "
"data structures. This lock will be held when xxx_action and xxx_poll are "
"called."
msgstr ""

#. (itstool) path: listitem/para
#: book.translate.xml:19692
msgid ""
"max_dev_transactions - maximal number of simultaneous transactions per SCSI "
"target in the non-tagged mode. This value will be almost universally equal "
"to 1, with possible exceptions only for the non-SCSI cards. Also the drivers "
"that hope to take advantage by preparing one transaction while another one "
"is executed may set it to 2 but this does not seem to be worth the "
"complexity."
msgstr ""
"max_dev_transactions - 无标签模式下每个SCSI目标的 最大并发（simultaneous）事"
"务数。这个值一般几乎总是等于1，只有非 SCSI卡才可能例外。此外，如果驱动程序希"
"望执行一个事务的同时准备另 一个事务，可以将其设置为2，但似乎不值得增加这种复"
"杂性。"

#. (itstool) path: listitem/para
#: book.translate.xml:19702
msgid ""
"max_tagged_dev_transactions - the same thing, but in the tagged mode. Tags "
"are the SCSI way to initiate multiple transactions on a device: each "
"transaction is assigned a unique tag and the transaction is sent to the "
"device. When the device completes some transaction it sends back the result "
"together with the tag so that the SCSI adapter (and the driver) can tell "
"which transaction was completed. This argument is also known as the maximal "
"tag depth. It depends on the abilities of the SCSI adapter."
msgstr ""
"max_tagged_dev_transactions - 同样的东西，但是 在标签模式下。标签是SCSI在设备"
"上发起多个事务的方式：每个事务 被赋予一个唯一的标签，并被发送到设备。当设备完"
"成某些事务，它 将结果连同标签一起发送回来，这样SCSI适配器（和驱动程序）就能知"
"道 哪个事务完成了。此参量也被认为是最大标签深度。它取决于SCSI 适配器的能力。"

#. (itstool) path: para/indexterm
#: book.translate.xml:19716
msgid "<primary>SCSI</primary><secondary>adapter</secondary>"
msgstr ""
"<primary>SCSI(小型计算机系统接口)</primary><secondary>adapter(适配器)</"
"secondary>"

#. (itstool) path: sect1/para
#: book.translate.xml:19715
msgid ""
"Finally we register the SCSI buses associated with our SCSI adapter<_:"
"indexterm-1/>:"
msgstr "最后我们注册与我们的SCSI适配器关联的SCSI总线<_:indexterm-1/>:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19718
#, no-wrap
msgid ""
"    if(xpt_bus_register(sim, softc, bus_number) != CAM_SUCCESS) {\n"
"        cam_sim_free(sim, /*free_devq*/ TRUE);\n"
"        error; /* some code to handle the error */\n"
"    }"
msgstr ""
"    if(xpt_bus_register(sim, softc, bus_number) != CAM_SUCCESS) {\n"
"        cam_sim_free(sim, /*free_devq*/ TRUE);\n"
"        error; /* some code to handle the error */\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:19723
msgid ""
"If there is one <varname remap=\"structname\">devq</varname> structure per "
"SCSI bus (i.e., we consider a card with multiple buses as multiple cards "
"with one bus each) then the bus number will always be 0, otherwise each bus "
"on the SCSI card should be get a distinct number. Each bus needs its own "
"separate structure cam_sim."
msgstr ""
"如果每条SCSI总线有一个<varname remap=\"structname\">devq</varname>结构（即， "
"我们将带有多条总线的卡看作多个卡，每个卡带有一条总线），则总线号 总是为0，否"
"则SCSI卡上的每条总线应当有不同的号。每条总线需要 它自己单独的cam_sim结构。"

#. (itstool) path: sect1/para
#: book.translate.xml:19730
msgid ""
"After that our controller is completely hooked to the CAM system. The value "
"of <varname remap=\"structname\">devq</varname> can be discarded now: sim "
"will be passed as an argument in all further calls from CAM and devq can be "
"derived from it."
msgstr ""
"这之后我们的控制器完全挂接到CAM系统。现在 <varname remap=\"structname"
"\">devq</varname>的值可以被丢弃：在所有以后从CAM发出的 调用中将以sim为参量，"
"devq可以由它导出。"

#. (itstool) path: sect1/para
#: book.translate.xml:19735
msgid ""
"CAM provides the framework for such asynchronous events. Some events "
"originate from the lower levels (the SIM drivers), some events originate "
"from the peripheral drivers, some events originate from the CAM subsystem "
"itself. Any driver can register callbacks for some types of the asynchronous "
"events, so that it would be notified if these events occur."
msgstr ""
"CAM为这些异步事件提供了框架。有些事件来自底层（SIM驱动程序）， 有些来自外围设"
"备驱动程序，还有一些来自CAM子系统本身。任何驱动 程序都可以为某些类型的异步事"
"件注册回调，这样那些事件发生时它就 会被通知。"

#. (itstool) path: sect1/para
#: book.translate.xml:19742
msgid ""
"A typical example of such an event is a device reset. Each transaction and "
"event identifies the devices to which it applies by the means of "
"<quote>path</quote>. The target-specific events normally occur during a "
"transaction with this device. So the path from that transaction may be re-"
"used to report this event (this is safe because the event path is copied in "
"the event reporting routine but not deallocated nor passed anywhere "
"further). Also it is safe to allocate paths dynamically at any time "
"including the interrupt routines, although that incurs certain overhead, and "
"a possible problem with this approach is that there may be no free memory at "
"that time. For a bus reset event we need to define a wildcard path including "
"all devices on the bus. So we can create the path for the future bus reset "
"events in advance and avoid problems with the future memory shortage:"
msgstr ""
"这种事件的一个典型例子就是设备复位。每个事务和事件以 <quote>path</quote>的方"
"式区分它们所作用的设备。目标特定的事件 通常在与设备进行事务处理期间发生。因此"
"那个事务的路径可以被重用 来报告此事件（这是安全的，因为事件路径的拷贝是在事件"
"报告例程中进行的， 而且既不会被deallocate也不作进一步传递）。在任何时刻，包括"
"中断例程中， 动态分配路径也是安全的，尽管那样会导致某些额外开销，并且这种方"
"法 可能存在的一个问题是碰巧那时可能没有空闲内存。对于总线复位事件， 我们需要"
"定义包括总线上所有设备在内的通配符路径。这样我们就能提前为 以后的总线复位事件"
"创建路径，避免以后内存不足的问题："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19758
#, no-wrap
msgid ""
"    struct cam_path *path;\n"
"\n"
"    if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                cam_sim_path(sim), CAM_TARGET_WILDCARD,\n"
"                CAM_LUN_WILDCARD) != CAM_REQ_CMP) {\n"
"        xpt_bus_deregister(cam_sim_path(sim));\n"
"        cam_sim_free(sim, /*free_devq*/TRUE);\n"
"        error; /* some code to handle the error */\n"
"    }\n"
"\n"
"    softc-&gt;wpath = path;\n"
"    softc-&gt;sim = sim;"
msgstr ""
"    struct cam_path *path;\n"
"\n"
"    if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                cam_sim_path(sim), CAM_TARGET_WILDCARD,\n"
"                CAM_LUN_WILDCARD) != CAM_REQ_CMP) {\n"
"        xpt_bus_deregister(cam_sim_path(sim));\n"
"        cam_sim_free(sim, /*free_devq*/TRUE);\n"
"        error; /* some code to handle the error */\n"
"    }\n"
"\n"
"    softc-&gt;wpath = path;\n"
"    softc-&gt;sim = sim;"

#. (itstool) path: sect1/para
#: book.translate.xml:19771
msgid "As you can see the path includes:"
msgstr "正如你所看到的，路径包括："

#. (itstool) path: listitem/para
#: book.translate.xml:19775
msgid "ID of the peripheral driver (NULL here because we have none)"
msgstr "外围设备驱动程序的ID（由于我们一个也没有，故此处为空）"

#. (itstool) path: listitem/para
#: book.translate.xml:19780
msgid "ID of the SIM driver (<function>cam_sim_path(sim)</function>)"
msgstr "SIM驱动程序的ID （<function>cam_sim_path(sim)</function>）"

#. (itstool) path: listitem/para
#: book.translate.xml:19785
msgid ""
"SCSI target number of the device (CAM_TARGET_WILDCARD means <quote>all "
"devices</quote>)"
msgstr ""
"设备的SCSI目标号（CAM_TARGET_WILDCARD的意思指 <quote>所有devices</quote>）"

#. (itstool) path: listitem/para
#: book.translate.xml:19790
msgid ""
"SCSI LUN number of the subdevice (CAM_LUN_WILDCARD means <quote>all LUNs</"
"quote>)"
msgstr "子设备的SCSI LUN号（CAM_LUN_WILDCARD的意思指 <quote>所有LUNs</quote>）"

#. (itstool) path: sect1/para
#: book.translate.xml:19795
msgid ""
"If the driver can not allocate this path it will not be able to work "
"normally, so in that case we dismantle that SCSI bus."
msgstr ""
"如果驱动程序不能分配这个路径，它将不能正常工作，因此那样情况下 我们卸除"
"（dismantle）那个SCSI总线。"

#. (itstool) path: sect1/para
#: book.translate.xml:19799
msgid ""
"And we save the path pointer in the <varname remap=\"structname\">softc</"
"varname> structure for future use. After that we save the value of sim (or "
"we can also discard it on the exit from <function>xxx_probe()</function> if "
"we wish)."
msgstr ""
"我们在<varname remap=\"structname\">softc</varname>结构中保存路径指针以便以"
"后 使用。这之后我们保存sim的值（或者如果我们愿意，也可以在从 "
"<function>xxx_probe()</function>退出时丢弃它）。"

#. (itstool) path: sect1/para
#: book.translate.xml:19804
msgid ""
"That is all for a minimalistic initialization. To do things right there is "
"one more issue left."
msgstr ""
"这就是最低要求的初始化所需要做的一切。为了把事情做正确无误， 还剩下一个问题。"

#. (itstool) path: sect1/para
#: book.translate.xml:19807
msgid ""
"For a SIM driver there is one particularly interesting event: when a target "
"device is considered lost. In this case resetting the SCSI negotiations with "
"this device may be a good idea. So we register a callback for this event "
"with CAM. The request is passed to CAM by requesting CAM action on a CAM "
"control block for this type of request:"
msgstr ""
"对于SIM驱动程序，有一个特殊感兴趣的事件：何时目标设备被认为 找不到了。这种情"
"况下复位与这个设备的SCSI协商可能是个好主意。因此我们 为这个事件向CAM注册一个"
"回调。通过为这种类型的请求来请求CAM控制块上 的CAM动作，请求就被传递到CAM："
"（译注：参看下面示例代码和原文）"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19814
#, no-wrap
msgid ""
"    struct ccb_setasync csa;\n"
"\n"
"    xpt_setup_ccb(&amp;csa.ccb_h, path, /*priority*/5);\n"
"    csa.ccb_h.func_code = XPT_SASYNC_CB;\n"
"    csa.event_enable = AC_LOST_DEVICE;\n"
"    csa.callback = xxx_async;\n"
"    csa.callback_arg = sim;\n"
"    xpt_action((union ccb *)&amp;csa);"
msgstr ""
"    struct ccb_setasync csa;\n"
"\n"
"    xpt_setup_ccb(&amp;csa.ccb_h, path, /*priority*/5);\n"
"    csa.ccb_h.func_code = XPT_SASYNC_CB;\n"
"    csa.event_enable = AC_LOST_DEVICE;\n"
"    csa.callback = xxx_async;\n"
"    csa.callback_arg = sim;\n"
"    xpt_action((union ccb *)&amp;csa);"

#. (itstool) path: sect1/para
#: book.translate.xml:19823
msgid ""
"Now we take a look at the <function>xxx_action()</function> and "
"<function>xxx_poll()</function> driver entry points."
msgstr ""
"现在我们看一下<function>xxx_action()</function> 和<function>xxx_poll()</"
"function>的驱动程序入口点。"

#. (itstool) path: sect1/para
#: book.translate.xml:19839
msgid ""
"Do some action on request of the CAM subsystem. Sim describes the SIM for "
"the request, CCB is the request itself. CCB stands for <quote>CAM Control "
"Block</quote>. It is a union of many specific instances, each describing "
"arguments for some type of transactions. All of these instances share the "
"CCB header where the common part of arguments is stored."
msgstr ""
"响应CAM子系统的请求采取某些动作。Sim描述了请求的SIM，CCB为 请求本身。CCB代表"
"<quote>CAM Control Block</quote>。它是很多特定 实例的联合，每个实例为某些类型"
"的事务描述参量。所有这些实例共享 存储着参量公共部分的CCB头部。（译注：这一段"
"不很准确，请自行参考原文）"

#. (itstool) path: sect1/para
#: book.translate.xml:19846
msgid ""
"CAM supports the SCSI controllers working in both initiator (<quote>normal</"
"quote>) mode and target (simulating a SCSI device) mode. Here we only "
"consider the part relevant to the initiator mode."
msgstr ""
"CAM既支持SCSI控制器工作于发起者(initiator)(<quote>normal</quote>) 模式，也支"
"持SCSI控制器工作于目标(target)（模拟SCSI设备）模式。这儿 我们只考虑与发起者模"
"式有关的部分。"

#. (itstool) path: sect1/para
#: book.translate.xml:19851
msgid ""
"There are a few function and macros (in other words, methods) defined to "
"access the public data in the struct sim:"
msgstr "定义了几个函数和宏（换句话说，方法）来访问结构sim中公共数据："

#. (itstool) path: listitem/para
#: book.translate.xml:19857
msgid "<function>cam_sim_path(sim)</function> - the path ID (see above)"
msgstr "<function>cam_sim_path(sim)</function> - 路径ID （参见上面）"

#. (itstool) path: listitem/para
#: book.translate.xml:19862
msgid "<function>cam_sim_name(sim)</function> - the name of the sim"
msgstr "<function>cam_sim_name(sim)</function> - sim的名字"

#. (itstool) path: listitem/para
#: book.translate.xml:19867
msgid ""
"<function>cam_sim_softc(sim)</function> - the pointer to the softc (driver "
"private data) structure"
msgstr ""
"<function>cam_sim_softc(sim)</function> - 指向softc（驱动程序私有数据）结构的"
"指针"

#. (itstool) path: listitem/para
#: book.translate.xml:19872
msgid "<function> cam_sim_unit(sim)</function> - the unit number"
msgstr "<function> cam_sim_unit(sim)</function> - 单元号"

#. (itstool) path: listitem/para
#: book.translate.xml:19877
msgid "<function> cam_sim_bus(sim)</function> - the bus ID"
msgstr "<function> cam_sim_bus(sim)</function> - 总线ID"

#. (itstool) path: sect1/para
#: book.translate.xml:19882
msgid ""
"To identify the device, <function>xxx_action()</function> can get the unit "
"number and pointer to its structure softc using these functions."
msgstr ""
"为了识别设备，<function>xxx_action()</function>可以使用这些 函数得到单元号和"
"指向它的softc结构的指针。"

#. (itstool) path: sect1/para
#: book.translate.xml:19886
msgid ""
"The type of request is stored in <varname remap=\"structfield\">ccb-&gt;"
"ccb_h.func_code</varname>. So generally <function>xxx_action()</function> "
"consists of a big switch:"
msgstr ""
"请求的类型被存储在 <varname remap=\"structfield\">ccb-&gt;ccb_h.func_code</"
"varname>。因此，通常 <function>xxx_action()</function>由一个大的switch组成："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19891
#, no-wrap
msgid ""
"    struct xxx_softc *softc = (struct xxx_softc *) cam_sim_softc(sim);\n"
"    struct ccb_hdr *ccb_h = &amp;ccb-&gt;ccb_h;\n"
"    int unit = cam_sim_unit(sim);\n"
"    int bus = cam_sim_bus(sim);\n"
"\n"
"    switch(ccb_h-&gt;func_code) {\n"
"    case ...:\n"
"        ...\n"
"    default:\n"
"        ccb_h-&gt;status = CAM_REQ_INVALID;\n"
"        xpt_done(ccb);\n"
"        break;\n"
"    }"
msgstr ""
"    struct xxx_softc *softc = (struct xxx_softc *) cam_sim_softc(sim);\n"
"    struct ccb_hdr *ccb_h = &amp;ccb-&gt;ccb_h;\n"
"    int unit = cam_sim_unit(sim);\n"
"    int bus = cam_sim_bus(sim);\n"
"\n"
"    switch(ccb_h-&gt;func_code) {\n"
"    case ...:\n"
"        ...\n"
"    default:\n"
"        ccb_h-&gt;status = CAM_REQ_INVALID;\n"
"        xpt_done(ccb);\n"
"        break;\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:19905
msgid ""
"As can be seen from the default case (if an unknown command was received) "
"the return code of the command is set into <varname remap=\"structfield"
"\">ccb-&gt;ccb_h.status</varname> and the completed CCB is returned back to "
"CAM by calling <function>xpt_done(ccb)</function>."
msgstr ""
"从default case语句部分可以看出（如果收到未知命令），命令的返回码 被设置到 "
"<varname remap=\"structfield\">ccb-&gt;ccb_h.status</varname> 中，并且通过 调"
"用<function>xpt_done(ccb)</function>将整个CCB返回到CAM中。"

#. (itstool) path: sect1/para
#: book.translate.xml:19911
msgid ""
"<function>xpt_done()</function> does not have to be called from "
"<function>xxx_action()</function>: For example an I/O request may be "
"enqueued inside the SIM driver and/or its SCSI controller. Then when the "
"device would post an interrupt signaling that the processing of this request "
"is complete <function>xpt_done()</function> may be called from the interrupt "
"handling routine."
msgstr ""
"<function>xpt_done()</function>不必从 <function>xxx_action()</function>中调"
"用：例如I/O请求可以在SIM驱动程序 和/或它的SCSI控制器中排队。（译注：它指I/O请"
"求？） 然后，当设备传递(post)一个中断信号，指示对此请求的处理已结束时， "
"<function>xpt_done()</function>可以从中断处理例程中被调用。"

#. (itstool) path: sect1/para
#: book.translate.xml:19919
msgid ""
"Actually, the CCB status is not only assigned as a return code but a CCB has "
"some status all the time. Before CCB is passed to the "
"<function>xxx_action()</function> routine it gets the status CCB_REQ_INPROG "
"meaning that it is in progress. There are a surprising number of status "
"values defined in <filename>/sys/cam/cam.h</filename> which should be able "
"to represent the status of a request in great detail. More interesting yet, "
"the status is in fact a <quote>bitwise or</quote> of an enumerated status "
"value (the lower 6 bits) and possible additional flag-like bits (the upper "
"bits). The enumerated values will be discussed later in more detail. The "
"summary of them can be found in the Errors Summary section. The possible "
"status flags are:"
msgstr ""
"实际上，CCB状态不是仅仅被赋值为一个返回码，而是始终有某种状态。 CCB被传递给"
"<function>xxx_action()</function>例程前，其取得状态 CCB_REQ_INPROG，表示其正"
"在进行中。<filename>/sys/cam/cam.h</filename> 中定义了数量惊人的状态值，它们"
"应该能非常详尽地表示请求的状态。 更有趣的是，状态实际上是一个枚举状态值（低6"
"位）和一些可能出现的附加 类(似)旗标位（高位）的<quote>位或(bitwise or)</"
"quote>。枚举值会在以后 更详细地讨论。对它们的汇总可以在错误概览节(Errors "
"Summary section) 找到。可能的状态旗标为："

#. (itstool) path: listitem/para
#: book.translate.xml:19935
msgid ""
"<emphasis>CAM_DEV_QFRZN</emphasis> - if the SIM driver gets a serious error "
"(for example, the device does not respond to the selection or breaks the "
"SCSI protocol) when processing a CCB it should freeze the request queue by "
"calling <function>xpt_freeze_simq()</function>, return the other enqueued "
"but not processed yet CCBs for this device back to the CAM queue, then set "
"this flag for the troublesome CCB and call <function>xpt_done()</function>. "
"This flag causes the CAM subsystem to unfreeze the queue after it handles "
"the error."
msgstr ""
"<emphasis>CAM_DEV_QFRZN</emphasis> - 当处理CCB时， 如果SIM驱动程序得到一个严"
"重错误（例如，驱动程序不能响应选择或违反 了SCSI协议），它应当调用"
"<function>xpt_freeze_simq()</function>冻结 请求队列，把此设备的其他已入队但尚"
"未被处理的CCB返回到CAM队列， 然后为有问题的CCB设置这个旗标并调用 "
"<function>xpt_done()</function>。这个旗标会使得CAM子系统处理错误后 解冻队列。"

#. (itstool) path: listitem/para
#: book.translate.xml:19948
msgid ""
"<emphasis>CAM_AUTOSNS_VALID</emphasis> - if the device returned an error "
"condition and the flag CAM_DIS_AUTOSENSE is not set in CCB the SIM driver "
"must execute the REQUEST SENSE command automatically to extract the sense "
"(extended error information) data from the device. If this attempt was "
"successful the sense data should be saved in the CCB and this flag set."
msgstr ""
"<emphasis>CAM_AUTOSNS_VALID</emphasis> - 如果设备 返回错误条件，且CCB中未设置"
"旗标CAM_DIS_AUTOSENSE，SIM驱动程序 必须自动执行REQUEST SENSE命令来从设备抽取"
"sense（扩展错误信息） 数据。如果这个尝试成功，sense数据应当被保存在CCB中且设"
"置此旗标。"

#. (itstool) path: listitem/para
#: book.translate.xml:19958
msgid ""
"<emphasis>CAM_RELEASE_SIMQ</emphasis> - like CAM_DEV_QFRZN but used in case "
"there is some problem (or resource shortage) with the SCSI controller "
"itself. Then all the future requests to the controller should be stopped by "
"<function>xpt_freeze_simq()</function>. The controller queue will be "
"restarted after the SIM driver overcomes the shortage and informs CAM by "
"returning some CCB with this flag set."
msgstr ""
"<emphasis>CAM_RELEASE_SIMQ</emphasis> - 类似于 CAM_DEV_QFRZN，但用于SCSI控制"
"器自身出问题(或资源短缺)的情况。 此后对控制器的所有请求会被"
"<function>xpt_freeze_simq()</function> 停止。SIM驱动程序克服这种短缺情况，并"
"通过返回设置了此旗标的CCB 通知CAM后，控制器队列将会被重新启动。"

#. (itstool) path: listitem/para
#: book.translate.xml:19969
msgid ""
"<emphasis>CAM_SIM_QUEUED</emphasis> - when SIM puts a CCB into its request "
"queue this flag should be set (and removed when this CCB gets dequeued "
"before being returned back to CAM). This flag is not used anywhere in the "
"CAM code now, so its purpose is purely diagnostic."
msgstr ""
"<emphasis>CAM_SIM_QUEUED</emphasis> - 当SIM将一个 CCB放入其请求队列时应当设置"
"此旗标（或当CCB出队但尚未返回给CAM时 去掉）。现在此旗标还没有在CAM代码的任何"
"地方使用过，因此其目的 纯粹用于诊断）。"

#. (itstool) path: listitem/para
#: book.translate.xml:19977
msgid "<emphasis>CAM_QOS_VALID</emphasis> - The QOS data is now valid."
msgstr ""

#. (itstool) path: sect1/para
#: book.translate.xml:19982
msgid ""
"The function <function>xxx_action()</function> is not allowed to sleep, so "
"all the synchronization for resource access must be done using SIM or device "
"queue freezing. Besides the aforementioned flags the CAM subsystem provides "
"functions <function>xpt_release_simq()</function> and "
"<function>xpt_release_devq()</function> to unfreeze the queues directly, "
"without passing a CCB to CAM."
msgstr ""
"函数<function>xxx_action()</function>不允许睡眠，因此对资源 访问的所有同步必"
"须通过冻结SIM或设备队列来完成。除了前述的旗标外， CAM子系统提供了函数"
"<function>xpt_release_simq()</function>和 <function>xpt_release_devq()</"
"function>来直接解冻队列，而不必将 CCB传递到CAM。"

#. (itstool) path: sect1/para
#: book.translate.xml:19990
msgid "The CCB header contains the following fields:"
msgstr "CCB头部包含如下字段："

#. (itstool) path: listitem/para
#: book.translate.xml:19994
msgid "<emphasis>path</emphasis> - path ID for the request"
msgstr "<emphasis>path</emphasis> - 请求的路径ID"

#. (itstool) path: listitem/para
#: book.translate.xml:19999
msgid "<emphasis>target_id</emphasis> - target device ID for the request"
msgstr "<emphasis>target_id</emphasis> - 请求的目标设备ID"

#. (itstool) path: listitem/para
#: book.translate.xml:20004
msgid "<emphasis>target_lun</emphasis> - LUN ID of the target device"
msgstr "<emphasis>target_lun</emphasis> - 目标设备的LUN ID"

#. (itstool) path: listitem/para
#: book.translate.xml:20009
msgid ""
"<emphasis>timeout</emphasis> - timeout interval for this command, in "
"milliseconds"
msgstr "<emphasis>timeout</emphasis> - 这个命令的超时间隔，以毫秒计"

#. (itstool) path: listitem/para
#: book.translate.xml:20014
msgid ""
"<emphasis>timeout_ch</emphasis> - a convenience place for the SIM driver to "
"store the timeout handle (the CAM subsystem itself does not make any "
"assumptions about it)"
msgstr ""
"<emphasis>timeout_ch</emphasis> - 一个为SIM驱动 程序存储超时处理函数的方便之"
"所（CAM子系统自身并不对此作任何假设）"

#. (itstool) path: listitem/para
#: book.translate.xml:20021
msgid ""
"<emphasis>flags</emphasis> - various bits of information about the request "
"spriv_ptr0, spriv_ptr1 - fields reserved for private use by the SIM driver "
"(such as linking to the SIM queues or SIM private control blocks); actually, "
"they exist as unions: spriv_ptr0 and spriv_ptr1 have the type (void *), "
"spriv_field0 and spriv_field1 have the type unsigned long, sim_priv."
"entries[0].bytes and sim_priv.entries[1].bytes are byte arrays of the size "
"consistent with the other incarnations of the union and sim_priv.bytes is "
"one array, twice bigger."
msgstr "<emphasis>flags</emphasis> - 有关请求的各个 信息位"

#. (itstool) path: sect1/para
#: book.translate.xml:20034
msgid ""
"The recommended way of using the SIM private fields of CCB is to define some "
"meaningful names for them and use these meaningful names in the driver, like:"
msgstr ""
"使用CCB的SIM私有字段的建议方法是为它们定义一些有意义的名字， 并且在驱动程序中"
"使用这些有意义的名字，就像下面这样："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:20038
#, no-wrap
msgid ""
"#define ccb_some_meaningful_name    sim_priv.entries[0].bytes\n"
"#define ccb_hcb spriv_ptr1 /* for hardware control block */"
msgstr ""
"#define ccb_some_meaningful_name    sim_priv.entries[0].bytes\n"
"#define ccb_hcb spriv_ptr1 /* for hardware control block */"

#. (itstool) path: sect1/para
#: book.translate.xml:20041
msgid "The most common initiator mode requests are:"
msgstr "最常见的发起者模式的请求是："

#. (itstool) path: listitem/para
#: book.translate.xml:20045
msgid "<emphasis>XPT_SCSI_IO</emphasis> - execute an I/O transaction"
msgstr "<emphasis>XPT_SCSI_IO</emphasis> - 执行I/O事务"

#. (itstool) path: listitem/para
#: book.translate.xml:20048
msgid ""
"The instance <quote>struct ccb_scsiio csio</quote> of the union ccb is used "
"to transfer the arguments. They are:"
msgstr ""
"联合ccb的<quote>struct ccb_scsiio csio</quote>实例用于传递参量。 它们是："

#. (itstool) path: listitem/para
#: book.translate.xml:20054
msgid ""
"<emphasis>cdb_io</emphasis> - pointer to the SCSI command buffer or the "
"buffer itself"
msgstr "<emphasis>cdb_io</emphasis> - 指向SCSI命令缓冲区的指针或缓冲区本身"

#. (itstool) path: listitem/para
#: book.translate.xml:20059
msgid "<emphasis>cdb_len</emphasis> - SCSI command length"
msgstr "<emphasis>cdb_len</emphasis> - SCSI 命令长度"

#. (itstool) path: listitem/para
#: book.translate.xml:20064
msgid ""
"<emphasis>data_ptr</emphasis> - pointer to the data buffer (gets a bit "
"complicated if scatter/gather is used)"
msgstr ""
"<emphasis>data_ptr</emphasis> - 指向数据缓冲区的指针（如果使用分散/集中会复杂"
"一点）"

#. (itstool) path: listitem/para
#: book.translate.xml:20070
msgid "<emphasis>dxfer_len</emphasis> - length of the data to transfer"
msgstr "<emphasis>dxfer_len</emphasis> - 待传输数据的长度"

#. (itstool) path: listitem/para
#: book.translate.xml:20075
msgid ""
"<emphasis>sglist_cnt</emphasis> - counter of the scatter/gather segments"
msgstr "<emphasis>sglist_cnt</emphasis> - 分散/集中段的计数"

#. (itstool) path: listitem/para
#: book.translate.xml:20080
msgid "<emphasis>scsi_status</emphasis> - place to return the SCSI status"
msgstr "<emphasis>scsi_status</emphasis> - 返回SCSI状态的地方"

#. (itstool) path: listitem/para
#: book.translate.xml:20085
msgid ""
"<emphasis>sense_data</emphasis> - buffer for the SCSI sense information if "
"the command returns an error (the SIM driver is supposed to run the REQUEST "
"SENSE command automatically in this case if the CCB flag CAM_DIS_AUTOSENSE "
"is not set)"
msgstr ""
"<emphasis>sense_data</emphasis> - 命令返回错误时保存SCSI sense信息的缓冲区"
"（这种情况下，如果没有 设置CCB的旗标CAM_DIS_AUTOSENSE，则假定SIM驱动程序会自"
"动运行 REQUEST SENSE命令）"

#. (itstool) path: listitem/para
#: book.translate.xml:20093
msgid ""
"<emphasis>sense_len</emphasis> - the length of that buffer (if it happens to "
"be higher than size of sense_data the SIM driver must silently assume the "
"smaller value) resid, sense_resid - if the transfer of data or SCSI sense "
"returned an error these are the returned counters of the residual (not "
"transferred) data. They do not seem to be especially meaningful, so in a "
"case when they are difficult to compute (say, counting bytes in the SCSI "
"controller's FIFO buffer) an approximate value will do as well. For a "
"successfully completed transfer they must be set to zero."
msgstr ""
"<emphasis>sense_len</emphasis> - 缓冲区的长度（如果碰巧大于sense_data的大小，"
"SIM驱动程序必须 悄悄地采用较小值）（译注：一点改动，参考原文及代码）"

#. (itstool) path: listitem/para
#: book.translate.xml:20108
msgid "<emphasis>tag_action</emphasis> - the kind of tag to use:"
msgstr "<emphasis>tag_action</emphasis> - 使用的标签的种类有："

#. (itstool) path: listitem/para
#: book.translate.xml:20113
msgid "CAM_TAG_ACTION_NONE - do not use tags for this transaction"
msgstr "CAM_TAG_ACTION_NONE - 事务不使用标签"

#. (itstool) path: listitem/para
#: book.translate.xml:20118
msgid ""
"MSG_SIMPLE_Q_TAG, MSG_HEAD_OF_Q_TAG, MSG_ORDERED_Q_TAG - value equal to the "
"appropriate tag message (see /sys/cam/scsi/scsi_message.h); this gives only "
"the tag type, the SIM driver must assign the tag value itself"
msgstr ""
"MSG_SIMPLE_Q_TAG, MSG_HEAD_OF_Q_TAG, MSG_ORDERED_Q_TAG - 值等于适当的标签信"
"息 （见/sys/cam/scsi/scsi_message.h）；仅给出标签类型，SIM驱动程序 必须自己赋"
"标签值"

#. (itstool) path: listitem/para
#: book.translate.xml:20128
msgid "The general logic of handling this request is the following:"
msgstr "处理请求的通常逻辑如下："

#. (itstool) path: listitem/para
#: book.translate.xml:20131
msgid ""
"The first thing to do is to check for possible races, to make sure that the "
"command did not get aborted when it was sitting in the queue:"
msgstr ""
"要做的第一件事情是检查可能的竞争条件，确保命令位于队列中时 不会被中止："

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20135
#, no-wrap
msgid ""
"    struct ccb_scsiio *csio = &amp;ccb-&gt;csio;\n"
"\n"
"    if ((ccb_h-&gt;status &amp; CAM_STATUS_MASK) != CAM_REQ_INPROG) {\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"
msgstr ""
"    struct ccb_scsiio *csio = &amp;ccb-&gt;csio;\n"
"\n"
"    if ((ccb_h-&gt;status &amp; CAM_STATUS_MASK) != CAM_REQ_INPROG) {\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"

#. (itstool) path: listitem/para
#: book.translate.xml:20142
msgid "Also we check that the device is supported at all by our controller:"
msgstr "我们也检查我们的控制器完全支持设备："

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20145
#, no-wrap
msgid ""
"    if(ccb_h-&gt;target_id &gt; OUR_MAX_SUPPORTED_TARGET_ID\n"
"    || cch_h-&gt;target_id == OUR_SCSI_CONTROLLERS_OWN_ID) {\n"
"        ccb_h-&gt;status = CAM_TID_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"    if(ccb_h-&gt;target_lun &gt; OUR_MAX_SUPPORTED_LUN) {\n"
"        ccb_h-&gt;status = CAM_LUN_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"
msgstr ""
"    if(ccb_h-&gt;target_id &gt; OUR_MAX_SUPPORTED_TARGET_ID\n"
"    || cch_h-&gt;target_id == OUR_SCSI_CONTROLLERS_OWN_ID) {\n"
"        ccb_h-&gt;status = CAM_TID_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"    if(ccb_h-&gt;target_lun &gt; OUR_MAX_SUPPORTED_LUN) {\n"
"        ccb_h-&gt;status = CAM_LUN_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"

#. (itstool) path: para/indexterm
#: book.translate.xml:20159
msgid "<primary>hardware control block</primary>"
msgstr "<primary>hardware control block(硬件控制块)</primary>"

#. (itstool) path: listitem/para
#: book.translate.xml:20157
msgid ""
"Then allocate whatever data structures (such as card-dependent hardware "
"control block<_:indexterm-1/>) we need to process this request. If we can "
"not then freeze the SIM queue and remember that we have a pending operation, "
"return the CCB back and ask CAM to re-queue it. Later when the resources "
"become available the SIM queue must be unfrozen by returning a ccb with the "
"<literal>CAM_SIMQ_RELEASE</literal> bit set in its status. Otherwise, if all "
"went well, link the CCB with the hardware control block (HCB) and mark it as "
"queued."
msgstr ""
"然后分配我们处理请求所需的数据结构（如卡相关的硬件控制块等）。 如果我们不能分"
"配则冻结SIM队列，记录下我们有一个挂起的操作，返回 CCB，请求CAM将CCB重新入队。"
"以后当资源可用时，必须通过返回其 状态中设置 <literal>CAM_SIMQ_RELEASE</"
"literal> 位的ccb来解冻SIM队列。否则，如果所有 正常，则将CCB与硬件控制块"
"（HCB）链接，并将其标志为已入队。"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20170
#, no-wrap
msgid ""
"    struct xxx_hcb *hcb = allocate_hcb(softc, unit, bus);\n"
"\n"
"    if(hcb == NULL) {\n"
"        softc-&gt;flags |= RESOURCE_SHORTAGE;\n"
"        xpt_freeze_simq(sim, /*count*/1);\n"
"        ccb_h-&gt;status = CAM_REQUEUE_REQ;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"\n"
"    hcb-&gt;ccb = ccb; ccb_h-&gt;ccb_hcb = (void *)hcb;\n"
"    ccb_h-&gt;status |= CAM_SIM_QUEUED;"
msgstr ""
"    struct xxx_hcb *hcb = allocate_hcb(softc, unit, bus);\n"
"\n"
"    if(hcb == NULL) {\n"
"        softc-&gt;flags |= RESOURCE_SHORTAGE;\n"
"        xpt_freeze_simq(sim, /*count*/1);\n"
"        ccb_h-&gt;status = CAM_REQUEUE_REQ;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"\n"
"    hcb-&gt;ccb = ccb; ccb_h-&gt;ccb_hcb = (void *)hcb;\n"
"    ccb_h-&gt;status |= CAM_SIM_QUEUED;"

#. (itstool) path: listitem/para
#: book.translate.xml:20183
msgid ""
"Extract the target data from CCB into the hardware control block. Check if "
"we are asked to assign a tag and if yes then generate an unique tag and "
"build the SCSI tag messages. The SIM driver is also responsible for "
"negotiations with the devices to set the maximal mutually supported bus "
"width, synchronous rate and offset."
msgstr ""
"从CCB中提取目标数据到硬件控制块。检查是否要求我们分配一个 标签，如果是则产生"
"一个唯一的标签并构造SCSI标签信息。SIM驱动程序 也负责与设备协商设定彼此支持的"
"最大总线宽度、同步速率和偏移。"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20190
#, no-wrap
msgid ""
"    hcb-&gt;target = ccb_h-&gt;target_id; hcb-&gt;lun = ccb_h-&gt;target_lun;\n"
"    generate_identify_message(hcb);\n"
"    if( ccb_h-&gt;tag_action != CAM_TAG_ACTION_NONE )\n"
"        generate_unique_tag_message(hcb, ccb_h-&gt;tag_action);\n"
"    if( !target_negotiated(hcb) )\n"
"        generate_negotiation_messages(hcb);"
msgstr ""
"    hcb-&gt;target = ccb_h-&gt;target_id; hcb-&gt;lun = ccb_h-&gt;target_lun;\n"
"    generate_identify_message(hcb);\n"
"    if( ccb_h-&gt;tag_action != CAM_TAG_ACTION_NONE )\n"
"        generate_unique_tag_message(hcb, ccb_h-&gt;tag_action);\n"
"    if( !target_negotiated(hcb) )\n"
"        generate_negotiation_messages(hcb);"

#. (itstool) path: listitem/para
#: book.translate.xml:20197
#, fuzzy
msgid ""
"Then set up the SCSI command. The command storage may be specified in the "
"CCB in many interesting ways, specified by the CCB flags. The command buffer "
"can be contained in CCB or pointed to, in the latter case the pointer may be "
"physical or virtual. Since the hardware commonly needs physical address we "
"always convert the address to the physical one, typically using the busdma "
"API."
msgstr ""
"然后设置SCSI命令。可以在CCB中以多种有趣的方式指定命令的存储， 这些方式由CCB中"
"的旗标指定。命令缓冲区可以包含在CCB中或者用指针 指向，后者情况下指针可以指向"
"物理地址或虚地址。由于硬件通常需要 物理地址，因此我们总是将地址转换为物理地"
"址。"

#. (itstool) path: listitem/para
#: book.translate.xml:20205
msgid ""
"In case if a physical address is requested it is OK to return the CCB with "
"the status <errorname>CAM_REQ_INVALID</errorname>, the current drivers do "
"that. If necessary a physical address can be also converted or mapped back "
"to a virtual address but with big pain, so we do not do that."
msgstr ""
"在请求物理地址的情况下，返回带有状态 <errorname>CAM_REQ_INVALID</errorname> "
"的CCB是可以的，当前的驱动程序就是那样做的。但也 可能像这个例子（驱动程序中应"
"当有不带条件编译的更直接做法）中那样 编译Alpha特定的代码片断。如果需要物理地"
"址也能转换或映射回虚地址， 但那样代价很大，因此我们不那样做。"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20212
#, no-wrap
msgid ""
"    if(ccb_h-&gt;flags &amp; CAM_CDB_POINTER) {\n"
"        /* CDB is a pointer */\n"
"        if(!(ccb_h-&gt;flags &amp; CAM_CDB_PHYS)) {\n"
"            /* CDB pointer is virtual */\n"
"            hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_ptr);\n"
"        } else {\n"
"            /* CDB pointer is physical */\n"
"            hcb-&gt;cmd = csio-&gt;cdb_io.cdb_ptr ;\n"
"        }\n"
"    } else {\n"
"        /* CDB is in the ccb (buffer) */\n"
"        hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_bytes);\n"
"    }\n"
"    hcb-&gt;cmdlen = csio-&gt;cdb_len;"
msgstr ""
"    if(ccb_h-&gt;flags &amp; CAM_CDB_POINTER) {\n"
"        /* CDB is a pointer */\n"
"        if(!(ccb_h-&gt;flags &amp; CAM_CDB_PHYS)) {\n"
"            /* CDB pointer is virtual */\n"
"            hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_ptr);\n"
"        } else {\n"
"            /* CDB pointer is physical */\n"
"            hcb-&gt;cmd = csio-&gt;cdb_io.cdb_ptr ;\n"
"        }\n"
"    } else {\n"
"        /* CDB is in the ccb (buffer) */\n"
"        hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_bytes);\n"
"    }\n"
"    hcb-&gt;cmdlen = csio-&gt;cdb_len;"

#. (itstool) path: listitem/para
#: book.translate.xml:20227
msgid ""
"Now it is time to set up the data. Again, the data storage may be specified "
"in the CCB in many interesting ways, specified by the CCB flags. First we "
"get the direction of the data transfer. The simplest case is if there is no "
"data to transfer:"
msgstr ""
"现在是设置数据的时候了，又一次，可以在CCB中以多种有趣的方式 指定数据存储，这"
"些方式由CCB中的旗标指定。首先我们得到数据传输的 方向。最简单的情况是没有数据"
"需要传输的情况："

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20233
#, no-wrap
msgid ""
"    int dir = (ccb_h-&gt;flags &amp; CAM_DIR_MASK);\n"
"\n"
"    if (dir == CAM_DIR_NONE)\n"
"        goto end_data;"
msgstr ""
"    int dir = (ccb_h-&gt;flags &amp; CAM_DIR_MASK);\n"
"\n"
"    if (dir == CAM_DIR_NONE)\n"
"        goto end_data;"

#. (itstool) path: listitem/para
#: book.translate.xml:20238
msgid ""
"Then we check if the data is in one chunk or in a scatter-gather list, and "
"the addresses are physical or virtual. The SCSI controller may be able to "
"handle only a limited number of chunks of limited length. If the request "
"hits this limitation we return an error. We use a special function to return "
"the CCB to handle in one place the HCB resource shortages. The functions to "
"add chunks are driver-dependent, and here we leave them without detailed "
"implementation. See description of the SCSI command (CDB) handling for the "
"details on the address-translation issues. If some variation is too "
"difficult or impossible to implement with a particular card it is OK to "
"return the status <errorname>CAM_REQ_INVALID</errorname>. Actually, it seems "
"like the scatter-gather ability is not used anywhere in the CAM code now. "
"But at least the case for a single non-scattered virtual buffer must be "
"implemented, it is actively used by CAM."
msgstr ""
"然后我们检查数据在一个chunk中还是在分散/集中列表中，并且是 物理地址还是虚地"
"址。SCSI控制器可能只能处理有限数目有限长度的 大块。如果请求到达到这个限制我们"
"就返回错误。我们使用一个特殊 函数返回CCB，并在一个地方处理HCB资源短缺。增加"
"chunk的函数是 驱动程序相关的，此处我们不进入它们的详细实现。对于地址翻译问题 "
"的细节可以参看SCSI命令(CDB)处理的描述。如果某些变体对于特定的卡 太困难或不可"
"能实现，返回状态 <errorname>CAM_REQ_INVALID</errorname> 是可以的。实际上， 现"
"在的CAM代码中似乎哪儿也没有使用分散/集中能力。但至少必须实现 单个非分散虚拟缓"
"冲区的情况，CAM中这种情况用得很多。"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20256
#, no-wrap
msgid ""
"    int rv;\n"
"\n"
"    initialize_hcb_for_data(hcb);\n"
"\n"
"    if((!(ccb_h-&gt;flags &amp; CAM_SCATTER_VALID)) {\n"
"        /* single buffer */\n"
"        if(!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {\n"
"            rv = add_virtual_chunk(hcb, csio-&gt;data_ptr, csio-&gt;dxfer_len, dir);\n"
"            }\n"
"        } else {\n"
"            rv = add_physical_chunk(hcb, csio-&gt;data_ptr, csio-&gt;dxfer_len, dir);\n"
"        }\n"
"    } else {\n"
"        int i;\n"
"        struct bus_dma_segment *segs;\n"
"        segs = (struct bus_dma_segment *)csio-&gt;data_ptr;\n"
"\n"
"        if ((ccb_h-&gt;flags &amp; CAM_SG_LIST_PHYS) != 0) {\n"
"            /* The SG list pointer is physical */\n"
"            rv = setup_hcb_for_physical_sg_list(hcb, segs, csio-&gt;sglist_cnt);\n"
"        } else if (!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {\n"
"            /* SG buffer pointers are virtual */\n"
"            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {\n"
"                rv = add_virtual_chunk(hcb, segs[i].ds_addr,\n"
"                    segs[i].ds_len, dir);\n"
"                if (rv != CAM_REQ_CMP)\n"
"                    break;\n"
"            }\n"
"        } else {\n"
"            /* SG buffer pointers are physical */\n"
"            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {\n"
"                rv = add_physical_chunk(hcb, segs[i].ds_addr,\n"
"                    segs[i].ds_len, dir);\n"
"                if (rv != CAM_REQ_CMP)\n"
"                    break;\n"
"            }\n"
"        }\n"
"    }\n"
"    if(rv != CAM_REQ_CMP) {\n"
"        /* we expect that add_*_chunk() functions return CAM_REQ_CMP\n"
"         * if they added a chunk successfully, CAM_REQ_TOO_BIG if\n"
"         * the request is too big (too many bytes or too many chunks),\n"
"         * CAM_REQ_INVALID in case of other troubles\n"
"         */\n"
"        free_hcb_and_ccb_done(hcb, ccb, rv);\n"
"        return;\n"
"    }\n"
"    end_data:"
msgstr ""
"    int rv;\n"
"\n"
"    initialize_hcb_for_data(hcb);\n"
"\n"
"    if((!(ccb_h-&gt;flags &amp; CAM_SCATTER_VALID)) {\n"
"        /* single buffer */\n"
"        if(!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {\n"
"            rv = add_virtual_chunk(hcb, csio-&gt;data_ptr, csio-&gt;dxfer_len, dir);\n"
"            }\n"
"        } else {\n"
"            rv = add_physical_chunk(hcb, csio-&gt;data_ptr, csio-&gt;dxfer_len, dir);\n"
"        }\n"
"    } else {\n"
"        int i;\n"
"        struct bus_dma_segment *segs;\n"
"        segs = (struct bus_dma_segment *)csio-&gt;data_ptr;\n"
"\n"
"        if ((ccb_h-&gt;flags &amp; CAM_SG_LIST_PHYS) != 0) {\n"
"            /* The SG list pointer is physical */\n"
"            rv = setup_hcb_for_physical_sg_list(hcb, segs, csio-&gt;sglist_cnt);\n"
"        } else if (!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {\n"
"            /* SG buffer pointers are virtual */\n"
"            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {\n"
"                rv = add_virtual_chunk(hcb, segs[i].ds_addr,\n"
"                    segs[i].ds_len, dir);\n"
"                if (rv != CAM_REQ_CMP)\n"
"                    break;\n"
"            }\n"
"        } else {\n"
"            /* SG buffer pointers are physical */\n"
"            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {\n"
"                rv = add_physical_chunk(hcb, segs[i].ds_addr,\n"
"                    segs[i].ds_len, dir);\n"
"                if (rv != CAM_REQ_CMP)\n"
"                    break;\n"
"            }\n"
"        }\n"
"    }\n"
"    if(rv != CAM_REQ_CMP) {\n"
"        /* we expect that add_*_chunk() functions return CAM_REQ_CMP\n"
"         * if they added a chunk successfully, CAM_REQ_TOO_BIG if\n"
"         * the request is too big (too many bytes or too many chunks),\n"
"         * CAM_REQ_INVALID in case of other troubles\n"
"         */\n"
"        free_hcb_and_ccb_done(hcb, ccb, rv);\n"
"        return;\n"
"    }\n"
"    end_data:"

#. (itstool) path: listitem/para
#: book.translate.xml:20305
msgid ""
"If disconnection is disabled for this CCB we pass this information to the "
"hcb:"
msgstr "如果这个CCB不允许断开连接，我们就传递这个信息到hcb："

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20308
#, no-wrap
msgid ""
"    if(ccb_h-&gt;flags &amp; CAM_DIS_DISCONNECT)\n"
"        hcb_disable_disconnect(hcb);"
msgstr ""
"    if(ccb_h-&gt;flags &amp; CAM_DIS_DISCONNECT)\n"
"        hcb_disable_disconnect(hcb);"

#. (itstool) path: listitem/para
#: book.translate.xml:20311
msgid ""
"If the controller is able to run REQUEST SENSE command all by itself then "
"the value of the flag CAM_DIS_AUTOSENSE should also be passed to it, to "
"prevent automatic REQUEST SENSE if the CAM subsystem does not want it."
msgstr ""
"如果控制器能够完全自己运行REQUEST SENSE命令，则也应当将旗标 CAM_DIS_AUTOSENSE"
"的值传递给它，这样可以在CAM子系统不想REQUEST SENSE 时阻止自动REQUEST SENSE。"

#. (itstool) path: listitem/para
#: book.translate.xml:20316
msgid ""
"The only thing left is to set up the timeout, pass our hcb to the hardware "
"and return, the rest will be done by the interrupt handler (or timeout "
"handler)."
msgstr ""
"剩下的唯一事情是设置超时，将我们的hcb传递给硬件并返回，余下的 由中断处理函数"
"（或超时处理函数）完成。"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20320
#, no-wrap
msgid ""
"    ccb_h-&gt;timeout_ch = timeout(xxx_timeout, (caddr_t) hcb,\n"
"        (ccb_h-&gt;timeout * hz) / 1000); /* convert milliseconds to ticks */\n"
"    put_hcb_into_hardware_queue(hcb);\n"
"    return;"
msgstr ""
"    ccb_h-&gt;timeout_ch = timeout(xxx_timeout, (caddr_t) hcb,\n"
"        (ccb_h-&gt;timeout * hz) / 1000); /* convert milliseconds to ticks */\n"
"    put_hcb_into_hardware_queue(hcb);\n"
"    return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20325
msgid "And here is a possible implementation of the function returning CCB:"
msgstr "这儿是返回CCB的函数的一个可能实现："

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20328
#, no-wrap
msgid ""
"    static void\n"
"    free_hcb_and_ccb_done(struct xxx_hcb *hcb, union ccb *ccb, u_int32_t status)\n"
"    {\n"
"        struct xxx_softc *softc = hcb-&gt;softc;\n"
"\n"
"        ccb-&gt;ccb_h.ccb_hcb = 0;\n"
"        if(hcb != NULL) {\n"
"            untimeout(xxx_timeout, (caddr_t) hcb, ccb-&gt;ccb_h.timeout_ch);\n"
"            /* we're about to free a hcb, so the shortage has ended */\n"
"            if(softc-&gt;flags &amp; RESOURCE_SHORTAGE)  {\n"
"                softc-&gt;flags &amp;= ~RESOURCE_SHORTAGE;\n"
"                status |= CAM_RELEASE_SIMQ;\n"
"            }\n"
"            free_hcb(hcb); /* also removes hcb from any internal lists */\n"
"        }\n"
"        ccb-&gt;ccb_h.status = status |\n"
"            (ccb-&gt;ccb_h.status &amp; ~(CAM_STATUS_MASK|CAM_SIM_QUEUED));\n"
"        xpt_done(ccb);\n"
"    }"
msgstr ""
"    static void\n"
"    free_hcb_and_ccb_done(struct xxx_hcb *hcb, union ccb *ccb, u_int32_t status)\n"
"    {\n"
"        struct xxx_softc *softc = hcb-&gt;softc;\n"
"\n"
"        ccb-&gt;ccb_h.ccb_hcb = 0;\n"
"        if(hcb != NULL) {\n"
"            untimeout(xxx_timeout, (caddr_t) hcb, ccb-&gt;ccb_h.timeout_ch);\n"
"            /* we're about to free a hcb, so the shortage has ended */\n"
"            if(softc-&gt;flags &amp; RESOURCE_SHORTAGE)  {\n"
"                softc-&gt;flags &amp;= ~RESOURCE_SHORTAGE;\n"
"                status |= CAM_RELEASE_SIMQ;\n"
"            }\n"
"            free_hcb(hcb); /* also removes hcb from any internal lists */\n"
"        }\n"
"        ccb-&gt;ccb_h.status = status |\n"
"            (ccb-&gt;ccb_h.status &amp; ~(CAM_STATUS_MASK|CAM_SIM_QUEUED));\n"
"        xpt_done(ccb);\n"
"    }"

#. (itstool) path: listitem/para
#: book.translate.xml:20350
msgid ""
"<emphasis>XPT_RESET_DEV</emphasis> - send the SCSI <quote>BUS DEVICE RESET</"
"quote> message to a device"
msgstr ""
"<emphasis>XPT_RESET_DEV</emphasis> - 发送SCSI <quote>BUS DEVICE RESET</quote>"
"消息到设备"

#. (itstool) path: listitem/para
#: book.translate.xml:20353
msgid ""
"There is no data transferred in CCB except the header and the most "
"interesting argument of it is target_id. Depending on the controller "
"hardware a hardware control block just like for the XPT_SCSI_IO request may "
"be constructed (see XPT_SCSI_IO request description) and sent to the "
"controller or the SCSI controller may be immediately programmed to send this "
"RESET message to the device or this request may be just not supported (and "
"return the status <errorname>CAM_REQ_INVALID</errorname>). Also on "
"completion of the request all the disconnected transactions for this target "
"must be aborted (probably in the interrupt routine)."
msgstr ""
"除了头部外CCB中没有数据传输，其中最让人感兴趣的参量为target_id。 依赖于控制器"
"硬件，硬件控制块就像XPT_SCSI_IO请求中那样被创建 （参看XPT_SCSI_IO请求的描述）"
"并被发送到控制器，或者立即编程让SCSI 控制器发送RESET消息到设备，或者这个请求"
"可能只是不被支持 （并返回状态 <errorname>CAM_REQ_INVALID</errorname>）。而且"
"请求完成时，目标的所有已断开 连接(disconnected)的事务必须被中止（可能在中断例"
"程中）。"

#. (itstool) path: listitem/para
#: book.translate.xml:20366
msgid ""
"Also all the current negotiations for the target are lost on reset, so they "
"might be cleaned too. Or they clearing may be deferred, because anyway the "
"target would request re-negotiation on the next transaction."
msgstr ""
"而且目标的所有当前协商在复位时会丢失，因此它们也可能被清除。 或者清除可能被延"
"迟，因为不管怎样目标将会在下一次事务时请求重新协商。"

#. (itstool) path: listitem/para
#: book.translate.xml:20374
msgid ""
"<emphasis>XPT_RESET_BUS</emphasis> - send the RESET signal to the SCSI bus"
msgstr "<emphasis>XPT_RESET_BUS</emphasis> - 发送RESET信号到SCSI总线"

#. (itstool) path: listitem/para
#: book.translate.xml:20377
msgid ""
"No arguments are passed in the CCB, the only interesting argument is the "
"SCSI bus indicated by the struct sim pointer."
msgstr ""
"CCB中并不传递参量，唯一感兴趣的参量是由指向结构sim的指针标识 的SCSI总线。"

#. (itstool) path: listitem/para
#: book.translate.xml:20381
msgid ""
"A minimalistic implementation would forget the SCSI negotiations for all the "
"devices on the bus and return the status CAM_REQ_CMP."
msgstr "最小实现会忘记总线上所有设备的SCSI协商，并返回状态 CAM_REQ_CMP。"

#. (itstool) path: listitem/para
#: book.translate.xml:20385
msgid ""
"The proper implementation would in addition actually reset the SCSI bus "
"(possible also reset the SCSI controller) and mark all the CCBs being "
"processed, both those in the hardware queue and those being disconnected, as "
"done with the status CAM_SCSI_BUS_RESET. Like:"
msgstr ""
"恰当的实现实际上会另外复位SCSI总线（可能也复位SCSI控制器）并 将所有在硬件队列"
"中的和断开连接的那些正被处理的CCB的完成状态标记为 CAM_SCSI_BUS_RESET。像这"
"样："

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20391
#, no-wrap
msgid ""
"    int targ, lun;\n"
"    struct xxx_hcb *h, *hh;\n"
"    struct ccb_trans_settings neg;\n"
"    struct cam_path *path;\n"
"\n"
"    /* The SCSI bus reset may take a long time, in this case its completion\n"
"     * should be checked by interrupt or timeout. But for simplicity\n"
"     * we assume here that it is really fast.\n"
"     */\n"
"    reset_scsi_bus(softc);\n"
"\n"
"    /* drop all enqueued CCBs */\n"
"    for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"        hh = h-&gt;next;\n"
"        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"    }\n"
"\n"
"    /* the clean values of negotiations to report */\n"
"    neg.bus_width = 8;\n"
"    neg.sync_period = neg.sync_offset = 0;\n"
"    neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"        | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"\n"
"    /* drop all disconnected CCBs and clean negotiations  */\n"
"    for(targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {\n"
"        clean_negotiations(softc, targ);\n"
"\n"
"        /* report the event if possible */\n"
"        if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                cam_sim_path(sim), targ,\n"
"                CAM_LUN_WILDCARD) == CAM_REQ_CMP) {\n"
"            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"            xpt_free_path(path);\n"
"        }\n"
"\n"
"        for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"            for(h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h = hh) {\n"
"                hh=h-&gt;next;\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"            }\n"
"    }\n"
"\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"\n"
"    /* report the event */\n"
"    xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);\n"
"    return;"
msgstr ""
"    int targ, lun;\n"
"    struct xxx_hcb *h, *hh;\n"
"    struct ccb_trans_settings neg;\n"
"    struct cam_path *path;\n"
"\n"
"    /* The SCSI bus reset may take a long time, in this case its completion\n"
"     * should be checked by interrupt or timeout. But for simplicity\n"
"     * we assume here that it is really fast.\n"
"     */\n"
"    reset_scsi_bus(softc);\n"
"\n"
"    /* drop all enqueued CCBs */\n"
"    for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"        hh = h-&gt;next;\n"
"        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"    }\n"
"\n"
"    /* the clean values of negotiations to report */\n"
"    neg.bus_width = 8;\n"
"    neg.sync_period = neg.sync_offset = 0;\n"
"    neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"        | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"\n"
"    /* drop all disconnected CCBs and clean negotiations  */\n"
"    for(targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {\n"
"        clean_negotiations(softc, targ);\n"
"\n"
"        /* report the event if possible */\n"
"        if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                cam_sim_path(sim), targ,\n"
"                CAM_LUN_WILDCARD) == CAM_REQ_CMP) {\n"
"            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"            xpt_free_path(path);\n"
"        }\n"
"\n"
"        for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"            for(h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h = hh) {\n"
"                hh=h-&gt;next;\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"            }\n"
"    }\n"
"\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"\n"
"    /* report the event */\n"
"    xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);\n"
"    return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20440
msgid ""
"Implementing the SCSI bus reset as a function may be a good idea because it "
"would be re-used by the timeout function as a last resort if the things go "
"wrong."
msgstr ""
"将SCSI总线复位作为函数来实现可能是个好主意，因为如果事情出了差错， 它会被超时"
"函数作为最后的报告来重用。"

#. (itstool) path: listitem/para
#: book.translate.xml:20447
msgid "<emphasis>XPT_ABORT</emphasis> - abort the specified CCB"
msgstr "<emphasis>XPT_ABORT</emphasis> - 中止指定的CCB"

#. (itstool) path: listitem/para
#: book.translate.xml:20450
msgid ""
"The arguments are transferred in the instance <quote>struct ccb_abort cab</"
"quote> of the union ccb. The only argument field in it is:"
msgstr ""
"参量在联合ccb的实例<quote>struct ccb_abort cab</quote> 中传输。其中唯一的参量"
"字段为："

#. (itstool) path: listitem/para
#: book.translate.xml:20454
msgid "<emphasis>abort_ccb</emphasis> - pointer to the CCB to be aborted"
msgstr "<emphasis>abort_ccb</emphasis> - 指向被中止的ccb的指针"

#. (itstool) path: listitem/para
#: book.translate.xml:20457
msgid ""
"If the abort is not supported just return the status CAM_UA_ABORT. This is "
"also the easy way to minimally implement this call, return CAM_UA_ABORT in "
"any case."
msgstr ""
"如果不支持中断就返回CAM_UA_ABORT。这也是最小化实现这个调用的 简易方式，任何情"
"况下都返回CAM_UA_ABORT。"

#. (itstool) path: listitem/para
#: book.translate.xml:20461
msgid ""
"The hard way is to implement this request honestly. First check that abort "
"applies to a SCSI transaction:"
msgstr "困难方式则是真正地实现这个请求。首先检查应用到SCSI事务的中止："

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20464
#, no-wrap
msgid ""
"    struct ccb *abort_ccb;\n"
"    abort_ccb = ccb-&gt;cab.abort_ccb;\n"
"\n"
"    if(abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {\n"
"        ccb-&gt;ccb_h.status = CAM_UA_ABORT;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"
msgstr ""
"    struct ccb *abort_ccb;\n"
"    abort_ccb = ccb-&gt;cab.abort_ccb;\n"
"\n"
"    if(abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {\n"
"        ccb-&gt;ccb_h.status = CAM_UA_ABORT;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"

#. (itstool) path: listitem/para
#: book.translate.xml:20473
msgid ""
"Then it is necessary to find this CCB in our queue. This can be done by "
"walking the list of all our hardware control blocks in search for one "
"associated with this CCB:"
msgstr ""
"然后需要在我们的队列中找到这个CCB。这可以通过遍历我们所有硬件 控制块列表，查"
"找与这个CCB关联的控制块来完成："

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20478
#, no-wrap
msgid ""
"    struct xxx_hcb *hcb, *h;\n"
"\n"
"    hcb = NULL;\n"
"\n"
"    /* We assume that softc-&gt;first_hcb is the head of the list of all\n"
"     * HCBs associated with this bus, including those enqueued for\n"
"     * processing, being processed by hardware and disconnected ones.\n"
"     */\n"
"    for(h = softc-&gt;first_hcb; h != NULL; h = h-&gt;next) {\n"
"        if(h-&gt;ccb == abort_ccb) {\n"
"            hcb = h;\n"
"            break;\n"
"        }\n"
"    }\n"
"\n"
"    if(hcb == NULL) {\n"
"        /* no such CCB in our queue */\n"
"        ccb-&gt;ccb_h.status = CAM_PATH_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"\n"
"    hcb=found_hcb;"
msgstr ""
"    struct xxx_hcb *hcb, *h;\n"
"\n"
"    hcb = NULL;\n"
"\n"
"    /* We assume that softc-&gt;first_hcb is the head of the list of all\n"
"     * HCBs associated with this bus, including those enqueued for\n"
"     * processing, being processed by hardware and disconnected ones.\n"
"     */\n"
"    for(h = softc-&gt;first_hcb; h != NULL; h = h-&gt;next) {\n"
"        if(h-&gt;ccb == abort_ccb) {\n"
"            hcb = h;\n"
"            break;\n"
"        }\n"
"    }\n"
"\n"
"    if(hcb == NULL) {\n"
"        /* no such CCB in our queue */\n"
"        ccb-&gt;ccb_h.status = CAM_PATH_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"\n"
"    hcb=found_hcb;"

#. (itstool) path: listitem/para
#: book.translate.xml:20502
msgid ""
"Now we look at the current processing status of the HCB. It may be either "
"sitting in the queue waiting to be sent to the SCSI bus, being transferred "
"right now, or disconnected and waiting for the result of the command, or "
"actually completed by hardware but not yet marked as done by software. To "
"make sure that we do not get in any races with hardware we mark the HCB as "
"being aborted, so that if this HCB is about to be sent to the SCSI bus the "
"SCSI controller will see this flag and skip it."
msgstr ""
"现在我们来看一下HCB当前的处理状态。它可能或呆在队列中正等待 被发送到SCSI总"
"线，或此时正在传输中，或已断开连接并等待命令结果， 或者实际上已由硬件完成但尚"
"未被软件标记为完成。为了确保我们不会 与硬件产生竞争条件，我们将HCB标记为中止"
"(aborted)，这样如果这个 HCB要被发送到SCSI总线的话，SCSI控制器将会看到这个旗标"
"并跳过它。"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20512
#, no-wrap
msgid ""
"    int hstatus;\n"
"\n"
"    /* shown as a function, in case special action is needed to make\n"
"     * this flag visible to hardware\n"
"     */\n"
"    set_hcb_flags(hcb, HCB_BEING_ABORTED);\n"
"\n"
"    abort_again:\n"
"\n"
"    hstatus = get_hcb_status(hcb);\n"
"    switch(hstatus) {\n"
"    case HCB_SITTING_IN_QUEUE:\n"
"        remove_hcb_from_hardware_queue(hcb);\n"
"        /* FALLTHROUGH */\n"
"    case HCB_COMPLETED:\n"
"        /* this is an easy case */\n"
"        free_hcb_and_ccb_done(hcb, abort_ccb, CAM_REQ_ABORTED);\n"
"        break;"
msgstr ""
"    int hstatus;\n"
"\n"
"    /* shown as a function, in case special action is needed to make\n"
"     * this flag visible to hardware\n"
"     */\n"
"    set_hcb_flags(hcb, HCB_BEING_ABORTED);\n"
"\n"
"    abort_again:\n"
"\n"
"    hstatus = get_hcb_status(hcb);\n"
"    switch(hstatus) {\n"
"    case HCB_SITTING_IN_QUEUE:\n"
"        remove_hcb_from_hardware_queue(hcb);\n"
"        /* FALLTHROUGH */\n"
"    case HCB_COMPLETED:\n"
"        /* this is an easy case */\n"
"        free_hcb_and_ccb_done(hcb, abort_ccb, CAM_REQ_ABORTED);\n"
"        break;"

#. (itstool) path: listitem/para
#: book.translate.xml:20531
msgid ""
"If the CCB is being transferred right now we would like to signal to the "
"SCSI controller in some hardware-dependent way that we want to abort the "
"current transfer. The SCSI controller would set the SCSI ATTENTION signal "
"and when the target responds to it send an ABORT message. We also reset the "
"timeout to make sure that the target is not sleeping forever. If the command "
"would not get aborted in some reasonable time like 10 seconds the timeout "
"routine would go ahead and reset the whole SCSI bus. Because the command "
"will be aborted in some reasonable time we can just return the abort request "
"now as successfully completed, and mark the aborted CCB as aborted (but not "
"mark it as done yet)."
msgstr ""
"如果CCB此时正在传输中，我们一般会以某种硬件相关的方式发信号 给SCSI控制器，通"
"知它我们希望中止当前的传输。SCSI控制器会设置 SCSI ATTENTION信号，并当目标对其"
"进行响应后发送ABORT消息。我们也复位 超时，以确保目标不会永远睡眠。如果命令不"
"能在某个合理的时间，如 10秒内中止，超时例程就会运行并复位整个SCSI总线。由于命"
"令会在某个 合理的时间后被中止，因此我们现在可以只将中止请求返回，当作成功完"
"成， 并将被中止的CCB标记为中止（但还没有将它标记为完成）。"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20545
#, no-wrap
msgid ""
"    case HCB_BEING_TRANSFERRED:\n"
"        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h.timeout_ch);\n"
"        abort_ccb-&gt;ccb_h.timeout_ch =\n"
"            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);\n"
"        abort_ccb-&gt;ccb_h.status = CAM_REQ_ABORTED;\n"
"        /* ask the controller to abort that HCB, then generate\n"
"         * an interrupt and stop\n"
"         */\n"
"        if(signal_hardware_to_abort_hcb_and_stop(hcb) &lt; 0) {\n"
"            /* oops, we missed the race with hardware, this transaction\n"
"             * got off the bus before we aborted it, try again */\n"
"            goto abort_again;\n"
"        }\n"
"\n"
"        break;"
msgstr ""
"    case HCB_BEING_TRANSFERRED:\n"
"        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h.timeout_ch);\n"
"        abort_ccb-&gt;ccb_h.timeout_ch =\n"
"            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);\n"
"        abort_ccb-&gt;ccb_h.status = CAM_REQ_ABORTED;\n"
"        /* ask the controller to abort that HCB, then generate\n"
"         * an interrupt and stop\n"
"         */\n"
"        if(signal_hardware_to_abort_hcb_and_stop(hcb) &lt; 0) {\n"
"            /* oops, we missed the race with hardware, this transaction\n"
"             * got off the bus before we aborted it, try again */\n"
"            goto abort_again;\n"
"        }\n"
"\n"
"        break;"

#. (itstool) path: listitem/para
#: book.translate.xml:20561
msgid ""
"If the CCB is in the list of disconnected then set it up as an abort request "
"and re-queue it at the front of hardware queue. Reset the timeout and report "
"the abort request to be completed."
msgstr ""
"如果CCB位于断开连接的列表中，则将它设置为中止请求，并在硬件 队列的前端将它重"
"新入队。复位超时，并报告中止请求完成。"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20566
#, no-wrap
msgid ""
"    case HCB_DISCONNECTED:\n"
"        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h.timeout_ch);\n"
"        abort_ccb-&gt;ccb_h.timeout_ch =\n"
"            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);\n"
"        put_abort_message_into_hcb(hcb);\n"
"        put_hcb_at_the_front_of_hardware_queue(hcb);\n"
"        break;\n"
"    }\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"
msgstr ""
"    case HCB_DISCONNECTED:\n"
"        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h.timeout_ch);\n"
"        abort_ccb-&gt;ccb_h.timeout_ch =\n"
"            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);\n"
"        put_abort_message_into_hcb(hcb);\n"
"        put_hcb_at_the_front_of_hardware_queue(hcb);\n"
"        break;\n"
"    }\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20578
msgid ""
"That is all for the ABORT request, although there is one more issue. Because "
"the ABORT message cleans all the ongoing transactions on a LUN we have to "
"mark all the other active transactions on this LUN as aborted. That should "
"be done in the interrupt routine, after the transaction gets aborted."
msgstr ""
"这就是关于ABORT请求的全部，尽管还有一个问题。由于ABORT消息 清除LUN上所有正在"
"进行中的事务，我们必须将LUN上所有其他活动事务 标记为中止。那应当在中断例程中"
"完成，且在中止事务之后。"

#. (itstool) path: listitem/para
#: book.translate.xml:20585
msgid ""
"Implementing the CCB abort as a function may be quite a good idea, this "
"function can be re-used if an I/O transaction times out. The only difference "
"would be that the timed out transaction would return the status "
"CAM_CMD_TIMEOUT for the timed out request. Then the case XPT_ABORT would be "
"small, like that:"
msgstr ""
"将CCB中止作为函数来实现可能是个很好的主意，因为如果I/O事务超时 这个函数能够被"
"重用。唯一的不同是超时事务将为超时请求返回状态 CAM_CMD_TIMEOUT。于是XPT_ABORT"
"的case语句就会很小，像下面这样："

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20592
#, no-wrap
msgid ""
"    case XPT_ABORT:\n"
"        struct ccb *abort_ccb;\n"
"        abort_ccb = ccb-&gt;cab.abort_ccb;\n"
"\n"
"        if(abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {\n"
"            ccb-&gt;ccb_h.status = CAM_UA_ABORT;\n"
"            xpt_done(ccb);\n"
"            return;\n"
"        }\n"
"        if(xxx_abort_ccb(abort_ccb, CAM_REQ_ABORTED) &lt; 0)\n"
"            /* no such CCB in our queue */\n"
"            ccb-&gt;ccb_h.status = CAM_PATH_INVALID;\n"
"        else\n"
"            ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"        xpt_done(ccb);\n"
"        return;"
msgstr ""
"    case XPT_ABORT:\n"
"        struct ccb *abort_ccb;\n"
"        abort_ccb = ccb-&gt;cab.abort_ccb;\n"
"\n"
"        if(abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {\n"
"            ccb-&gt;ccb_h.status = CAM_UA_ABORT;\n"
"            xpt_done(ccb);\n"
"            return;\n"
"        }\n"
"        if(xxx_abort_ccb(abort_ccb, CAM_REQ_ABORTED) &lt; 0)\n"
"            /* no such CCB in our queue */\n"
"            ccb-&gt;ccb_h.status = CAM_PATH_INVALID;\n"
"        else\n"
"            ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"        xpt_done(ccb);\n"
"        return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20611
msgid ""
"<emphasis>XPT_SET_TRAN_SETTINGS</emphasis> - explicitly set values of SCSI "
"transfer settings"
msgstr "<emphasis>XPT_SET_TRAN_SETTINGS</emphasis> - 显式设置SCSI传输设置的值"

#. (itstool) path: listitem/para
#: book.translate.xml:20614
msgid ""
"The arguments are transferred in the instance <quote>struct "
"ccb_trans_setting cts</quote> of the union ccb:"
msgstr ""
"在联合ccb的实例<quote>struct ccb_trans_setting cts</quote> 中传输的参量："

#. (itstool) path: listitem/para
#: book.translate.xml:20620
msgid ""
"<emphasis>valid</emphasis> - a bitmask showing which settings should be "
"updated:"
msgstr "<emphasis>valid</emphasis> - 位掩码，显示应当更新那些设置："

#. (itstool) path: listitem/para
#: book.translate.xml:20625
msgid ""
"<emphasis>CCB_TRANS_SYNC_RATE_VALID</emphasis> - synchronous transfer rate"
msgstr "<emphasis>CCB_TRANS_SYNC_RATE_VALID</emphasis> - 同步传输速率"

#. (itstool) path: listitem/para
#: book.translate.xml:20630
msgid "<emphasis>CCB_TRANS_SYNC_OFFSET_VALID</emphasis> - synchronous offset"
msgstr "<emphasis>CCB_TRANS_SYNC_OFFSET_VALID</emphasis> - 同步位移"

#. (itstool) path: listitem/para
#: book.translate.xml:20635
msgid "<emphasis>CCB_TRANS_BUS_WIDTH_VALID</emphasis> - bus width"
msgstr "<emphasis>CCB_TRANS_BUS_WIDTH_VALID</emphasis> - 总线宽度"

#. (itstool) path: listitem/para
#: book.translate.xml:20640
msgid ""
"<emphasis>CCB_TRANS_DISC_VALID</emphasis> - set enable/disable disconnection"
msgstr "<emphasis>CCB_TRANS_DISC_VALID</emphasis> - 设置启用/禁用断开连接"

#. (itstool) path: listitem/para
#: book.translate.xml:20645
msgid ""
"<emphasis>CCB_TRANS_TQ_VALID</emphasis> - set enable/disable tagged queuing"
msgstr "<emphasis>CCB_TRANS_TQ_VALID</emphasis> - 设置启用/禁用带标签的排队"

#. (itstool) path: listitem/para
#: book.translate.xml:20650
msgid ""
"<emphasis>flags</emphasis> - consists of two parts, binary arguments and "
"identification of sub-operations. The binary arguments are:"
msgstr ""
"<emphasis>flags</emphasis> - 由两部分组成，两元参量和子操作标识。两元参量为："

#. (itstool) path: listitem/para
#: book.translate.xml:20656
msgid "<emphasis>CCB_TRANS_DISC_ENB</emphasis> - enable disconnection"
msgstr "<emphasis>CCB_TRANS_DISC_ENB</emphasis> - 启用断开连接"

#. (itstool) path: listitem/para
#: book.translate.xml:20661
msgid "<emphasis>CCB_TRANS_TAG_ENB</emphasis> - enable tagged queuing"
msgstr "<emphasis>CCB_TRANS_TAG_ENB</emphasis> - 启用带标签的排队"

#. (itstool) path: listitem/para
#: book.translate.xml:20668
msgid "the sub-operations are:"
msgstr "子操作为："

#. (itstool) path: listitem/para
#: book.translate.xml:20672
msgid ""
"<emphasis>CCB_TRANS_CURRENT_SETTINGS</emphasis> - change the current "
"negotiations"
msgstr "<emphasis>CCB_TRANS_CURRENT_SETTINGS</emphasis> - 改变当前的协商"

#. (itstool) path: listitem/para
#: book.translate.xml:20677
msgid ""
"<emphasis>CCB_TRANS_USER_SETTINGS</emphasis> - remember the desired user "
"values sync_period, sync_offset - self-explanatory, if sync_offset==0 then "
"the asynchronous mode is requested bus_width - bus width, in bits (not bytes)"
msgstr "<emphasis>CCB_TRANS_USER_SETTINGS</emphasis> - 记住希望的用户值"

#. (itstool) path: listitem/para
#: book.translate.xml:20687
msgid ""
"Two sets of negotiated parameters are supported, the user settings and the "
"current settings. The user settings are not really used much in the SIM "
"drivers, this is mostly just a piece of memory where the upper levels can "
"store (and later recall) its ideas about the parameters. Setting the user "
"parameters does not cause re-negotiation of the transfer rates. But when the "
"SCSI controller does a negotiation it must never set the values higher than "
"the user parameters, so it is essentially the top boundary."
msgstr ""
"支持两组协商参数，用户设置和当前设置。用户设置在SIM驱动程序中 实际上用得不"
"多，这通常只是一片内存，供上层存储（并在以后恢复）其关于 参数的一些主张。设置"
"用户参数并不会导致重新协商传输速率。但当SCSI 控制器协商时，它必须永远不能设置"
"高于用户参数的值，因此它实质上是 上限。"

#. (itstool) path: listitem/para
#: book.translate.xml:20698
msgid ""
"The current settings are, as the name says, current. Changing them means "
"that the parameters must be re-negotiated on the next transfer. Again, these "
"<quote>new current settings</quote> are not supposed to be forced on the "
"device, just they are used as the initial step of negotiations. Also they "
"must be limited by actual capabilities of the SCSI controller: for example, "
"if the SCSI controller has 8-bit bus and the request asks to set 16-bit wide "
"transfers this parameter must be silently truncated to 8-bit transfers "
"before sending it to the device."
msgstr ""
"当前设置，正如其名字所示，指当前的。改变它们意味着下一次传输时 必须重新协商参"
"数。又一次，这些<quote>new current settings</quote> 并没有被假定为强制用于设"
"备上，它们只是用作协商的起始步骤。此外， 它们必须受SCSI控制器的实际能力限制："
"例如，如果SCSI控制器有8位总线， 而请求要求设置16位传输，则在发送给设备前参数"
"必须被悄悄地截取为8位。"

#. (itstool) path: listitem/para
#: book.translate.xml:20710
msgid ""
"One caveat is that the bus width and synchronous parameters are per target "
"while the disconnection and tag enabling parameters are per lun."
msgstr ""
"一个需要注意的问题就是总线宽度和同步两个参数是针对每目标的而言的， 而断开连接"
"和启用标签两个参数是针对每lun而言的。"

#. (itstool) path: listitem/para
#: book.translate.xml:20714
msgid ""
"The recommended implementation is to keep 3 sets of negotiated (bus width "
"and synchronous transfer) parameters:"
msgstr "建议的实现是保持3组协商参数（总线宽度和同步传输）："

#. (itstool) path: listitem/para
#: book.translate.xml:20720
msgid "<emphasis>user</emphasis> - the user set, as above"
msgstr "<emphasis>user</emphasis> - 用户的一组，如上"

#. (itstool) path: listitem/para
#: book.translate.xml:20725
msgid "<emphasis>current</emphasis> - those actually in effect"
msgstr "<emphasis>current</emphasis> - 实际生效的那些"

#. (itstool) path: listitem/para
#: book.translate.xml:20730
msgid ""
"<emphasis>goal</emphasis> - those requested by setting of the "
"<quote>current</quote> parameters"
msgstr ""
"<emphasis>goal</emphasis> - 通过设置<quote>current</quote>参数所请求的那些"

#. (itstool) path: listitem/para
#: book.translate.xml:20736
msgid "The code looks like:"
msgstr "代码看起来像："

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20738
#, no-wrap
msgid ""
"    struct ccb_trans_settings *cts;\n"
"    int targ, lun;\n"
"    int flags;\n"
"\n"
"    cts = &amp;ccb-&gt;cts;\n"
"    targ = ccb_h-&gt;target_id;\n"
"    lun = ccb_h-&gt;target_lun;\n"
"    flags = cts-&gt;flags;\n"
"    if(flags &amp; CCB_TRANS_USER_SETTINGS) {\n"
"        if(flags &amp; CCB_TRANS_SYNC_RATE_VALID)\n"
"            softc-&gt;user_sync_period[targ] = cts-&gt;sync_period;\n"
"        if(flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)\n"
"            softc-&gt;user_sync_offset[targ] = cts-&gt;sync_offset;\n"
"        if(flags &amp; CCB_TRANS_BUS_WIDTH_VALID)\n"
"            softc-&gt;user_bus_width[targ] = cts-&gt;bus_width;\n"
"\n"
"        if(flags &amp; CCB_TRANS_DISC_VALID) {\n"
"            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;\n"
"            softc-&gt;user_tflags[targ][lun] |= flags &amp; CCB_TRANS_DISC_ENB;\n"
"        }\n"
"        if(flags &amp; CCB_TRANS_TQ_VALID) {\n"
"            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;\n"
"            softc-&gt;user_tflags[targ][lun] |= flags &amp; CCB_TRANS_TQ_ENB;\n"
"        }\n"
"    }\n"
"    if(flags &amp; CCB_TRANS_CURRENT_SETTINGS) {\n"
"        if(flags &amp; CCB_TRANS_SYNC_RATE_VALID)\n"
"            softc-&gt;goal_sync_period[targ] =\n"
"                max(cts-&gt;sync_period, OUR_MIN_SUPPORTED_PERIOD);\n"
"        if(flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)\n"
"            softc-&gt;goal_sync_offset[targ] =\n"
"                min(cts-&gt;sync_offset, OUR_MAX_SUPPORTED_OFFSET);\n"
"        if(flags &amp; CCB_TRANS_BUS_WIDTH_VALID)\n"
"            softc-&gt;goal_bus_width[targ] = min(cts-&gt;bus_width, OUR_BUS_WIDTH);\n"
"\n"
"        if(flags &amp; CCB_TRANS_DISC_VALID) {\n"
"            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;\n"
"            softc-&gt;current_tflags[targ][lun] |= flags &amp; CCB_TRANS_DISC_ENB;\n"
"        }\n"
"        if(flags &amp; CCB_TRANS_TQ_VALID) {\n"
"            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;\n"
"            softc-&gt;current_tflags[targ][lun] |= flags &amp; CCB_TRANS_TQ_ENB;\n"
"        }\n"
"    }\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"
msgstr ""
"    struct ccb_trans_settings *cts;\n"
"    int targ, lun;\n"
"    int flags;\n"
"\n"
"    cts = &amp;ccb-&gt;cts;\n"
"    targ = ccb_h-&gt;target_id;\n"
"    lun = ccb_h-&gt;target_lun;\n"
"    flags = cts-&gt;flags;\n"
"    if(flags &amp; CCB_TRANS_USER_SETTINGS) {\n"
"        if(flags &amp; CCB_TRANS_SYNC_RATE_VALID)\n"
"            softc-&gt;user_sync_period[targ] = cts-&gt;sync_period;\n"
"        if(flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)\n"
"            softc-&gt;user_sync_offset[targ] = cts-&gt;sync_offset;\n"
"        if(flags &amp; CCB_TRANS_BUS_WIDTH_VALID)\n"
"            softc-&gt;user_bus_width[targ] = cts-&gt;bus_width;\n"
"\n"
"        if(flags &amp; CCB_TRANS_DISC_VALID) {\n"
"            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;\n"
"            softc-&gt;user_tflags[targ][lun] |= flags &amp; CCB_TRANS_DISC_ENB;\n"
"        }\n"
"        if(flags &amp; CCB_TRANS_TQ_VALID) {\n"
"            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;\n"
"            softc-&gt;user_tflags[targ][lun] |= flags &amp; CCB_TRANS_TQ_ENB;\n"
"        }\n"
"    }\n"
"    if(flags &amp; CCB_TRANS_CURRENT_SETTINGS) {\n"
"        if(flags &amp; CCB_TRANS_SYNC_RATE_VALID)\n"
"            softc-&gt;goal_sync_period[targ] =\n"
"                max(cts-&gt;sync_period, OUR_MIN_SUPPORTED_PERIOD);\n"
"        if(flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)\n"
"            softc-&gt;goal_sync_offset[targ] =\n"
"                min(cts-&gt;sync_offset, OUR_MAX_SUPPORTED_OFFSET);\n"
"        if(flags &amp; CCB_TRANS_BUS_WIDTH_VALID)\n"
"            softc-&gt;goal_bus_width[targ] = min(cts-&gt;bus_width, OUR_BUS_WIDTH);\n"
"\n"
"        if(flags &amp; CCB_TRANS_DISC_VALID) {\n"
"            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;\n"
"            softc-&gt;current_tflags[targ][lun] |= flags &amp; CCB_TRANS_DISC_ENB;\n"
"        }\n"
"        if(flags &amp; CCB_TRANS_TQ_VALID) {\n"
"            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;\n"
"            softc-&gt;current_tflags[targ][lun] |= flags &amp; CCB_TRANS_TQ_ENB;\n"
"        }\n"
"    }\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20786
msgid ""
"Then when the next I/O request will be processed it will check if it has to "
"re-negotiate, for example by calling the function target_negotiated(hcb). It "
"can be implemented like this:"
msgstr ""
"此后当下一次要处理I/O请求时，它会检查其是否需要重新协商， 例如通过调用函数"
"target_negotiated(hcb)。它可以如下实现："

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20791
#, no-wrap
msgid ""
"    int\n"
"    target_negotiated(struct xxx_hcb *hcb)\n"
"    {\n"
"        struct softc *softc = hcb-&gt;softc;\n"
"        int targ = hcb-&gt;targ;\n"
"\n"
"        if( softc-&gt;current_sync_period[targ] != softc-&gt;goal_sync_period[targ]\n"
"        || softc-&gt;current_sync_offset[targ] != softc-&gt;goal_sync_offset[targ]\n"
"        || softc-&gt;current_bus_width[targ] != softc-&gt;goal_bus_width[targ] )\n"
"            return 0; /* FALSE */\n"
"        else\n"
"            return 1; /* TRUE */\n"
"    }"
msgstr ""
"    int\n"
"    target_negotiated(struct xxx_hcb *hcb)\n"
"    {\n"
"        struct softc *softc = hcb-&gt;softc;\n"
"        int targ = hcb-&gt;targ;\n"
"\n"
"        if( softc-&gt;current_sync_period[targ] != softc-&gt;goal_sync_period[targ]\n"
"        || softc-&gt;current_sync_offset[targ] != softc-&gt;goal_sync_offset[targ]\n"
"        || softc-&gt;current_bus_width[targ] != softc-&gt;goal_bus_width[targ] )\n"
"            return 0; /* FALSE */\n"
"        else\n"
"            return 1; /* TRUE */\n"
"    }"

#. (itstool) path: listitem/para
#: book.translate.xml:20805
msgid ""
"After the values are re-negotiated the resulting values must be assigned to "
"both current and goal parameters, so for future I/O transactions the current "
"and goal parameters would be the same and <function>target_negotiated()</"
"function> would return TRUE. When the card is initialized (in "
"<function>xxx_attach()</function>) the current negotiation values must be "
"initialized to narrow asynchronous mode, the goal and current values must be "
"initialized to the maximal values supported by controller."
msgstr ""
"重新协商这些值后，结果值必须同时赋给当前和目的(goal)参数， 这样对于以后的I/O"
"事务当前和目的参数将相同，且 <function>target_negotiated()</function>会返回"
"TRUE。当初始化卡 （在<function>xxx_attach()</function>中）当前协商值必须被初"
"始化为 最窄同步模式，目的和当前值必须被初始化为控制器所支持的最大值。 （译"
"注：原文可能有误，此处未改）"

#. (itstool) path: listitem/para
#: book.translate.xml:20816
msgid ""
"<emphasis>XPT_GET_TRAN_SETTINGS</emphasis> - get values of SCSI transfer "
"settings"
msgstr "<emphasis>XPT_GET_TRAN_SETTINGS</emphasis> - 获得SCSI传输设置的值"

#. (itstool) path: listitem/para
#: book.translate.xml:20819
msgid ""
"This operations is the reverse of XPT_SET_TRAN_SETTINGS. Fill up the CCB "
"instance <quote>struct ccb_trans_setting cts</quote> with data as requested "
"by the flags CCB_TRANS_CURRENT_SETTINGS or CCB_TRANS_USER_SETTINGS (if both "
"are set then the existing drivers return the current settings). Set all the "
"bits in the valid field."
msgstr ""
"此操作为XPT_SET_TRAN_SETTINGS的逆操作。用通过旗标 CCB_TRANS_CURRENT_SETTINGS"
"或CCB_TRANS_USER_SETTINGS（如果同时设置则 现有驱动程序返回当前设置）所请求而"
"得的数据填充CCB实例 <quote>struct ccb_trans_setting cts</quote>."

#. (itstool) path: listitem/para
#: book.translate.xml:20827
msgid ""
"<emphasis>XPT_CALC_GEOMETRY</emphasis> - calculate logical (BIOS)<_:"
"indexterm-1/> geometry of the disk"
msgstr ""
"<emphasis>XPT_CALC_GEOMETRY</emphasis> - 计算磁盘的逻辑（BIOS）结构(geometry)"

#. (itstool) path: listitem/para
#: book.translate.xml:20831
msgid ""
"The arguments are transferred in the instance <quote>struct "
"ccb_calc_geometry ccg</quote> of the union ccb:"
msgstr ""
"参量在联合ccb的实例<quote>struct ccb_calc_geometry ccg</quote> 中传输："

#. (itstool) path: listitem/para
#: book.translate.xml:20838
msgid ""
"<emphasis>block_size</emphasis> - input, block (A.K.A sector) size in bytes"
msgstr "<emphasis>block_size</emphasis> - 输入，以字节计的块大小（也称为扇区）"

#. (itstool) path: listitem/para
#: book.translate.xml:20843
msgid "<emphasis>volume_size</emphasis> - input, volume size in bytes"
msgstr "<emphasis>volume_size</emphasis> - 输入，以字节计的卷大小"

#. (itstool) path: listitem/para
#: book.translate.xml:20848
msgid "<emphasis>cylinders</emphasis> - output, logical cylinders"
msgstr "<emphasis>cylinders</emphasis> - 输出，逻辑柱面"

#. (itstool) path: listitem/para
#: book.translate.xml:20853
msgid "<emphasis>heads</emphasis> - output, logical heads"
msgstr "<emphasis>heads</emphasis> - 输出，逻辑磁头"

#. (itstool) path: listitem/para
#: book.translate.xml:20858
msgid "<emphasis>secs_per_track</emphasis> - output, logical sectors per track"
msgstr "<emphasis>secs_per_track</emphasis> - 输出，每磁道的逻辑扇区"

#. (itstool) path: para/indexterm
#: book.translate.xml:20864
msgid "<primary>SCSI</primary> <secondary>BIOS</secondary>"
msgstr ""
"<primary>SCSI(小型计算机系统接口)</primary><secondary>BIOS(基本输入输出系统, "
"Basic Input Output System)</secondary>"

#. (itstool) path: listitem/para
#: book.translate.xml:20863
msgid ""
"If the returned geometry differs much enough from what the SCSI controller "
"BIOS<_:indexterm-1/> thinks and a disk on this SCSI controller is used as "
"bootable the system may not be able to boot. The typical calculation example "
"taken from the aic7xxx driver is:"
msgstr ""
"如果返回的结构与SCSI控制器BIOS所想象的差别很大，并且SCSI 控制器上的磁盘被作为"
"可引导的，则系统可能无法启动。从aic7xxx 驱动程序中摘取的典型计算示例："

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20870
#, no-wrap
msgid ""
"    struct    ccb_calc_geometry *ccg;\n"
"    u_int32_t size_mb;\n"
"    u_int32_t secs_per_cylinder;\n"
"    int   extended;\n"
"\n"
"    ccg = &amp;ccb-&gt;ccg;\n"
"    size_mb = ccg-&gt;volume_size\n"
"        / ((1024L * 1024L) / ccg-&gt;block_size);\n"
"    extended = check_cards_EEPROM_for_extended_geometry(softc);\n"
"\n"
"    if (size_mb &gt; 1024 &amp;&amp; extended) {\n"
"        ccg-&gt;heads = 255;\n"
"        ccg-&gt;secs_per_track = 63;\n"
"    } else {\n"
"        ccg-&gt;heads = 64;\n"
"        ccg-&gt;secs_per_track = 32;\n"
"    }\n"
"    secs_per_cylinder = ccg-&gt;heads * ccg-&gt;secs_per_track;\n"
"    ccg-&gt;cylinders = ccg-&gt;volume_size / secs_per_cylinder;\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"
msgstr ""
"    struct    ccb_calc_geometry *ccg;\n"
"    u_int32_t size_mb;\n"
"    u_int32_t secs_per_cylinder;\n"
"    int   extended;\n"
"\n"
"    ccg = &amp;ccb-&gt;ccg;\n"
"    size_mb = ccg-&gt;volume_size\n"
"        / ((1024L * 1024L) / ccg-&gt;block_size);\n"
"    extended = check_cards_EEPROM_for_extended_geometry(softc);\n"
"\n"
"    if (size_mb &gt; 1024 &amp;&amp; extended) {\n"
"        ccg-&gt;heads = 255;\n"
"        ccg-&gt;secs_per_track = 63;\n"
"    } else {\n"
"        ccg-&gt;heads = 64;\n"
"        ccg-&gt;secs_per_track = 32;\n"
"    }\n"
"    secs_per_cylinder = ccg-&gt;heads * ccg-&gt;secs_per_track;\n"
"    ccg-&gt;cylinders = ccg-&gt;volume_size / secs_per_cylinder;\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20893
msgid ""
"This gives the general idea, the exact calculation depends on the quirks of "
"the particular BIOS. If BIOS provides no way set the <quote>extended "
"translation</quote> flag in EEPROM this flag should normally be assumed "
"equal to 1. Other popular geometries are:"
msgstr ""
"这给出了一般思路，精确计算依赖于特定BIOS的癖好(quirk)。如果 BIOS没有提供方法"
"设置EEPROM中的<quote>extended translation</quote> 旗标，则此旗标通常应当假定"
"等于1。其他流行结构有："

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20899
#, no-wrap
msgid ""
"    128 heads, 63 sectors - Symbios controllers\n"
"    16 heads, 63 sectors - old controllers"
msgstr ""
"    128 heads, 63 sectors - Symbios controllers\n"
"    16 heads, 63 sectors - old controllers"

#. (itstool) path: listitem/para
#: book.translate.xml:20902
msgid ""
"Some system BIOSes and SCSI BIOSes fight with each other with variable "
"success, for example a combination of Symbios 875/895 SCSI and Phoenix BIOS "
"can give geometry 128/63 after power up and 255/63 after a hard reset or "
"soft reboot."
msgstr ""
"一些系统BIOS和SCSI BIOS会相互竞争，胜负不定，例如Symbios 875/895 SCSI和"
"Phoenix BIOS的结合在系统加电时会给出结构128/63， 而当冷启动或软启动后会是"
"255/63。"

#. (itstool) path: listitem/para
#: book.translate.xml:20910
msgid ""
"<emphasis>XPT_PATH_INQ</emphasis> - path inquiry, in other words get the SIM "
"driver and SCSI controller (also known as HBA - Host Bus Adapter) properties"
msgstr ""
"<emphasis>XPT_PATH_INQ</emphasis> - 路径问询， 换句话说，获得SIM驱动程序和"
"SCSI控制器（也称为HBA - 主机总线适配器） 的特性。"

#. (itstool) path: listitem/para
#: book.translate.xml:20914
msgid ""
"The properties are returned in the instance <quote>struct ccb_pathinq cpi</"
"quote> of the union ccb:"
msgstr "特性在联合ccb的实例<quote>struct ccb_pathinq cpi</quote> 中返回："

#. (itstool) path: listitem/para
#: book.translate.xml:20920
msgid "version_num - the SIM driver version number, now all drivers use 1"
msgstr "version_num - SIM驱动程序号，当前所有驱动程序使用1"

#. (itstool) path: listitem/para
#: book.translate.xml:20925
msgid "hba_inquiry - bitmask of features supported by the controller:"
msgstr "hba_inquiry - 控制器所支持特性的位掩码："

#. (itstool) path: listitem/para
#: book.translate.xml:20930
msgid "PI_MDP_ABLE - supports MDP message (something from SCSI3?)"
msgstr "PI_MDP_ABLE - 支持MDP消息（来自SCSI3的一些东西?）"

#. (itstool) path: listitem/para
#: book.translate.xml:20935
msgid "PI_WIDE_32 - supports 32 bit wide SCSI"
msgstr "PI_WIDE_32 - 支持32位宽SCSI"

#. (itstool) path: listitem/para
#: book.translate.xml:20940
msgid "PI_WIDE_16 - supports 16 bit wide SCSI"
msgstr "PI_WIDE_16 - 支持16位宽SCSI"

#. (itstool) path: listitem/para
#: book.translate.xml:20945
msgid "PI_SDTR_ABLE - can negotiate synchronous transfer rate"
msgstr "PI_SDTR_ABLE - 可以协商同步传输速率"

#. (itstool) path: listitem/para
#: book.translate.xml:20950
msgid "PI_LINKED_CDB - supports linked commands"
msgstr "PI_LINKED_CDB - 支持链接的命令"

#. (itstool) path: listitem/para
#: book.translate.xml:20955
msgid "PI_TAG_ABLE - supports tagged commands"
msgstr "PI_TAG_ABLE - 支持带标签的命令"

#. (itstool) path: listitem/para
#: book.translate.xml:20960
msgid ""
"PI_SOFT_RST - supports soft reset alternative (hard reset and soft reset are "
"mutually exclusive within a SCSI bus)"
msgstr "PI_SOFT_RST - 支持软复位选择 （硬复位和软复位在SCSI总线中是互斥的）"

#. (itstool) path: listitem/para
#: book.translate.xml:20966
msgid "target_sprt - flags for target mode support, 0 if unsupported"
msgstr "target_sprt - 目标模式支持的旗标，如果不支持则为0"

#. (itstool) path: listitem/para
#: book.translate.xml:20971
msgid "hba_misc - miscellaneous controller features:"
msgstr "hba_misc - 控制器特性杂项："

#. (itstool) path: listitem/para
#: book.translate.xml:20976
msgid "PIM_SCANHILO - bus scans from high ID to low ID"
msgstr "PIM_SCANHILO - 从高ID到低ID的总线扫描"

#. (itstool) path: listitem/para
#: book.translate.xml:20981
msgid "PIM_NOREMOVE - removable devices not included in scan"
msgstr "PIM_NOREMOVE - 可移除设备不包括在扫描之列"

#. (itstool) path: listitem/para
#: book.translate.xml:20986
msgid "PIM_NOINITIATOR - initiator role not supported"
msgstr "PIM_NOINITIATOR - 不支持发起者角色"

#. (itstool) path: listitem/para
#: book.translate.xml:20991
msgid "PIM_NOBUSRESET - user has disabled initial BUS RESET"
msgstr "PIM_NOBUSRESET - 用户禁用初始BUS RESET"

#. (itstool) path: listitem/para
#: book.translate.xml:20996
msgid ""
"hba_eng_cnt - mysterious HBA engine count, something related to compression, "
"now is always set to 0"
msgstr "hba_eng_cnt - 神秘的HBA引擎计数，与压缩有关的一些 东西，当前总是置为0"

#. (itstool) path: listitem/para
#: book.translate.xml:21001
msgid "vuhba_flags - vendor-unique flags, unused now"
msgstr "vuhba_flags - 供应商唯一的旗标，当前未用"

#. (itstool) path: listitem/para
#: book.translate.xml:21005
msgid ""
"max_target - maximal supported target ID (7 for 8-bit bus, 15 for 16-bit "
"bus, 127 for Fibre Channel)"
msgstr ""
"max_target - 最大支持的目标ID（对8位总线为7， 16位总线为15，光纤通道为127）"

#. (itstool) path: listitem/para
#: book.translate.xml:21011
msgid ""
"max_lun - maximal supported LUN ID (7 for older SCSI controllers, 63 for "
"newer ones)"
msgstr "max_lun - 最大支持的LUN ID（对较老的SCSI控制器 为7，较新的为63）"

#. (itstool) path: listitem/para
#: book.translate.xml:21016
msgid "async_flags - bitmask of installed Async handler, unused now"
msgstr "async_flags - 安装的异步处理函数的位掩码，当前未用"

#. (itstool) path: listitem/para
#: book.translate.xml:21021
msgid "hpath_id - highest Path ID in the subsystem, unused now"
msgstr "hpath_id - 子系统中最高的路径ID，当前未用"

#. (itstool) path: listitem/para
#: book.translate.xml:21026
msgid "unit_number - the controller unit number, cam_sim_unit(sim)"
msgstr "unit_number - 控制器单元号，cam_sim_unit(sim)"

#. (itstool) path: listitem/para
#: book.translate.xml:21031
msgid "bus_id - the bus number, cam_sim_bus(sim)"
msgstr "bus_id - 总线号，cam_sim_bus(sim)"

#. (itstool) path: listitem/para
#: book.translate.xml:21035
msgid "initiator_id - the SCSI ID of the controller itself"
msgstr "initiator_id - 控制器自己的SCSI ID"

#. (itstool) path: listitem/para
#: book.translate.xml:21040
msgid ""
"base_transfer_speed - nominal transfer speed in KB/s for asynchronous narrow "
"transfers, equals to 3300 for SCSI"
msgstr ""
"base_transfer_speed - 异步窄传输的名义传输速率， 以 KB/s 计，对于SCSI等于3300"

#. (itstool) path: listitem/para
#: book.translate.xml:21046
msgid ""
"sim_vid - SIM driver's vendor id, a zero-terminated string of maximal length "
"SIM_IDLEN including the terminating zero"
msgstr ""
"sim_vid - SIM驱动程序的供应商ID，以0结束的字符串， 包含结尾0在内的最大长度为"
"SIM_IDLEN"

#. (itstool) path: listitem/para
#: book.translate.xml:21052
msgid ""
"hba_vid - SCSI controller's vendor id, a zero-terminated string of maximal "
"length HBA_IDLEN including the terminating zero"
msgstr ""
"hba_vid - SCSI控制器的供应商ID，以0结束的字符串， 包含结尾0在内的最大长度为"
"HBA_IDLEN"

#. (itstool) path: listitem/para
#: book.translate.xml:21058
msgid ""
"dev_name - device driver name, a zero-terminated string of maximal length "
"DEV_IDLEN including the terminating zero, equal to cam_sim_name(sim)"
msgstr ""
"dev_name - 设备驱动程序名字，以0结尾的字符串， 包含结尾0在内的最大长度为"
"DEV_IDLEN，等于cam_sim_name(sim)"

#. (itstool) path: listitem/para
#: book.translate.xml:21064
msgid ""
"The recommended way of setting the string fields is using strncpy, like:"
msgstr "设置字符串字段的建议方法是使用strncpy，如："

#. (itstool) path: listitem/programlisting
#: book.translate.xml:21067
#, no-wrap
msgid "    strncpy(cpi-&gt;dev_name, cam_sim_name(sim), DEV_IDLEN);"
msgstr "    strncpy(cpi-&gt;dev_name, cam_sim_name(sim), DEV_IDLEN);"

#. (itstool) path: listitem/para
#: book.translate.xml:21069
msgid ""
"After setting the values set the status to CAM_REQ_CMP and mark the CCB as "
"done."
msgstr "设置这些值后将状态设置为CAM_REQ_CMP，并将CCB标记为完成。"

#. (itstool) path: sect1/title
#: book.translate.xml:21076
msgid "Polling"
msgstr "轮询"

#. (itstool) path: sect1/para
#: book.translate.xml:21089
msgid ""
"The poll function is used to simulate the interrupts when the interrupt "
"subsystem is not functioning (for example, when the system has crashed and "
"is creating the system dump). The CAM subsystem sets the proper interrupt "
"level before calling the poll routine. So all it needs to do is to call the "
"interrupt routine (or the other way around, the poll routine may be doing "
"the real action and the interrupt routine would just call the poll routine). "
"Why bother about a separate function then? Because of different calling "
"conventions. The <function>xxx_poll</function> routine gets the struct "
"cam_sim pointer as its argument when the PCI interrupt routine by common "
"convention gets pointer to the struct <varname remap=\"structname"
"\">xxx_softc</varname> and the ISA interrupt routine gets just the device "
"unit number. So the poll routine would normally look as:"
msgstr ""
"轮询函数用于当中断子系统不起作用时（例如，系统崩溃或正在创建 系统转储）模拟中"
"断。CAM子系统在调用轮询函数前设置适当的中断级别。 因此它所需做全部的只是调用"
"中断例程（或其他方法，轮询例程来 进行实际动作, 而中断例程只是调用轮询例程）。"
"那么为什么要找麻烦 弄出一个单独的函数来呢？这是由于不同的调用约定。 "
"<function>xxx_poll</function>例程取结构cam_sim的指针作为参量， 而PCI中断例程"
"按照普通约定取的是指向结构 <varname remap=\"structname\">xxx_softc</varname>"
"的指针，ISA中断例程只是取设备号， 因此轮询例程一般看起来像："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21105
#, no-wrap
msgid ""
"static void\n"
"xxx_poll(struct cam_sim *sim)\n"
"{\n"
"    xxx_intr((struct xxx_softc *)cam_sim_softc(sim)); /* for PCI device */\n"
"}"
msgstr ""
"static void\n"
"xxx_poll(struct cam_sim *sim)\n"
"{\n"
"    xxx_intr((struct xxx_softc *)cam_sim_softc(sim)); /* for PCI device */\n"
"}"

#. (itstool) path: sect1/para
#: book.translate.xml:21111
msgid "or"
msgstr "或"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21113
#, no-wrap
msgid ""
"static void\n"
"xxx_poll(struct cam_sim *sim)\n"
"{\n"
"    xxx_intr(cam_sim_unit(sim)); /* for ISA device */\n"
"}"
msgstr ""
"static void\n"
"xxx_poll(struct cam_sim *sim)\n"
"{\n"
"    xxx_intr(cam_sim_unit(sim)); /* for ISA device */\n"
"}"

#. (itstool) path: sect1/title
#: book.translate.xml:21121
msgid "Asynchronous Events"
msgstr "异步事件"

#. (itstool) path: sect1/para
#: book.translate.xml:21123
msgid ""
"If an asynchronous event callback has been set up then the callback function "
"should be defined."
msgstr "如果建立了异步事件回调，则应当定义回调函数。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21126
#, no-wrap
msgid ""
"static void\n"
"ahc_async(void *callback_arg, u_int32_t code, struct cam_path *path, void *arg)"
msgstr ""
"static void\n"
"ahc_async(void *callback_arg, u_int32_t code, struct cam_path *path, void *arg)"

#. (itstool) path: listitem/para
#: book.translate.xml:21131
msgid "callback_arg - the value supplied when registering the callback"
msgstr "callback_arg - 注册回调时提供的值"

#. (itstool) path: listitem/para
#: book.translate.xml:21136
msgid "code - identifies the type of event"
msgstr "code - 标识事件类型"

#. (itstool) path: listitem/para
#: book.translate.xml:21140
msgid "path - identifies the devices to which the event applies"
msgstr "path - 标识事件作用于其上的设备"

#. (itstool) path: listitem/para
#: book.translate.xml:21145
msgid "arg - event-specific argument"
msgstr "arg - 事件特定的参量"

#. (itstool) path: sect1/para
#: book.translate.xml:21149
msgid "Implementation for a single type of event, AC_LOST_DEVICE, looks like:"
msgstr "单一类型事件的实现，AC_LOST_DEVICE，看起来如下："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21152
#, no-wrap
msgid ""
"    struct xxx_softc *softc;\n"
"    struct cam_sim *sim;\n"
"    int targ;\n"
"    struct ccb_trans_settings neg;\n"
"\n"
"    sim = (struct cam_sim *)callback_arg;\n"
"    softc = (struct xxx_softc *)cam_sim_softc(sim);\n"
"    switch (code) {\n"
"    case AC_LOST_DEVICE:\n"
"        targ = xpt_path_target_id(path);\n"
"        if(targ &lt;= OUR_MAX_SUPPORTED_TARGET) {\n"
"            clean_negotiations(softc, targ);\n"
"            /* send indication to CAM */\n"
"            neg.bus_width = 8;\n"
"            neg.sync_period = neg.sync_offset = 0;\n"
"            neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"                | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"        }\n"
"        break;\n"
"    default:\n"
"        break;\n"
"    }"
msgstr ""
"    struct xxx_softc *softc;\n"
"    struct cam_sim *sim;\n"
"    int targ;\n"
"    struct ccb_trans_settings neg;\n"
"\n"
"    sim = (struct cam_sim *)callback_arg;\n"
"    softc = (struct xxx_softc *)cam_sim_softc(sim);\n"
"    switch (code) {\n"
"    case AC_LOST_DEVICE:\n"
"        targ = xpt_path_target_id(path);\n"
"        if(targ &lt;= OUR_MAX_SUPPORTED_TARGET) {\n"
"            clean_negotiations(softc, targ);\n"
"            /* send indication to CAM */\n"
"            neg.bus_width = 8;\n"
"            neg.sync_period = neg.sync_offset = 0;\n"
"            neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"                | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"        }\n"
"        break;\n"
"    default:\n"
"        break;\n"
"    }"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:21180
msgid "<primary>SCSI</primary><secondary>interrupts</secondary>"
msgstr ""
"<primary>SCSI(小型计算机系统接口)</primary><secondary>interrupts(中断)</"
"secondary>"

#. (itstool) path: sect1/para
#: book.translate.xml:21182
msgid ""
"The exact type of the interrupt routine depends on the type of the "
"peripheral bus (PCI, ISA and so on) to which the SCSI controller is "
"connected."
msgstr ""
"中断例程的确切类型依赖于SCSI控制器所连接到的外围总线的类型（PCI， ISA等等）。"

#. (itstool) path: sect1/para
#: book.translate.xml:21186
msgid ""
"The interrupt routines of the SIM drivers run at the interrupt level splcam. "
"So <function>splcam()</function> should be used in the driver to synchronize "
"activity between the interrupt routine and the rest of the driver (for a "
"multiprocessor-aware driver things get yet more interesting but we ignore "
"this case here). The pseudo-code in this document happily ignores the "
"problems of synchronization. The real code must not ignore them. A simple-"
"minded approach is to set <function>splcam()</function> on the entry to the "
"other routines and reset it on return thus protecting them by one big "
"critical section. To make sure that the interrupt level will be always "
"restored a wrapper function can be defined, like:"
msgstr ""
"SIM驱动程序的中断例程运行在中断级别splcam上。因此应当在驱动 程序中使用"
"<function>splcam()</function>来同步中断例程与驱动程序 剩余部分的活动（对于能"
"察觉多处理器的驱动程序，事情更要有趣，但 此处我们忽略这种情况）。本文档中的伪"
"代码简单地忽略了同步问题。 实际代码一定不能忽略它们。一个较笨的办法就是在进入"
"其他例程的 入口点处设<function>splcam()</function>，并在返回时将它复位，从而 "
"用一个大的临界区保护它们。为了确保中断级别总是会被恢复，可以定义 一个包装函"
"数，如："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21199
#, no-wrap
msgid ""
"    static void\n"
"    xxx_action(struct cam_sim *sim, union ccb *ccb)\n"
"    {\n"
"        int s;\n"
"        s = splcam();\n"
"        xxx_action1(sim, ccb);\n"
"        splx(s);\n"
"    }\n"
"\n"
"    static void\n"
"    xxx_action1(struct cam_sim *sim, union ccb *ccb)\n"
"    {\n"
"        ... process the request ...\n"
"    }"
msgstr ""
"    static void\n"
"    xxx_action(struct cam_sim *sim, union ccb *ccb)\n"
"    {\n"
"        int s;\n"
"        s = splcam();\n"
"        xxx_action1(sim, ccb);\n"
"        splx(s);\n"
"    }\n"
"\n"
"    static void\n"
"    xxx_action1(struct cam_sim *sim, union ccb *ccb)\n"
"    {\n"
"        ... process the request ...\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:21214
msgid ""
"This approach is simple and robust but the problem with it is that "
"interrupts may get blocked for a relatively long time and this would "
"negatively affect the system's performance. On the other hand the functions "
"of the <function>spl()</function> family have rather high overhead, so vast "
"amount of tiny critical sections may not be good either."
msgstr ""
"这种方法简单而且健壮，但它存在的问题是中断可能会被阻塞相对 很长的事件，这会对"
"系统性能产生负面影响。另一方面， <function>spl()</function>函数族有相当高的额"
"外开销，因此大量 很小的临界区可能也不好。"

#. (itstool) path: sect1/para
#: book.translate.xml:21221
msgid ""
"The conditions handled by the interrupt routine and the details depend very "
"much on the hardware. We consider the set of <quote>typical</quote> "
"conditions."
msgstr ""
"中断例程处理的情况和其中细节严重依赖于硬件。我们考虑 <quote>典型(typical)</"
"quote>情况。"

#. (itstool) path: sect1/para
#: book.translate.xml:21225
msgid ""
"First, we check if a SCSI reset was encountered on the bus (probably caused "
"by another SCSI controller on the same SCSI bus). If so we drop all the "
"enqueued and disconnected requests, report the events and re-initialize our "
"SCSI controller. It is important that during this initialization the "
"controller will not issue another reset or else two controllers on the same "
"SCSI bus could ping-pong resets forever. The case of fatal controller error/"
"hang could be handled in the same place, but it will probably need also "
"sending RESET signal to the SCSI bus to reset the status of the connections "
"with the SCSI devices."
msgstr ""
"首先，我们检查总线上是否遇到了SCSI复位（可能由同一SCSI总线上 的另一SCSI控制器"
"引起）。如果这样我们丢弃所有入队的和断开连接的 请求，报告事件并重新初始化我们"
"的SCSI控制器。初始化期间控制器 不会发出另一个复位，这对我们十分重要，否则同一"
"SCSI总线上的两个控制器 可能会一直来回地复位下去。控制器致命错误/挂起的情况可"
"以在同一 地方进行处理，但这可能需要发送RESET信号到SCSI总线来复位与SCSI 设备的"
"连接状态。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21237
#, no-wrap
msgid ""
"    int fatal=0;\n"
"    struct ccb_trans_settings neg;\n"
"    struct cam_path *path;\n"
"\n"
"    if( detected_scsi_reset(softc)\n"
"    || (fatal = detected_fatal_controller_error(softc)) ) {\n"
"        int targ, lun;\n"
"        struct xxx_hcb *h, *hh;\n"
"\n"
"        /* drop all enqueued CCBs */\n"
"        for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"            hh = h-&gt;next;\n"
"            free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"        }\n"
"\n"
"        /* the clean values of negotiations to report */\n"
"        neg.bus_width = 8;\n"
"        neg.sync_period = neg.sync_offset = 0;\n"
"        neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"            | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"\n"
"        /* drop all disconnected CCBs and clean negotiations  */\n"
"        for(targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {\n"
"            clean_negotiations(softc, targ);\n"
"\n"
"            /* report the event if possible */\n"
"            if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                    cam_sim_path(sim), targ,\n"
"                    CAM_LUN_WILDCARD) == CAM_REQ_CMP) {\n"
"                xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"                xpt_free_path(path);\n"
"            }\n"
"\n"
"            for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"                for(h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h = hh) {\n"
"                    hh=h-&gt;next;\n"
"                    if(fatal)\n"
"                        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_UNREC_HBA_ERROR);\n"
"                    else\n"
"                        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"                }\n"
"        }\n"
"\n"
"        /* report the event */\n"
"        xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);\n"
"\n"
"        /* re-initialization may take a lot of time, in such case\n"
"         * its completion should be signaled by another interrupt or\n"
"         * checked on timeout - but for simplicity we assume here that\n"
"         * it is really fast\n"
"         */\n"
"        if(!fatal) {\n"
"            reinitialize_controller_without_scsi_reset(softc);\n"
"        } else {\n"
"            reinitialize_controller_with_scsi_reset(softc);\n"
"        }\n"
"        schedule_next_hcb(softc);\n"
"        return;\n"
"    }"
msgstr ""
"    int fatal=0;\n"
"    struct ccb_trans_settings neg;\n"
"    struct cam_path *path;\n"
"\n"
"    if( detected_scsi_reset(softc)\n"
"    || (fatal = detected_fatal_controller_error(softc)) ) {\n"
"        int targ, lun;\n"
"        struct xxx_hcb *h, *hh;\n"
"\n"
"        /* drop all enqueued CCBs */\n"
"        for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"            hh = h-&gt;next;\n"
"            free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"        }\n"
"\n"
"        /* the clean values of negotiations to report */\n"
"        neg.bus_width = 8;\n"
"        neg.sync_period = neg.sync_offset = 0;\n"
"        neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"            | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"\n"
"        /* drop all disconnected CCBs and clean negotiations  */\n"
"        for(targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {\n"
"            clean_negotiations(softc, targ);\n"
"\n"
"            /* report the event if possible */\n"
"            if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                    cam_sim_path(sim), targ,\n"
"                    CAM_LUN_WILDCARD) == CAM_REQ_CMP) {\n"
"                xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"                xpt_free_path(path);\n"
"            }\n"
"\n"
"            for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"                for(h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h = hh) {\n"
"                    hh=h-&gt;next;\n"
"                    if(fatal)\n"
"                        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_UNREC_HBA_ERROR);\n"
"                    else\n"
"                        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"                }\n"
"        }\n"
"\n"
"        /* report the event */\n"
"        xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);\n"
"\n"
"        /* re-initialization may take a lot of time, in such case\n"
"         * its completion should be signaled by another interrupt or\n"
"         * checked on timeout - but for simplicity we assume here that\n"
"         * it is really fast\n"
"         */\n"
"        if(!fatal) {\n"
"            reinitialize_controller_without_scsi_reset(softc);\n"
"        } else {\n"
"            reinitialize_controller_with_scsi_reset(softc);\n"
"        }\n"
"        schedule_next_hcb(softc);\n"
"        return;\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:21297
msgid ""
"If interrupt is not caused by a controller-wide condition then probably "
"something has happened to the current hardware control block. Depending on "
"the hardware there may be other non-HCB-related events, we just do not "
"consider them here. Then we analyze what happened to this HCB:"
msgstr ""
"如果中断不是由控制器范围的条件引起的，则很可能当前硬件控制块 出现了问题。依赖"
"于硬件，可能有非HCB相关的事件，此处我们指示不考虑 它们。然后我们分析这个HCB发"
"生了什么："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21303
#, no-wrap
msgid ""
"    struct xxx_hcb *hcb, *h, *hh;\n"
"    int hcb_status, scsi_status;\n"
"    int ccb_status;\n"
"    int targ;\n"
"    int lun_to_freeze;\n"
"\n"
"    hcb = get_current_hcb(softc);\n"
"    if(hcb == NULL) {\n"
"        /* either stray interrupt or something went very wrong\n"
"         * or this is something hardware-dependent\n"
"         */\n"
"        handle as necessary;\n"
"        return;\n"
"    }\n"
"\n"
"    targ = hcb-&gt;target;\n"
"    hcb_status = get_status_of_current_hcb(softc);"
msgstr ""
"    struct xxx_hcb *hcb, *h, *hh;\n"
"    int hcb_status, scsi_status;\n"
"    int ccb_status;\n"
"    int targ;\n"
"    int lun_to_freeze;\n"
"\n"
"    hcb = get_current_hcb(softc);\n"
"    if(hcb == NULL) {\n"
"        /* either stray interrupt or something went very wrong\n"
"         * or this is something hardware-dependent\n"
"         */\n"
"        handle as necessary;\n"
"        return;\n"
"    }\n"
"\n"
"    targ = hcb-&gt;target;\n"
"    hcb_status = get_status_of_current_hcb(softc);"

#. (itstool) path: sect1/para
#: book.translate.xml:21321
msgid ""
"First we check if the HCB has completed and if so we check the returned SCSI "
"status."
msgstr "首先我们检查HCB是否完成，如果完成我们就检查返回的SCSI状态。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21324
#, no-wrap
msgid ""
"    if(hcb_status == COMPLETED) {\n"
"        scsi_status = get_completion_status(hcb);"
msgstr ""
"    if(hcb_status == COMPLETED) {\n"
"        scsi_status = get_completion_status(hcb);"

#. (itstool) path: sect1/para
#: book.translate.xml:21327
msgid ""
"Then look if this status is related to the REQUEST SENSE command and if so "
"handle it in a simple way."
msgstr ""
"然后看这个状态是否与REQUEST SENSE命令有关，如果有关则简单 地处理一下它。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21330
#, no-wrap
msgid ""
"        if(hcb-&gt;flags &amp; DOING_AUTOSENSE) {\n"
"            if(scsi_status == GOOD) { /* autosense was successful */\n"
"                hcb-&gt;ccb-&gt;ccb_h.status |= CAM_AUTOSNS_VALID;\n"
"                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_SCSI_STATUS_ERROR);\n"
"            } else {\n"
"        autosense_failed:\n"
"                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_AUTOSENSE_FAIL);\n"
"            }\n"
"            schedule_next_hcb(softc);\n"
"            return;\n"
"        }"
msgstr ""
"        if(hcb-&gt;flags &amp; DOING_AUTOSENSE) {\n"
"            if(scsi_status == GOOD) { /* autosense was successful */\n"
"                hcb-&gt;ccb-&gt;ccb_h.status |= CAM_AUTOSNS_VALID;\n"
"                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_SCSI_STATUS_ERROR);\n"
"            } else {\n"
"        autosense_failed:\n"
"                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_AUTOSENSE_FAIL);\n"
"            }\n"
"            schedule_next_hcb(softc);\n"
"            return;\n"
"        }"

#. (itstool) path: sect1/para
#: book.translate.xml:21342
msgid ""
"Else the command itself has completed, pay more attention to details. If "
"auto-sense is not disabled for this CCB and the command has failed with "
"sense data then run REQUEST SENSE command to receive that data."
msgstr ""
"否则命令自身已经完成，把更多注意力放在细节上。如果这个CCB 没有禁用auto-sense"
"并且命令连同sense数据失败，则运行REQUEST SENSE 命令接收那些数据。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21347
#, no-wrap
msgid ""
"        hcb-&gt;ccb-&gt;csio.scsi_status = scsi_status;\n"
"        calculate_residue(hcb);\n"
"\n"
"        if( (hcb-&gt;ccb-&gt;ccb_h.flags &amp; CAM_DIS_AUTOSENSE)==0\n"
"        &amp;&amp; ( scsi_status == CHECK_CONDITION\n"
"                || scsi_status == COMMAND_TERMINATED) ) {\n"
"            /* start auto-SENSE */\n"
"            hcb-&gt;flags |= DOING_AUTOSENSE;\n"
"            setup_autosense_command_in_hcb(hcb);\n"
"            restart_current_hcb(softc);\n"
"            return;\n"
"        }\n"
"        if(scsi_status == GOOD)\n"
"            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_REQ_CMP);\n"
"        else\n"
"            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_SCSI_STATUS_ERROR);\n"
"        schedule_next_hcb(softc);\n"
"        return;\n"
"    }"
msgstr ""
"        hcb-&gt;ccb-&gt;csio.scsi_status = scsi_status;\n"
"        calculate_residue(hcb);\n"
"\n"
"        if( (hcb-&gt;ccb-&gt;ccb_h.flags &amp; CAM_DIS_AUTOSENSE)==0\n"
"        &amp;&amp; ( scsi_status == CHECK_CONDITION\n"
"                || scsi_status == COMMAND_TERMINATED) ) {\n"
"            /* start auto-SENSE */\n"
"            hcb-&gt;flags |= DOING_AUTOSENSE;\n"
"            setup_autosense_command_in_hcb(hcb);\n"
"            restart_current_hcb(softc);\n"
"            return;\n"
"        }\n"
"        if(scsi_status == GOOD)\n"
"            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_REQ_CMP);\n"
"        else\n"
"            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_SCSI_STATUS_ERROR);\n"
"        schedule_next_hcb(softc);\n"
"        return;\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:21367
msgid ""
"One typical thing would be negotiation events: negotiation messages received "
"from a SCSI target (in answer to our negotiation attempt or by target's "
"initiative) or the target is unable to negotiate (rejects our negotiation "
"messages or does not answer them)."
msgstr ""
"属于协商事件的一个典型事情：从SCSI目标（回答我们的协商企图或 由目标发起的）接"
"收到的协商消息，或目标无法协商（拒绝我们的协商消息 或不回答它们）。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21373
#, no-wrap
msgid ""
"    switch(hcb_status) {\n"
"    case TARGET_REJECTED_WIDE_NEG:\n"
"        /* revert to 8-bit bus */\n"
"        softc-&gt;current_bus_width[targ] = softc-&gt;goal_bus_width[targ] = 8;\n"
"        /* report the event */\n"
"        neg.bus_width = 8;\n"
"        neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    case TARGET_ANSWERED_WIDE_NEG:\n"
"        {\n"
"            int wd;\n"
"\n"
"            wd = get_target_bus_width_request(softc);\n"
"            if(wd &lt;= softc-&gt;goal_bus_width[targ]) {\n"
"                /* answer is acceptable */\n"
"                softc-&gt;current_bus_width[targ] =\n"
"                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;\n"
"\n"
"                /* report the event */\n"
"                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"            } else {\n"
"                prepare_reject_message(hcb);\n"
"            }\n"
"        }\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    case TARGET_REQUESTED_WIDE_NEG:\n"
"        {\n"
"            int wd;\n"
"\n"
"            wd = get_target_bus_width_request(softc);\n"
"            wd = min (wd, OUR_BUS_WIDTH);\n"
"            wd = min (wd, softc-&gt;user_bus_width[targ]);\n"
"\n"
"            if(wd != softc-&gt;current_bus_width[targ]) {\n"
"                /* the bus width has changed */\n"
"                softc-&gt;current_bus_width[targ] =\n"
"                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;\n"
"\n"
"                /* report the event */\n"
"                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"            }\n"
"            prepare_width_nego_rsponse(hcb, wd);\n"
"        }\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    }"
msgstr ""
"    switch(hcb_status) {\n"
"    case TARGET_REJECTED_WIDE_NEG:\n"
"        /* revert to 8-bit bus */\n"
"        softc-&gt;current_bus_width[targ] = softc-&gt;goal_bus_width[targ] = 8;\n"
"        /* report the event */\n"
"        neg.bus_width = 8;\n"
"        neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    case TARGET_ANSWERED_WIDE_NEG:\n"
"        {\n"
"            int wd;\n"
"\n"
"            wd = get_target_bus_width_request(softc);\n"
"            if(wd &lt;= softc-&gt;goal_bus_width[targ]) {\n"
"                /* answer is acceptable */\n"
"                softc-&gt;current_bus_width[targ] =\n"
"                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;\n"
"\n"
"                /* report the event */\n"
"                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"            } else {\n"
"                prepare_reject_message(hcb);\n"
"            }\n"
"        }\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    case TARGET_REQUESTED_WIDE_NEG:\n"
"        {\n"
"            int wd;\n"
"\n"
"            wd = get_target_bus_width_request(softc);\n"
"            wd = min (wd, OUR_BUS_WIDTH);\n"
"            wd = min (wd, softc-&gt;user_bus_width[targ]);\n"
"\n"
"            if(wd != softc-&gt;current_bus_width[targ]) {\n"
"                /* the bus width has changed */\n"
"                softc-&gt;current_bus_width[targ] =\n"
"                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;\n"
"\n"
"                /* report the event */\n"
"                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"            }\n"
"            prepare_width_nego_rsponse(hcb, wd);\n"
"        }\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:21425
msgid ""
"Then we handle any errors that could have happened during auto-sense in the "
"same simple-minded way as before. Otherwise we look closer at the details "
"again."
msgstr ""
"然后我们用与前面相同的笨办法处理auto-sense期间可能出现的任何 错误。否则，我们"
"再一次进入细节。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21429
#, no-wrap
msgid ""
"    if(hcb-&gt;flags &amp; DOING_AUTOSENSE)\n"
"        goto autosense_failed;\n"
"\n"
"    switch(hcb_status) {"
msgstr ""
"    if(hcb-&gt;flags &amp; DOING_AUTOSENSE)\n"
"        goto autosense_failed;\n"
"\n"
"    switch(hcb_status) {"

#. (itstool) path: sect1/para
#: book.translate.xml:21434
msgid ""
"The next event we consider is unexpected disconnect. Which is considered "
"normal after an ABORT or BUS DEVICE RESET message and abnormal in other "
"cases."
msgstr ""
"我们考虑的下一事件是未预期的连接断开，这个事件在ABORT或 BUS DEVICE RESET消息"
"之后被看作是正常的，其他情况下是非正常的。"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21438
#, no-wrap
msgid ""
"    case UNEXPECTED_DISCONNECT:\n"
"        if(requested_abort(hcb)) {\n"
"            /* abort affects all commands on that target+LUN, so\n"
"             * mark all disconnected HCBs on that target+LUN as aborted too\n"
"             */\n"
"            for(h = softc-&gt;first_discon_hcb[hcb-&gt;target][hcb-&gt;lun];\n"
"                    h != NULL; h = hh) {\n"
"                hh=h-&gt;next;\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQ_ABORTED);\n"
"            }\n"
"            ccb_status = CAM_REQ_ABORTED;\n"
"        } else if(requested_bus_device_reset(hcb)) {\n"
"            int lun;\n"
"\n"
"            /* reset affects all commands on that target, so\n"
"             * mark all disconnected HCBs on that target+LUN as reset\n"
"             */\n"
"\n"
"            for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"                for(h = softc-&gt;first_discon_hcb[hcb-&gt;target][lun];\n"
"                        h != NULL; h = hh) {\n"
"                    hh=h-&gt;next;\n"
"                    free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"                }\n"
"\n"
"            /* send event */\n"
"            xpt_async(AC_SENT_BDR, hcb-&gt;ccb-&gt;ccb_h.path_id, NULL);\n"
"\n"
"            /* this was the CAM_RESET_DEV request itself, it is completed */\n"
"            ccb_status = CAM_REQ_CMP;\n"
"        } else {\n"
"            calculate_residue(hcb);\n"
"            ccb_status = CAM_UNEXP_BUSFREE;\n"
"            /* request the further code to freeze the queue */\n"
"            hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"            lun_to_freeze = hcb-&gt;lun;\n"
"        }\n"
"        break;"
msgstr ""
"    case UNEXPECTED_DISCONNECT:\n"
"        if(requested_abort(hcb)) {\n"
"            /* abort affects all commands on that target+LUN, so\n"
"             * mark all disconnected HCBs on that target+LUN as aborted too\n"
"             */\n"
"            for(h = softc-&gt;first_discon_hcb[hcb-&gt;target][hcb-&gt;lun];\n"
"                    h != NULL; h = hh) {\n"
"                hh=h-&gt;next;\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQ_ABORTED);\n"
"            }\n"
"            ccb_status = CAM_REQ_ABORTED;\n"
"        } else if(requested_bus_device_reset(hcb)) {\n"
"            int lun;\n"
"\n"
"            /* reset affects all commands on that target, so\n"
"             * mark all disconnected HCBs on that target+LUN as reset\n"
"             */\n"
"\n"
"            for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"                for(h = softc-&gt;first_discon_hcb[hcb-&gt;target][lun];\n"
"                        h != NULL; h = hh) {\n"
"                    hh=h-&gt;next;\n"
"                    free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"                }\n"
"\n"
"            /* send event */\n"
"            xpt_async(AC_SENT_BDR, hcb-&gt;ccb-&gt;ccb_h.path_id, NULL);\n"
"\n"
"            /* this was the CAM_RESET_DEV request itself, it is completed */\n"
"            ccb_status = CAM_REQ_CMP;\n"
"        } else {\n"
"            calculate_residue(hcb);\n"
"            ccb_status = CAM_UNEXP_BUSFREE;\n"
"            /* request the further code to freeze the queue */\n"
"            hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"            lun_to_freeze = hcb-&gt;lun;\n"
"        }\n"
"        break;"

#. (itstool) path: sect1/para
#: book.translate.xml:21477
msgid ""
"If the target refuses to accept tags we notify CAM about that and return "
"back all commands for this LUN:"
msgstr "如果目标拒绝接受标签，我们就通知CAM，并返回此LUN的所有命令："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21480
#, no-wrap
msgid ""
"    case TAGS_REJECTED:\n"
"        /* report the event */\n"
"        neg.flags = 0 &amp; ~CCB_TRANS_TAG_ENB;\n"
"        neg.valid = CCB_TRANS_TQ_VALID;\n"
"        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"\n"
"        ccb_status = CAM_MSG_REJECT_REC;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = hcb-&gt;lun;\n"
"        break;"
msgstr ""
"    case TAGS_REJECTED:\n"
"        /* report the event */\n"
"        neg.flags = 0 &amp; ~CCB_TRANS_TAG_ENB;\n"
"        neg.valid = CCB_TRANS_TQ_VALID;\n"
"        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"\n"
"        ccb_status = CAM_MSG_REJECT_REC;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = hcb-&gt;lun;\n"
"        break;"

#. (itstool) path: sect1/para
#: book.translate.xml:21492
msgid ""
"Then we check a number of other conditions, with processing basically "
"limited to setting the CCB status:"
msgstr "然后我们检查一些其他情况，处理(processing)基本上仅限于设置CCB状态："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21495
#, no-wrap
msgid ""
"    case SELECTION_TIMEOUT:\n"
"        ccb_status = CAM_SEL_TIMEOUT;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = CAM_LUN_WILDCARD;\n"
"        break;\n"
"    case PARITY_ERROR:\n"
"        ccb_status = CAM_UNCOR_PARITY;\n"
"        break;\n"
"    case DATA_OVERRUN:\n"
"    case ODD_WIDE_TRANSFER:\n"
"        ccb_status = CAM_DATA_RUN_ERR;\n"
"        break;\n"
"    default:\n"
"        /* all other errors are handled in a generic way */\n"
"        ccb_status = CAM_REQ_CMP_ERR;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = CAM_LUN_WILDCARD;\n"
"        break;\n"
"    }"
msgstr ""
"    case SELECTION_TIMEOUT:\n"
"        ccb_status = CAM_SEL_TIMEOUT;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = CAM_LUN_WILDCARD;\n"
"        break;\n"
"    case PARITY_ERROR:\n"
"        ccb_status = CAM_UNCOR_PARITY;\n"
"        break;\n"
"    case DATA_OVERRUN:\n"
"    case ODD_WIDE_TRANSFER:\n"
"        ccb_status = CAM_DATA_RUN_ERR;\n"
"        break;\n"
"    default:\n"
"        /* all other errors are handled in a generic way */\n"
"        ccb_status = CAM_REQ_CMP_ERR;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = CAM_LUN_WILDCARD;\n"
"        break;\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:21517
msgid ""
"Then we check if the error was serious enough to freeze the input queue "
"until it gets proceeded and do so if it is:"
msgstr ""
"然后我们检查是否错误严重到需要冻结输入队列，直到它得到处理方可 解冻，如果是这"
"样那么就这样来处理："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21520
#, no-wrap
msgid ""
"    if(hcb-&gt;ccb-&gt;ccb_h.status &amp; CAM_DEV_QFRZN) {\n"
"        /* freeze the queue */\n"
"        xpt_freeze_devq(ccb-&gt;ccb_h.path, /*count*/1);\n"
"\n"
"        /* re-queue all commands for this target/LUN back to CAM */\n"
"\n"
"        for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"            hh = h-&gt;next;\n"
"\n"
"            if(targ == h-&gt;targ\n"
"            &amp;&amp; (lun_to_freeze == CAM_LUN_WILDCARD || lun_to_freeze == h-&gt;lun) )\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQUEUE_REQ);\n"
"        }\n"
"    }\n"
"    free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, ccb_status);\n"
"    schedule_next_hcb(softc);\n"
"    return;"
msgstr ""
"    if(hcb-&gt;ccb-&gt;ccb_h.status &amp; CAM_DEV_QFRZN) {\n"
"        /* freeze the queue */\n"
"        xpt_freeze_devq(ccb-&gt;ccb_h.path, /*count*/1);\n"
"\n"
"        /* re-queue all commands for this target/LUN back to CAM */\n"
"\n"
"        for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"            hh = h-&gt;next;\n"
"\n"
"            if(targ == h-&gt;targ\n"
"            &amp;&amp; (lun_to_freeze == CAM_LUN_WILDCARD || lun_to_freeze == h-&gt;lun) )\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQUEUE_REQ);\n"
"        }\n"
"    }\n"
"    free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, ccb_status);\n"
"    schedule_next_hcb(softc);\n"
"    return;"

#. (itstool) path: sect1/para
#: book.translate.xml:21538
msgid ""
"This concludes the generic interrupt handling although specific controllers "
"may require some additions."
msgstr "这包括通用中断处理，尽管特定处理器可能需要某些附加处理。"

#. (itstool) path: sect1/title
#: book.translate.xml:21543
msgid "Errors Summary"
msgstr "错误总览"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:21545
msgid "<primary>SCSI</primary><secondary>errors</secondary>"
msgstr ""
"<primary>SCSI(小型计算机系统接口)</primary><secondary>errors(出错)</"
"secondary>"

#. (itstool) path: sect1/para
#: book.translate.xml:21547
msgid ""
"When executing an I/O request many things may go wrong. The reason of error "
"can be reported in the CCB status with great detail. Examples of use are "
"spread throughout this document. For completeness here is the summary of "
"recommended responses for the typical error conditions:"
msgstr ""
"当执行I/O请求时很多事情可能出错。可以在CCB状态中非常详尽地 报告错误原因。使用"
"的例子散布于本文档中。为了完整起见此处给出 对典型错误条件的建议响应的一个总"
"览："

#. (itstool) path: listitem/para
#: book.translate.xml:21555
msgid ""
"<emphasis>CAM_RESRC_UNAVAIL</emphasis> - some resource is temporarily "
"unavailable and the SIM driver cannot generate an event when it will become "
"available. An example of this resource would be some intra-controller "
"hardware resource for which the controller does not generate an interrupt "
"when it becomes available."
msgstr ""
"<emphasis>CAM_RESRC_UNAVAIL</emphasis> - 某些资源 暂时不可用，并且当其变为可"
"用时SIM驱动程序不能产生事件。这种资源 的一个例子就是某些控制器内部硬件资源，"
"当其可用时控制器不会为其 产生中断。"

#. (itstool) path: listitem/para
#: book.translate.xml:21564
msgid ""
"<emphasis>CAM_UNCOR_PARITY</emphasis> - unrecovered parity error occurred"
msgstr "<emphasis>CAM_UNCOR_PARITY</emphasis> - 发生不可恢复的奇偶校验错误"

#. (itstool) path: listitem/para
#: book.translate.xml:21569
msgid ""
"<emphasis>CAM_DATA_RUN_ERR</emphasis> - data overrun or unexpected data "
"phase (going in other direction than specified in CAM_DIR_MASK) or odd "
"transfer length for wide transfer"
msgstr ""
"<emphasis>CAM_DATA_RUN_ERR</emphasis> - 数据外溢或未预期的数据状态(phase)（跑"
"在另一个方向上而不是 CAM_DIR_MASK指定的方向），或对于宽传输出现奇数传输长度"

#. (itstool) path: listitem/para
#: book.translate.xml:21576
msgid ""
"<emphasis>CAM_SEL_TIMEOUT</emphasis> - selection timeout occurred (target "
"does not respond)"
msgstr "<emphasis>CAM_SEL_TIMEOUT</emphasis> - 发生选择超时（目标不响应）"

#. (itstool) path: listitem/para
#: book.translate.xml:21581
msgid ""
"<emphasis>CAM_CMD_TIMEOUT</emphasis> - command timeout occurred (the timeout "
"function ran)"
msgstr "<emphasis>CAM_CMD_TIMEOUT</emphasis> - 发生命令超时（超时函数运行）"

#. (itstool) path: listitem/para
#: book.translate.xml:21586
msgid "<emphasis>CAM_SCSI_STATUS_ERROR</emphasis> - the device returned error"
msgstr "<emphasis>CAM_SCSI_STATUS_ERROR</emphasis> - 设备返回的错误"

#. (itstool) path: listitem/para
#: book.translate.xml:21591
msgid ""
"<emphasis>CAM_AUTOSENSE_FAIL</emphasis> - the device returned error and the "
"REQUEST SENSE COMMAND failed"
msgstr ""
"<emphasis>CAM_AUTOSENSE_FAIL</emphasis> - 设备返回的错误且REQUEST SENSE命令失"
"败"

#. (itstool) path: listitem/para
#: book.translate.xml:21596
msgid ""
"<emphasis>CAM_MSG_REJECT_REC</emphasis> - MESSAGE REJECT message was received"
msgstr "<emphasis>CAM_MSG_REJECT_REC</emphasis> - 收到MESSAGE REJECT消息"

#. (itstool) path: listitem/para
#: book.translate.xml:21601
msgid "<emphasis>CAM_SCSI_BUS_RESET</emphasis> - received SCSI bus reset"
msgstr "<emphasis>CAM_SCSI_BUS_RESET</emphasis> - 收到SCSI总线复位"

#. (itstool) path: listitem/para
#: book.translate.xml:21606
msgid ""
"<emphasis>CAM_REQ_CMP_ERR</emphasis> - <quote>impossible</quote> SCSI phase "
"occurred or something else as weird or just a generic error if further "
"detail is not available"
msgstr ""
"<emphasis>CAM_REQ_CMP_ERR</emphasis> - 出现<quote>不可能(impossible)</"
"quote>SCSI状态(phase) 或者其他怪异事情，或者如果进一步的信息不可用则只是通用"
"错误"

#. (itstool) path: listitem/para
#: book.translate.xml:21613
msgid "<emphasis>CAM_UNEXP_BUSFREE</emphasis> - unexpected disconnect occurred"
msgstr "<emphasis>CAM_UNEXP_BUSFREE</emphasis> - 出现未预期的断开连接"

#. (itstool) path: listitem/para
#: book.translate.xml:21618
msgid ""
"<emphasis>CAM_BDR_SENT</emphasis> - BUS DEVICE RESET message was sent to the "
"target"
msgstr "<emphasis>CAM_BDR_SENT</emphasis> - BUS DEVICE RESET消息被发送到目标"

#. (itstool) path: listitem/para
#: book.translate.xml:21623
msgid ""
"<emphasis>CAM_UNREC_HBA_ERROR</emphasis> - unrecoverable Host Bus Adapter "
"Error"
msgstr ""
"<emphasis>CAM_UNREC_HBA_ERROR</emphasis> - 不可恢复的主机总线适配器错误"

#. (itstool) path: listitem/para
#: book.translate.xml:21628
msgid ""
"<emphasis>CAM_REQ_TOO_BIG</emphasis> - the request was too large for this "
"controller"
msgstr "<emphasis>CAM_REQ_TOO_BIG</emphasis> - 请求对于控制器太大"

#. (itstool) path: listitem/para
#: book.translate.xml:21633
msgid ""
"<emphasis>CAM_REQUEUE_REQ</emphasis> - this request should be re-queued to "
"preserve transaction ordering. This typically occurs when the SIM recognizes "
"an error that should freeze the queue and must place other queued requests "
"for the target at the sim level back into the XPT queue. Typical cases of "
"such errors are selection timeouts, command timeouts and other like "
"conditions. In such cases the troublesome command returns the status "
"indicating the error, the and the other commands which have not be sent to "
"the bus yet get re-queued."
msgstr ""
"<emphasis>CAM_REQUEUE_REQ</emphasis> - 此请求应当被重新入队以保持事务的次序"
"性。这典型地出现在下列 时刻：SIM识别出了应当冻结队列的错误，并且必须在sim级别"
"上将目标的 其他入队请求放回到XPT队列。这些错误的典型情况有选择超时、命令 超时"
"和其他类似情况。这些情况下出问题的命令返回状态来指示错误， 此命令和其他还没有"
"被发送到总线的命令被重新入队。"

#. (itstool) path: listitem/para
#: book.translate.xml:21646
msgid ""
"<emphasis>CAM_LUN_INVALID</emphasis> - the LUN ID in the request is not "
"supported by the SCSI controller"
msgstr "<emphasis>CAM_LUN_INVALID</emphasis> - SCSI控制器不支持请求中的LUN ID"

#. (itstool) path: listitem/para
#: book.translate.xml:21651
msgid ""
"<emphasis>CAM_TID_INVALID</emphasis> - the target ID in the request is not "
"supported by the SCSI controller"
msgstr "<emphasis>CAM_TID_INVALID</emphasis> - SCSI控制器不支持请求中的目标ID"

#. (itstool) path: sect1/title
#: book.translate.xml:21658
msgid "Timeout Handling"
msgstr "超时处理"

#. (itstool) path: sect1/para
#: book.translate.xml:21660
msgid ""
"When the timeout for an HCB expires that request should be aborted, just "
"like with an XPT_ABORT request. The only difference is that the returned "
"status of aborted request should be CAM_CMD_TIMEOUT instead of "
"CAM_REQ_ABORTED (that is why implementation of the abort better be done as a "
"function). But there is one more possible problem: what if the abort request "
"itself will get stuck? In this case the SCSI bus should be reset, just like "
"with an XPT_RESET_BUS request (and the idea about implementing it as a "
"function called from both places applies here too). Also we should reset the "
"whole SCSI bus if a device reset request got stuck. So after all the timeout "
"function would look like:"
msgstr ""
"当HCB的超时期满时，请求就应当被中止，就像处理XPT_ABORT请求 一样。唯一区别在于"
"被中止的请求的返回状态应当为CAM_CMD_TIMEOUT 而不是CAM_REQ_ABORTED（这就是为什"
"么中止的实现最好由函数来完成）。 但还有一个可能的问题：如果中止请求自己出了麻"
"烦怎么办？这种情况下 应当复位SCSI总线，就像处理XPT_RESET_BUS请求一样（并且将"
"其实现为 函数，从两个地方调用的想法也适用于这儿）。而且如果设备复位请求出了 "
"问题，我们应当复位整个SCSI总线。因此最终超时函数看起来像下面样子："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21673
#, no-wrap
msgid ""
"static void\n"
"xxx_timeout(void *arg)\n"
"{\n"
"    struct xxx_hcb *hcb = (struct xxx_hcb *)arg;\n"
"    struct xxx_softc *softc;\n"
"    struct ccb_hdr *ccb_h;\n"
"\n"
"    softc = hcb-&gt;softc;\n"
"    ccb_h = &amp;hcb-&gt;ccb-&gt;ccb_h;\n"
"\n"
"    if(hcb-&gt;flags &amp; HCB_BEING_ABORTED\n"
"    || ccb_h-&gt;func_code == XPT_RESET_DEV) {\n"
"        xxx_reset_bus(softc);\n"
"    } else {\n"
"        xxx_abort_ccb(hcb-&gt;ccb, CAM_CMD_TIMEOUT);\n"
"    }\n"
"}"
msgstr ""
"static void\n"
"xxx_timeout(void *arg)\n"
"{\n"
"    struct xxx_hcb *hcb = (struct xxx_hcb *)arg;\n"
"    struct xxx_softc *softc;\n"
"    struct ccb_hdr *ccb_h;\n"
"\n"
"    softc = hcb-&gt;softc;\n"
"    ccb_h = &amp;hcb-&gt;ccb-&gt;ccb_h;\n"
"\n"
"    if(hcb-&gt;flags &amp; HCB_BEING_ABORTED\n"
"    || ccb_h-&gt;func_code == XPT_RESET_DEV) {\n"
"        xxx_reset_bus(softc);\n"
"    } else {\n"
"        xxx_abort_ccb(hcb-&gt;ccb, CAM_CMD_TIMEOUT);\n"
"    }\n"
"}"

#. (itstool) path: sect1/para
#: book.translate.xml:21691
msgid ""
"When we abort a request all the other disconnected requests to the same "
"target/LUN get aborted too. So there appears a question, should we return "
"them with status CAM_REQ_ABORTED or CAM_CMD_TIMEOUT? The current drivers use "
"CAM_CMD_TIMEOUT. This seems logical because if one request got timed out "
"then probably something really bad is happening to the device, so if they "
"would not be disturbed they would time out by themselves."
msgstr ""
"当我们中止一个请求时，同一目标/LUN的所有其他断开连接的请求 也会被中止。因此出"
"现了一个问题，我们应当返回它们的状态 CAM_REQ_ABORTED还是CAM_CMD_TIMEOUT？当前"
"的驱动程序使用 CAM_CMD_TIMEOUT。这看起来符合逻辑，因为如果一个请求超时，则可"
"能 设备出现了某些的确很糟的事情，因此如果它们没有被扰乱则它们自己 应当超时。"

#. (itstool) path: info/title
#: book.translate.xml:21709
msgid "USB Devices"
msgstr "USB设备"

#. (itstool) path: authorgroup/author
#: book.translate.xml:21712
msgid ""
"<personname> <firstname>Nick</firstname> <surname>Hibma</surname> </"
"personname> <contrib>Written by </contrib>"
msgstr ""
"<personname> <firstname>Nick</firstname> <surname>Hibma</surname> </"
"personname> <contrib>Written by </contrib>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:21721
msgid ""
"<personname> <firstname>Murray</firstname> <surname>Stokely</surname> </"
"personname> <contrib>Modifications for Handbook made by </contrib>"
msgstr ""
"<personname> <firstname>Murray</firstname> <surname>Stokely</surname> </"
"personname> <contrib>Modifications for Handbook made by </contrib>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:21734
msgid "<primary>Universal Serial Bus (USB)</primary>"
msgstr "<primary>Universal Serial Bus (USB)</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:21736
msgid "<primary>NetBSD</primary>"
msgstr "<primary>NetBSD</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:21738
msgid ""
"The Universal Serial Bus (USB) is a new way of attaching devices to personal "
"computers. The bus architecture features two-way communication and has been "
"developed as a response to devices becoming smarter and requiring more "
"interaction with the host. USB support is included in all current PC "
"chipsets and is therefore available in all recently built PCs. Apple's "
"introduction of the USB-only iMac has been a major incentive for hardware "
"manufacturers to produce USB versions of their devices. The future PC "
"specifications specify that all legacy connectors on PCs should be replaced "
"by one or more USB connectors, providing generic plug and play capabilities. "
"Support for USB hardware was available at a very early stage in NetBSD and "
"was developed by Lennart Augustsson for the NetBSD project. The code has "
"been ported to FreeBSD and we are currently maintaining a shared code base. "
"For the implementation of the USB subsystem a number of features of USB are "
"important."
msgstr ""
"通用串行总线(USB)是将设备连接到个人计算机的一种新方法。总线 结构突出了双向通"
"信的特色，并且其开发充分考虑到了设备正逐渐智能化 和需要与host进行更多交互的现"
"实。对USB的支持包含在当前所有芯片中, 因此在新近制造的PC中都可用。苹果(Apple)"
"引入仅带USB的iMac对硬件 制造商生产他们USB版本的设备是一个很大的激励。未来的PC"
"规范指定 PC上的所有老连接器应当由一个或多个USB连接器取代，提供通用的 即插即用"
"能力。对USB硬件的支持在NetBSD的相当早期就有了，它是由 Lennart Augustsson为"
"NetBSD项目开发的。代码已经被移植到FreeBSD上， 我们目前维护着一个底层共享代"
"码。对USB子系统的实现来说，许多USB的 特性很重要。"

#. (itstool) path: sect1/para
#: book.translate.xml:21755
msgid ""
"<emphasis>Lennart Augustsson has done most of the implementation of the USB "
"support for the NetBSD project. Many thanks for this incredible amount of "
"work. Many thanks also to Ardy and Dirk for their comments and proofreading "
"of this paper.</emphasis>"
msgstr ""
"<emphasis>Lennart Augustsson已经完成了NetBSD项目中USB支持的 大部分实现。十分"
"感谢这项工作量惊人的工作。也十分感谢Ardy和Dirk 对本文稿的评论和校对。</"
"emphasis>"

#. (itstool) path: listitem/para
#: book.translate.xml:21764
msgid ""
"Devices connect to ports on the computer directly or on devices called hubs, "
"forming a treelike device structure."
msgstr ""
"设备直接连接到计算机上的端口，或者连接到称为 集中器的设备，形成树型设备结构。"

#. (itstool) path: listitem/para
#: book.translate.xml:21770
msgid "The devices can be connected and disconnected at run time."
msgstr "设备可在运行时连接或断开。"

#. (itstool) path: listitem/para
#: book.translate.xml:21775
msgid "Devices can suspend themselves and trigger resumes of the host system"
msgstr "设备可以挂起自身并触发host系统的重新投入运行。"

#. (itstool) path: listitem/para
#: book.translate.xml:21780
msgid ""
"As the devices can be powered from the bus, the host software has to keep "
"track of power budgets for each hub."
msgstr "由于设备可由总线供电，因此host软件必须跟踪每个 集中器的电源预算。"

#. (itstool) path: listitem/para
#: book.translate.xml:21786
msgid ""
"Different quality of service requirements by the different device types "
"together with the maximum of 126 devices that can be connected to the same "
"bus, require proper scheduling of transfers on the shared bus to take full "
"advantage of the 12Mbps bandwidth available. (over 400Mbps with USB 2.0)"
msgstr ""
"不同设备类型需要不同的服务质量，并且同一总线 可以连接最多126个设备，这就需要"
"恰当地调度总线上的传输以充分 利用12Mbps的可用带宽。（USB 2.0超过400Mbps）"

#. (itstool) path: listitem/para
#: book.translate.xml:21795
msgid ""
"Devices are intelligent and contain easily accessible information about "
"themselves"
msgstr "设备智能化并包含很容易访问到的关于自身的信息。"

#. (itstool) path: sect1/para
#: book.translate.xml:21801
msgid ""
"The development of drivers for the USB subsystem and devices connected to it "
"is supported by the specifications that have been developed and will be "
"developed. These specifications are publicly available from the USB home "
"pages. Apple has been very strong in pushing for standards based drivers, by "
"making drivers for the generic classes available in their operating system "
"MacOS and discouraging the use of separate drivers for each new device. This "
"chapter tries to collate essential information for a basic understanding of "
"the USB 2.0 implementation stack in FreeBSD/NetBSD. It is recommended "
"however to read it together with the relevant 2.0 specifications and other "
"developer resources:"
msgstr ""
"为USB子系统以及连接到它的设备开发驱动程序受已开发或将要开发的 规范的支持。这"
"些规范可以从USB主页公开获得。苹果(Apple)通过使得 通用类驱动程序可从其操作系统"
"MacOS中获得，而且不鼓励为每种新设备 使用单独的驱动程序来强烈推行基于标准的驱"
"动程序。本章试图整理基本 信息以便对FreeBSD/NetBSD中USB栈的当前实现有个基本的"
"了解。然而， 建议将下面参考中提及的相关规范与本章同时阅读："

#. (itstool) path: listitem/para
#: book.translate.xml:21816
msgid ""
"USB 2.0 Specification (<link xlink:href=\"http://www.usb.org/developers/docs/"
"usb20_docs/\">http://www.usb.org/developers/docs/usb20_docs/</link>)"
msgstr ""
"USB 2.0 Specification (<link xlink:href=\"http://www.usb.org/developers/docs/"
"usb20_docs/\">http://www.usb.org/developers/docs/usb20_docs/</link>)"

#. (itstool) path: listitem/para
#: book.translate.xml:21820
msgid ""
"Universal Host Controller Interface (<acronym>UHCI</acronym>) Specification "
"(<link xlink:href=\"ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf"
"\">ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf)</link>"
msgstr ""
"Universal Host Controller Interface (<acronym>UHCI</acronym>) Specification "
"(<link xlink:href=\"ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf"
"\">ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf)</link>"

#. (itstool) path: listitem/para
#: book.translate.xml:21825
msgid ""
"Open Host Controller Interface (<acronym>OHCI</acronym>) Specification(<link "
"xlink:href=\"ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a.pdf"
"\">ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a.pdf</link>)"
msgstr ""
"Open Host Controller Interface (<acronym>OHCI</acronym>) Specification(<link "
"xlink:href=\"ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a.pdf"
"\">ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a.pdf</link>)"

#. (itstool) path: listitem/para
#: book.translate.xml:21830
msgid ""
"Developer section of <acronym>USB</acronym> home page (<link xlink:href="
"\"http://www.usb.org/developers/\">http://www.usb.org/developers/</link>)"
msgstr ""
"Developer section of <acronym>USB</acronym> home page (<link xlink:href="
"\"http://www.usb.org/developers/\">http://www.usb.org/developers/</link>)"

#. (itstool) path: sect2/title
#: book.translate.xml:21836
msgid "Structure of the USB Stack"
msgstr "USB栈的结构"

#. (itstool) path: sect2/para
#: book.translate.xml:21838
msgid ""
"The USB support in FreeBSD can be split into three layers. The lowest layer "
"contains the host controller driver, providing a generic interface to the "
"hardware and its scheduling facilities. It supports initialisation of the "
"hardware, scheduling of transfers and handling of completed and/or failed "
"transfers. Each host controller driver implements a virtual hub providing "
"hardware independent access to the registers controlling the root ports on "
"the back of the machine."
msgstr ""
"FreeBSD中的USB支持可被分为三层。最底层包含主控器，向硬件 及其调度设施提供一个"
"通用接口。它支持硬件初始化，对传输进行调度， 处理已完成/失败的传输。每个主控"
"器驱动程序实现一个虚拟hub， 以硬件无关方式提供对控制机器背面根端口的寄存器的"
"访问。"

#. (itstool) path: sect2/para
#: book.translate.xml:21848
msgid ""
"The middle layer handles the device connection and disconnection, basic "
"initialisation of the device, driver selection, the communication channels "
"(pipes) and does resource management. This services layer also controls the "
"default pipes and the device requests transferred over them."
msgstr ""
"中间层处理设备连接和断开，设备的基本初始化，驱动程序的选择， 通信通道（管道）"
"和资源管理。这个服务层也控制默认管道和其上传输的 设备请求。"

#. (itstool) path: sect2/para
#: book.translate.xml:21855
msgid ""
"The top layer contains the individual drivers supporting specific (classes "
"of) devices. These drivers implement the protocol that is used over the "
"pipes other than the default pipe. They also implement additional "
"functionality to make the device available to other parts of the kernel or "
"userland. They use the USB driver interface (USBDI) exposed by the services "
"layer."
msgstr ""
"顶层包含支持特定（类）设备的各个驱动程序。这些驱动程序实现 除默认管道外的其他"
"管道上使用的协议。他们也实现额外功能，使得设备 对内核或用户空间是可见的。他们"
"使用服务层暴露出的USB驱动程序接口 (USBDI)。"

#. (itstool) path: sect1/title
#: book.translate.xml:21866
msgid "Host Controllers"
msgstr "主控器"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:21868
msgid "<primary>USB</primary><secondary>host controllers</secondary>"
msgstr ""
"<primary>USB(通用串行总线)</primary><secondary>host controllers(主控制器)</"
"secondary>"

#. (itstool) path: sect1/para
#: book.translate.xml:21870
msgid ""
"The host controller (HC) controls the transmission of packets on the bus. "
"Frames of 1 millisecond are used. At the start of each frame the host "
"controller generates a Start of Frame (SOF) packet."
msgstr ""
"主控器（HC）控制总线上包的传输。使用1毫秒的帧。在每帧开始 时，主控器产生一个"
"帧开始（SOF, Start of Frame）包。"

#. (itstool) path: sect1/para
#: book.translate.xml:21875
msgid ""
"The SOF packet is used to synchronise to the start of the frame and to keep "
"track of the frame number. Within each frame packets are transferred, either "
"from host to device (out) or from device to host (in). Transfers are always "
"initiated by the host (polled transfers). Therefore there can only be one "
"host per USB bus. Each transfer of a packet has a status stage in which the "
"recipient of the data can return either ACK (acknowledge reception), NAK "
"(retry), STALL (error condition) or nothing (garbled data stage, device not "
"available or disconnected). Section 8.5 of the USB 2.0 Specification "
"explains the details of packets in more detail. Four different types of "
"transfers can occur on a USB bus: control, bulk, interrupt and isochronous. "
"The types of transfers and their characteristics are described below."
msgstr ""
"SOF包用于同步帧的开始和跟踪帧的数目。包在帧中被传输，或由host 到设备（out），"
"或由设备到host（in）。传输总是由host发起（轮询传输）。 因此每条USB总线只能有"
"一个host。每个包的传输都有一个状态阶段， 数据接收者可以在其中返回ACK（应答接"
"收），NAK（重试），STALL（错误 条件）或什么也没有（混乱数据阶段，设备不可用或"
"已断开）。USB规范 <link xlink:href=\"http://www.usb.org/developers/docs.html"
"\">USB specification</link>的第8.5节更详细地解释了包的细节。USB总线 上可以出"
"现四中不同类型的传输：控制(control)， 大块(bulk)， 中断 (interrupt)和同步"
"(isochronous)。传输的类型和他们的特性在下面 描述（`管道'子节中）。"

#. (itstool) path: sect1/para
#: book.translate.xml:21890
msgid ""
"Large transfers between the device on the USB bus and the device driver are "
"split up into multiple packets by the host controller or the HC driver."
msgstr ""
"USB总线上的设备和设备驱动程序间的大型传输被主控器或HC 驱动程序分割为多个包。"

#. (itstool) path: sect1/para
#: book.translate.xml:21894
msgid ""
"Device requests (control transfers) to the default endpoints are special. "
"They consist of two or three phases: SETUP, DATA (optional) and STATUS. The "
"set-up packet is sent to the device. If there is a data phase, the direction "
"of the data packet(s) is given in the set-up packet. The direction in the "
"status phase is the opposite of the direction during the data phase, or IN "
"if there was no data phase. The host controller hardware also provides "
"registers with the current status of the root ports and the changes that "
"have occurred since the last reset of the status change register. Access to "
"these registers is provided through a virtualised hub as suggested in the "
"USB specification. The virtual hub must comply with the hub device class "
"given in chapter 11 of that specification. It must provide a default pipe "
"through which device requests can be sent to it. It returns the standard "
"andhub class specific set of descriptors. It should also provide an "
"interrupt pipe that reports changes happening at its ports. There are "
"currently two specifications for host controllers available: Universal Host "
"Controller Interface (<acronym>UHCI</acronym>) from Intel and Open Host "
"Controller Interface (<acronym>OHCI</acronym>) from Compaq, Microsoft, and "
"National Semiconductor. The <acronym>UHCI</acronym> specification has been "
"designed to reduce hardware complexity by requiring the host controller "
"driver to supply a complete schedule of the transfers for each frame. OHCI "
"type controllers are much more independent by providing a more abstract "
"interface doing a lot of work themselves."
msgstr ""
"到默认端点的设备请求（控制传输）有些特殊。它们由两或三个阶段 组成：启动"
"（SETUP），数据（DATA，可选）和状态（STATUS）。设置（set-up） 包被发送到设"
"备。如果存在数据阶段，数据包的方向在设置包中给出。 状态阶段中的方向与数据阶段"
"期间的方向相反，或者当没有数据阶段时 为IN。主控器硬件也提供寄存器，用于保存根"
"端口的当前状态和自从 状态改变寄存器最后一次复位以来所发生的改变。USB规范[2]建"
"议使用一个 虚拟hub来提供对这些寄存器的访问。虚拟hub必须符合规范第11章中给出"
"的 hub设备类。它必须提供一个默认管道使得设备请求可以发送给它。它返回 标准和"
"hub类特定的一组描述符。它也应当提供一个中断管道用来报告其 端口发生的变化。当"
"前可用的主控器规范有两个：通用主控器接口（<acronym>UHCI</acronym>；英特尔）和"
"开放主控器接口（<acronym>OHCI</acronym>；康柏，微软，国家半导体）。 "
"<acronym>UHCI</acronym>规范的设计通过要求主控器驱动程序为每帧的传输提供完整的"
"调度， 从而减少了硬件复杂性。OHCI类型的控制器自身提供一个更抽象的接口来 完成"
"很多工作，从而更加独立。"

#. (itstool) path: sect2/title
#: book.translate.xml:21923
msgid "UHCI"
msgstr "UHCI"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:21925
msgid "<primary>USB</primary> <secondary>UHCI</secondary>"
msgstr "<primary>USB</primary> <secondary>UHCI</secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:21930
msgid ""
"The UHCI host controller maintains a framelist with 1024 pointers to per "
"frame data structures. It understands two different data types: transfer "
"descriptors (TD) and queue heads (QH). Each TD represents a packet to be "
"communicated to or from a device endpoint. QHs are a means to groupTDs (and "
"QHs) together."
msgstr ""
"UHCI主控器维护着带有1024个指向每帧数据结构的帧列表。 它理解两种不同的数据类"
"型：传输描述符（TD）和队列头（QH）。每个 TD表示表示与设备端点进行通信的一个"
"包。QH是将一些TD（和QH）划分 成组的一种方法。"

#. (itstool) path: sect2/para
#: book.translate.xml:21937
msgid ""
"Each transfer consists of one or more packets. The UHCI driver splits large "
"transfers into multiple packets. For every transfer, apart from isochronous "
"transfers, a QH is allocated. For every type of transfer these QHs are "
"collected at a QH for that type. Isochronous transfers have to be executed "
"first because of the fixed latency requirement and are directly referred to "
"by the pointer in the framelist. The last isochronous TD refers to the QH "
"for interrupt transfers for that frame. All QHs for interrupt transfers "
"point at the QH for control transfers, which in turn points at the QH for "
"bulk transfers. The following diagram gives a graphical overview of this:"
msgstr ""
"每个传输由一个或多个包组成。UHCI驱动程序将大的传输分割成 多个包。除同步传输"
"外，每个传输都会分配一个QH。对于每种类型的 传输，都有一个与此类型对应的QH，所"
"有这些QH都会被集中到这个QH上。 由于有固定的时延需求，同步传输必须首先执行，它"
"是通过帧列表中的 指针直接引用的。最后的同步TD传输引用那一帧的中断传输的QH。中"
"断 传输的所有QH指向控制传输的QH，控制传输的QH又指向大块传输的QH。 下面的图表"
"给出了一个图形概览："

#. (itstool) path: sect2/para
#: book.translate.xml:21950
msgid ""
"This results in the following schedule being run in each frame. After "
"fetching the pointer for the current frame from the framelist the controller "
"first executes the TDs for all the isochronous packets in that frame. The "
"last of these TDs refers to the QH for the interrupt transfers for "
"thatframe. The host controller will then descend from that QH to the QHs for "
"the individual interrupt transfers. After finishing that queue, the QH for "
"the interrupt transfers will refer the controller to the QH for all control "
"transfers. It will execute all the subqueues scheduled there, followed by "
"all the transfers queued at the bulk QH. To facilitate the handling of "
"finished or failed transfers different types of interrupts are generated by "
"the hardware at the end of each frame. In the last TD for a transfer the "
"Interrupt-On Completion bit is set by the HC driver to flag an interrupt "
"when the transfer has completed. An error interrupt is flagged if a TD "
"reaches its maximum error count. If the short packet detect bit is set in a "
"TD and less than the set packet length is transferred this interrupt is "
"flagged to notify the controller driver of the completed transfer. It is the "
"host controller driver's task to find out which transfer has completed or "
"produced an error. When called the interrupt service routine will locate all "
"the finished transfers and call their callbacks."
msgstr ""
"这导致下面的调度会在每帧中运行。控制器从帧列表中取得当前帧 的指针后，首先为那"
"一帧中的所有的同步(isochronous)包执行TD。 这些TD的最后一个 引用那一帧的中断传"
"输的QH。然后主控器将从那个QH下行到各个 中断传输的QH。完成那一队列后，中断传输"
"的QH会将控制器指向到所有 控制传输的QH。它将执行在那儿等待调度的所有子队列，然"
"后是在大块QH中 排队的所有传输。为了方便处理已完成或失败的传输，硬件会在每帧末"
"尾 产生不同类型的中断。在传输的最后一个TD中，HC驱动程序设置 Interrupt-On-"
"Completion位来标记传输完成时的一个中断。如果TD达到了 其最大错误数，就标记错误"
"中断。如果在TD中设置短包侦测位，且传输了 小于所设置的包长度（的包），就会标记"
"此中断以通知控制器驱动程序传输 已完成。找出哪个传输已完成或产生错误是主控器驱"
"动程序的任务。 当中断服务例程被调用时，它将定位所有已完成的传输并调用它们的回"
"调。"

#. (itstool) path: sect2/para
#: book.translate.xml:21974
msgid ""
"Refer to the <acronym>UHCI</acronym> Specification for a more elaborate "
"description."
msgstr "更详尽的说明请参阅 <acronym>UHCI</acronym> 规范。"

#. (itstool) path: sect2/title
#: book.translate.xml:21980
msgid "OHCI"
msgstr "OHCI"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:21982
msgid "<primary>USB</primary> <secondary>OHCI</secondary>"
msgstr "<primary>USB</primary> <secondary>OHCI</secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:21987
msgid ""
"Programming an OHCI host controller is much simpler. The controller assumes "
"that a set of endpoints is available, and is aware of scheduling priorities "
"and the ordering of the types of transfers in a frame. The main data "
"structure used by the host controller is the endpoint descriptor (ED) to "
"which a queue of transfer descriptors (TDs) is attached. The ED contains the "
"maximum packet size allowed for an endpoint and the controller hardware does "
"the splitting into packets. The pointers to the data buffers are updated "
"after each transfer and when the start and end pointer are equal, the TD is "
"retired to the done-queue. The four types of endpoints (interrupt, "
"isochronous, control, and bulk) have their own queues. Control and bulk "
"endpoints are queued each at their own queue. Interrupt EDs are queued in a "
"tree, with the level in the tree defining the frequency at which they run."
msgstr ""
"对OHCI主控器进行编程要容易得多。控制器假设有一组端点(endpoint)可用， 并知道帧"
"中不同传输类型的调度优先级和排序。主控器使用的主要 数据结构是端点描述符"
"（ED），它上面连接着一个传输描述符（TD）的队列。 ED包含端点所允许的最大的包大"
"小，控制器硬件完成包的分割。每次传输 后都会更新指向数据缓冲区的指针，当起始和"
"终止指针相等时，TD就退归 到完成队列(done-queue)。四种类型的端点各有其自己的队"
"列。控制和 大块(bulk)端点分别在它们自己的队列排队。中断ED在树中排队，在树中的"
"深度 定义了它们运行的频度。"

#. (itstool) path: sect2/para
#: book.translate.xml:22003
msgid ""
"The schedule being run by the host controller in each frame looks as "
"follows. The controller will first run the non-periodic control and bulk "
"queues, up to a time limit set by the HC driver. Then the interrupt "
"transfers for that frame number are run, by using the lower five bits of the "
"frame number as an index into level 0 of the tree of interrupts EDs. At the "
"end of this tree the isochronous EDs are connected and these are traversed "
"subsequently. The isochronous TDs contain the frame number of the first "
"frame the transfer should be run in. After all the periodic transfers have "
"been run, the control and bulk queues are traversed again. Periodically the "
"interrupt service routine is called to process the done queue and call the "
"callbacks for each transfer and reschedule interrupt and isochronous "
"endpoints."
msgstr ""
"主控器在每帧中运行的调度看起来如下。控制器首先运行非 周期性控制和大块队列，最"
"长可到HC驱动程序设置的一个时间限制。 然后以帧编号低5位作为中断ED树上深度为0的"
"那一层中的索引，运行 那个帧编号的中断传输。在这个树的末尾，同步ED被连接，并随"
"后被 遍历。同步TD包含了传输应当运行其中的第一个帧的帧编号。所有周期 性的传输"
"运行过以后，控制和大块队列再次被遍历。中断服务例程会被 周期性地调用，来处理完"
"成的队列，为每个传输调用回调，并重新调度 中断和同步端点。"

#. (itstool) path: sect2/para
#: book.translate.xml:22018
msgid ""
"See the <acronym>UHCI</acronym> Specification for a more elaborate "
"description. The middle layer provides access to the device in a controlled "
"way and maintains resources in use by the different drivers and the services "
"layer. The layer takes care of the following aspects:"
msgstr ""
"更详尽的描述请看<acronym>UHCI</acronym>标准描述。服务层，即中间层，提供了以可"
"控的方式 对设备进行访问，并维护着由不同驱动程序和服务层所使用的资源。 此层处"
"理下面几方面："

#. (itstool) path: listitem/para
#: book.translate.xml:22026
msgid "The device configuration information"
msgstr "设备配置信息"

#. (itstool) path: listitem/para
#: book.translate.xml:22029
msgid "The pipes to communicate with a device"
msgstr "与设备进行通信的管道"

#. (itstool) path: listitem/para
#: book.translate.xml:22032
msgid "Probing and attaching and detaching form a device."
msgstr "探测和连接设备，以及从设备分离(detach)。"

#. (itstool) path: sect1/title
#: book.translate.xml:22040
msgid "USB Device Information"
msgstr "USB设备信息"

#. (itstool) path: sect2/title
#: book.translate.xml:22043
msgid "Device Configuration Information"
msgstr "设备配置信息"

#. (itstool) path: sect2/para
#: book.translate.xml:22045
msgid ""
"Each device provides different levels of configuration information. Each "
"device has one or more configurations, of which one is selected during probe/"
"attach. A configuration provides power and bandwidth requirements. Within "
"each configuration there can be multiple interfaces. A device interface is a "
"collection of endpoints. For example USB speakers can have an interface for "
"the audio data (Audio Class) and an interface for the knobs, dials and "
"buttons (HID Class). All interfaces in a configuration are active at the "
"same time and can be attached to by different drivers. Each interface can "
"have alternates, providing different quality of service parameters. In for "
"example cameras this is used to provide different frame sizes and numbers of "
"frames per second."
msgstr ""
"每个设备提供了不同级别的配置信息。每个设备具有一个或多个 配置，探测/连接期间"
"从其中选定一个。配置提供功率和带宽要求。 每个配置中可以有多个接口。设备接口是"
"端点的汇集(collection)。 例如，USB扬声器可以有一个音频接口（音频类），和对旋"
"钮(knob)、 拨号盘(dial)和按钮的接口（HID类）。 一个配置中的所有接口可以同时有"
"效，并可被不同的 驱动程序连接。每个接口可以有备用接口，以提供不同质量的服务参"
"数。 例如，在照相机中，这用来提供不同的帧大小以及每秒帧数。"

#. (itstool) path: sect2/para
#: book.translate.xml:22060
msgid ""
"Within each interface, 0 or more endpoints can be specified. Endpoints are "
"the unidirectional access points for communicating with a device. They "
"provide buffers to temporarily store incoming or outgoing data from the "
"device. Each endpoint has a unique address within a configuration, the "
"endpoint's number plus its direction. The default endpoint, endpoint 0, is "
"not part of any interface and available in all configurations. It is managed "
"by the services layer and not directly available to device drivers."
msgstr ""
"每个接口中可以指定0或多个端点。端点是与设备进行通信的单向 访问点。它们提供缓"
"冲区来临时存储从设备而来的，或外出到设备的数据。 每个端点在配置中有唯一地址，"
"即端点号加上其方向。默认端点，即 端点0，不是任何接口的一部分，并且在所有配置"
"中可用。它由服务层 管理，并且设备驱动程序不能直接使用。"

#. (itstool) path: sect2/para
#: book.translate.xml:22076
msgid ""
"This hierarchical configuration information is described in the device by a "
"standard set of descriptors (see section 9.6 of the USB specification). They "
"can be requested through the Get Descriptor Request. The services layer "
"caches these descriptors to avoid unnecessary transfers on the USB bus. "
"Access to the descriptors is provided through function calls."
msgstr ""
"这种层次化配置信息在设备中通过标准的一组描述符来描述（参看 USB规范[2]第9.6"
"节）。它们可以通过Get Descriptor Request来请求。 服务层缓存这些描述符以避免在"
"USB总线上进行不必要的传输。对这些 描述符的访问是通过函数调用来提供的。"

#. (itstool) path: listitem/para
#: book.translate.xml:22086
msgid ""
"Device descriptors: General information about the device, like Vendor, "
"Product and Revision Id, supported device class, subclass and protocol if "
"applicable, maximum packet size for the default endpoint, etc."
msgstr ""
"设备描述符：关于设备的通用信息，如供应商，产品 和修订ID，支持的设备类、子类和"
"适用的协议，默认端点的最大包大小 等。"

#. (itstool) path: listitem/para
#: book.translate.xml:22093
msgid ""
"Configuration descriptors: The number of interfaces in this configuration, "
"suspend and resume functionality supported and power requirements."
msgstr "配置描述符：此配置中的接口数，支持的挂起和 恢复能力，以及功率要求。"

#. (itstool) path: listitem/para
#: book.translate.xml:22099
msgid ""
"Interface descriptors: interface class, subclass and protocol if applicable, "
"number of alternate settings for the interface and the number of endpoints."
msgstr "接口描述符：接口类、子类和适用的协议，接口备用 配置的数目和端点数目。"

#. (itstool) path: listitem/para
#: book.translate.xml:22105
msgid ""
"Endpoint descriptors: Endpoint address, direction and type, maximum packet "
"size supported and polling frequency if type is interrupt endpoint. There is "
"no descriptor for the default endpoint (endpoint 0) and it is never counted "
"in an interface descriptor."
msgstr ""
"端点描述符：端点地址、方向和类型，支持的最大包 大小，如果是中断类型的端点则还"
"包括轮询频率。默认端点（端点0） 没有描述符，而且从不被计入接口描述符中。"

#. (itstool) path: listitem/para
#: book.translate.xml:22113
msgid ""
"String descriptors: In the other descriptors string indices are supplied for "
"some fields.These can be used to retrieve descriptive strings, possibly in "
"multiple languages."
msgstr ""
"字符串描述符：在其他描述符中会为某些字段提供 字符串索引。它们可被用来检取描述"
"性字符串，可能以多种语言 的形式提供。"

#. (itstool) path: sect2/para
#: book.translate.xml:22120
msgid ""
"Class specifications can add their own descriptor types that are available "
"through the GetDescriptor Request."
msgstr ""
"类说明(specification)可以添加它们自己的描述符类型，这些描述符 也可以通过"
"GetDescriptor Request来获得。"

#. (itstool) path: sect2/para
#: book.translate.xml:22123
msgid ""
"Pipes Communication to end points on a device flows through so-called pipes. "
"Drivers submit transfers to endpoints to a pipe and provide a callback to be "
"called on completion or failure of the transfer (asynchronous transfers) or "
"wait for completion (synchronous transfer). Transfers to an endpoint are "
"serialised in the pipe. A transfer can either complete, fail or time-out (if "
"a time-out has been set). There are two types of time-outs for transfers. "
"Time-outs can happen due to time-out on the USBbus (milliseconds). These "
"time-outs are seen as failures and can be due to disconnection of the "
"device. A second form of time-out is implemented in software and is "
"triggered when a transfer does not complete within a specified amount of "
"time (seconds). These are caused by a device acknowledging negatively (NAK) "
"the transferred packets. The cause for this is the device not being ready to "
"receive data, buffer under- or overrun or protocol errors."
msgstr ""
"管道与设备上端点的通信，流经所谓的管道。驱动程序将到端点的 传输提交到管道，并"
"提供传输（异步传输）失败或完成时调用的回调， 或等待完成（同步传输）。到端点的"
"传输在管道中被串行化。传输或者完成， 或者失败，或者超时（如果设置了超时）。对"
"于传输有两种类型的超时。 超时的发生可能由于USB总线上的超时（毫秒）。这些超时"
"被视为失败， 可能是由于设备断开连接引起的。另一种超时在软件中实现，当传输没"
"有 在指定的时间（秒）内完成时触发。这是由于设备对传输的包否定应答引起的。 其"
"原因是由于设备还没有准备好接收数据，缓冲区欠载或超载，或协议错误。"

#. (itstool) path: sect2/para
#: book.translate.xml:22141
msgid ""
"If a transfer over a pipe is larger than the maximum packet size specified "
"in the associated endpoint descriptor, the host controller (OHCI) or the HC "
"driver (UHCI) will split the transfer into packets of maximum packet size, "
"with the last packet possibly smaller than the maximum packet size."
msgstr ""
"如果管道上的传输大于关联的端点描述符中指定的最大包大小，主 控器（OHCI）或HC驱"
"动程序（UHCI）将按最大包大小分割传输，并且最后 一个包可能小于最大包的大小。"

#. (itstool) path: sect2/para
#: book.translate.xml:22148
msgid ""
"Sometimes it is not a problem for a device to return less data than "
"requested. For example abulk-in-transfer to a modem might request 200 bytes "
"of data, but the modem has only 5 bytes available at that time. The driver "
"can set the short packet (SPD) flag. It allows the host controller to accept "
"a packet even if the amount of data transferred is less than requested. This "
"flag is only valid for in-transfers, as the amount of data to be sent to a "
"device is always known beforehand. If an unrecoverable error occurs in a "
"device during a transfer the pipe is stalled. Before any more data is "
"accepted or sent the driver needs to resolve the cause of the stall and "
"clear the endpoint stall condition through send the clear endpoint halt "
"device request over the default pipe. The default endpoint should never "
"stall."
msgstr ""
"有时候对设备来说返回少于所请求的数据并不是个问题。例如， 到调制解调器的大块in"
"传输可能请求200字节的数据，但调制解调器 那时只有5个字节可用。驱动程序可以设置"
"短包(SPD)标志。它允许主 控器即使在传输的数据量少于所请求的数据量的情况下也接"
"受包。 这个标志只在in传输中有效，因为将要被发送到设备的数据量总是事先 知道"
"的。如果传输过程中设备出现不可恢复的错误，管道会被停顿。 接受或发送更多数据以"
"前，驱动程序需要确定停顿的原因，并通过在 默认管道上发送清除端点挂起设备请求"
"(clear endpoint halt device request)来清除端点停顿条件。"

#. (itstool) path: sect2/para
#: book.translate.xml:22163
msgid ""
"There are four different types of endpoints and corresponding pipes: - "
"Control pipe / default pipe: There is one control pipe per device, connected "
"to the default endpoint (endpoint 0). The pipe carries the device requests "
"and associated data. The difference between transfers over the default pipe "
"and other pipes is that the protocol for the transfers is described in the "
"USB specification. These requests are used to reset and configure the "
"device. A basic set of commands that must be supported by each device is "
"provided in chapter 9 of the USB specification. The commands supported on "
"this pipe can be extended by a device class specification to support "
"additional functionality."
msgstr ""
"有四种不同类型的端点和对应的管道： -控制管道/默认管道： 每个设备有一个控制管"
"道，连接到默认端点（端点0）。此管道运载设备 请求和关联的数据。默认管道和其他"
"管道上的传输的区别在于传输所 使用的协议，协议在USB规范[2]中描述。这些请求用于"
"复位和配置设备。 每个设备必须支持USB规范[2]的第9章中提供的一组基本命令。管道"
"上 支持的命令可以通过设备类规范扩展，以支持额外的功能。"

#. (itstool) path: listitem/para
#: book.translate.xml:22178
msgid "Bulk pipe: This is the USB equivalent to a raw transmission medium."
msgstr "大块(bulk)管道：这是USB与原始传输媒体对应的等价物。"

#. (itstool) path: listitem/para
#: book.translate.xml:22183
msgid ""
"Interrupt pipe: The host sends a request for data to the device and if the "
"device has nothing to send, it will NAK the data packet. Interrupt transfers "
"are scheduled at a frequency specified when creating the pipe."
msgstr ""
"中断管道：host向设备发送数据请求，如果设备没有 东西发送，则将NAK（否定应答）"
"数据包。中断传输按创建管道时指定的 频率被调度。"

#. (itstool) path: listitem/para
#: book.translate.xml:22191
msgid ""
"Isochronous pipe: These pipes are intended for isochronous data, for example "
"video or audio streams, with fixed latency, but no guaranteed delivery. Some "
"support for pipes of this type is available in the current implementation. "
"Packets in control, bulk and interrupt transfers are retried if an error "
"occurs during transmission or the device acknowledges the packet negatively "
"(NAK) due to for example lack of buffer space to store the incoming data. "
"Isochronous packets are however not retried in case of failed delivery or "
"NAK of a packet as this might violate the timing constraints."
msgstr ""
"同步管道：这些管道用于具有固定时延的同步数据， 例如视频或音频流，但不保证一定"
"传输。当前实现中已经有对这种类型 管道的某些支持。当传输期间出现错误，或者由"
"于，例如缺乏缓冲区空间 来存储进入的数据而引起的设备否定应答包（NAK）时，控"
"制、大块和中断 管道中的包会被重试。而同步包在传递失败或对包NAK时不会重试，因"
"为 那样可能违反同步约束。"

#. (itstool) path: sect2/para
#: book.translate.xml:22206
msgid ""
"The availability of the necessary bandwidth is calculated during the "
"creation of the pipe. Transfers are scheduled within frames of 1 "
"millisecond. The bandwidth allocation within a frame is prescribed by the "
"USB specification, section 5.6 [ 2]. Isochronous and interrupt transfers are "
"allowed to consume up to 90% of the bandwidth within a frame. Packets for "
"control and bulk transfers are scheduled after all isochronous and interrupt "
"packets and will consume all the remaining bandwidth."
msgstr ""
"所需带宽的可用性在管道的创建期间被计算。传输在1毫秒的帧内 进行调度。帧中的带"
"宽分配由USB规范的第5.6节规定。同步和中断传输被 允许消耗帧中多达90%的带宽。控"
"制和大块传输的包在所有同步和中断包 之后进行调度，并将消耗所有剩余带宽。"

#. (itstool) path: sect2/para
#: book.translate.xml:22216
msgid ""
"More information on scheduling of transfers and bandwidth reclamation can be "
"found in chapter 5 of the USB specification, section 1.3 of the UHCI "
"specification, and section 3.4.2 of the OHCI specification."
msgstr ""
"关于传输调度和带宽回收的更多信息可以在USB规范[2]的第5章， UHCI规范[3]的的第"
"1.3节，OHCI规范[4]的3.4.2节中找到。"

#. (itstool) path: sect1/title
#: book.translate.xml:22224
msgid "Device Probe and Attach"
msgstr "设备的探测和连接"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:22226
msgid "<primary>USB</primary> <secondary>probe</secondary>"
msgstr "<primary>USB(通用串行总线)</primary><secondary>probe(探测)</secondary>"

#. (itstool) path: sect1/para
#: book.translate.xml:22231
msgid ""
"After the notification by the hub that a new device has been connected, the "
"service layer switches on the port, providing the device with 100 mA of "
"current. At this point the device is in its default state and listening to "
"device address 0. The services layer will proceed to retrieve the various "
"descriptors through the default pipe. After that it will send a Set Address "
"request to move the device away from the default device address (address 0). "
"Multiple device drivers might be able to support the device. For example a "
"modem driver might be able to support an ISDN TA through the AT "
"compatibility interface. A driver for that specific model of the ISDN "
"adapter might however be able to provide much better support for this "
"device. To support this flexibility, the probes return priorities indicating "
"their level of support. Support for a specific revision of a product ranks "
"the highest and the generic driver the lowest priority. It might also be "
"that multiple drivers could attach to one device if there are multiple "
"interfaces within one configuration. Each driver only needs to support a "
"subset of the interfaces."
msgstr ""
"集中器(hub)通知新设备已连接后，服务层给端口加电(switch on)， 为设备提供100mA"
"的电流。 此时设备处于其默认状态，并监听设备地址0。服务层会通过默认 管道继续检"
"取各种描述符。此后它将向设备发送Set Address请求，将设备 从默认设备地址(地址0)"
"移开。可能有多个设备驱动程序支持此设备。例如， 一个调制解调器可能通过AT兼容接"
"口支持ISDN TA。然而，特定型号的ISDN 适配器的驱动程序可能提供对此设备的更好支"
"持。为了支持这样的灵活性， 探测会返回优先级，指示他们的支持级别。支持产品的特"
"定版本会具有最高 优先级，通用驱动程序具有最低优先级。如果一个配置内有多个接"
"口，也可能 多个驱动程序会连接到一个设备。每个驱动程序只需支持所有接口的一个子"
"集。"

#. (itstool) path: sect1/para
#: book.translate.xml:22250
msgid ""
"The probing for a driver for a newly attached device checks first for device "
"specific drivers. If not found, the probe code iterates over all supported "
"configurations until a driver attaches in a configuration. To support "
"devices with multiple drivers on different interfaces, the probe iterates "
"over all interfaces in a configuration that have not yet been claimed by a "
"driver. Configurations that exceed the power budget for the hub are ignored. "
"During attach the driver should initialise the device to its proper state, "
"but not reset it, as this will make the device disconnect itself from the "
"bus and restart the probing process for it. To avoid consuming unnecessary "
"bandwidth should not claim the interrupt pipe at attach time, but should "
"postpone allocating the pipe until the file is opened and the data is "
"actually used. When the file is closed the pipe should be closed again, even "
"though the device might still be attached."
msgstr ""
"为新连接的设备探测驱动程序时，首先探测设备特定的驱动程序。 如果没有发现，则探"
"测代码在所有支持的配置上重复探测过程，直到 在一个配置中连接到一个驱动程序。为"
"了支持不同接口上使用多个驱动 程序的设备，探测会在一个配置中的所有尚未被驱动程"
"序声明(claim)的 接口上重复进行。超出集中器功率预算的配置会被忽略。连接期间，"
"驱动 程序应当把设备初始化到适当状态，但不能复位，因为那样会使得设备将 它自己"
"从总线上断开，并重新启动探测过程。为了避免消耗不必要的带宽， 不应当在连接时声"
"明中断管道，而应当延迟分配管道，直到打开文件并真的 使用数据。当关闭文件时，管"
"道也应当被再次关闭，尽管设备可能仍然 连接着。"

#. (itstool) path: sect2/title
#: book.translate.xml:22268
msgid "Device Disconnect and Detach"
msgstr "设备断开连接(disconnect)和分离(detach)"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:22270
msgid "<primary>USB</primary> <secondary>disconnect</secondary>"
msgstr ""
"<primary>USB(通用串行总线)</primary><secondary>disconnect(断开)</secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:22275
msgid ""
"A device driver should expect to receive errors during any transaction with "
"the device. The design of USB supports and encourages the disconnection of "
"devices at any point in time. Drivers should make sure that they do the "
"right thing when the device disappears."
msgstr ""
"设备驱动程序与设备进行任何事务期间，应当预期会接收到错误。 USB的设计支持并鼓"
"励设备在任何点及时断开连接。驱动程序应当确保 当设备不在时做正确的事情。"

#. (itstool) path: sect2/para
#: book.translate.xml:22281
msgid ""
"Furthermore a device that has been disconnected and reconnected will not be "
"reattached at the same device instance. This might change in the future when "
"more devices support serial numbers (see the device descriptor) or other "
"means of defining an identity for a device have been developed."
msgstr ""
"此外，断开连接(disconnect)后又重新连接(reconnect)的设备不会 被重新连接"
"(reattach)为相同的设备实例。 将来当更多的设备支持序列号（参看设备描述符）， "
"或开发出其他定义设备标识的方法的时候，这种情况可能会改变。"

#. (itstool) path: sect2/para
#: book.translate.xml:22288
msgid ""
"The disconnection of a device is signaled by a hub in the interrupt packet "
"delivered to the hub driver. The status change information indicates which "
"port has seen a connection change. The device detach method for all device "
"drivers for the device connected on that port are called and the structures "
"cleaned up. If the port status indicates that in the mean time a device has "
"been connected to that port, the procedure for probing and attaching the "
"device will be started. A device reset will produce a disconnect-connect "
"sequence on the hub and will be handled as described above."
msgstr ""
"设备断开连接是由集中器在传递到集中器驱动程序的中断包中发 信号通知(signal)的。"
"状态改变信息指示哪个端口发现了连接改变。 连接到那个端口上的设备的所有设备驱动"
"程序共用的设备分离方法被调用， 结构被彻底清理。如果端口状态指示同时一个设备已"
"经连接(connect)到那个 端口，则探测和连接设备的过程将被启动。设备复位将在集中"
"器上产生 一个断开-连接序列，并将按上面所述进行处理。"

#. (itstool) path: sect1/title
#: book.translate.xml:22303
msgid "USB Drivers Protocol Information"
msgstr "USB驱动程序的协议信息"

#. (itstool) path: sect1/para
#: book.translate.xml:22305
msgid ""
"The protocol used over pipes other than the default pipe is undefined by the "
"USB specification. Information on this can be found from various sources. "
"The most accurate source is the developer's section on the USB home pages. "
"From these pages, a growing number of deviceclass specifications are "
"available. These specifications specify what a compliant device should look "
"like from a driver perspective, basic functionality it needs to provide and "
"the protocol that is to be used over the communication channels. The USB "
"specification includes the description of the Hub Class. A class "
"specification for Human Interface Devices (HID) has been created to cater "
"for keyboards, tablets, bar-code readers, buttons, knobs, switches, etc. A "
"third example is the class specification for mass storage devices. For a "
"full list of device classes see the developers section on the USB home pages."
msgstr ""
"USB规范没有定义除默认管道外其他管道上使用的协议。这方面的信息 可以从各种来源"
"获得。最准确的来源是USB主页[1]上的开发者部分。从这些 页面上可以得到数目不断增"
"长的设备类的规范。这些规范指定从驱动程序 角度看起来兼容设备应当怎样，它需要提"
"供的基本功能和通信通道上使用的 协议。USB规范[2]包括了集中器类的描述。人机界面"
"设备(HID)的类规范已经 创建出来，以迎合对键盘、数字输入板、条形码阅读器、按"
"钮、旋钮(手柄knob)、 开关等的要求。另一个例子是用于大容量存储设备的类规范。设"
"备类的完整列表 参看USB主页[1]的开发者部分。"

#. (itstool) path: sect1/para
#: book.translate.xml:22321
msgid ""
"For many devices the protocol information has not yet been published "
"however. Information on the protocol being used might be available from the "
"company making the device. Some companies will require you to sign a Non -"
"Disclosure Agreement (NDA) before giving you the specifications. This in "
"most cases precludes making the driver open source."
msgstr ""
"然而, 许多设备的协议信息还没有被公布。关于所用协议的信息 可能可以从制造设备的"
"公司获得。一些公司会在给你规范之前要求你签署 保密协议(Non-Disclosure "
"Agreement, NDA)。大多数情况下，这会阻止 将驱动程序开放源代码。"

#. (itstool) path: sect1/para
#: book.translate.xml:22328
msgid ""
"Another good source of information is the Linux driver sources, as a number "
"of companies have started to provide drivers for Linux for their devices. It "
"is always a good idea to contact the authors of those drivers for their "
"source of information."
msgstr ""
"另一个信息的很好来源是Linux驱动程序源代码，因为很多公司已经 开始为他们的设备"
"提供Linux下的驱动程序。联系那些驱动程序作者询问 他们的信息来源总是一个好主"
"意。"

#. (itstool) path: sect1/para
#: book.translate.xml:22334
msgid ""
"Example: Human Interface Devices The specification for the Human Interface "
"Devices like keyboards, mice, tablets, buttons, dials,etc. is referred to in "
"other device class specifications and is used in many devices."
msgstr ""
"例子：人机界面设备。人机界面设备，如键盘、鼠标、数字输入板、 按钮、拨号盘等的"
"规范被其他设备类规范引用，并在很多设备中使用。"

#. (itstool) path: sect1/para
#: book.translate.xml:22339
msgid ""
"For example audio speakers provide endpoints to the digital to analogue "
"converters and possibly an extra pipe for a microphone. They also provide a "
"HID endpoint in a separate interface for the buttons and dials on the front "
"of the device. The same is true for the monitor control class. It is "
"straightforward to build support for these interfaces through the available "
"kernel and userland libraries together with the HID class driver or the "
"generic driver. Another device that serves as an example for interfaces "
"within one configuration driven by different device drivers is a cheap "
"keyboard with built-in legacy mouse port. To avoid having the cost of "
"including the hardware for a USB hub in the device, manufacturers combined "
"the mouse data received from the PS/2 port on the back of the keyboard and "
"the key presses from the keyboard into two separate interfaces in the same "
"configuration. The mouse and keyboard drivers each attach to the appropriate "
"interface and allocate the pipes to the two independent endpoints."
msgstr ""
"例如，音频扬声器提供到数模转换器的端点，可能还提供额外管道 用于麦克风。它们也"
"为设备前面的按钮和拨号盘在单独的接口中提供HID 端点。监视器控制类也是如此。通"
"过可用的内核和用户空间的库，与HID 类驱动程序或通用驱动程序一起可以简单直接地"
"创建对这些接口的支持。 另一个设备可以作为在一个配置中的多个接口由不同的设备驱"
"动程序驱动 的例子，这个设备是一种便宜的键盘，带有老的鼠标接口。为了避免在 设"
"备中为USB集中器包括一个硬件而导致的成本上升，制造商将从键盘背面的 PS/2端口接"
"收到的鼠标数据与来自键盘的按键组合成在同一个配置中的 两个单独的接口。鼠标和键"
"盘驱动程序各自连接到适当的接口，并分配到 两个独立端点的管道."

#. (itstool) path: sect1/indexterm
#: book.translate.xml:22358
msgid "<primary>USB</primary> <secondary>firmware</secondary>"
msgstr ""
"<primary>USB(通用串行总线)</primary><secondary>firmware(固件)</secondary>"

#. (itstool) path: sect1/para
#: book.translate.xml:22363
msgid ""
"Example: Firmware download Many devices that have been developed are based "
"on a general purpose processor with an additional USB core added to it. "
"Because the development of drivers and firmware for USB devices is still "
"very new, many devices require the downloading of the firmware after they "
"have been connected."
msgstr ""
"例子：固件下载。已经开发出来的许多设备是基于通用目的处理器， 并将额外的USB核"
"心加入其中。由于驱动程序的开发和USB设备的固件仍然 非常新，许多设备需要在连接"
"(connect)之后下载固件。"

#. (itstool) path: sect1/para
#: book.translate.xml:22370
msgid ""
"The procedure followed is straightforward. The device identifies itself "
"through a vendor and product Id. The first driver probes and attaches to it "
"and downloads the firmware into it. After that the device soft resets itself "
"and the driver is detached. After a short pause the device announces its "
"presence on the bus. The device will have changed its vendor/product/"
"revision Id to reflect the fact that it has been supplied with firmware and "
"as a consequence a second driver will probe it and attach to it."
msgstr ""
"下面的步骤非常简明直接。设备通过供应商和产品ID标识自身。第一 个驱动程序探测并"
"连接到它，并将固件下载到其中。此后设备自己软复位， 驱动程序分离。短暂的暂停之"
"后设备宣布它在总线上的存在。设备将改变 其供应商/产品/版本的ID以反映其提供有固"
"件的事实，因此另一个驱动程序 将探测它并连接(attach)到它。"

#. (itstool) path: sect1/para
#: book.translate.xml:22380
msgid ""
"An example of these types of devices is the ActiveWire I/O board, based on "
"the EZ-USB chip. For this chip a generic firmware downloader is available. "
"The firmware downloaded into the ActiveWire board changes the revision Id. "
"It will then perform a soft reset of the USB part of the EZ-USB chip to "
"disconnect from the USB bus and again reconnect."
msgstr ""
"这些类型的设备的一个例子是基于EZ-USB的ActiveWire I/O板。这个 芯片有一个通用固"
"件下载器。下载到ActiveWire板子上的固件改变版本ID。 然后它将执行EZ-USB芯片的"
"USB部分的软复位，从USB总线上断开，并再次 重新连接。"

#. (itstool) path: sect1/para
#: book.translate.xml:22387
msgid ""
"Example: Mass Storage Devices Support for mass storage devices is mainly "
"built around existing protocols. The Iomega USB Zipdrive is based on the "
"SCSI version of their drive. The SCSI commands and status messages are "
"wrapped in blocks and transferred over the bulk pipes to and from the "
"device, emulating a SCSI controller over the USB wire. ATAPI and UFI "
"commands are supported in a similar fashion."
msgstr ""
"例子：大容量存储设备。对大容量存储设备的支持主要围绕现有的 协议构建。Iomega "
"USB Zip驱动器是基于SCSI版本的驱动器。SCSI命令和 状态信息被包装到块中，在大块"
"(bulk)管道上传输到/来自设备，在USB线 上模拟SCSI控制器。ATAPI和UFI命令以相似的"
"方式被支持。"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:22395
msgid "<primary>ATAPI</primary>"
msgstr "<primary>ATAPI</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:22397
msgid ""
"The Mass Storage Specification supports 2 different types of wrapping of the "
"command block.The initial attempt was based on sending the command and "
"status through the default pipe and using bulk transfers for the data to be "
"moved between the host and the device. Based on experience a second approach "
"was designed that was based on wrapping the command and status blocks and "
"sending them over the bulk out and in endpoint. The specification specifies "
"exactly what has to happen when and what has to be done in case an error "
"condition is encountered. The biggest challenge when writing drivers for "
"these devices is to fit USB based protocol into the existing support for "
"mass storage devices. CAM provides hooks to do this in a fairly straight "
"forward way. ATAPI is less simple as historically the IDE interface has "
"never had many different appearances."
msgstr ""
"大容量存储规范支持两种不同类型的对命令块的包装。最初的尝试 基于通过默认管道发"
"送命令和状态信息，使用大块传输在host和设备之间 移动数据。在经验基础上设计出另"
"一种方法，这种方法基于包装命令和 状态块，并在大块out和in端点上发送它们。规范"
"精确地指定了何时必须 发生什么，以及在碰到错误条件的情况下应该做什么。为这些设"
"备编写 驱动程序的最大挑战是协调基于USB的协议，让它适合已有的对大容量存储设备 "
"的支持。CAM提供了钩子，以相当直接了当的方式来完成这个。ATAPI就 没有这么简单"
"了，因为历史上IDE接口从未有过多种不同的表现方式。"

#. (itstool) path: sect1/para
#: book.translate.xml:22412
msgid ""
"The support for the USB floppy from Y-E Data is again less straightforward "
"as a new command set has been designed."
msgstr ""
"来自Y-E Data的对USB软盘的支持也不是那么直观，因为设计了一套 新的命令集。"

#. (itstool) path: info/title
#: book.translate.xml:22443
msgid "Newbus"
msgstr "Newbus"

#. (itstool) path: affiliation/address
#: book.translate.xml:22452
#, no-wrap
msgid ""
"\n"
"\t    <email>asmodai@FreeBSD.org</email>\n"
"\t  "
msgstr ""
"\n"
"\t    <email>asmodai@FreeBSD.org</email>\n"
"\t  "

#. (itstool) path: authorgroup/author
#: book.translate.xml:22446
msgid ""
"<personname> <firstname>Jeroen</firstname> <surname>Ruigrok van der Werven "
"(asmodai)</surname> </personname> <affiliation> <_:address-1/> </"
"affiliation> <contrib>Written by </contrib>"
msgstr ""
"<personname> <firstname>Jeroen</firstname> <surname>Ruigrok van der Werven "
"(asmodai)</surname> </personname> <affiliation> <_:address-1/> </"
"affiliation> <contrib>Written by </contrib>"

#. (itstool) path: affiliation/address
#: book.translate.xml:22464
#, no-wrap
msgid ""
"\n"
"\t    <email>hiten@uk.FreeBSD.org</email>\n"
"\t  "
msgstr ""
"\n"
"\t    <email>hiten@uk.FreeBSD.org</email>\n"
"\t  "

#. (itstool) path: authorgroup/author
#: book.translate.xml:22458
msgid ""
"<personname> <firstname>Hiten</firstname> <surname>Pandya</surname> </"
"personname> <affiliation> <_:address-1/> </affiliation>"
msgstr ""
"<personname> <firstname>Hiten</firstname> <surname>Pandya</surname> </"
"personname> <affiliation> <_:address-1/> </affiliation>"

#. (itstool) path: chapter/para
#: book.translate.xml:22472
msgid ""
"<emphasis>Special thanks to Matthew N. Dodd, Warner Losh, Bill Paul, Doug "
"Rabson, Mike Smith, Peter Wemm and Scott Long</emphasis>."
msgstr ""
"<emphasis>特别感谢Matthew N. Dodd, Warner Losh, Bill Paul, Doug Rabson, Mike "
"Smith, Peter Wemm and Scott Long</emphasis>."

#. (itstool) path: chapter/para
#: book.translate.xml:22476
msgid "This chapter explains the Newbus device framework in detail."
msgstr "本章详细解释了Newbus设备框架。"

#. (itstool) path: sect2/title
#: book.translate.xml:22483
msgid "Purpose of a Device Driver"
msgstr "设备驱动程序的目的"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:22487
msgid "<primary>device driver</primary><secondary>introduction</secondary>"
msgstr ""
"<primary>device driver(设备驱动程序)</primary><secondary>introduction(介绍)</"
"secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:22490
msgid ""
"A device driver is a software component which provides the interface between "
"the kernel's generic view of a peripheral (e.g., disk, network adapter) and "
"the actual implementation of the peripheral. The <emphasis>device driver "
"interface (DDI)</emphasis> is the defined interface between the kernel and "
"the device driver component."
msgstr ""
"设备驱动程序是软件组件，它在内核关于外围设备（例如，磁盘、网络 适配卡）的通用"
"视图和外围设备的实际实现之间提供了接口。 <emphasis>设备驱动程序接口(DDI)</"
"emphasis>是内核与设备驱动程序组件 之间定义的接口。"

#. (itstool) path: sect2/title
#: book.translate.xml:22499
msgid "Types of Device Drivers"
msgstr "设备驱动程序的类型"

#. (itstool) path: sect2/para
#: book.translate.xml:22501
msgid ""
"There used to be days in <trademark class=\"registered\">UNIX</trademark>, "
"and thus FreeBSD, in which there were four types of devices defined:"
msgstr ""
"在<trademark class=\"registered\">UNIX</trademark>那个时代，FreeBSD也从中延续"
"而来，定义了四种类型的 设备："

#. (itstool) path: listitem/para
#: book.translate.xml:22505
msgid "block device drivers"
msgstr "块设备驱动程序"

#. (itstool) path: listitem/para
#: book.translate.xml:22506
msgid "character device drivers"
msgstr "字符设备驱动程序"

#. (itstool) path: listitem/para
#: book.translate.xml:22507
msgid "network device drivers"
msgstr "网络设备驱动程序"

#. (itstool) path: listitem/para
#: book.translate.xml:22508
msgid "pseudo-device drivers"
msgstr "伪设备驱动程序"

#. (itstool) path: sect2/para
#: book.translate.xml:22513
msgid ""
"<emphasis>Block devices</emphasis> performed in a way that used fixed size "
"blocks [of data]. This type of driver depended on the so-called "
"<emphasis>buffer cache</emphasis>, which had cached accessed blocks of data "
"in a dedicated part of memory. Often this buffer cache was based on write-"
"behind, which meant that when data was modified in memory it got synced to "
"disk whenever the system did its periodical disk flushing, thus optimizing "
"writes."
msgstr ""
"<emphasis>块设备</emphasis>以使用固定大小的[数据]块的方式运行。 这种类型的驱"
"动程序依赖所谓的 <emphasis>缓冲区缓存(buffer cache)</emphasis>，其目的 是在内"
"存中的专用区域缓存访问过的数据块。这种缓冲区缓存常常基于后台写 (write-"
"behind)，这意味着数据在内存中被修改后，当系统进行其周期性 磁盘刷新时才会被同"
"步到磁盘，从而优化写操作。"

#. (itstool) path: sect2/para
#: book.translate.xml:22528
msgid ""
"However, in the versions of FreeBSD 4.0 and onward the distinction between "
"block and character devices became non-existent."
msgstr ""
"然而，在FreeBSD 4.0版本以及后续版本中， 块设备和字符设备的区别变得不存在了。"

#. (itstool) path: sect1/title
#: book.translate.xml:22539
msgid "Overview of Newbus"
msgstr "Newbus概览"

#. (itstool) path: sect1/para
#: book.translate.xml:22543
msgid ""
"<emphasis>Newbus</emphasis> is the implementation of a new bus architecture "
"based on abstraction layers which saw its introduction in FreeBSD 3.0 when "
"the Alpha port was imported into the source tree. It was not until 4.0 "
"before it became the default system to use for device drivers. Its goals are "
"to provide a more object-oriented means of interconnecting the various "
"busses and devices which a host system provides to the <emphasis>Operating "
"System</emphasis>."
msgstr ""
"<emphasis>Newbus</emphasis>实现了一种基于抽象层的新型总线结构， 可以在"
"FreeBSD 3.0中看到这种总线结构的介绍，当时Alpha的移植被导入到 代码树中。直到"
"4.0它才成为设备驱动程序使用的默认系统。其目的是为主机 系统提供给<emphasis>操"
"作系统</emphasis>的各种总线和设备的互连提供更加 面向对象的方法。"

#. (itstool) path: sect1/para
#: book.translate.xml:22552
msgid "Its main features include amongst others:"
msgstr "其主要特点包括:"

#. (itstool) path: listitem/para
#: book.translate.xml:22555
msgid "dynamic attaching"
msgstr "动态连接"

#. (itstool) path: listitem/para
#: book.translate.xml:22556
msgid "easy modularization of drivers"
msgstr "驱动程序容易模块化"

#. (itstool) path: listitem/para
#: book.translate.xml:22557
msgid "pseudo-busses"
msgstr "伪总线"

#. (itstool) path: sect1/para
#: book.translate.xml:22560
msgid ""
"One of the most prominent changes is the migration from the flat and ad-hoc "
"system to a device tree layout."
msgstr "最显著的改变之一是从平面和特殊系统演变为设备树布局。"

#. (itstool) path: sect1/para
#: book.translate.xml:22563
msgid ""
"At the top level resides the <emphasis><quote>root</quote></emphasis> device "
"which is the parent to hang all other devices on. For each architecture, "
"there is typically a single child of <quote>root</quote> which has such "
"things as <emphasis>host-to-PCI bridges</emphasis>, etc. attached to it. For "
"x86, this <quote>root</quote> device is the <emphasis><quote>nexus</quote></"
"emphasis> device. For Alpha, various different models of Alpha have "
"different top-level devices corresponding to the different hardware "
"chipsets, including <emphasis>lca</emphasis>, <emphasis>apecs</emphasis>, "
"<emphasis>cia</emphasis> and <emphasis>tsunami</emphasis>."
msgstr ""
"顶层驻留的是<emphasis><quote>根</quote></emphasis>设备，它作为 父设备，所有其"
"他设备挂接在它上面。对于每个结构，通常<quote>根</quote> 只有单个孩子，其上连"
"接着诸如<emphasis>host-to-PCI桥</emphasis> 等东西。对于x86，这种<quote>根</"
"quote>设备为 <emphasis><quote>nexus</quote></emphasis>设备，对于Alpha，Alpha"
"的各种 不同型号有不同的顶层设备，对应不同的硬件芯片组，包括 <emphasis>lca</"
"emphasis>，<emphasis>apecs</emphasis>， <emphasis>cia</emphasis>和"
"<emphasis>tsunami</emphasis>。"

#. (itstool) path: sect1/para
#: book.translate.xml:22576
msgid ""
"A device in the Newbus context represents a single hardware entity in the "
"system. For instance each PCI device is represented by a Newbus device. Any "
"device in the system can have children; a device which has children is often "
"called a <emphasis><quote>bus</quote></emphasis>. Examples of common busses "
"in the system are ISA and PCI, which manage lists of devices attached to ISA "
"and PCI busses respectively."
msgstr ""
"Newbus上下文中的设备表示系统中的单个硬件实体。例如，每个PCI设备被 表示为一个"
"Newbus设备。系统中的任何设备可以有孩子；有孩子的设备通常被 称为"
"<emphasis><quote>bus</quote></emphasis>。系统中常用总线的例子就是 ISA和PCI，"
"他们各自管理连接到ISA和PCI总线上的设备列表。"

#. (itstool) path: sect1/para
#: book.translate.xml:22584
msgid ""
"Often, a connection between different kinds of bus is represented by a "
"<emphasis><quote>bridge</quote></emphasis> device, which normally has one "
"child for the attached bus. An example of this is a <emphasis>PCI-to-PCI "
"bridge</emphasis> which is represented by a device "
"<emphasis><filename>pcibN</filename></emphasis> on the parent PCI bus and "
"has a child <emphasis><filename>pciN</filename></emphasis> for the attached "
"bus. This layout simplifies the implementation of the PCI bus tree, allowing "
"common code to be used for both top-level and bridged busses."
msgstr ""
"通常，不同类型的总线之间的连接被表示为 <emphasis><quote>桥</quote></emphasis>"
"设备，它的孩子就是它所连接的 总线。一个例子就是<emphasis>PCI-to-PCI桥</"
"emphasis>，它在父PCI总线上被 表示为<emphasis><filename>pcibN</filename></"
"emphasis>，而用它的孩子 <emphasis><filename>pciN</filename></emphasis>表示连"
"接在它上面的 总线。这种布局简化了PCI总线树的实现，允许公共代码同时用于顶层和"
"桥接的 总线。"

#. (itstool) path: sect1/para
#: book.translate.xml:22596
msgid ""
"Each device in the Newbus architecture asks its parent to map its resources. "
"The parent then asks its own parent until the nexus is reached. So, "
"basically the nexus is the only part of the Newbus system which knows about "
"all resources."
msgstr ""
"Newbus结构中的每个设备请求它的父设备来为其映射资源。父设备接着请求 它的父设"
"备，直到到达nexus。因此，基本上nexus是Newbus系统中唯一知道所有 资源的部分。"

#. (itstool) path: tip/para
#: book.translate.xml:22601
msgid ""
"An ISA device might want to map its IO port at <literal>0x230</literal>, so "
"it asks its parent, in this case the ISA bus. The ISA bus hands it over to "
"the PCI-to-ISA bridge which in its turn asks the PCI bus, which reaches the "
"host-to-PCI bridge and finally the nexus. The beauty of this transition "
"upwards is that there is room to translate the requests. For example, the "
"<literal>0x230</literal> IO port request might become memory-mapped at "
"<literal>0xb0000230</literal> on a <acronym>MIPS</acronym> box by the PCI "
"bridge."
msgstr ""
"ISA设备可能想在<literal>0x230</literal>映射其IO端口，因此它向其 父设备请求，"
"这种情况下是ISA总线。ISA总线将它交给PCI-to-ISA桥，PCI-to-ISA 桥接着请求PCI总"
"线，PCI总线到达host-to-PCI桥，最后到达nexus。这种向上 过渡的优美之处在于可以"
"有空间来变换请求。对<literal>0x230</literal>IO端口 的请求在<acronym>MIPS</"
"acronym>机器上可以被PCI桥变成 <literal>0xb0000230</literal>处的内存映射。"

#. (itstool) path: sect1/para
#: book.translate.xml:22612
msgid ""
"Resource allocation can be controlled at any place in the device tree. For "
"instance on many Alpha platforms, ISA interrupts are managed separately from "
"PCI interrupts and resource allocations for ISA interrupts are managed by "
"the Alpha's ISA bus device. On IA-32, ISA and PCI interrupts are both "
"managed by the top-level nexus device. For both ports, memory and port "
"address space is managed by a single entity - nexus for IA-32 and the "
"relevant chipset driver on Alpha (e.g., CIA or tsunami)."
msgstr ""
"资源分配可以在设备树的任何地方加以控制。例如，在很多Alpha平台上， ISA中断与"
"PCI中断是单独管理的，对ISA中断的资源分配是由Alpha的ISA总线设备 管理的。在"
"IA-32上，ISA和PCI中断都由顶层的nexus设备管理。对于两种移植， 内存和端口地址空"
"间由单个实体管理 - 在IA-32上是nexus，在Alpha（例如，CIA 或tsunami）上是相关的"
"芯片组驱动程序。"

#. (itstool) path: sect1/para
#: book.translate.xml:22622
msgid ""
"In order to normalize access to memory and port mapped resources, Newbus "
"integrates the <literal>bus_space</literal> APIs from NetBSD. These provide "
"a single API to replace inb/outb and direct memory reads/writes. The "
"advantage of this is that a single driver can easily use either memory-"
"mapped registers or port-mapped registers (some hardware supports both)."
msgstr ""
"为了规范化对内存和端口映射资源的访问，Newbus整合了NetBSD的 "
"<literal>bus_space</literal> API。他们提供了单一的API来代替inb/outb 和直接内"
"存读写。这样做的优势在于单个驱动程序就可以使用内存映射寄存器 或端口映射寄存器"
"（有些硬件支持两者）。"

#. (itstool) path: sect1/para
#: book.translate.xml:22629
msgid ""
"This support is integrated into the resource allocation mechanism. When a "
"resource is allocated, a driver can retrieve the associated <varname remap="
"\"structfield\">bus_space_tag_t</varname> and <varname remap=\"structfield"
"\">bus_space_handle_t</varname> from the resource."
msgstr ""
"这种支持被合并到了资源分配机制中。分配资源时，驱动程序可以从资源 中检取关联的"
"<varname remap=\"structfield\">bus_space_tag_t</varname>和 <varname remap="
"\"structfield\">bus_space_handle_t</varname>。"

#. (itstool) path: sect1/para
#: book.translate.xml:22634
msgid ""
"Newbus also allows for definitions of interface methods in files dedicated "
"to this purpose. These are the <filename>.m</filename> files that are found "
"under the <filename>src/sys</filename> hierarchy."
msgstr ""
"Newbus也允许在专用于此目的的文件中定义接口方法。这些是 <filename>.m</"
"filename>文件，可以在<filename>src/sys</filename> 目录树中找到。"

#. (itstool) path: sect1/para
#: book.translate.xml:22639
msgid ""
"The core of the Newbus system is an extensible <quote>object-based "
"programming</quote> model. Each device in the system has a table of methods "
"which it supports. The system and other devices uses those methods to "
"control the device and request services. The different methods supported by "
"a device are defined by a number of <quote>interfaces</quote>. An "
"<quote>interface</quote> is simply a group of related methods which can be "
"implemented by a device."
msgstr ""
"Newbus系统的核心是可扩展的<quote>基于对象编程(object-based programming)</"
"quote>的模型。系统中的每个设备具有它所支持的一个方法表。 系统和其他设备使用这"
"些方法来控制设备并请求服务。设备所支持的不同方法 被定义为多个<quote>接口</"
"quote>。<quote>接口</quote>只是 设备实现的一组相关的方法。"

#. (itstool) path: sect1/para
#: book.translate.xml:22648
msgid ""
"In the Newbus system, the methods for a device are provided by the various "
"device drivers in the system. When a device is attached to a driver during "
"<emphasis>auto-configuration</emphasis>, it uses the method table declared "
"by the driver. A device can later <emphasis>detach</emphasis> from its "
"driver and <emphasis>re-attach</emphasis> to a new driver with a new method "
"table. This allows dynamic replacement of drivers which can be useful for "
"driver development."
msgstr ""
"在Newbus系统中，设备方法是通过系统中的各种设备驱动程序提供的。当 <emphasis>自"
"动配置(auto-configuration)</emphasis>期间设备被连接(attach) 到驱动程序，它使"
"用驱动程序声明的方法表。以后设备可以从其驱动程序 <emphasis>分离(detach)</"
"emphasis>，并 <emphasis>重新连接(re-attach)</emphasis>到具有新方法表的新驱动"
"程序。这就 允许驱动程序的动态替换，而动态替换对于驱动程序的开发非常有用。"

#. (itstool) path: sect1/para
#: book.translate.xml:22658
msgid ""
"The interfaces are described by an interface definition language similar to "
"the language used to define vnode operations for file systems. The interface "
"would be stored in a methods file (which would normally be named "
"<filename>foo_if.m</filename>)."
msgstr ""
"接口通过与文件系统中用于定义vnode操作的语言相似的接口定义语言来 描述。接口被"
"保存在方法文件中（通常命名为<filename>foo_if.m</filename>）。"

#. (itstool) path: example/title
#: book.translate.xml:22665
msgid "Newbus Methods"
msgstr "Newbus的方法"

#. (itstool) path: example/programlisting
#: book.translate.xml:22667
#, no-wrap
msgid ""
"      # Foo subsystem/driver (a comment...)\n"
"\n"
"\t  INTERFACE foo\n"
"\n"
"\tMETHOD int doit {\n"
"\t\tdevice_t dev;\n"
"\t};\n"
"\n"
"\t# DEFAULT is the method that will be used, if a method was not\n"
"\t# provided via: DEVMETHOD()\n"
"\n"
"\tMETHOD void doit_to_child {\n"
"\t\tdevice_t dev;\n"
"\t\tdriver_t child;\n"
"\t} DEFAULT doit_generic_to_child;"
msgstr ""
"      # Foo subsystem/driver (a comment...)\n"
"\n"
"\t  INTERFACE foo\n"
"\n"
"\tMETHOD int doit {\n"
"\t\tdevice_t dev;\n"
"\t};\n"
"\n"
"\t# DEFAULT is the method that will be used, if a method was not\n"
"\t# provided via: DEVMETHOD()\n"
"\n"
"\tMETHOD void doit_to_child {\n"
"\t\tdevice_t dev;\n"
"\t\tdriver_t child;\n"
"\t} DEFAULT doit_generic_to_child;"

#. (itstool) path: sect1/para
#: book.translate.xml:22684
msgid ""
"When this interface is compiled, it generates a header file "
"<quote><filename>foo_if.h</filename></quote> which contains function "
"declarations:"
msgstr ""
"当接口被编译后，它产生一个头文件 <quote><filename>foo_if.h</filename></"
"quote>，其中包含函数声明："

#. (itstool) path: sect1/programlisting
#: book.translate.xml:22688
#, no-wrap
msgid ""
"      int FOO_DOIT(device_t dev);\n"
"      int FOO_DOIT_TO_CHILD(device_t dev, device_t child);"
msgstr ""
"      int FOO_DOIT(device_t dev);\n"
"      int FOO_DOIT_TO_CHILD(device_t dev, device_t child);"

#. (itstool) path: sect1/para
#: book.translate.xml:22691
msgid ""
"A source file, <quote><filename>foo_if.c</filename></quote> is also created "
"to accompany the automatically generated header file; it contains "
"implementations of those functions which look up the location of the "
"relevant functions in the object's method table and call that function."
msgstr ""
"伴随自动产生的头文件，也会创建一个源文件 <quote><filename>foo_if.c</"
"filename></quote>；其中包含一些函数的实现， 这些函数用于在对象方法表中查找相"
"关函数的位置并调用那个函数。"

#. (itstool) path: sect1/para
#: book.translate.xml:22697
msgid ""
"The system defines two main interfaces. The first fundamental interface is "
"called <emphasis><quote>device</quote></emphasis> and includes methods which "
"are relevant to all devices. Methods in the <emphasis><quote>device</quote></"
"emphasis> interface include <emphasis><quote>probe</quote></emphasis>, "
"<emphasis><quote>attach</quote></emphasis> and <emphasis><quote>detach</"
"quote></emphasis> to control detection of hardware and "
"<emphasis><quote>shutdown</quote></emphasis>, <emphasis><quote>suspend</"
"quote></emphasis> and <emphasis><quote>resume</quote></emphasis> for "
"critical event notification."
msgstr ""
"系统定义了两个主要接口。第一个基本接口被称为 <emphasis><quote>设备(device)</"
"quote></emphasis>，并包括与所有设备相关 的方法。<emphasis><quote>设备"
"(device)</quote></emphasis>接口中的方法 包括<emphasis><quote>探测(probe)</"
"quote></emphasis>， <emphasis><quote>连接(attach)</quote></emphasis>和 "
"<emphasis><quote>分离(detach)</quote></emphasis>，他们用来控制硬件的侦测， 以"
"及<emphasis><quote>关闭(shutdown)</quote></emphasis>， <emphasis><quote>挂起"
"(suspend)</quote></emphasis>和 <emphasis><quote>恢复(resume)</quote></"
"emphasis>，他们用于关键事件通知。"

#. (itstool) path: footnote/para
#: book.translate.xml:22714
msgid ""
"<citerefentry><refentrytitle>bus_generic_read_ivar</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> and "
"<citerefentry><refentrytitle>bus_generic_write_ivar</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""
"<citerefentry><refentrytitle>bus_generic_read_ivar</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> and "
"<citerefentry><refentrytitle>bus_generic_write_ivar</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"

#. (itstool) path: sect1/para
#: book.translate.xml:22710
msgid ""
"The second, more complex interface is <emphasis><quote>bus</quote></"
"emphasis>. This interface contains methods suitable for devices which have "
"children, including methods to access bus specific per-device information <_:"
"footnote-1/>, event notification (<emphasis><literal>child_detached</"
"literal></emphasis>, <emphasis><literal>driver_added</literal></emphasis>) "
"and resource management (<emphasis><literal>alloc_resource</literal></"
"emphasis>, <emphasis><literal>activate_resource</literal></emphasis>, "
"<emphasis><literal>deactivate_resource</literal></emphasis>, "
"<emphasis><literal>release_resource</literal></emphasis>)."
msgstr ""
"另一个，更加复杂接口是<emphasis><quote>bus</quote></emphasis>。 此接口包含的"
"方法适用于带有孩子的设备，包括访问总线特定的每设备信息 <_:footnote-1/>，事件"
"通知 （<emphasis><literal>child_detached</literal></emphasis>， "
"<emphasis><literal>driver_added</literal></emphasis>）和响应管理 "
"（<emphasis><literal>alloc_resource</literal></emphasis>， "
"<emphasis><literal>activate_resource</literal></emphasis>， "
"<emphasis><literal>deactivate_resource</literal></emphasis>， "
"<emphasis><literal>release_resource</literal></emphasis>）。"

#. (itstool) path: sect1/para
#: book.translate.xml:22725
msgid ""
"Many methods in the <quote>bus</quote> interface are performing services for "
"some child of the bus device. These methods would normally use the first two "
"arguments to specify the bus providing the service and the child device "
"which is requesting the service. To simplify driver code, many of these "
"methods have accessor functions which lookup the parent and call a method on "
"the parent. For instance the method <literal>BUS_TEARDOWN_INTR(device_t dev, "
"device_t child, ...)</literal> can be called using the function "
"<literal>bus_teardown_intr(device_t child, ...)</literal>."
msgstr ""
"<quote>bus</quote>接口中的很多方法为总线设备的某些孩子执行服务。 这些方法通常"
"使用前两个参量指定提供服务的总线和请求服务的子设备。为了 简化设备驱动程序代"
"码，这些方法中的很多都有访问者(accessor)函数，访问者 函数用来查找父设备并调用"
"父设备上的方法。例如，方法 <literal>BUS_TEARDOWN_INTR(device_t dev, device_t "
"child, ...)</literal> 可以使用函数 <literal>bus_teardown_intr(device_t "
"child, ...)</literal>来调用。"

#. (itstool) path: sect1/para
#: book.translate.xml:22737
msgid ""
"Some bus types in the system define additional interfaces to provide access "
"to bus-specific functionality. For instance, the PCI bus driver defines the "
"<quote>pci</quote> interface which has two methods "
"<emphasis><literal>read_config</literal></emphasis> and "
"<emphasis><literal>write_config</literal></emphasis> for accessing the "
"configuration registers of a PCI device."
msgstr ""
"系统中的某些总线类型提供了额外接口以提供对总线特定功能的访问。 例如，PCI总线"
"驱动程序定义了<quote>pci</quote>接口，此接口有两个方法 "
"<emphasis><literal>read_config</literal></emphasis>和 "
"<emphasis><literal>write_config</literal></emphasis>，用于访问PCI设备 的配置"
"寄存器。"

#. (itstool) path: sect1/title
#: book.translate.xml:22747
msgid "Newbus API"
msgstr "Newbus API"

#. (itstool) path: sect1/para
#: book.translate.xml:22749
msgid ""
"As the Newbus API is huge, this section makes some effort at documenting it. "
"More information to come in the next revision of this document."
msgstr ""
"由于Newbus API非常庞大，本节努力将它文档化。本文档的下一版本会 带来更多信息。"

#. (itstool) path: sect2/title
#: book.translate.xml:22754
msgid "Important Locations in the Source Hierarchy"
msgstr "源代码目录树中的重要位置"

#. (itstool) path: sect2/para
#: book.translate.xml:22756
msgid ""
"<filename>src/sys/[arch]/[arch]</filename> - Kernel code for a specific "
"machine architecture resides in this directory. For example, the "
"<literal>i386</literal> architecture, or the <literal>SPARC64</literal> "
"architecture."
msgstr ""
"<filename>src/sys/[arch]/[arch]</filename> - 特定机器结构的 内核代码位于这个"
"目录。例如<literal>i386</literal>结构或 <literal>SPARC64</literal>结构。"

#. (itstool) path: sect2/para
#: book.translate.xml:22761
msgid ""
"<filename>src/sys/dev/[bus]</filename> - device support for a specific "
"<literal>[bus]</literal> resides in this directory."
msgstr ""
"<filename>src/sys/dev/[bus]</filename> - 支持特定 <literal>[bus]</literal>的"
"设备位于这个目录。"

#. (itstool) path: sect2/para
#: book.translate.xml:22765
msgid ""
"<filename>src/sys/dev/pci</filename> - PCI bus support code resides in this "
"directory."
msgstr "<filename>src/sys/dev/pci</filename> - PCI总线支持代码位于 这个目录。"

#. (itstool) path: sect2/para
#: book.translate.xml:22768
msgid ""
"<filename>src/sys/[isa|pci]</filename> - PCI/ISA device drivers reside in "
"this directory. The PCI/ISA bus support code used to exist in this directory "
"in FreeBSD version <literal>4.0</literal>."
msgstr ""
"<filename>src/sys/[isa|pci]</filename> - PCI/ISA设备驱动程序 位于这个目录。"
"FreeBSD<literal>4.0</literal>版本中，PCI/ISA支持代码 过去存在于这个目录中。"

#. (itstool) path: sect2/title
#: book.translate.xml:22775
msgid "Important Structures and Type Definitions"
msgstr "重要结构和类型定义"

#. (itstool) path: sect2/para
#: book.translate.xml:22777
msgid ""
"<literal>devclass_t</literal> - This is a type definition of a pointer to a "
"<literal>struct devclass</literal>."
msgstr ""
"<literal>devclass_t</literal> - 这是指向 <literal>struct devclass</literal>的"
"指针的类型定义。"

#. (itstool) path: sect2/para
#: book.translate.xml:22780
msgid ""
"<literal>device_method_t</literal> - This is the same as "
"<literal>kobj_method_t</literal> (see <filename>src/sys/kobj.h</filename>)."
msgstr ""
"<literal>device_method_t</literal> - 与 <literal>kobj_method_t</literal>相同"
"（参看 <filename>src/sys/kobj.h</filename>）。"

#. (itstool) path: sect2/para
#: book.translate.xml:22784
msgid ""
"<literal>device_t</literal> - This is a type definition of a pointer to a "
"<literal>struct device</literal>. <literal>device_t</literal> represents a "
"device in the system. It is a kernel object. See <filename>src/sys/sys/"
"bus_private.h</filename> for implementation details."
msgstr ""
"<literal>device_t</literal> - 这是指向 <literal>struct device</literal>的指针"
"的类型定义。 <literal>device_t</literal> 表示系统中的设备。它是内核对象。 实"
"现细节参看<filename>src/sys/sys/bus_private.h</filename>。"

#. (itstool) path: sect2/para
#: book.translate.xml:22791
msgid ""
"<literal>driver_t</literal> - This is a type definition which references "
"<literal>struct driver</literal>. The <literal>driver</literal> struct is a "
"class of the <literal>device</literal> kernel object; it also holds data "
"private to the driver."
msgstr ""
"<literal>driver_t</literal> - 这是一个类型定义，它引用 <literal>struct "
"driver</literal>。 <literal>driver</literal>结构是一类 <literal>device(设"
"备)</literal>内核对象；它也保存着驱动程序的私有数据。"

#. (itstool) path: figure/title
#: book.translate.xml:22798
msgid "<emphasis>driver_t</emphasis> Implementation"
msgstr "<emphasis>driver_t</emphasis>实现"

#. (itstool) path: figure/programlisting
#: book.translate.xml:22800
#, no-wrap
msgid ""
"\t  struct driver {\n"
"\t\tKOBJ_CLASS_FIELDS;\n"
"\t\tvoid\t*priv;\t\t\t/* driver private data */\n"
"\t  };"
msgstr ""
"\t  struct driver {\n"
"\t\tKOBJ_CLASS_FIELDS;\n"
"\t\tvoid\t*priv;\t\t\t/* driver private data */\n"
"\t  };"

#. (itstool) path: sect2/para
#: book.translate.xml:22806
msgid ""
"A <literal>device_state_t</literal> type, which is an enumeration, "
"<literal>device_state</literal>. It contains the possible states of a Newbus "
"device before and after the autoconfiguration process."
msgstr ""
"<literal>device_state_t</literal>是一个枚举类型，即 <literal>device_state</"
"literal>。它包含Newbus设备在自动配置前后 可能的状态。"

#. (itstool) path: figure/title
#: book.translate.xml:22812
msgid "Device States <emphasis>device_state_t</emphasis>"
msgstr "设备状态<emphasis>device_state_t</emphasis>"

#. (itstool) path: figure/programlisting
#: book.translate.xml:22815
#, no-wrap
msgid ""
"\t  /*\n"
"\t   * src/sys/sys/bus.h\n"
"\t   */\n"
"\t  typedef enum device_state {\n"
"\t\tDS_NOTPRESENT,\t/* not probed or probe failed */\n"
"\t\tDS_ALIVE,\t\t/* probe succeeded */\n"
"\t\tDS_ATTACHED,\t/* attach method called */\n"
"\t\tDS_BUSY\t\t\t/* device is open */\n"
"\t  } device_state_t;"
msgstr ""
"\t  /*\n"
"\t   * src/sys/sys/bus.h\n"
"\t   */\n"
"\t  typedef enum device_state {\n"
"\t\tDS_NOTPRESENT,\t/* not probed or probe failed */\n"
"\t\tDS_ALIVE,\t\t/* probe succeeded */\n"
"\t\tDS_ATTACHED,\t/* attach method called */\n"
"\t\tDS_BUSY\t\t\t/* device is open */\n"
"\t  } device_state_t;"

#. (itstool) path: info/title
#: book.translate.xml:22838
msgid "Sound Subsystem"
msgstr "声音子系统"

#. (itstool) path: authorgroup/author
#: book.translate.xml:22841
#, fuzzy
#| msgid ""
#| "<personname><firstname>Jean-Francois</firstname><surname>Dockes</"
#| "surname></personname><contrib>Contributed by </contrib>"
msgid ""
"<personname> <firstname>Jean-Francois</firstname> <surname>Dockes</surname> "
"</personname> <contrib>Contributed by </contrib>"
msgstr ""
"<personname><firstname>Jean-Francois</firstname><surname>Dockes</surname></"
"personname><contrib>Contributed by </contrib>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:22854
msgid "<primary>sound subsystem</primary>"
msgstr "<primary>sound subsystem(声音子系统)</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:22856
msgid ""
"The FreeBSD sound subsystem cleanly separates generic sound handling issues "
"from device-specific ones. This makes it easier to add support for new "
"hardware."
msgstr ""
"FreeBSD声音子系统清晰地将通用声音处理问题与设备特定的问题分离 开来。这使得更"
"容易加入对新设备的支持。"

#. (itstool) path: sect1/para
#: book.translate.xml:22860
msgid ""
"The <citerefentry><refentrytitle>pcm</refentrytitle><manvolnum>4</"
"manvolnum></citerefentry> framework is the central piece of the sound "
"subsystem. It mainly implements the following elements:"
msgstr ""
"<citerefentry><refentrytitle>pcm</refentrytitle><manvolnum>4</manvolnum></"
"citerefentry>框架是声音子系统的中心部分。它主要实现下面的组件："

#. (itstool) path: sect1/indexterm
#: book.translate.xml:22863
msgid "<primary>system call interface</primary>"
msgstr "<primary>system call interface(系统调用接口)</primary>"

#. (itstool) path: listitem/para
#: book.translate.xml:22867
msgid ""
"A system call interface (read, write, ioctls) to digitized sound and mixer "
"functions. The ioctl command set is compatible with the legacy "
"<emphasis>OSS</emphasis> or <emphasis>Voxware</emphasis> interface, allowing "
"common multimedia applications to be ported without modification."
msgstr ""
"一个到数字化声音和混音器函数的系统调用接口（read, write, ioctls）。ioctl命令"
"集合兼容老的<emphasis>OSS</emphasis> 或<emphasis>Voxware</emphasis>接口，允许"
"一般多媒体应用程序 不加修改地移植。"

#. (itstool) path: listitem/para
#: book.translate.xml:22876
msgid ""
"Common code for processing sound data (format conversions, virtual channels)."
msgstr "处理声音数据的公共代码（格式转换，虚拟通道）。"

#. (itstool) path: listitem/para
#: book.translate.xml:22881
msgid ""
"A uniform software interface to hardware-specific audio interface modules."
msgstr "一个统一的软件接口，与硬件特定的音频接口模块接口"

#. (itstool) path: listitem/para
#: book.translate.xml:22886
msgid ""
"Additional support for some common hardware interfaces (ac97), or shared "
"hardware-specific code (ex: ISA DMA routines)."
msgstr ""
"对某些通用硬件接口（ac97）或共享的硬件特定代码 （例如：ISA DMA例程）的额外支"
"持。"

#. (itstool) path: sect1/para
#: book.translate.xml:22892
msgid ""
"The support for specific sound cards is implemented by hardware-specific "
"drivers, which provide channel and mixer interfaces to plug into the generic "
"<filename>pcm</filename> code."
msgstr ""
"对特定声卡的支持是通过硬件特定的驱动程序来实现的，这些驱动程序 提供通道和混音"
"器接口，插入到通用<filename>pcm</filename>代码中。"

#. (itstool) path: sect1/para
#: book.translate.xml:22897
msgid ""
"In this chapter, the term <filename>pcm</filename> will refer to the "
"central, common part of the sound driver, as opposed to the hardware-"
"specific modules."
msgstr ""
"本章中，术语<filename>pcm</filename>将指声音驱动程序的 中心，通用部分，这是对"
"比硬件特定的模块而言的。"

#. (itstool) path: sect1/para
#: book.translate.xml:22901
msgid ""
"The prospective driver writer will of course want to start from an existing "
"module and use the code as the ultimate reference. But, while the sound code "
"is nice and clean, it is also mostly devoid of comments. This document tries "
"to give an overview of the framework interface and answer some questions "
"that may arise while adapting the existing code."
msgstr ""
"预期的驱动程序编写者当然希望从现有模块开始，并使用那些代码作为 最终参考。但"
"是，由于声音代码十分简洁漂亮，这也基本上免除了注释。 本文档试图给出框架接口的"
"一个概览，并回答改写现有代码时可能出现的 一些问题。"

#. (itstool) path: sect1/para
#: book.translate.xml:22908
msgid ""
"As an alternative, or in addition to starting from a working example, you "
"can find a commented driver template at <link xlink:href=\"https://people."
"FreeBSD.org/~cg/template.c\"> https://people.FreeBSD.org/~cg/template.c</"
"link>"
msgstr ""
"作为另外的途径，或者说除了从一个可工作的范例开始的办法之外， 你可以从<link "
"xlink:href=\"http://people.FreeBSD.org/~cg/template.c\"> http://people."
"FreeBSD.org/~cg/template.c</link>找到一个注释过的 驱动程序模板。"

#. (itstool) path: sect1/title
#: book.translate.xml:22915
msgid "Files"
msgstr "文件"

#. (itstool) path: sect1/para
#: book.translate.xml:22917
msgid ""
"All the relevant code lives in <filename>/usr/src/sys/dev/sound/</filename>, "
"except for the public ioctl interface definitions, found in <filename>/usr/"
"src/sys/sys/soundcard.h</filename>"
msgstr ""
"除<filename>/usr/src/sys/sys/soundcard.h</filename>中的公共 ioctl接口定义外，"
"所有的相关代码当前(FreeBSD 4.4)位于 <filename>/usr/src/sys/dev/sound/</"
"filename>。"

#. (itstool) path: sect1/para
#: book.translate.xml:22922
msgid ""
"Under <filename>/usr/src/sys/dev/sound/</filename>, the <filename>pcm/</"
"filename> directory holds the central code, while the <filename>pci/</"
"filename>, <filename>isa/</filename> and <filename>usb/</filename> "
"directories have the drivers for PCI and ISA boards, and for USB audio "
"devices."
msgstr ""
"在<filename>/usr/src/sys/dev/sound/</filename>下面， <filename>pcm/</"
"filename>目录中保存着中心代码， 而<filename>isa/</filename>和<filename>pci/</"
"filename>目录中有 ISA和PCI板的驱动程序。"

#. (itstool) path: sect1/title
#: book.translate.xml:22930
msgid "Probing, Attaching, etc."
msgstr "探测，连接等"

#. (itstool) path: sect1/para
#: book.translate.xml:22932
#, fuzzy
#| msgid ""
#| "Sound drivers probe and attach in almost the same way as any hardware "
#| "driver module. You might want to look at the <link linkend=\"isa-driver"
#| "\"> ISA</link> or <link linkend=\"pci\">PCI</link> specific sections of "
#| "the handbook for more information."
msgid ""
"Sound drivers probe and attach in almost the same way as any hardware driver "
"module. You might want to look at the <link linkend=\"isa-driver\">ISA</"
"link> or <link linkend=\"pci\">PCI</link> specific sections of the handbook "
"for more information."
msgstr ""
"声音驱动程序使用与任何硬件驱动程序模块相同的方法探测和连接（设备）。 你可能希"
"望浏览一下手册中<link linkend=\"isa-driver\">ISA</link>或<link linkend=\"pci"
"\">PCI</link>章节的内容来获取更多信息。"

#. (itstool) path: sect1/para
#: book.translate.xml:22936
msgid "However, sound drivers differ in some ways:"
msgstr "然而，声音驱动程序在某些方面又有些不同："

#. (itstool) path: listitem/para
#: book.translate.xml:22940
msgid ""
"They declare themselves as <filename>pcm</filename> class devices, with a "
"<varname remap=\"structname\">struct snddev_info</varname> device private "
"structure:"
msgstr ""
"他们将自己声明为<filename>pcm</filename>类设备，带有一个 设备私有结构"
"<varname remap=\"structname\">struct snddev_info</varname>："

#. (itstool) path: listitem/programlisting
#: book.translate.xml:22944
#, no-wrap
msgid ""
"          static driver_t xxx_driver = {\n"
"              \"pcm\",\n"
"              xxx_methods,\n"
"              sizeof(struct snddev_info)\n"
"          };\n"
"\n"
"          DRIVER_MODULE(snd_xxxpci, pci, xxx_driver, pcm_devclass, 0, 0);\n"
"          MODULE_DEPEND(snd_xxxpci, snd_pcm, PCM_MINVER, PCM_PREFVER,PCM_MAXVER);"
msgstr ""
"          static driver_t xxx_driver = {\n"
"              \"pcm\",\n"
"              xxx_methods,\n"
"              sizeof(struct snddev_info)\n"
"          };\n"
"\n"
"          DRIVER_MODULE(snd_xxxpci, pci, xxx_driver, pcm_devclass, 0, 0);\n"
"          MODULE_DEPEND(snd_xxxpci, snd_pcm, PCM_MINVER, PCM_PREFVER,PCM_MAXVER);"

#. (itstool) path: para/indexterm
#: book.translate.xml:22954
#, fuzzy
#| msgid "<primary>device drivers</primary><secondary>sound</secondary>"
msgid "<primary>device drivers</primary> <secondary>sound</secondary>"
msgstr ""
"<primary>device driver(设备驱动程序)</primary><secondary>sound(声音)</"
"secondary>"

#. (itstool) path: listitem/para
#: book.translate.xml:22953
#, fuzzy
#| msgid ""
#| "Most sound drivers<_:indexterm-1/> need to store additional private "
#| "information about their device. A private data structure is usually "
#| "allocated in the attach routine. Its address is passed to <filename>pcm</"
#| "filename> by the calls to <function>pcm_register()</function> and "
#| "<function>mixer_init()</function>. <filename>pcm</filename> later passes "
#| "back this address as a parameter in calls to the sound driver interfaces."
msgid ""
"Most sound drivers <_:indexterm-1/> need to store additional private "
"information about their device. A private data structure is usually "
"allocated in the attach routine. Its address is passed to <filename>pcm</"
"filename> by the calls to <function>pcm_register()</function> and "
"<function>mixer_init()</function>. <filename>pcm</filename> later passes "
"back this address as a parameter in calls to the sound driver interfaces."
msgstr ""
"大多数声音驱动程序需要存储关于其设备的附加私有信息。私有数据 结构通常在连接例"
"程中分配。其地址通过调用 <function>pcm_register()</function>和 "
"<function>mixer_init()</function>传递给 <filename>pcm</filename>。后面"
"<filename>pcm</filename> 将此地址作为调用声音驱动程序接口时的参数传递回来。"

#. (itstool) path: listitem/para
#: book.translate.xml:22970
msgid ""
"The sound driver attach routine should declare its MIXER or AC97 interface "
"to <filename>pcm</filename> by calling <function>mixer_init()</function>. "
"For a MIXER interface, this causes in turn a call to <link linkend="
"\"xxxmixer-init\"><function>xxxmixer_init()</function></link>."
msgstr ""
"声音驱动程序的连接例程应当通过调用<function>mixer_init() </function>向"
"<filename>pcm</filename>声明它的MIXER或AC97 接口。对于MIXER接口，这会接着引起"
"调用 <link linkend=\"xxxmixer-init\"> <function>xxxmixer_init()</function></"
"link>。"

#. (itstool) path: listitem/para
#: book.translate.xml:22977
msgid ""
"The sound driver attach routine declares its general CHANNEL configuration "
"to <filename>pcm</filename> by calling <function>pcm_register(dev, sc, "
"nplay, nrec)</function>, where <varname>sc</varname> is the address for the "
"device data structure, used in further calls from <filename>pcm</filename>, "
"and <varname>nplay</varname> and <varname>nrec</varname> are the number of "
"play and record channels."
msgstr ""
"声音驱动程序的连接例程通过调用 <function>pcm_register(dev, sc, nplay, nrec)</"
"function> 向<filename>pcm</filename>声明其通用CHANNEL配置，其中 <varname>sc</"
"varname>是设备数据结构的地址， 在<filename>pcm</filename>以后的调用中将会用到"
"它， <varname>nplay</varname>和<varname>nrec</varname>是播放和录音 通道的数"
"目。"

#. (itstool) path: listitem/para
#: book.translate.xml:22988
msgid ""
"The sound driver attach routine declares each of its channel objects by "
"calls to <function>pcm_addchan()</function>. This sets up the channel glue "
"in <filename>pcm</filename> and causes in turn a call to <link linkend="
"\"xxxchannel-init\"> <function>xxxchannel_init()</function></link>."
msgstr ""
"声音驱动程序的连接例程通过调用 <function>pcm_addchan()</function>声明它的每个"
"通道对象。这会在 <filename>pcm</filename>中建立起通道合成，并接着会引起调用 "
"<link linkend=\"xxxchannel-init\"> <function>xxxchannel_init()</function></"
"link> （译注：请参考原文）。"

#. (itstool) path: listitem/para
#: book.translate.xml:22998
msgid ""
"The sound driver detach routine should call <function>pcm_unregister()</"
"function> before releasing its resources."
msgstr ""
"声音驱动程序的分离例程在释放其资源之前应当调用 <function>pcm_unregister()</"
"function>。"

#. (itstool) path: sect1/para
#: book.translate.xml:23004
msgid "There are two possible methods to handle non-PnP devices:"
msgstr "有两种可能的方法来处理非PnP设备："

#. (itstool) path: listitem/para
#: book.translate.xml:23009
msgid ""
"Use a <function>device_identify()</function> method (example: "
"<filename>sound/isa/es1888.c</filename>). The <function>device_identify()</"
"function> method probes for the hardware at known addresses and, if it finds "
"a supported device, creates a new pcm device which is then passed to probe/"
"attach."
msgstr ""
"使用<function>device_identify()</function>方法 （范例：<filename>sound/isa/"
"es1888.c</filename>）。 <function>device_identify()</function>方法在已知地址"
"探测硬件， 如果发现支持的设备就会创建一个新的pcm设备，这个pcm设备接着 会被传"
"递到probe/attach。"

#. (itstool) path: listitem/para
#: book.translate.xml:23018
msgid ""
"Use a custom kernel configuration with appropriate hints for pcm devices "
"(example: <filename>sound/isa/mss.c</filename>)."
msgstr ""
"使用定制内核配置的方法，为pcm设备设置适当的hints（范例： <filename>sound/isa/"
"mss.c</filename>）。"

#. (itstool) path: sect1/para
#: book.translate.xml:23024
msgid ""
"<filename>pcm</filename> drivers should implement <function>device_suspend</"
"function>, <function>device_resume</function> and <function>device_shutdown</"
"function> routines, so that power management and module unloading function "
"correctly."
msgstr ""
"<filename>pcm</filename>驱动程序应当实现 <function>device_suspend</"
"function>， <function>device_resume</function>和 <function>device_shutdown</"
"function>例程，这样电源管理和模块卸载就能 正确地发挥作用。"

#. (itstool) path: sect1/title
#: book.translate.xml:23032
msgid "Interfaces"
msgstr "网络接口"

#. (itstool) path: sect1/para
#: book.translate.xml:23034
msgid ""
"The interface between the <filename>pcm</filename> core and the sound "
"drivers is defined in terms of <link linkend=\"kernel-objects\">kernel "
"objects</link>."
msgstr ""
"<filename>pcm</filename>核心与声音驱动程序之间的接口以术语 <link linkend="
"\"kernel-objects\">内核对象</link>的叫法来定义。"

#. (itstool) path: sect1/para
#: book.translate.xml:23037
msgid ""
"There are two main interfaces that a sound driver will usually provide: "
"<emphasis>CHANNEL</emphasis> and either <emphasis>MIXER</emphasis> or "
"<emphasis>AC97</emphasis>."
msgstr ""
"声音驱动程序通常提供两种主要的接口： <emphasis>CHANNEL</emphasis>以及 "
"<emphasis>MIXER</emphasis>或<emphasis>AC97</emphasis>。"

#. (itstool) path: sect1/para
#: book.translate.xml:23041
msgid ""
"The <emphasis>AC97</emphasis> interface is a very small hardware access "
"(register read/write) interface, implemented by drivers for hardware with an "
"AC97 codec. In this case, the actual MIXER interface is provided by the "
"shared AC97 code in <filename>pcm</filename>."
msgstr ""
"<emphasis>AC97</emphasis>是一个很小的硬件访问（寄存器读/写） 接口，由驱动程序"
"为带AC97编码解码器的硬件来实现。这种情况下，实际的 MIXER接口由<filename>pcm</"
"filename>中共享的AC97代码提供。"

#. (itstool) path: sect2/title
#: book.translate.xml:23048
msgid "The CHANNEL Interface"
msgstr "CHANNEL接口"

#. (itstool) path: sect3/title
#: book.translate.xml:23051
msgid "Common Notes for Function Parameters"
msgstr "函数参数的通常注意事项"

#. (itstool) path: sect3/para
#: book.translate.xml:23053
msgid ""
"Sound drivers usually have a private data structure to describe their "
"device, and one structure for each play and record data channel that it "
"supports."
msgstr ""
"声音驱动程序通常用一个私有数据结构来描述他们的设备，驱动 程序所支持的播放和录"
"音数据通道各有一个。"

#. (itstool) path: sect3/para
#: book.translate.xml:23057
msgid ""
"For all CHANNEL interface functions, the first parameter is an opaque "
"pointer."
msgstr "对于所有的CHANNEL接口函数，第一个参数是一个不透明的指针。"

#. (itstool) path: sect3/para
#: book.translate.xml:23060
msgid ""
"The second parameter is a pointer to the private channel data structure, "
"except for <function>channel_init()</function> which has a pointer to the "
"private device structure (and returns the channel pointer for further use by "
"<filename>pcm</filename>)."
msgstr ""
"第二个参数是指向私有的通道数据结构的指针， <function>channel_init()</"
"function>是个例外，它的指针指向私有 设备结构（并返回由<filename>pcm</"
"filename>以后使用的通道指针）。"

#. (itstool) path: sect3/title
#: book.translate.xml:23069
msgid "Overview of Data Transfer Operations"
msgstr "数据传输操作概览"

#. (itstool) path: sect3/para
#: book.translate.xml:23071
msgid ""
"For sound data transfers, the <filename>pcm</filename> core and the sound "
"drivers communicate through a shared memory area, described by a <varname "
"remap=\"structname\">struct snd_dbuf</varname>."
msgstr ""
"对于声音数据传输，<filename>pcm</filename>核心与声音驱动 程序是通过一个由"
"<varname remap=\"structname\">struct snd_dbuf</varname>描述的 共享内存区域进"
"行通信的。"

#. (itstool) path: sect3/para
#: book.translate.xml:23077
msgid ""
"<varname remap=\"structname\">struct snd_dbuf</varname> is private to "
"<filename>pcm</filename>, and sound drivers obtain values of interest by "
"calls to accessor functions (<function>sndbuf_getxxx()</function>)."
msgstr ""
"<varname remap=\"structname\">struct snd_dbuf</varname>是 <filename>pcm</"
"filename>私有的，声音驱动程序通过调用访问者 函数（<function>sndbuf_getxxx()</"
"function>）来获得感兴趣的值。"

#. (itstool) path: sect3/para
#: book.translate.xml:23082
msgid ""
"The shared memory area has a size of <function>sndbuf_getsize()</function> "
"and is divided into fixed size blocks of <function>sndbuf_getblksz()</"
"function> bytes."
msgstr ""
"共享内存区域的大小等于 <function>sndbuf_getsize()</function>，并被分割为大小"
"固定，且等于 <function>sndbuf_getblksz()</function>字节的很多块。"

#. (itstool) path: sect3/para
#: book.translate.xml:23087
msgid ""
"When playing, the general transfer mechanism is as follows (reverse the idea "
"for recording):"
msgstr "当播放时，常规的传输机制如下（将意思反过来就是录音）："

#. (itstool) path: listitem/para
#: book.translate.xml:23092
msgid ""
"<filename>pcm</filename> initially fills up the buffer, then calls the sound "
"driver's <link linkend=\"channel-trigger\"> <function>xxxchannel_trigger()</"
"function></link> function with a parameter of PCMTRIG_START."
msgstr ""
"<filename>pcm</filename>开始时填充缓冲区，然后以 参数PCMTRIG_START调用声音驱"
"动程序的<link linkend=\"channel-trigger\"> <function>xxxchannel_trigger()</"
"function></link> 。"

#. (itstool) path: listitem/para
#: book.translate.xml:23099
msgid ""
"The sound driver then arranges to repeatedly transfer the whole memory area "
"(<function>sndbuf_getbuf()</function>, <function>sndbuf_getsize()</"
"function>) to the device, in blocks of <function>sndbuf_getblksz()</"
"function> bytes. It calls back the <function>chn_intr()</function> "
"<filename>pcm</filename> function for each transferred block (this will "
"typically happen at interrupt time)."
msgstr ""
"声音驱动程序接着安排以 <function>sndbuf_getblksz()</function>字节大小为块，重"
"复将 整个内存区域（<function>sndbuf_getbuf()</function>， "
"<function>sndbuf_getsize()</function>）传输到设备。对于每个 传输块回调"
"<filename>pcm</filename>函数 <function>chn_intr()</function>（这通常在中断时"
"间发生）。"

#. (itstool) path: listitem/para
#: book.translate.xml:23111
msgid ""
"<function>chn_intr()</function> arranges to copy new data to the area that "
"was transferred to the device (now free), and make appropriate updates to "
"the <varname remap=\"structname\">snd_dbuf</varname> structure."
msgstr ""
"<function>chn_intr()</function>安排将新数据拷贝到那些 数据已传输到设备（现在"
"空闲）的区域，并对 <varname remap=\"structname\">snd_dbuf</varname>结构进行适"
"当的更新。"

#. (itstool) path: sect3/title
#: book.translate.xml:23120
msgid "channel_init"
msgstr "channel_init"

#. (itstool) path: sect3/para
#: book.translate.xml:23122
msgid ""
"<function>xxxchannel_init()</function> is called to initialize each of the "
"play or record channels. The calls are initiated from the sound driver "
"attach routine. (See the <link linkend=\"pcm-probe-and-attach\">probe and "
"attach section</link>)."
msgstr ""
"调用<function>xxxchannel_init()</function>来初始化每个播放 和录音通道。这个调"
"用从声音驱动程序的连接例程中发起。（参看 <link linkend=\"pcm-probe-and-attach"
"\">探测和连接</link>一节）。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23128
#, no-wrap
msgid ""
"          static void *\n"
"          xxxchannel_init(kobj_t obj, void *data,\n"
"             struct snd_dbuf *b, struct pcm_channel *c, int dir)<co xml:id=\"co-chinit-params\"/>\n"
"          {\n"
"              struct xxx_info *sc = data;\n"
"              struct xxx_chinfo *ch;\n"
"               ...\n"
"              return ch;<co xml:id=\"co-chinit-return\"/>\n"
"           }"
msgstr ""
"          static void *\n"
"          xxxchannel_init(kobj_t obj, void *data,\n"
"             struct snd_dbuf *b, struct pcm_channel *c, int dir)<co xml:id=\"co-chinit-params\"/>\n"
"          {\n"
"              struct xxx_info *sc = data;\n"
"              struct xxx_chinfo *ch;\n"
"               ...\n"
"              return ch;<co xml:id=\"co-chinit-return\"/>\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23140
msgid ""
"<varname>b</varname> is the address for the channel <varname remap="
"\"structname\">struct snd_dbuf</varname>. It should be initialized in the "
"function by calling <function>sndbuf_alloc()</function>. The buffer size to "
"use is normally a small multiple of the 'typical' unit transfer size for "
"your device."
msgstr ""
"<varname>b</varname>为通道 <varname remap=\"structname\">struct snd_dbuf</"
"varname>的地址。它应当在 函数中通过调用<function>sndbuf_alloc()</function>来"
"初始化。 所用的缓冲区大小通常是设备'典型'传输大小的一个较小的倍数。"

#. (itstool) path: callout/para
#: book.translate.xml:23147
msgid ""
"<varname>c</varname> is the <filename>pcm</filename> channel control "
"structure pointer. This is an opaque object. The function should store it in "
"the local channel structure, to be used in later calls to <filename>pcm</"
"filename> (ie: <function>chn_intr(c)</function>)."
msgstr ""
"<varname>c</varname>为 <filename>pcm</filename>通道控制结构的指针。这是个不透"
"明 指针。函数应当将它保存到局部通道结构中，在后面调用 <filename>pcm</"
"filename>函数（例如： <function>chn_intr(c)</function>）时会使用它。"

#. (itstool) path: callout/para
#: book.translate.xml:23154
msgid ""
"<varname>dir</varname> indicates the channel direction "
"(<literal>PCMDIR_PLAY</literal> or <literal>PCMDIR_REC</literal>)."
msgstr ""
"<varname>dir</varname>指示通道方向 （<literal>PCMDIR_PLAY</literal>或 "
"<literal>PCMDIR_REC</literal>）。"

#. (itstool) path: callout/para
#: book.translate.xml:23160
msgid ""
"The function should return a pointer to the private area used to control "
"this channel. This will be passed as a parameter to other channel interface "
"calls."
msgstr ""
"函数应当返回一个指针，此指针指向用于控制此通道的私有 区域。它将作为参数被传递"
"到对其他通道接口的调用。"

#. (itstool) path: sect3/title
#: book.translate.xml:23168
msgid "channel_setformat"
msgstr "channel_setformat"

#. (itstool) path: sect3/para
#: book.translate.xml:23170
msgid ""
"<function>xxxchannel_setformat()</function> should set up the hardware for "
"the specified channel for the specified sound format."
msgstr ""
"<function>xxxchannel_setformat()</function>应当按特定通道， 特定声音格式设置"
"硬件。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23174
#, no-wrap
msgid ""
"          static int\n"
"          xxxchannel_setformat(kobj_t obj, void *data, u_int32_t format)<co xml:id=\"co-chsetformat-params\"/>\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return 0;\n"
"           }"
msgstr ""
"          static int\n"
"          xxxchannel_setformat(kobj_t obj, void *data, u_int32_t format)<co xml:id=\"co-chsetformat-params\"/>\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return 0;\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23184
msgid ""
"<varname>format</varname> is specified as an <literal>AFMT_XXX value</"
"literal> (<filename>soundcard.h</filename>)."
msgstr ""
"<varname>format</varname>为 <literal>AFMT_XXX value</literal>值之一 "
"（<filename>soundcard.h</filename>）。"

#. (itstool) path: sect3/title
#: book.translate.xml:23192
msgid "channel_setspeed"
msgstr "channel_setspeed"

#. (itstool) path: sect3/para
#: book.translate.xml:23194
msgid ""
"<function>xxxchannel_setspeed()</function> sets up the channel hardware for "
"the specified sampling speed, and returns the possibly adjusted speed."
msgstr ""
"<function>xxxchannel_setspeed()</function>按指定的取样速度 设置通道硬件，并返"
"回返回可能调整过的速度。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23198
#, no-wrap
msgid ""
"          static int\n"
"          xxxchannel_setspeed(kobj_t obj, void *data, u_int32_t speed)\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return speed;\n"
"           }"
msgstr ""
"          static int\n"
"          xxxchannel_setspeed(kobj_t obj, void *data, u_int32_t speed)\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return speed;\n"
"           }"

#. (itstool) path: sect3/title
#: book.translate.xml:23208
msgid "channel_setblocksize"
msgstr "channel_setblocksize"

#. (itstool) path: sect3/para
#: book.translate.xml:23210
msgid ""
"<function>xxxchannel_setblocksize()</function> sets the block size, which is "
"the size of unit transactions between <filename>pcm</filename> and the sound "
"driver, and between the sound driver and the device. Typically, this would "
"be the number of bytes transferred before an interrupt occurs. During a "
"transfer, the sound driver should call <filename>pcm</filename>'s "
"<function>chn_intr()</function> every time this size has been transferred."
msgstr ""
"<function>xxxchannel_setblocksize()</function>设置块大小， 这是"
"<filename>pcm</filename>与声音驱动程序，以及声音驱动 程序与设备之间的传输单位"
"的大小。传输期间，每次传输这样大小的 数据后，声音驱动程序都应当调用"
"<filename>pcm</filename>的 <function>chn_intr()</function>。"

#. (itstool) path: sect3/para
#: book.translate.xml:23220
msgid ""
"Most sound drivers only take note of the block size here, to be used when an "
"actual transfer will be started."
msgstr ""
"大多数驱动程序只注意这儿的块大小，因为当实际传输开始时应该 使用这个值。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23224
#, no-wrap
msgid ""
"          static int\n"
"          xxxchannel_setblocksize(kobj_t obj, void *data, u_int32_t blocksize)\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"                ...\n"
"              return blocksize;<co xml:id=\"co-chsetblocksize-return\"/>\n"
"           }"
msgstr ""
"          static int\n"
"          xxxchannel_setblocksize(kobj_t obj, void *data, u_int32_t blocksize)\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"                ...\n"
"              return blocksize;<co xml:id=\"co-chsetblocksize-return\"/>\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23234
msgid ""
"The function returns the possibly adjusted block size. In case the block "
"size is indeed changed, <function>sndbuf_resize()</function> should be "
"called to adjust the buffer."
msgstr ""
"函数返回可能调整过的块大小。如果块大小真的变化了， 这种情况下应当调用"
"<function>sndbuf_resize()</function>调整 缓冲区的大小。"

#. (itstool) path: sect3/title
#: book.translate.xml:23243
msgid "channel_trigger"
msgstr "channel_trigger"

#. (itstool) path: sect3/para
#: book.translate.xml:23245
msgid ""
"<function>xxxchannel_trigger()</function> is called by <filename>pcm</"
"filename> to control data transfer operations in the driver."
msgstr ""
"<function>xxxchannel_trigger()</function>由 <filename>pcm</filename>来控制驱"
"动程序中的实际传输操作。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23249
#, no-wrap
msgid ""
"          static int\n"
"          xxxchannel_trigger(kobj_t obj, void *data, int go)<co xml:id=\"co-chtrigger-params\"/>\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return 0;\n"
"           }"
msgstr ""
"          static int\n"
"          xxxchannel_trigger(kobj_t obj, void *data, int go)<co xml:id=\"co-chtrigger-params\"/>\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return 0;\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23259
msgid ""
"<varname>go</varname> defines the action for the current call. The possible "
"values are:"
msgstr "<varname>go</varname>定义当前调用的动作。可能的值为："

#. (itstool) path: listitem/para
#: book.translate.xml:23264
msgid ""
"<literal>PCMTRIG_START</literal>: the driver should start a data transfer "
"from or to the channel buffer. If needed, the buffer base and size can be "
"retrieved through <function>sndbuf_getbuf()</function> and "
"<function>sndbuf_getsize()</function>."
msgstr ""
"<literal>PCMTRIG_START</literal>：驱动程序应当 启动从/到通道缓冲区的数据传"
"输。如果需要，应当通过 <function>sndbuf_getbuf()</function>和 "
"<function>sndbuf_getsize()</function>检取缓冲区的 基地址和大小。"

#. (itstool) path: listitem/para
#: book.translate.xml:23273
msgid ""
"<literal>PCMTRIG_EMLDMAWR</literal> / <literal>PCMTRIG_EMLDMARD</literal>: "
"this tells the driver that the input or output buffer may have been updated. "
"Most drivers just ignore these calls."
msgstr ""
"<literal>PCMTRIG_EMLDMAWR</literal> / <literal>PCMTRIG_EMLDMARD</literal>：告"
"诉驱动程序， 输入或输出缓冲区可能已被更新过了。大多数驱动程序只是 忽略这些调"
"用。"

#. (itstool) path: listitem/para
#: book.translate.xml:23281
msgid ""
"<literal>PCMTRIG_STOP</literal> / <literal>PCMTRIG_ABORT</literal>: the "
"driver should stop the current transfer."
msgstr ""
"<literal>PCMTRIG_STOP</literal> / <literal>PCMTRIG_ABORT</literal>：驱动程序"
"应当停止当前 的传输。"

#. (itstool) path: note/para
#: book.translate.xml:23290
msgid ""
"If the driver uses ISA DMA, <function>sndbuf_isadma()</function> should be "
"called before performing actions on the device, and will take care of the "
"DMA chip side of things."
msgstr ""
"如果驱动程序使用ISA DMA，则应当在设备上执行动作前 调用"
"<function>sndbuf_isadma()</function>，并处理DMA芯片一方的 事情。"

#. (itstool) path: sect3/title
#: book.translate.xml:23298
msgid "channel_getptr"
msgstr "channel_getptr"

#. (itstool) path: sect3/para
#: book.translate.xml:23300
msgid ""
"<function>xxxchannel_getptr()</function> returns the current offset in the "
"transfer buffer. This will typically be called by <function>chn_intr()</"
"function>, and this is how <filename>pcm</filename> knows where it can "
"transfer new data."
msgstr ""
"<function>xxxchannel_getptr()</function>返回传输缓冲区中 当前的缓冲。它通常由"
"<function>chn_intr()</function>调用，而且 这也是为什么<filename>pcm</"
"filename>知道它应当往哪儿传送 新数据。"

#. (itstool) path: sect3/title
#: book.translate.xml:23308
msgid "channel_free"
msgstr "channel_free"

#. (itstool) path: sect3/para
#: book.translate.xml:23310
msgid ""
"<function>xxxchannel_free()</function> is called to free up channel "
"resources, for example when the driver is unloaded, and should be "
"implemented if the channel data structures are dynamically allocated or if "
"<function>sndbuf_alloc()</function> was not used for buffer allocation."
msgstr ""
"调用<function>xxxchannel_free()</function>来释放通道资源， 例如当驱动程序卸载"
"时，并且如果通道数据结构是动态分配的，或者 如果不使用"
"<function>sndbuf_alloc()</function>进行缓冲区分配， 则应当实现这个函数。"

#. (itstool) path: sect3/title
#: book.translate.xml:23319
msgid "channel_getcaps"
msgstr "channel_getcaps"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23321
#, no-wrap
msgid ""
"          struct pcmchan_caps *\n"
"          xxxchannel_getcaps(kobj_t obj, void *data)\n"
"          {\n"
"              return &amp;xxx_caps;<co xml:id=\"co-chgetcaps-return\"/>\n"
"           }"
msgstr ""
"          struct pcmchan_caps *\n"
"          xxxchannel_getcaps(kobj_t obj, void *data)\n"
"          {\n"
"              return &amp;xxx_caps;<co xml:id=\"co-chgetcaps-return\"/>\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23330
msgid ""
"The routine returns a pointer to a (usually statically-defined) <varname "
"remap=\"structname\">pcmchan_caps</varname> structure (defined in "
"<filename>sound/pcm/channel.h</filename>. The structure holds the minimum "
"and maximum sampling frequencies, and the accepted sound formats. Look at "
"any sound driver for an example."
msgstr ""
"这个例程返回指向（通常静态定义的） <varname remap=\"structname"
"\">pcmchan_caps</varname>结构的指针（在 <filename>sound/pcm/channel.h</"
"filename>中定义）。这个结构 保存着最小和最大采样频率和被接受的声音格式。任何"
"声音驱动 程序都可以作为一个范例。"

#. (itstool) path: sect3/title
#: book.translate.xml:23341
msgid "More Functions"
msgstr "更多函数"

#. (itstool) path: sect3/para
#: book.translate.xml:23343
msgid ""
"<function>channel_reset()</function>, <function>channel_resetdone()</"
"function>, and <function>channel_notify()</function> are for special "
"purposes and should not be implemented in a driver without discussing it on "
"the <link xlink:href=\"http://lists.FreeBSD.org/mailman/listinfo/freebsd-"
"multimedia\">FreeBSD multimedia mailing list</link>."
msgstr ""
"<function>channel_reset()</function>, <function>channel_resetdone()</"
"function>和 <function>channel_notify()</function>用于特殊目的，未与权威人士 "
"(Cameron Grant)进行探讨之前不应当在驱动程序中实现它。"

#. (itstool) path: sect3/para
#: book.translate.xml:23349
msgid "<function>channel_setdir()</function> is deprecated."
msgstr "<function>channel_setdir()</function>已被弃用。"

#. (itstool) path: sect2/title
#: book.translate.xml:23355
msgid "The MIXER Interface"
msgstr "MIXER 接口"

#. (itstool) path: sect3/title
#: book.translate.xml:23358
msgid "mixer_init"
msgstr "mixer_init"

#. (itstool) path: sect3/para
#: book.translate.xml:23360
msgid ""
"<function>xxxmixer_init()</function> initializes the hardware and tells "
"<filename>pcm</filename> what mixer devices are available for playing and "
"recording"
msgstr ""
"<function>xxxmixer_init()</function>初始化硬件，并告诉 <filename>pcm</"
"filename>什么混音器设备可用来播放和录音。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23364
#, no-wrap
msgid ""
"          static int\n"
"          xxxmixer_init(struct snd_mixer *m)\n"
"          {\n"
"              struct xxx_info   *sc = mix_getdevinfo(m);\n"
"              u_int32_t v;\n"
"\n"
"              [Initialize hardware]\n"
"\n"
"              [Set appropriate bits in v for play mixers]<co xml:id=\"co-mxini-sd\"/>\n"
"              mix_setdevs(m, v);\n"
"              [Set appropriate bits in v for record mixers]\n"
"              mix_setrecdevs(m, v)\n"
"\n"
"              return 0;\n"
"          }"
msgstr ""
"          static int\n"
"          xxxmixer_init(struct snd_mixer *m)\n"
"          {\n"
"              struct xxx_info   *sc = mix_getdevinfo(m);\n"
"              u_int32_t v;\n"
"\n"
"              [Initialize hardware]\n"
"\n"
"              [Set appropriate bits in v for play mixers]<co xml:id=\"co-mxini-sd\"/>\n"
"              mix_setdevs(m, v);\n"
"              [Set appropriate bits in v for record mixers]\n"
"              mix_setrecdevs(m, v)\n"
"\n"
"              return 0;\n"
"          }"

#. (itstool) path: callout/para
#: book.translate.xml:23382
msgid ""
"Set bits in an integer value and call <function>mix_setdevs()</function> and "
"<function>mix_setrecdevs()</function> to tell <filename>pcm</filename> what "
"devices exist."
msgstr ""
"设置一个整数值中的位，并调用 <function>mix_setdevs()</function>和 "
"<function>mix_setrecdevs()</function>来告诉 <filename>pcm</filename>存在什么"
"设备。"

#. (itstool) path: sect3/para
#: book.translate.xml:23389
msgid ""
"Mixer bits definitions can be found in <filename>soundcard.h</filename> "
"(<literal>SOUND_MASK_XXX</literal> values and <literal>SOUND_MIXER_XXX</"
"literal> bit shifts)."
msgstr ""
"混音器的位定义可以在<filename>soundcard.h</filename>中 找到。"
"（<literal>SOUND_MASK_XXX</literal>值和 <literal>SOUND_MIXER_XXX</literal>移"
"位）。"

#. (itstool) path: sect3/title
#: book.translate.xml:23396
msgid "mixer_set"
msgstr ""

#. (itstool) path: sect3/para
#: book.translate.xml:23398
msgid ""
"<function>xxxmixer_set()</function> sets the volume level for one mixer "
"device."
msgstr "<function>xxxmixer_set()</function>为混音器设备设置音量级别 (level)。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23401
#, no-wrap
msgid ""
"          static int\n"
"          xxxmixer_set(struct snd_mixer *m, unsigned dev,\n"
"                           unsigned left, unsigned right)<co xml:id=\"co-mxset-params\"/>\n"
"          {\n"
"              struct sc_info *sc = mix_getdevinfo(m);\n"
"              [set volume level]\n"
"              return left | (right &lt;&lt; 8);<co xml:id=\"co-mxset-return\"/>\n"
"          }"
msgstr ""
"          static int\n"
"          xxxmixer_set(struct snd_mixer *m, unsigned dev,\n"
"                           unsigned left, unsigned right)<co xml:id=\"co-mxset-params\"/>\n"
"          {\n"
"              struct sc_info *sc = mix_getdevinfo(m);\n"
"              [set volume level]\n"
"              return left | (right &lt;&lt; 8);<co xml:id=\"co-mxset-return\"/>\n"
"          }"

#. (itstool) path: callout/para
#: book.translate.xml:23412
msgid "The device is specified as a <literal>SOUND_MIXER_XXX</literal> value"
msgstr "设备被指定为 <literal>SOUND_MIXER_XXX</literal> 值"

#. (itstool) path: callout/para
#: book.translate.xml:23415
msgid ""
"The volume values are specified in range [0-100]. A value of zero should "
"mute the device."
msgstr "在范围[0-100]之间指定音量值。零值应当让设备静音。"

#. (itstool) path: callout/para
#: book.translate.xml:23420
msgid ""
"As the hardware levels probably will not match the input scale, and some "
"rounding will occur, the routine returns the actual level values (in range "
"0-100) as shown."
msgstr ""
"由于硬件(音量)级别(level)可能不匹配输入比例，会出现 某些圆整，例程返回如上面"
"所示的实际级别值（范围0-100内）。"

#. (itstool) path: sect3/title
#: book.translate.xml:23430
msgid "mixer_setrecsrc"
msgstr "mixer_setrecsrc"

#. (itstool) path: sect3/para
#: book.translate.xml:23432
msgid ""
"<function>xxxmixer_setrecsrc()</function> sets the recording source device."
msgstr "<function>xxxmixer_setrecsrc()</function>设定录音源设备。"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23435
#, no-wrap
msgid ""
"          static int\n"
"          xxxmixer_setrecsrc(struct snd_mixer *m, u_int32_t src)<co xml:id=\"co-mxsr-params\"/>\n"
"          {\n"
"              struct xxx_info *sc = mix_getdevinfo(m);\n"
"\n"
"              [look for non zero bit(s) in src, set up hardware]\n"
"\n"
"              [update src to reflect actual action]\n"
"              return src;<co xml:id=\"co-mxsr-return\"/>\n"
"           }"
msgstr ""
"          static int\n"
"          xxxmixer_setrecsrc(struct snd_mixer *m, u_int32_t src)<co xml:id=\"co-mxsr-params\"/>\n"
"          {\n"
"              struct xxx_info *sc = mix_getdevinfo(m);\n"
"\n"
"              [look for non zero bit(s) in src, set up hardware]\n"
"\n"
"              [update src to reflect actual action]\n"
"              return src;<co xml:id=\"co-mxsr-return\"/>\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23448
msgid "The desired recording devices are specified as a bit field"
msgstr "期望的录音设备由一个位域指定."

#. (itstool) path: callout/para
#: book.translate.xml:23453
msgid ""
"The actual devices set for recording are returned. Some drivers can only set "
"one device for recording. The function should return -1 if an error occurs."
msgstr ""
"返回设置用来录音的实际设备。一些驱动程序只能设置一个 录音设备。如果出现错误，"
"函数应当返回-1。"

#. (itstool) path: sect3/title
#: book.translate.xml:23461
msgid "mixer_uninit, mixer_reinit"
msgstr "mixer_uninit, mixer_reinit"

#. (itstool) path: sect3/para
#: book.translate.xml:23463
#, fuzzy
#| msgid ""
#| "<function>xxxmixer_uninit()</function> should ensure that all sound is "
#| "muted and if possible mixer hardware should be powered down"
msgid ""
"<function>xxxmixer_uninit()</function> should ensure that all sound is muted "
"and if possible mixer hardware should be powered down."
msgstr ""
"<function>xxxmixer_uninit()</function>应当确保不会发出任何 声音，并且如果可能"
"则应当让混音器硬件断电。"

#. (itstool) path: sect3/para
#: book.translate.xml:23467
msgid ""
"<function>xxxmixer_reinit()</function> should ensure that the mixer hardware "
"is powered up and any settings not controlled by <function>mixer_set()</"
"function> or <function>mixer_setrecsrc()</function> are restored."
msgstr ""
"<function>xxxmixer_reinit()</function>应当确保混音器硬件 加电，并且恢复所有不"
"受<function>mixer_set()</function>或 <function>mixer_setrecsrc()</function>控"
"制的设置。"

#. (itstool) path: sect2/title
#: book.translate.xml:23475
msgid "The AC97 Interface"
msgstr "AC97接口"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23477
msgid "<primary>AC97</primary>"
msgstr "<primary>AC97</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:23479
msgid ""
"The <emphasis>AC97</emphasis> interface is implemented by drivers with an "
"AC97 codec. It only has three methods:"
msgstr ""
"<emphasis>AC97</emphasis>由带有AC97编码解码器的驱动程序实现。 它只有三个方"
"法："

#. (itstool) path: listitem/para
#: book.translate.xml:23485
msgid ""
"<function>xxxac97_init()</function> returns the number of ac97 codecs found."
msgstr "<function>xxxac97_init()</function>返回找到的 ac97编码解码器的数目。"

#. (itstool) path: listitem/para
#: book.translate.xml:23490
msgid ""
"<function>ac97_read()</function> and <function>ac97_write()</function> read "
"or write a specified register."
msgstr ""
"<function>ac97_read()</function>与 <function>ac97_write()</function>读写指定"
"的寄存器。"

#. (itstool) path: sect2/para
#: book.translate.xml:23496
msgid ""
"The <emphasis>AC97</emphasis> interface is used by the AC97 code in "
"<filename>pcm</filename> to perform higher level operations. Look at "
"<filename>sound/pci/maestro3.c</filename> or many others under "
"<filename>sound/pci/</filename> for an example."
msgstr ""
"The <emphasis>AC97</emphasis>接口由 <filename>pcm</filename>中的AC97代码来执"
"行高层操作。参看 <filename>sound/pci/maestro3.c</filename>或 <filename>sound/"
"pci/</filename>下很多其他内容作为范例。"

#. (itstool) path: chapter/title
#: book.translate.xml:23512
msgid "PC Card"
msgstr "PC Card"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:23514
msgid "<primary>PC Card</primary>"
msgstr "<primary>PC Card</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:23515
msgid "<primary>CardBus</primary>"
msgstr "<primary>CardBus</primary>"

#. (itstool) path: chapter/para
#: book.translate.xml:23517
msgid ""
"This chapter will talk about the FreeBSD mechanisms for writing a device "
"driver for a PC Card or CardBus device. However, at present it just "
"documents how to add a new device to an existing pccard driver."
msgstr ""
"本章将讨论FreeBSD为编写PC Card或CardBus设备的驱动程序而提供的机制。 但目前本"
"文只记录了如何向现有的pccard驱动程序中添加驱动程序。"

#. (itstool) path: sect1/title
#: book.translate.xml:23523
msgid "Adding a Device"
msgstr "添加设备"

#. (itstool) path: sect1/para
#: book.translate.xml:23525
msgid ""
"Device drivers know what devices they support. There is a table of supported "
"devices in the kernel that drivers use to attach to a device."
msgstr ""
"向所支持的pccard设备列表中添加新设备的步骤已经与系统在FreeBSD 4 中使用的方法"
"不同了。在以前的版本中，需要编辑 <filename>/etc</filename>中的一个文件来列出"
"设备。从FreeBSD 5.0开始， 设备驱动程序知道它们支持什么设备。现在内核中有一个"
"受支持设备的表， 驱动程序用它来连接设备。"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23532
msgid "<primary>CIS</primary>"
msgstr "<primary>CIS</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:23533
msgid ""
"PC Cards are identified in one of two ways, both based on the "
"<firstterm>Card Information Structure</firstterm> (<acronym role=\"Card "
"Information Structure\">CIS</acronym>) stored on the card. The first method "
"is to use numeric manufacturer and product numbers. The second method is to "
"use the human readable strings that are also contained in the CIS. The PC "
"Card bus uses a centralized database and some macros to facilitate a design "
"pattern to help the driver writer match devices to his driver."
msgstr ""
"可以有两种方法来识别PC Card，他们都基于卡上的 <acronym>CIS</acronym>信息。第"
"一种方法是使用制造商和产品的数字编号。 第二种方法是使用人可读的字符串，字符串"
"也是包含在CIS中。PC Card总线 使用集中式数据库和一些宏来提供一个易用的设计模"
"式，让驱动程序的编写 者很容易地确定匹配其驱动程序的设备。"

#. (itstool) path: sect2/para
#: book.translate.xml:23544
msgid ""
"Original equipment manufacturers (<acronym>OEM</acronym>s) often develop a "
"reference design for a PC Card product, then sell this design to other "
"companies to market. Those companies refine the design, market the product "
"to their target audience or geographic area, and put their own name plate "
"onto the card. The refinements to the physical card are typically very "
"minor, if any changes are made at all. To strengthen their brand, these "
"vendors place their company name in the human readable strings in the CIS "
"space, but leave the manufacturer and product IDs unchanged."
msgstr ""
"一个很普遍的实际情况是，某个公司为一款PC Card产品开发出参考 设计，然后把这个"
"设计卖给另外的公司，以便在市场上出售。那些公司改进 原设计，把向他们的目标客户"
"群或地理区域出售产品，并将他们自己的名字 放到卡中。然而所谓的对现有卡的改进，"
"即使做过任何修改，这些修改通常 也微乎其微。然而，为了强化他们自己版本的品牌，"
"这些供货商常常会把他们 公司的名字放入CIS空间的可读字符串中，却不会改动制造商"
"和产品的ID。"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23555
msgid "<primary>NetGear</primary>"
msgstr "<primary>NetGear</primary>"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23556
msgid "<primary>Linksys</primary>"
msgstr "<primary>Linksys</primary>"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23557
msgid "<primary>D-Link</primary>"
msgstr "<primary>D-Link</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:23559
msgid ""
"Because of this practice, FreeBSD drivers usually rely on numeric IDs for "
"device identification. Using numeric IDs and a centralized database "
"complicates adding IDs and support for cards to the system. One must "
"carefully check to see who really made the card, especially when it appears "
"that the vendor who made the card might already have a different "
"manufacturer ID listed in the central database. Linksys, D-Link, and NetGear "
"are a number of US manufacturers of LAN hardware that often sell the same "
"design. These same designs can be sold in Japan under names such as Buffalo "
"and Corega. Often, these devices will all have the same manufacturer and "
"product IDs."
msgstr ""
"鉴于以上情况，对于FreeBSD来说使用数字ID可以减小工作量。同时也 会减小将ID加入"
"到系统的过程中所带来的复杂性。必须仔细检查谁是卡的 真正制造者，尤其当提供原卡"
"的供货商在中心数据库中已经有一个不同的ID 时。Linksys，D-Link和NetGear是经常出"
"售相同设计的几个美国制造商。 相同的设计可能在日本以诸如Buffalo和Corega的名字"
"出售。然而，这些 设备常常具有相同的制造商和产品ID。"

#. (itstool) path: sect2/para
#: book.translate.xml:23572
msgid ""
"The PC Card bus code keeps a central database of card information, but not "
"which driver is associated with them, in <filename>/sys/dev/pccard/"
"pccarddevs</filename>. It also provides a set of macros that allow one to "
"easily construct simple entries in the table the driver uses to claim "
"devices."
msgstr ""
"PC Card总线在其中心数据库 <filename>/sys/dev/pccard/pccarddevs</filename>中保"
"存了卡的信息， 但不包含哪个驱动程序与它们关联的信息。它也提供了一套宏，以允许"
"在 驱动程序用来声明设备的表中容易地创建简单条目。"

#. (itstool) path: sect2/para
#: book.translate.xml:23579
msgid ""
"Finally, some really low end devices do not contain manufacturer "
"identification at all. These devices must be detected by matching the human "
"readable CIS strings. While it would be nice if we did not need this method "
"as a fallback, it is necessary for some very low end CD-ROM players and "
"Ethernet cards. This method should generally be avoided, but a number of "
"devices are listed in this section because they were added prior to the "
"recognition of the <acronym>OEM</acronym> nature of the PC Card business. "
"When adding new devices, prefer using the numeric method."
msgstr ""
"最后，某些非常低端的设备根本不包含制造商标识。这些设备需要使用 可读CIS字符串"
"来匹配它们。如果我们不需要这种应急办法该有多好，但对于 某些非常低端却非常流行"
"的CD-ROM播放器来说却是必需的。通常应当避免 使用这种方法，但本节中还是列出了很"
"多设备，因为它们是在认识到PC Card商业的<acronym>OEM</acronym>本质之前加入的，"
"应当优先使用 数字方法。"

#. (itstool) path: sect2/title
#: book.translate.xml:23592
msgid "Format of <filename>pccarddevs</filename>"
msgstr "<filename>pccarddevs</filename>的格式"

#. (itstool) path: sect2/para
#: book.translate.xml:23594
msgid ""
"There are four sections in the <filename>pccarddevs</filename> files. The "
"first section lists the manufacturer numbers for vendors that use them. This "
"section is sorted in numerical order. The next section has all of the "
"products that are used by these vendors, along with their product ID numbers "
"and a description string. The description string typically is not used "
"(instead we set the device's description based on the human readable CIS, "
"even if we match on the numeric version). These two sections are then "
"repeated for devices that use the string matching method. Finally, C-style "
"comments enclosed in <literal>/*</literal> and <literal>*/</literal> "
"characters are allowed anywhere in the file."
msgstr ""
"<filename>pccarddevs</filename>文件有四节。第一节为使用 它们的那些供货商列出"
"了制造商号码。本节按数字排序。下一节包含了 这些供货商使用的所有产品，包括他们"
"的产品ID号码和描述字符串。 描述字符串通常不会被使用（相反，即使我们可以匹配数"
"字版本号，我们 仍然基于人可读的CIS设置设备的描述）。然后为使用字符串匹配方法"
"的 那些设备重复这两节的东西。最后，文件任何地方可以使用C风格的注释。"

#. (itstool) path: sect2/para
#: book.translate.xml:23608
msgid ""
"The first section of the file contains the vendor IDs. Please keep this list "
"sorted in numeric order. Also, please coordinate changes to this file "
"because we share it with NetBSD to help facilitate a common clearing house "
"for this information. For example, here are the first few vendor IDs:"
msgstr ""
"文件的第一节包含供货商ID。请保持列表按数字排序。此外，为了 能有一个通用清晰的"
"保存地来方便地保存这些信息，我们与NetBSD共享此 文件，因此请协调对此文件的任何"
"更改。例如："

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23615
#, no-wrap
msgid ""
"vendor FUJITSU\t\t\t0x0004  Fujitsu Corporation\n"
"vendor NETGEAR_2\t\t0x000b  Netgear\n"
"vendor PANASONIC\t\t0x0032\tMatsushita Electric Industrial Co.\n"
"vendor SANDISK\t\t\t0x0045\tSandisk Corporation"
msgstr ""
"vendor FUJITSU\t\t\t0x0004  Fujitsu Corporation\n"
"vendor NETGEAR_2\t\t0x000b  Netgear\n"
"vendor PANASONIC\t\t0x0032\tMatsushita Electric Industrial Co.\n"
"vendor SANDISK\t\t\t0x0045\tSandisk Corporation"

#. (itstool) path: sect2/para
#: book.translate.xml:23620
msgid ""
"Chances are very good that the <literal>NETGEAR_2</literal> entry is really "
"an OEM that NETGEAR purchased cards from and the author of support for those "
"cards was unaware at the time that Netgear was using someone else's ID. "
"These entries are fairly straightforward. The vendor keyword denotes the "
"kind of line that this is, followed by the name of the vendor. This name "
"will be repeated later in <filename>pccarddevs</filename>, as well as used "
"in the driver's match tables, so keep it short and a valid C identifier. A "
"numeric ID in hex identifies the manufacturer. Do not add IDs of the form "
"<literal>0xffffffff</literal> or <literal>0xffff</literal> because these are "
"reserved IDs (the former is <quote>no ID set</quote> while the latter is "
"sometimes seen in extremely poor quality cards to try to indicate "
"<quote>none</quote>). Finally there is a string description of the company "
"that makes the card. This string is not used in FreeBSD for anything but "
"commentary purposes."
msgstr ""
"显示了几个供货商ID。很凑巧的是<literal>NETGEAR_2</literal> 实际上是NETGEAR从"
"其购买卡的OEM，对那些卡提供支持的作者那时并不知道 NETgear使用的是别人的ID。这"
"些条目相当直接易懂。每行上都有供货商 关键字来指示本行的类别。也有供货商的名"
"字。名字将会在pccarddevs文件 的后面重复出现，名字也会用在驱动程序的匹配表中，"
"因此保持它的短小 并且是有效的C标识符。还有一个给供货商的十六进制数字ID。不要"
"添加 <literal>0xffffffff</literal>或<literal>0xffff</literal>形式的ID， 因为"
"它们是保留ID（前者是'空ID集合'，而后者有时会在质量极其差的卡中 看到，用来指示"
"none）。最后还有关于制卡公司的描述字符串。这个字符串 在FreeBSD中除了用于注释"
"目的外并没有被使用过。"

#. (itstool) path: sect2/para
#: book.translate.xml:23639
msgid ""
"The second section of the file contains the products. As shown in this "
"example, the format is similar to the vendor lines:"
msgstr "文件的第二节包含产品. 如你在下面例子中看到的:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23643
#, no-wrap
msgid ""
"/* Allied Telesis K.K. */\n"
"product ALLIEDTELESIS LA_PCM\t0x0002 Allied Telesis LA-PCM\n"
"\n"
"/* Archos */\n"
"product\tARCHOS ARC_ATAPI\t0x0043 MiniCD"
msgstr ""
"/* Allied Telesis K.K. */\n"
"product ALLIEDTELESIS LA_PCM\t0x0002 Allied Telesis LA-PCM\n"
"\n"
"/* Archos */\n"
"product\tARCHOS ARC_ATAPI\t0x0043 MiniCD"

#. (itstool) path: sect2/para
#: book.translate.xml:23649
msgid ""
"The <literal>product</literal> keyword is followed by the vendor name, "
"repeated from above. This is followed by the product name, which is used by "
"the driver and should be a valid C identifier, but may also start with a "
"number. As with the vendors, the hex product ID for this card follows the "
"same convention for <literal>0xffffffff</literal> and <literal>0xffff</"
"literal>. Finally, there is a string description of the device itself. This "
"string typically is not used in FreeBSD, since FreeBSD's pccard bus driver "
"will construct a string from the human readable CIS entries, but it can be "
"used in the rare cases where this is somehow insufficient. The products are "
"in alphabetical order by manufacturer, then numerical order by product ID. "
"They have a C comment before each manufacturer's entries and there is a "
"blank line between entries."
msgstr ""
"格式与供货商的那些行相似。其中有产品关键字。然后是供货商名字， 由上面重复而"
"来。后面跟着产品名字，此名字在驱动程序中使用，且应当 是一个有效C标识符，但可"
"以以数字开头。然后是卡的十六进制产品ID。 供货商通常对<literal>0xffffffff</"
"literal>和 <literal>0xffff</literal>有相同的约定。最后是关于设备自身的字符串 "
"描述。由于FreeBSD的pccard总线驱动程序会从人可读的CIS条目创建一个 字符串，因此"
"这个字符串在FreeBSD中通常不被使用，但某些CIS条目不能 满足要求的情况下还可能使"
"用。产品按制造商的字母顺序排序，然后再按 产品ID的数字排序。每个制造商条目前有"
"一条C注释，条目之间有一个空行。"

#. (itstool) path: sect2/para
#: book.translate.xml:23666
msgid ""
"The third section is like the previous vendor section, but with all of the "
"manufacturer numeric IDs set to <literal>-1</literal>, meaning <quote>match "
"anything found</quote> in the FreeBSD pccard bus code. Since these are C "
"identifiers, their names must be unique. Otherwise the format is identical "
"to the first section of the file."
msgstr ""
"第三节很象前面的供货商一节，但所由的制造商ID为 <literal>-1</literal>。"
"<literal>-1</literal>在FreeBSD pccard总线 代码中意味着<quote>匹配发现的任何东"
"西</quote>。由于它们是C标识符， 它们的名字必须唯一。除此之外格式等同于文件的"
"第一节。"

#. (itstool) path: sect2/para
#: book.translate.xml:23674
msgid ""
"The final section contains the entries for those cards that must be "
"identified by string entries. This section's format is a little different "
"from the generic section:"
msgstr ""
"最后一节包含那些必须用字符串匹配的卡。这一节的格式与通用 节的格式有点不同："

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23678
#, no-wrap
msgid ""
"product ADDTRON AWP100\t\t{ \"Addtron\", \"AWP-100&amp;spWireless&amp;spPCMCIA\", \"Version&amp;sp01.02\", NULL }\n"
"product ALLIEDTELESIS WR211PCM\t{ \"Allied&amp;spTelesis&amp;spK.K.\", \"WR211PCM\", NULL, NULL } Allied Telesis WR211PCM"
msgstr ""
"product ADDTRON AWP100\t\t{ \"Addtron\", \"AWP-100&amp;spWireless&amp;spPCMCIA\", \"Version&amp;sp01.02\", NULL }\n"
"product ALLIEDTELESIS WR211PCM\t{ \"Allied&amp;spTelesis&amp;spK.K.\", \"WR211PCM\", NULL, NULL } Allied Telesis WR211PCM"

#. (itstool) path: sect2/para
#: book.translate.xml:23681
msgid ""
"The familiar <literal>product</literal> keyword is followed by the vendor "
"name and the card name, just as in the second section of the file. Here the "
"format deviates from that used earlier. There is a {} grouping, followed by "
"a number of strings. These strings correspond to the vendor, product, and "
"extra information that is defined in a CIS_INFO tuple. These strings are "
"filtered by the program that generates <filename>pccarddevs.h</filename> to "
"replace &amp;sp with a real space. NULL strings mean that the corresponding "
"part of the entry should be ignored. The example shown here contains a bad "
"entry. It should not contain the version number unless that is critical for "
"the operation of the card. Sometimes vendors will have many different "
"versions of the card in the field that all work, in which case that "
"information only makes it harder for someone with a similar card to use it "
"with FreeBSD. Sometimes it is necessary when a vendor wishes to sell many "
"different parts under the same brand due to market considerations "
"(availability, price, and so forth). Then it can be critical to "
"disambiguating the card in those rare cases where the vendor kept the same "
"manufacturer/product pair. Regular expression matching is not available at "
"this time."
msgstr ""
"我们已经熟悉了产品关键字，后跟供货商名字，然后再跟卡的名字， 就象在文件第二节"
"中那样。然而，这之后就与那格式不同了。有一个 {}分组，后跟几个字符串。这些字符"
"串对应CIS_INFO三元组中定义的 供货商，产品和额外信息。这些字符串被产生 "
"<filename>pccarddevs.h</filename>的程序过滤，将 &amp;sp替换为 实际的空格。空"
"条目意味着条目的这部分应当被忽略。在我选择的例子中 有一个错误的条目。除非对卡"
"的操作来说至关重要，否则不应当在其中 包含版本号。有时供货商在这个字段中会有卡"
"的很多不同版本，这些版本 都能工作，这种情况下那些信息只会让那些拥有相似卡的人"
"在FreeBSD中 更难以使用。有时当供货商出于市场考虑（可用性，价格等等），希望出"
"售 同一品牌下的很多不同部分时，这也是有必要的。如果这样，则在那些 供货商仍然"
"保持相同的制造商/产品对的少见情况下，能否区分开卡至关 重要. 此时不能使用正则"
"表达式匹配。"

#. (itstool) path: sect2/title
#: book.translate.xml:23706
msgid "Sample Probe Routine"
msgstr "探测例程样例"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23708
msgid "<primary>PC Card</primary> <secondary>probe</secondary>"
msgstr ""
"<primary>PC卡(PCMCIA卡, Personal Computer Memory Card International "
"Association)</primary><secondary>probe(探测)</secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:23713
msgid ""
"To understand how to add a device to the list of supported devices, one must "
"understand the probe and/or match routines that many drivers have. It is "
"complicated a little in FreeBSD 5.x because there is a compatibility layer "
"for OLDCARD present as well. Since only the window-dressing is different, an "
"idealized version will be presented here."
msgstr ""
"要懂得如何向所支持的设备列表中添加设备，就必须懂得很多驱动程序 都有的探测和/"
"或匹配例程。由于也为老卡提供了一个兼容层，这在 FreeBSD 5.x中有一点复杂。由于"
"只是window-dressing不同，这儿给出了 一个理想化的版本。"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23720
#, no-wrap
msgid ""
"static const struct pccard_product wi_pccard_products[] = {\n"
"\tPCMCIA_CARD(3COM, 3CRWE737A, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_PCM_S11, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_CF_S11G, 0),\n"
"\tPCMCIA_CARD(TDK, LAK_CD011WL, 0),\n"
"\t{ NULL }\n"
"};\n"
"\n"
"static int\n"
"wi_pccard_probe(dev)\n"
"\tdevice_t\tdev;\n"
"{\n"
"\tconst struct pccard_product *pp;\n"
"\n"
"\tif ((pp = pccard_product_lookup(dev, wi_pccard_products,\n"
"\t    sizeof(wi_pccard_products[0]), NULL)) != NULL) {\n"
"\t\tif (pp-&gt;pp_name != NULL)\n"
"\t\t\tdevice_set_desc(dev, pp-&gt;pp_name);\n"
"\t\treturn (0);\n"
"\t}\n"
"\treturn (ENXIO);\n"
"}"
msgstr ""
"static const struct pccard_product wi_pccard_products[] = {\n"
"\tPCMCIA_CARD(3COM, 3CRWE737A, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_PCM_S11, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_CF_S11G, 0),\n"
"\tPCMCIA_CARD(TDK, LAK_CD011WL, 0),\n"
"\t{ NULL }\n"
"};\n"
"\n"
"static int\n"
"wi_pccard_probe(dev)\n"
"\tdevice_t\tdev;\n"
"{\n"
"\tconst struct pccard_product *pp;\n"
"\n"
"\tif ((pp = pccard_product_lookup(dev, wi_pccard_products,\n"
"\t    sizeof(wi_pccard_products[0]), NULL)) != NULL) {\n"
"\t\tif (pp-&gt;pp_name != NULL)\n"
"\t\t\tdevice_set_desc(dev, pp-&gt;pp_name);\n"
"\t\treturn (0);\n"
"\t}\n"
"\treturn (ENXIO);\n"
"}"

#. (itstool) path: sect2/para
#: book.translate.xml:23743
msgid ""
"Here we have a simple pccard probe routine that matches a few devices. As "
"stated above, the name may vary (if it is not <function>foo_pccard_probe()</"
"function> it will be <function>foo_pccard_match()</function>). The function "
"<function>pccard_product_lookup()</function> is a generalized function that "
"walks the table and returns a pointer to the first entry that it matches. "
"Some drivers may use this mechanism to convey additional information about "
"some cards to the rest of the driver, so there may be some variance in the "
"table. The only requirement is that each row of the table must have a "
"<function>struct</function> <varname remap=\"structname\">pccard_product</"
"varname> as the first element."
msgstr ""
"这儿我们有一个可以匹配少数几个设备的简单pccard探测例程。如上面 所提到，名字可"
"能不同（如果不是 <function>foo_pccard_probe()</function>则就是 "
"<function>foo_pccard_match()</function>）。函数 "
"<function>pccard_product_lookup()</function>是一个通用函数，它遍历 表并返回指"
"向它所匹配的第一项的指针。一些驱动程序可能使用这个机制来 将某些卡的附加信息传"
"递到驱动程序的其它部分，因此表中可能有些变体。 唯一的要求就是如果你有一个不同"
"的表，则让表的结构的第一个元素为 结构pccard_product。"

#. (itstool) path: sect2/para
#: book.translate.xml:23757
msgid ""
"Looking at the table <varname remap=\"structname\">wi_pccard_products</"
"varname>, one notices that all the entries are of the form "
"<function>PCMCIA_CARD(<replaceable>foo</replaceable>, <replaceable>bar</"
"replaceable>, <replaceable>baz</replaceable>)</function>. The "
"<replaceable>foo</replaceable> part is the manufacturer ID from "
"<filename>pccarddevs</filename>. The <replaceable>bar</replaceable> part is "
"the product ID. <replaceable>baz</replaceable> is the expected function "
"number for this card. Many pccards can have multiple functions, and some way "
"to disambiguate function 1 from function 0 is needed. You may see "
"<literal>PCMCIA_CARD_D</literal>, which includes the device description from "
"<filename>pccarddevs</filename>. You may also see <literal>PCMCIA_CARD2</"
"literal> and <literal>PCMCIA_CARD2_D</literal> which are used when you need "
"to match both CIS strings and manufacturer numbers, in the <quote>use the "
"default description</quote> and <quote>take the description from pccarddevs</"
"quote> flavors."
msgstr ""
"观察一下表<varname remap=\"structname\">wi_pccard_products</varname>就会发"
"现， 所有条目都是 <function>PCMCIA_CARD(<replaceable>foo</replaceable>， "
"<replaceable>bar</replaceable>， <replaceable>baz</replaceable>)</function>的"
"形式。 <replaceable>foo</replaceable>部分为来自 <filename>pccarddevs</"
"filename>的制造商ID。 <replaceable>bar</replaceable>部分为产品。 "
"<replaceable>baz</replaceable>为此卡所期望的功能号。许多pccards 可以有多个功"
"能，需要有办法区分开功能1和功能0。你可以看一下 <literal>PCMCIA_CARD_D</"
"literal>，它包括了来自 <filename>pccarddevs</filename>文件的设备描述。你也可"
"以看看 <literal>PCMCIA_CARD2</literal>和 <literal>PCMCIA_CARD2_D</literal>，"
"当你需要按 <quote>使用默认描述</quote>和<quote>从pccarddevs中取得</quote> 做"
"法，同时匹配CIS字符串和制造商号码时就会用到它们。"

#. (itstool) path: sect2/title
#: book.translate.xml:23780
msgid "Putting it All Together"
msgstr "将它合在一起"

#. (itstool) path: sect2/para
#: book.translate.xml:23782
msgid ""
"To add a new device, one must first obtain the identification information "
"from the device. The easiest way to do this is to insert the device into a "
"PC Card or CF slot and issue <command>devinfo -v</command>. Sample output:"
msgstr ""
"因此，为了一个增加新设备，必须进行下面步骤。首先，必须从设备 获得标识信息。完"
"成这个最容易的方法就是将设备插入到PC Card或CF槽中， 并发出<command>devinfo -"
"v</command>。你可能会看到一些类似下面的 东西："

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23788
#, no-wrap
msgid ""
"        cbb1 pnpinfo vendor=0x104c device=0xac51 subvendor=0x1265 subdevice=0x0300 class=0x060700 at slot=10 function=1\n"
"          cardbus1\n"
"          pccard1\n"
"            unknown pnpinfo manufacturer=0x026f product=0x030c cisvendor=\"BUFFALO\" cisproduct=\"WLI2-CF-S11\" function_type=6 at function=0"
msgstr ""
"        cbb1 pnpinfo vendor=0x104c device=0xac51 subvendor=0x1265 subdevice=0x0300 class=0x060700 at slot=10 function=1\n"
"          cardbus1\n"
"          pccard1\n"
"            unknown pnpinfo manufacturer=0x026f product=0x030c cisvendor=\"BUFFALO\" cisproduct=\"WLI2-CF-S11\" function_type=6 at function=0"

#. (itstool) path: sect2/para
#: book.translate.xml:23793
msgid ""
"<literal>manufacturer</literal> and <literal>product</literal> are the "
"numeric IDs for this product, while <literal>cisvendor</literal> and "
"<literal>cisproduct</literal> are the product description strings from the "
"CIS."
msgstr ""
"作为输出的一部分。制造商和产品为产品的数字ID。而cisvender和 cisproduct为CIS中"
"提供的描述本产品的字符串。"

#. (itstool) path: sect2/para
#: book.translate.xml:23799
msgid ""
"Since we first want to prefer the numeric option, first try to construct an "
"entry based on that. The above card has been slightly fictionalized for the "
"purpose of this example. The vendor is BUFFALO, which we see already has an "
"entry:"
msgstr ""
"由于我们首先想优先使用数字选项，因此首先尝试创建基于此的条目。 为了示例，上面"
"的卡已经被稍稍虚构化了。我们看到的供货商为BUFFALO， 它已经有一个条目了："

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23805
#, no-wrap
msgid "vendor BUFFALO\t\t\t0x026f\tBUFFALO (Melco Corporation)"
msgstr "vendor BUFFALO\t\t\t0x026f\tBUFFALO (Melco Corporation)"

#. (itstool) path: sect2/para
#: book.translate.xml:23807
msgid "But there is no entry for this particular card. Instead we find:"
msgstr "这样我们就可以了。为这个卡查找一个条目，但我们没有发现。但我们 发现："

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23810
#, no-wrap
msgid ""
"/* BUFFALO */\n"
"product BUFFALO WLI_PCM_S11\t0x0305\tBUFFALO AirStation 11Mbps WLAN\n"
"product BUFFALO LPC_CF_CLT\t0x0307\tBUFFALO LPC-CF-CLT\n"
"product\tBUFFALO\tLPC3_CLT\t0x030a\tBUFFALO LPC3-CLT Ethernet Adapter\n"
"product BUFFALO WLI_CF_S11G\t0x030b\tBUFFALO AirStation 11Mbps CF WLAN"
msgstr ""
"/* BUFFALO */\n"
"product BUFFALO WLI_PCM_S11\t0x0305\tBUFFALO AirStation 11Mbps WLAN\n"
"product BUFFALO LPC_CF_CLT\t0x0307\tBUFFALO LPC-CF-CLT\n"
"product\tBUFFALO\tLPC3_CLT\t0x030a\tBUFFALO LPC3-CLT Ethernet Adapter\n"
"product BUFFALO WLI_CF_S11G\t0x030b\tBUFFALO AirStation 11Mbps CF WLAN"

#. (itstool) path: sect2/para
#: book.translate.xml:23816
msgid ""
"To add the device, we can just add this entry to <filename>pccarddevs</"
"filename>:"
msgstr "我们就可以向<filename>pccarddevs</filename>中添加："

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23819
#, no-wrap
msgid "product BUFFALO WLI2_CF_S11G\t0x030c\tBUFFALO AirStation ultra 802.11b CF"
msgstr "product BUFFALO WLI2_CF_S11G\t0x030c\tBUFFALO AirStation ultra 802.11b CF"

#. (itstool) path: sect2/para
#: book.translate.xml:23821
msgid ""
"Once these steps are complete, the card can be added to the driver. That is "
"a simple operation of adding one line:"
msgstr ""
"目前，需要一个手动步骤来 重新产生<filename>pccarddevs.h</filename>，用来将这"
"些标识符转换 到客户驱动程序。你在驱动程序中使用它们之前必须完成下面步骤："

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23825
#, no-wrap
msgid ""
"static const struct pccard_product wi_pccard_products[] = {\n"
"\tPCMCIA_CARD(3COM, 3CRWE737A, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_PCM_S11, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_CF_S11G, 0),\n"
"+\tPCMCIA_CARD(BUFFALO, WLI_CF2_S11G, 0),\n"
"\tPCMCIA_CARD(TDK, LAK_CD011WL, 0),\n"
"\t{ NULL }\n"
"};"
msgstr ""
"static const struct pccard_product wi_pccard_products[] = {\n"
"\tPCMCIA_CARD(3COM, 3CRWE737A, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_PCM_S11, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_CF_S11G, 0),\n"
"+\tPCMCIA_CARD(BUFFALO, WLI_CF2_S11G, 0),\n"
"\tPCMCIA_CARD(TDK, LAK_CD011WL, 0),\n"
"\t{ NULL }\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:23834
msgid ""
"Note that I have included a '<literal>+</literal>' in the line before the "
"line that I added, but that is simply to highlight the line. Do not add it "
"to the actual driver. Once you have added the line, you can recompile your "
"kernel or module and test it. If the device is recognized and works, please "
"submit a patch. If it does not work, please figure out what is needed to "
"make it work and submit a patch. If the device is not recognized at all, you "
"have done something wrong and should recheck each step."
msgstr ""
"注意，我在我添加的行前面包含了'<literal>+</literal>'，但这只是 用来强调这一"
"行。不要把它添加到实际驱动程序中。一旦你添加了这行，就 可以重新编译内核或模"
"块，并试着看它是否能识别设备。如果它识别出设备 并能工作，请提交补丁。如果它不"
"工作，请找出让它工作所需要的东西并 提交一个补丁。如果它根本不识别设备，那么你"
"可能做错了什么，应当重新 检查每一步。"

#. (itstool) path: sect2/para
#: book.translate.xml:23844
msgid ""
"If you are a FreeBSD src committer, and everything appears to be working, "
"then you can commit the changes to the tree. However, there are some minor "
"tricky things to be considered. <filename>pccarddevs</filename> must be "
"committed to the tree first. Then <filename>pccarddevs.h</filename> must be "
"regenerated and committed as a second step, ensuring that the right $FreeBSD"
"$ tag is in the latter file. Finally, commit the additions to the driver."
msgstr ""
"如果你是一个FreeBSD源代码的committer，并且所有东西看起来都 正常工作，则你应当"
"把这些改变提交到树中。然而有些小技巧的东西你 需要考虑。首先，你必须提交"
"<filename>pccarddevs</filename>文件到 树中。完成后，你必须重新产生"
"<filename>pccarddevs.h</filename> 并将它作为另一次提交来提交（这是为了确保正"
"确的 $FreeBSD$标签会留在后面的文件中）。最后，你需要把 其它东西提交到驱动程"
"序。"

#. (itstool) path: sect2/title
#: book.translate.xml:23855
msgid "Submitting a New Device"
msgstr "提交新设备"

#. (itstool) path: sect2/para
#: book.translate.xml:23857
msgid ""
"Please do not send entries for new devices to the author directly. Instead, "
"submit them as a PR and send the author the PR number for his records. This "
"ensures that entries are not lost. When submitting a PR, it is unnecessary "
"to include the <filename>pccardevs.h</filename> diffs in the patch, since "
"those will be regenerated. It is necessary to include a description of the "
"device, as well as the patches to the client driver. If you do not know the "
"name, use OEM99 as the name, and the author will adjust OEM99 accordingly "
"after investigation. Committers should not commit OEM99, but instead find "
"the highest OEM entry and commit one more than that."
msgstr ""
"很多人直接把新设备的条目发送给作者。请不要那样做。请将它们作为 PR来提交，并将"
"PR号码发送给作者用于记录。这样确保条目不会丢失。提交 PR时，补丁中没有必要包含"
"<filename>pccardevs.h</filename>的diff， 因为那些东西可以重新产生。包含设备的"
"描述和客户驱动程序的补丁是必要 的。如果你不知道名字，使用OEM99作为名字，作者"
"将会调查后相应地调整 OEM99。提交者不应当提交OEM99，而应该找到最高的OEM条目并"
"提交高于那个 的一个。"

#. (itstool) path: part/title
#: book.translate.xml:23911
msgid "Appendices"
msgstr "附录"

#. (itstool) path: authorgroup/author
#: book.translate.xml:23917
#, fuzzy
#| msgid ""
#| "<personname><firstname>Marshall</firstname><othername role=\"Middle"
#| "\">Kirk</othername><surname>McKusick</surname></personname>"
msgid ""
"<personname> <firstname>Marshall</firstname> <othername role=\"Middle"
"\">Kirk</othername> <surname>McKusick</surname> </personname>"
msgstr ""
"<personname><firstname>Marshall</firstname><othername role=\"Middle\">Kirk</"
"othername><surname>McKusick</surname></personname>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:23924
#, fuzzy
#| msgid ""
#| "<personname><firstname>Keith</firstname><surname>Bostic</surname></"
#| "personname>"
msgid ""
"<personname> <firstname>Keith</firstname> <surname>Bostic</surname> </"
"personname>"
msgstr ""
"<personname><firstname>Keith</firstname><surname>Bostic</surname></"
"personname>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:23930
#, fuzzy
#| msgid ""
#| "<personname><firstname>Michael</firstname><othername role=\"MI\">J</"
#| "othername><surname>Karels</surname></personname>"
msgid ""
"<personname> <firstname>Michael</firstname> <othername role=\"MI\">J</"
"othername> <surname>Karels</surname> </personname>"
msgstr ""
"<personname><firstname>Michael</firstname><othername role=\"MI\">J</"
"othername><surname>Karels</surname></personname>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:23937
#, fuzzy
#| msgid ""
#| "<personname><firstname>John</firstname><othername role=\"MI\">S</"
#| "othername><surname>Quarterman</surname></personname>"
msgid ""
"<personname> <firstname>John</firstname> <othername role=\"MI\">S</"
"othername> <surname>Quarterman</surname> </personname>"
msgstr ""
"<personname><firstname>John</firstname><othername role=\"MI\">S</"
"othername><surname>Quarterman</surname></personname>"

#. (itstool) path: biblioentry/copyright
#: book.translate.xml:23946
msgid ""
"<year>1996</year> <holder>Addison-Wesley Publishing Company, Inc.</holder>"
msgstr ""
"<year>1996</year> <holder>Addison-Wesley Publishing Company, Inc.</holder>"

#. (itstool) path: biblioentry/biblioid
#: book.translate.xml:23951
msgid "0-201-54979-4"
msgstr "0-201-54979-4"

#. (itstool) path: publisher/publishername
#: book.translate.xml:23954
msgid "Addison-Wesley Publishing Company, Inc."
msgstr "Addison-Wesley Publishing Company, Inc."

#. (itstool) path: biblioentry/citetitle
#: book.translate.xml:23958
msgid "The Design and Implementation of the 4.4 BSD Operating System"
msgstr "The Design and Implementation of the 4.4 BSD Operating System"

#. (itstool) path: biblioentry/pagenums
#: book.translate.xml:23961
msgid "1-2"
msgstr "1-2"
