# Danilo G. Baio <dbaio@FreeBSD.org>, 2019. #zanata
# Edson Brandi <ebrandi@FreeBSD.org>, 2019. #zanata
# kanazuchi <contato@kanazuchi.com>, 2019. #zanata
# Edson Brandi <ebrandi@freebsd.org>, 2019.
# Alexandre Liberato <psybox@gmail.com>, 2020.
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2020-06-06 11:10-0300\n"
"PO-Revision-Date: 2020-11-24 10:46+0000\n"
"Last-Translator: Alexandre Liberato <psybox@gmail.com>\n"
"Language-Team: Portuguese (Brazil) <https://translate-dev.freebsd.org/"
"projects/freebsd-doc/boooks_arch-handbook/pt_BR/>\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Weblate 4.3.2\n"

#. Put one translator per line, in the form NAME <EMAIL>, YEAR1, YEAR2
msgctxt "_"
msgid "translator-credits"
msgstr ""
"Edson Brandi, ebrandi@FreeBSD.org, 2018\n"
"Alexandre Liberato, alexandre@feiler.co,2\n"
"Alexandre Vasconcelos, alex.vasconcelos@gmail.com, 2018\n"
"André Franciosi, andre@franciosi.org, 2018"

#. (itstool) path: info/title
#: book.translate.xml:142
msgid "FreeBSD Architecture Handbook"
msgstr "Handbook de Arquitetura do FreeBSD"

#. (itstool) path: info/author
#: book.translate.xml:144
msgid "<orgname>The FreeBSD Documentation Project</orgname>"
msgstr "<orgname>Projeto de Documentação do FreeBSD</orgname>"

#. (itstool) path: info/pubdate
#. (itstool) path: info/releaseinfo
#: book.translate.xml:147 book.translate.xml:226
msgid ""
"$FreeBSD: head/en_US.ISO8859-1/books/arch-handbook/book.xml 53369 2019-09-05 "
"15:28:22Z bcr $"
msgstr ""
"$FreeBSD: head/en_US.ISO8859-1/books/arch-handbook/book.xml 53369 2019-09-05 "
"15:28:22Z bcr $"

#. (itstool) path: info/copyright
#: book.translate.xml:149
msgid ""
"<year>2000</year> <year>2001</year> <year>2002</year> <year>2003</year> "
"<year>2004</year> <year>2005</year> <year>2006</year> <year>2012</year> "
"<year>2013</year> <holder>The FreeBSD Documentation Project</holder>"
msgstr ""
"<year>2000</year> <year>2001</year> <year>2002</year> <year>2003</year> "
"<year>2004</year> <year>2005</year> <year>2006</year> <year>2012</year> "
"<year>2013</year> <holder>The FreeBSD Documentation Project</holder>"

#. (itstool) path: legalnotice/para
#: book.translate.xml:163
msgid "FreeBSD is a registered trademark of the FreeBSD Foundation."
msgstr "FreeBSD is a registered trademark of the FreeBSD Foundation."

#. (itstool) path: legalnotice/para
#: book.translate.xml:165
msgid ""
"UNIX is a registered trademark of The Open Group in the United States and "
"other countries."
msgstr ""
"UNIX is a registered trademark of The Open Group in the United States and "
"other countries."

#. (itstool) path: legalnotice/para
#: book.translate.xml:167
msgid ""
"Apple, AirPort, FireWire, iMac, iPhone, iPad, Mac, Macintosh, Mac OS, "
"Quicktime, and TrueType are trademarks of Apple Inc., registered in the U.S. "
"and other countries."
msgstr ""
"Apple, AirPort, FireWire, iMac, iPhone, iPad, Mac, Macintosh, Mac OS, "
"Quicktime, and TrueType are trademarks of Apple Inc., registered in the U.S. "
"and other countries."

#. (itstool) path: legalnotice/para
#: book.translate.xml:172
msgid ""
"Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media and Windows "
"NT are either registered trademarks or trademarks of Microsoft Corporation "
"in the United States and/or other countries."
msgstr ""
"Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media and Windows "
"NT are either registered trademarks or trademarks of Microsoft Corporation "
"in the United States and/or other countries."

#. (itstool) path: legalnotice/para
#: book.translate.xml:176
msgid ""
"Many of the designations used by manufacturers and sellers to distinguish "
"their products are claimed as trademarks. Where those designations appear in "
"this document, and the FreeBSD Project was aware of the trademark claim, the "
"designations have been followed by the <quote>™</quote> or the <quote>®</"
"quote> symbol."
msgstr ""
"Many of the designations used by manufacturers and sellers to distinguish "
"their products are claimed as trademarks. Where those designations appear in "
"this document, and the FreeBSD Project was aware of the trademark claim, the "
"designations have been followed by the <quote>™</quote> or the <quote>®</"
"quote> symbol."

#. (itstool) path: legalnotice/title
#: book.translate.xml:186
msgid "Copyright"
msgstr "Copyright"

#. (itstool) path: legalnotice/para
#: book.translate.xml:188
msgid ""
"Redistribution and use in source (XML DocBook) and 'compiled' forms (XML, "
"HTML, PDF, PostScript, RTF and so forth) with or without modification, are "
"permitted provided that the following conditions are met:"
msgstr ""
"Redistribution and use in source (XML DocBook) and 'compiled' forms (XML, "
"HTML, PDF, PostScript, RTF and so forth) with or without modification, are "
"permitted provided that the following conditions are met:"

#. (itstool) path: listitem/para
#: book.translate.xml:195
msgid ""
"Redistributions of source code (XML DocBook) must retain the above copyright "
"notice, this list of conditions and the following disclaimer as the first "
"lines of this file unmodified."
msgstr ""
"Redistributions of source code (XML DocBook) must retain the above copyright "
"notice, this list of conditions and the following disclaimer as the first "
"lines of this file unmodified."

#. (itstool) path: listitem/para
#: book.translate.xml:201 book.translate.xml:4385
msgid ""
"Redistributions in compiled form (transformed to other DTDs, converted to "
"PDF, PostScript, RTF and other formats) must reproduce the above copyright "
"notice, this list of conditions and the following disclaimer in the "
"documentation and/or other materials provided with the distribution."
msgstr ""
"Redistributions in compiled form (transformed to other DTDs, converted to "
"PDF, PostScript, RTF and other formats) must reproduce the above copyright "
"notice, this list of conditions and the following disclaimer in the "
"documentation and/or other materials provided with the distribution."

#. (itstool) path: important/para
#: book.translate.xml:210
msgid ""
"THIS DOCUMENTATION IS PROVIDED BY THE FREEBSD DOCUMENTATION PROJECT \"AS IS"
"\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE "
"IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE "
"ARE DISCLAIMED. IN NO EVENT SHALL THE FREEBSD DOCUMENTATION PROJECT BE "
"LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR "
"CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF "
"SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS "
"INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN "
"CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) "
"ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF "
"THE POSSIBILITY OF SUCH DAMAGE."
msgstr ""
"THIS DOCUMENTATION IS PROVIDED BY THE FREEBSD DOCUMENTATION PROJECT \"AS IS"
"\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE "
"IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE "
"ARE DISCLAIMED. IN NO EVENT SHALL THE FREEBSD DOCUMENTATION PROJECT BE "
"LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR "
"CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF "
"SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS "
"INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN "
"CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) "
"ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF "
"THE POSSIBILITY OF SUCH DAMAGE."

#. (itstool) path: abstract/para
#: book.translate.xml:229
msgid ""
"Welcome to the FreeBSD Architecture Handbook. This manual is a "
"<emphasis>work in progress</emphasis> and is the work of many individuals. "
"Many sections do not yet exist and some of those that do exist need to be "
"updated. If you are interested in helping with this project, send email to "
"the <link xlink:href=\"http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc"
"\">FreeBSD documentation project mailing list</link>."
msgstr ""
"Welcome to the FreeBSD Architecture Handbook. This manual is a "
"<emphasis>work in progress</emphasis> and is the work of many individuals. "
"Many sections do not yet exist and some of those that do exist need to be "
"updated. If you are interested in helping with this project, send email to "
"the <link xlink:href=\"http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc"
"\">FreeBSD documentation project mailing list</link>."

#. (itstool) path: abstract/para
#: book.translate.xml:236
msgid ""
"The latest version of this document is always available from the <link xlink:"
"href=\"@@URL_RELPREFIX@@/index.html\">FreeBSD World Wide Web server</link>. "
"It may also be downloaded in a variety of formats and compression options "
"from the <link xlink:href=\"https://download.freebsd.org/ftp/doc/\">FreeBSD "
"FTP server</link> or one of the numerous <link xlink:href="
"\"@@URL_RELPREFIX@@/doc/en_US.ISO8859-1/books/handbook/mirrors-ftp.html"
"\">mirror sites</link>."
msgstr ""
"The latest version of this document is always available from the <link xlink:"
"href=\"@@URL_RELPREFIX@@/index.html\">FreeBSD World Wide Web server</link>. "
"It may also be downloaded in a variety of formats and compression options "
"from the <link xlink:href=\"https://download.freebsd.org/ftp/doc/\">FreeBSD "
"FTP server</link> or one of the numerous <link xlink:href="
"\"@@URL_RELPREFIX@@/doc/en_US.ISO8859-1/books/handbook/mirrors-ftp.html"
"\">mirror sites</link>."

#. (itstool) path: part/title
#: book.translate.xml:246
msgid "Kernel"
msgstr "Kernel"

#. (itstool) path: info/title
#: book.translate.xml:262
msgid "Bootstrapping and Kernel Initialization"
msgstr "Bootstrapping e Inicialização do Kernel"

#. (itstool) path: authorgroup/author
#: book.translate.xml:265
msgid ""
"<personname> <firstname>Sergey</firstname> <surname>Lyubka</surname> </"
"personname> <contrib>Contributed by </contrib>"
msgstr ""
" <personname><firstname>Sergey</firstname><surname> Lyubka</surname></"
"personname><contrib> Contribuíram por </contrib> "

#. (itstool) path: authorgroup/author
#: book.translate.xml:277
msgid ""
"<personname> <firstname>Sergio Andrés</firstname> <surname> Gómez del Real</"
"surname> </personname> <contrib>Updated and enhanced by </contrib>"
msgstr ""
"<personname> <firstname>Sergio Andrés</firstname> <surname> Gómez del Real</"
"surname> </personname> <contrib>Atualizado e melhorado por </contrib>"

#. (itstool) path: sect1/title
#: book.translate.xml:290 book.translate.xml:4412 book.translate.xml:16510
#: book.translate.xml:19480
msgid "Synopsis"
msgstr "Sinopse "

#. (itstool) path: sect1/indexterm
#. (itstool) path: para/indexterm
#: book.translate.xml:292 book.translate.xml:20828
msgid "<primary>BIOS</primary>"
msgstr " <primary>BIOS</primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:293
msgid "<primary>firmware</primary>"
msgstr " <primary>firmware</primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:294
msgid "<primary>POST</primary>"
msgstr "<primary>POST</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:295
msgid "<primary>IA-32</primary>"
msgstr " <primary>IA-32</primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:296
msgid "<primary>booting</primary>"
msgstr " <primary>inicialização</primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:297
msgid "<primary>system initialization</primary>"
msgstr " <primary>inicialização do sistema</primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:298
msgid ""
"This chapter is an overview of the boot and system initialization processes, "
"starting from the <acronym>BIOS</acronym> (firmware) <acronym>POST</"
"acronym>, to the first user process creation. Since the initial steps of "
"system startup are very architecture dependent, the IA-32 architecture is "
"used as an example."
msgstr ""
"Este capítulo é uma visão geral dos processos de inicialização e "
"inicialização do sistema, desde o <acronym>POST</acronym> da <acronym>BIOS</"
"acronym> (firmware) até a primeira criação do processo do usuário. Como as "
"etapas iniciais da inicialização do sistema são muito dependentes da "
"arquitetura, a arquitetura IA-32 é usada como um exemplo."

#. (itstool) path: sect1/para
#: book.translate.xml:305
msgid ""
"The FreeBSD boot process can be surprisingly complex. After control is "
"passed from the <acronym>BIOS</acronym>, a considerable amount of low-level "
"configuration must be done before the kernel can be loaded and executed. "
"This setup must be done in a simple and flexible manner, allowing the user a "
"great deal of customization possibilities."
msgstr ""
"O processo de inicialização do FreeBSD pode ser surpreendentemente complexo. "
"Após o controle ser passado da <acronym>BIOS</acronym>, uma quantidade "
"considerável de configuração de baixo nével deve ser feita antes que o "
"kernel possa ser carregado e executado. Essa configuração deve ser feita de "
"maneira simples e flexível, permitindo ao usuário uma grande quantidade de "
"possibilidades de personalização. "

#. (itstool) path: sect1/title
#. (itstool) path: sect2/title
#: book.translate.xml:314 book.translate.xml:23530
msgid "Overview"
msgstr "Visão geral"

#. (itstool) path: sect1/para
#: book.translate.xml:316
msgid ""
"The boot process is an extremely machine-dependent activity. Not only must "
"code be written for every computer architecture, but there may also be "
"multiple types of booting on the same architecture. For example, a directory "
"listing of <filename>/usr/src/sys/boot</filename> reveals a great amount of "
"architecture-dependent code. There is a directory for each of the various "
"supported architectures. In the x86-specific <filename>i386</filename> "
"directory, there are subdirectories for different boot standards like "
"<filename>mbr</filename> (Master Boot Record), <filename>gpt</filename> "
"(<acronym>GUID</acronym> Partition Table), and <filename>efi</filename> "
"(Extensible Firmware Interface). Each boot standard has its own conventions "
"and data structures. The example that follows shows booting an x86 computer "
"from an <acronym>MBR</acronym> hard drive with the FreeBSD <filename>boot0</"
"filename> multi-boot loader stored in the very first sector. That boot code "
"starts the FreeBSD three-stage boot process."
msgstr ""
"O processo de inicialização é uma atividade extremamente dependente da "
"máquina. Não sé deve ser escrito código para cada arquitetura de computador, "
"mas também pode haver vários tipos de inicialização na mesma arquitetura. "
"Por exemplo, uma lista de diretórios de <filename>/usr/src/sys/boot</"
"filename> revela uma grande quantidade de código dependente de arquitetura. "
"Existe um diretório para cada uma das várias arquiteturas suportadas. No x86-"
"specific <filename>i386</filename> diretório, existem subdiretórios para "
"diferentes padrões de inicialização, como <filename>mbr</filename> (Master "
"Boot Record), <filename>gpt</filename> (Tabela de Partição <acronym>GUID</"
"acronym> ) e <filename>efi</filename> (Interface de Firmware Extensível). "
"Cada padrão de inicialização possui suas próprias convenções e estruturas de "
"dados. O exemplo a seguir mostra a inicialização de um computador x86 de um "
"disco rígido <acronym>MBR</acronym> com o FreeBSD <filename>boot0</filename> "
"carregador multi-boot armazenado no primeiro setor. Esse código inicia o "
"processo de inicialização de três estágios do FreeBSD. "

#. (itstool) path: sect1/para
#: book.translate.xml:335
msgid ""
"The key to understanding this process is that it is a series of stages of "
"increasing complexity. These stages are <filename>boot1</filename>, "
"<filename>boot2</filename>, and <filename>loader</filename> (see "
"<citerefentry><refentrytitle>boot</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> for more detail). The boot system executes each stage in "
"sequence. The last stage, <filename>loader</filename>, is responsible for "
"loading the FreeBSD kernel. Each stage is examined in the following sections."
msgstr ""
"A chave para entender esse processo é que ele é uma série de estágios de "
"crescente complexidade. Esses estágios são <filename>boot1</filename> , "
"<filename>boot2</filename> e <filename>carregador</filename> (Vejo "
"<citerefentry><refentrytitle>boot</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> para mais detalhes). O sistema de inicialização executa cada "
"estágio em sequência. O último estágio <filename>carregador</filename> , é "
"responsável por carregar o kernel do FreeBSD. Cada estágio é examinado nas "
"seções seguintes. "

#. (itstool) path: sect1/para
#: book.translate.xml:344
msgid ""
"Here is an example of the output generated by the different boot stages. "
"Actual output may differ from machine to machine:"
msgstr ""
"Aqui está um exemplo da saída gerada pelos diferentes estágios de "
"inicialização. A saída real pode diferir de máquina para máquina:"

#. (itstool) path: row/entry
#: book.translate.xml:352
msgid "FreeBSD Component"
msgstr "Componente do FreeBSD"

#. (itstool) path: row/entry
#: book.translate.xml:353
msgid "Output (may vary)"
msgstr "Saída (pode variar)"

#. (itstool) path: row/entry
#: book.translate.xml:357
msgid "<literal>boot0</literal>"
msgstr " <literal>boot0</literal> "

#. (itstool) path: entry/screen
#: book.translate.xml:358
#, no-wrap
msgid ""
"F1    FreeBSD\n"
"F2    BSD\n"
"F5    Disk 2"
msgstr ""
"F1    FreeBSD\n"
"F2    BSD\n"
"F5    Disk 2"

#. (itstool) path: footnote/para
#: book.translate.xml:365
msgid ""
"This prompt will appear if the user presses a key just after selecting an OS "
"to boot at the <literal>boot0</literal> stage."
msgstr ""
"Este aviso aparecerá se o usuário pressionar uma tecla logo após selecionar "
"um SO para inicializar no <literal>boot0</literal> etapa."

#. (itstool) path: row/entry
#: book.translate.xml:364
msgid "<literal>boot2</literal> <_:footnote-1/>"
msgstr "<literal>boot2</literal> <_:footnote-1/>"

#. (itstool) path: entry/screen
#: book.translate.xml:369
#, no-wrap
msgid ""
"&gt;&gt;FreeBSD/i386 BOOT\n"
"Default: 1:ad(1,a)/boot/loader\n"
"boot:"
msgstr ""
"&gt;&gt;FreeBSD/i386 BOOT\n"
"Default: 1:ad(1,a)/boot/loader\n"
"boot:"

#. (itstool) path: row/entry
#: book.translate.xml:375
msgid "<filename>loader</filename>"
msgstr " <filename>carregador</filename> "

#. (itstool) path: entry/screen
#: book.translate.xml:376
#, no-wrap
msgid ""
"BTX loader 1.00 BTX version is 1.02\n"
"Consoles: internal video/keyboard\n"
"BIOS drive C: is disk0\n"
"BIOS 639kB/2096064kB available memory\n"
"\n"
"FreeBSD/x86 bootstrap loader, Revision 1.1\n"
"Console internal video/keyboard\n"
"(root@snap.freebsd.org, Thu Jan 16 22:18:05 UTC 2014)\n"
"Loading /boot/defaults/loader.conf\n"
"/boot/kernel/kernel text=0xed9008 data=0x117d28+0x176650 syms=[0x8+0x137988+0x8+0x1515f8]"
msgstr ""
"BTX loader 1.00 BTX version is 1.02\n"
"Consoles: internal video/keyboard\n"
"BIOS drive C: is disk0\n"
"BIOS 639kB/2096064kB available memory\n"
"\n"
"FreeBSD/x86 bootstrap loader, Revision 1.1\n"
"Console internal video/keyboard\n"
"(root@snap.freebsd.org, Thu Jan 16 22:18:05 UTC 2014)\n"
"Loading /boot/defaults/loader.conf\n"
"/boot/kernel/kernel text=0xed9008 data=0x117d28+0x176650 syms=[0x8+0x137988+0x8+0x1515f8]"

#. (itstool) path: row/entry
#: book.translate.xml:389
msgid "kernel"
msgstr "núcleo"

#. (itstool) path: entry/screen
#: book.translate.xml:390
#, no-wrap
msgid ""
"Copyright (c) 1992-2013 The FreeBSD Project.\n"
"Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994\n"
"        The Regents of the University of California. All rights reserved.\n"
"FreeBSD is a registered trademark of The FreeBSD Foundation.\n"
"FreeBSD 10.0-RELEASE #0 r260789: Thu Jan 16 22:34:59 UTC 2014\n"
"    root@snap.freebsd.org:/usr/obj/usr/src/sys/GENERIC amd64\n"
"FreeBSD clang version 3.3 (tags/RELEASE_33/final 183502) 20130610"
msgstr ""
"Copyright (c) 1992-2013 The FreeBSD Project.\n"
"Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994\n"
"        The Regents of the University of California. All rights reserved.\n"
"FreeBSD is a registered trademark of The FreeBSD Foundation.\n"
"FreeBSD 10.0-RELEASE #0 r260789: Thu Jan 16 22:34:59 UTC 2014\n"
"    root@snap.freebsd.org:/usr/obj/usr/src/sys/GENERIC amd64\n"
"FreeBSD clang version 3.3 (tags/RELEASE_33/final 183502) 20130610"

#. (itstool) path: sect1/title
#: book.translate.xml:404
msgid "The <acronym>BIOS</acronym>"
msgstr "O <acronym>BIOS</acronym>"

#. (itstool) path: sect1/para
#: book.translate.xml:406
msgid ""
"When the computer powers on, the processor's registers are set to some "
"predefined values. One of the registers is the <emphasis>instruction "
"pointer</emphasis> register, and its value after a power on is well defined: "
"it is a 32-bit value of <literal>0xfffffff0</literal>. The instruction "
"pointer register (also known as the Program Counter) points to code to be "
"executed by the processor. Another important register is the <literal>cr0</"
"literal> 32-bit control register, and its value just after a reboot is "
"<literal>0</literal>. One of <literal>cr0</literal>'s bits, the PE "
"(Protection Enabled) bit, indicates whether the processor is running in 32-"
"bit protected mode or 16-bit real mode. Since this bit is cleared at boot "
"time, the processor boots in 16-bit real mode. Real mode means, among other "
"things, that linear and physical addresses are identical. The reason for the "
"processor not to start immediately in 32-bit protected mode is backwards "
"compatibility. In particular, the boot process relies on the services "
"provided by the <acronym>BIOS</acronym>, and the <acronym>BIOS</acronym> "
"itself works in legacy, 16-bit code."
msgstr ""
"Quando o computador liga, os registros do processador são ajustados para "
"alguns valores pré-definidos. Um dos registradores é o <emphasis>ponteiro de "
"instrução</emphasis> registrar, e seu valor após um power on é bem definido: "
"é um valor de 32 bits de <literal>0xfffffff0</literal> . O registrador de "
"ponteiro de instrução (também conhecido como Contador de Programa) aponta "
"para o código a ser executado pelo processador. Outro registro importante é "
"o <literal>cr0</literal> Registro de controle de 32 bits, e seu valor logo "
"após a reinicialização é <literal>0</literal>. Um de <literal>cr0</"
"literal>'s bits, o bit PE (Protection Enabled), indica se o processador está "
"sendo executado no modo protegido de 32 bits ou no modo real de 16 bits. "
"Como esse bit é limpo no momento da inicialização, o processador é "
"inicializado no modo real de 16 bits. O modo real significa, entre outras "
"coisas, que os endereços linear e físico são idênticos. O motivo para o "
"processador não iniciar imediatamente no modo protegido de 32 bits é "
"compatível com versões anteriores. Em particular, o processo de "
"inicialização depende dos serviços fornecidos pelo <acronym>BIOS</acronym>, "
"e o próprio <acronym>BIOS</acronym> funciona em código legado de 16 bits. "

#. (itstool) path: sect1/para
#: book.translate.xml:426
#, fuzzy
#| msgid ""
#| "The value of <literal>0xfffffff0</literal> is slightly less than 4 GB, so "
#| "unless the machine has 4 GB of physical memory, it cannot point to a "
#| "valid memory address. The computer's hardware translates this address so "
#| "that it points to a <acronym>BIOS</acronym> memory block."
msgid ""
"The value of <literal>0xfffffff0</literal> is slightly less than 4 GB, so "
"unless the machine has 4 GB of physical memory, it cannot point to a valid "
"memory address. The computer's hardware translates this address so that it "
"points to a <acronym>BIOS</acronym> memory block."
msgstr ""
"O valor de <literal>0xfffffff0</literal> é um pouco menor que 4 GB, "
"portanto, a menos que a máquina tenha 4 GB de memória física, ela não pode "
"apontar para um endereço de memória válido. O hardware do computador traduz "
"esse endereço para que ele aponte para um bloco de memória da <acronym>BIOS</"
"acronym> . "

#. (itstool) path: sect1/para
#: book.translate.xml:432
msgid ""
"The <acronym>BIOS</acronym> (Basic Input Output System) is a chip on the "
"motherboard that has a relatively small amount of read-only memory "
"(<acronym>ROM</acronym>). This memory contains various low-level routines "
"that are specific to the hardware supplied with the motherboard. The "
"processor will first jump to the address 0xfffffff0, which really resides in "
"the <acronym>BIOS</acronym>'s memory. Usually this address contains a jump "
"instruction to the <acronym>BIOS</acronym>'s POST routines."
msgstr ""
"O <acronym>BIOS</acronym> (Basic Input Output System) é um chip da placa-mãe "
"que tem uma quantidade relativamente pequena de memória somente leitura "
"(<acronym>ROM</acronym>). Essa memória contém várias rotinas de baixo nível "
"que são específicas para o hardware fornecido com a placa-mãe. O processador "
"irá primeiro saltar para o endereço 0xfffffff0, que realmente reside na "
"memória do <acronym>BIOS</acronym>. Normalmente, este endereço contém uma "
"instrução de salto para as rotinas de POST do <acronym>BIOS</acronym>. "

#. (itstool) path: sect1/para
#: book.translate.xml:442
msgid ""
"The <acronym>POST</acronym> (Power On Self Test) is a set of routines "
"including the memory check, system bus check, and other low-level "
"initialization so the <acronym>CPU</acronym> can set up the computer "
"properly. The important step of this stage is determining the boot device. "
"Modern <acronym>BIOS</acronym> implementations permit the selection of a "
"boot device, allowing booting from a floppy, <acronym>CD-ROM</acronym>, hard "
"disk, or other devices."
msgstr ""
"O <acronym>POST</acronym> (Power On Self Test) é um conjunto de rotinas "
"incluindo a verificação de memória, verificação do barramento do sistema e "
"outras inicializações de baixo nível para que a <acronym>CPU</acronym> possa "
"configurar o computador corretamente. A etapa importante deste estágio é "
"determinar o dispositivo de inicialização. As implementações modernas do "
"<acronym>BIOS</acronym> permitem a seleção de um dispositivo de "
"inicialização, permitindo a inicialização a partir de um disquete, "
"<acronym>CD-ROM</acronym>, disco rígido ou outros dispositivos. "

#. (itstool) path: sect1/para
#: book.translate.xml:451
msgid ""
"The very last thing in the <acronym>POST</acronym> is the <literal>INT 0x19</"
"literal> instruction. The <literal>INT 0x19</literal> handler reads 512 "
"bytes from the first sector of boot device into the memory at address "
"<literal>0x7c00</literal>. The term <emphasis>first sector</emphasis> "
"originates from hard drive architecture, where the magnetic plate is divided "
"into a number of cylindrical tracks. Tracks are numbered, and every track is "
"divided into a number (usually 64) of sectors. Track numbers start at 0, but "
"sector numbers start from 1. Track 0 is the outermost on the magnetic plate, "
"and sector 1, the first sector, has a special purpose. It is also called the "
"<acronym>MBR</acronym>, or Master Boot Record. The remaining sectors on the "
"first track are never used."
msgstr ""
"A última coisa no <acronym>POST</acronym> é a <literal>INT 0x19</literal> "
"instrução. o <literal>INT 0x19</literal> manipulador lê 512 bytes do "
"primeiro setor do dispositivo de inicialização para a memória no endereço "
"<literal>0x7c00</literal>. O termo <emphasis>primeiro setor</emphasis> "
"origina-se da arquitetura do disco rígido, onde a placa magnética é dividida "
"em vários trilhos cilíndricos. As faixas são numeradas e todas as faixas são "
"divididas em um número (geralmente 64) de setores. Os números das faixas "
"começam em 0, mas os números setoriais começam em 1. A faixa 0 é a mais "
"externa na placa magnética, e o setor 1, o primeiro setor, tem uma "
"finalidade especial. Também é chamado de <acronym>MBR</acronym> ou Master "
"Boot Record. Os setores restantes na primeira faixa nunca são usados."

#. (itstool) path: sect1/para
#: book.translate.xml:466
msgid ""
"This sector is our boot-sequence starting point. As we will see, this sector "
"contains a copy of our <filename>boot0</filename> program. A jump is made by "
"the <acronym>BIOS</acronym> to address <literal>0x7c00</literal> so it "
"starts executing."
msgstr ""
"Este setor é o nosso ponto de partida da sequência de inicialização. Como "
"veremos, este setor contém uma cópia do nosso <filename>boot0</filename> "
"programa. Um salto é feito pelo <acronym>BIOS</acronym> para endereçar "
"<literal>0x7c00</literal> então começa a execução. "

#. (itstool) path: sect1/title
#: book.translate.xml:474
msgid "The Master Boot Record (<literal>boot0</literal>)"
msgstr "O registro mestre de inicialização (<literal>boot0</literal>) "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:476
msgid "<primary>MBR</primary>"
msgstr " <primary>MBR</primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:478
msgid ""
"After control is received from the <acronym>BIOS</acronym> at memory address "
"<literal>0x7c00</literal>, <filename>boot0</filename> starts executing. It "
"is the first piece of code under FreeBSD control. The task of "
"<filename>boot0</filename> is quite simple: scan the partition table and let "
"the user choose which partition to boot from. The Partition Table is a "
"special, standard data structure embedded in the <acronym>MBR</acronym> "
"(hence embedded in <filename>boot0</filename>) describing the four standard "
"PC <quote>partitions</quote> <_:footnote-1/>. <filename>boot0</filename> "
"resides in the filesystem as <filename>/boot/boot0</filename>. It is a small "
"512-byte file, and it is exactly what FreeBSD's installation procedure wrote "
"to the hard disk's <acronym>MBR</acronym> if you chose the "
"<quote>bootmanager</quote> option at installation time. Indeed, "
"<filename>boot0</filename> <emphasis>is</emphasis> the <acronym>MBR</"
"acronym>."
msgstr ""
"Depois que o controle é recebido do <acronym>BIOS</acronym> no endereço de "
"memória <literal>0x7c00</literal>, <filename>boot0</filename> começa a "
"executar. É o primeiro pedaço de código sob controle do FreeBSD. A tarefa de "
"<filename>boot0</filename> é bastante simples: escaneie a tabela de "
"partições e deixe o usuário escolher de qual partição inicializar. A Tabela "
"de Partição é uma estrutura de dados padrão especial incorporada no "
"<acronym>MBR</acronym> (portanto, <filename>boot0</filename>) descrevendo o "
"quatro PC padrão <quote>partições</quote> <_:footnote-1/>. <filename>boot0</"
"filename> reside no sistema de arquivos como <filename>/boot/boot0</"
"filename> . É um pequeno arquivo de 512 bytes, e é exatamente o que o "
"procedimento de instalação do FreeBSD escreveu para o <acronym>MBR</acronym> "
"do disco rígido se você escolheu <quote> bootmanager </quote> opção no "
"momento da instalação. De fato, <filename>boot0</filename><emphasis> é </"
"emphasis> o <acronym>MBR</acronym>."

#. (itstool) path: sect1/para
#: book.translate.xml:498
msgid ""
"As mentioned previously, the <literal>INT 0x19</literal> instruction causes "
"the <literal>INT 0x19</literal> handler to load an <acronym>MBR</acronym> "
"(<filename>boot0</filename>) into memory at address <literal>0x7c00</"
"literal>. The source file for <filename>boot0</filename> can be found in "
"<filename>sys/boot/i386/boot0/boot0.S</filename> - which is an awesome piece "
"of code written by Robert Nordier."
msgstr ""
"Como mencionado anteriormente, o <literal>INT 0x19</literal> instrução faz "
"com que o <literal>INT 0x19</literal> manipulador para carregar um "
"<acronym>MBR</acronym> (<filename>boot0</filename>) na memória no endereço "
"<literal>0x7c00</literal> . O arquivo de origem para <filename>boot0</"
"filename> pode ser encontrado em <filename>sys/boot/i386/boot0/boot0.S</"
"filename> - que é um pedaço incrível de código escrito por Robert Nordier."

#. (itstool) path: sect1/para
#: book.translate.xml:506
msgid ""
"A special structure starting from offset <literal>0x1be</literal> in the "
"<acronym>MBR</acronym> is called the <emphasis>partition table</emphasis>. "
"It has four records of 16 bytes each, called <emphasis>partition records</"
"emphasis>, which represent how the hard disk is partitioned, or, in "
"FreeBSD's terminology, sliced. One byte of those 16 says whether a partition "
"(slice) is bootable or not. Exactly one record must have that flag set, "
"otherwise <filename>boot0</filename>'s code will refuse to proceed."
msgstr ""
"Uma estrutura especial a partir de offset <literal>0x1be</literal> no "
"<acronym>MBR</acronym> é chamado de <emphasis>tabela de partições</"
"emphasis>. Tem quatro registros de 16 bytes cada, chamados "
"<emphasis>registros de partições</emphasis>, que representam como o disco "
"rígido é particionado, ou, na terminologia do FreeBSD, fatiado. Um byte "
"desses 16 diz se uma partição (fatia) é inicializável ou não. Exatamente um "
"registro deve ter esse sinalizador definido, caso contrário <filename>boot0</"
"filename> O código da empresa se recusará a prosseguir. "

#. (itstool) path: sect1/para
#: book.translate.xml:516
msgid "A partition record has the following fields:"
msgstr "Um registro de partição possui os seguintes campos:"

#. (itstool) path: listitem/para
#: book.translate.xml:520
msgid "the 1-byte filesystem type"
msgstr "o tipo de sistema de arquivos de 1 byte "

#. (itstool) path: listitem/para
#: book.translate.xml:524
msgid "the 1-byte bootable flag"
msgstr "o sinalizador de inicialização de 1 byte"

#. (itstool) path: listitem/para
#: book.translate.xml:528
msgid "the 6 byte descriptor in CHS format"
msgstr "o descritor de 6 bytes no formato CHS "

#. (itstool) path: listitem/para
#: book.translate.xml:532
msgid "the 8 byte descriptor in LBA format"
msgstr "o descritor de 8 bytes no formato do LBA "

#. (itstool) path: sect1/para
#: book.translate.xml:536
msgid ""
"A partition record descriptor contains information about where exactly the "
"partition resides on the drive. Both descriptors, <acronym>LBA</acronym> and "
"<acronym>CHS</acronym>, describe the same information, but in different "
"ways: <acronym>LBA</acronym> (Logical Block Addressing) has the starting "
"sector for the partition and the partition's length, while <acronym>CHS</"
"acronym> (Cylinder Head Sector) has coordinates for the first and last "
"sectors of the partition. The partition table ends with the special "
"signature <literal>0xaa55</literal>."
msgstr ""
"Um descritor de registro de partição contém informações sobre onde "
"exatamente a partição reside na unidade. Ambos os descritores, <acronym>LBA</"
"acronym> e <acronym>CHS</acronym>, descrevem as mesmas informações, mas de "
"maneiras diferentes: <acronym>LBA</acronym> (Logical Block Addressing) tem o "
"setor inicial da partição e da partição. comprimento, enquanto <acronym>CHS</"
"acronym> (Cylinder Head Sector) tem coordenadas para o primeiro e último "
"setores da partição.A tabela de partição termina com a assinatura especial "
"<literal>0xaa55</literal>. "

#. (itstool) path: sect1/para
#: book.translate.xml:547
msgid ""
"The <acronym>MBR</acronym> must fit into 512 bytes, a single disk sector. "
"This program uses low-level <quote>tricks</quote> like taking advantage of "
"the side effects of certain instructions and reusing register values from "
"previous operations to make the most out of the fewest possible "
"instructions. Care must also be taken when handling the partition table, "
"which is embedded in the <acronym>MBR</acronym> itself. For these reasons, "
"be very careful when modifying <filename>boot0.S</filename>."
msgstr ""
"O <acronym>MBR</acronym> deve caber em 512 bytes, um único setor de disco. "
"Este programa usa baixo nível <quote>truques</quote> como aproveitar os "
"efeitos colaterais de certas instruções e reutilizar valores de registro de "
"operações anteriores para obter o máximo das instruções possíveis. Cuidado "
"também deve ser tomado ao manusear a tabela de partições, que está embutida "
"no próprio <acronym>MBR</acronym>. Por estas razões, tenha muito cuidado ao "
"modificar o <filename>boot0.S</filename>."

#. (itstool) path: sect1/para
#: book.translate.xml:557
msgid ""
"Note that the <filename>boot0.S</filename> source file is assembled "
"<quote>as is</quote>: instructions are translated one by one to binary, with "
"no additional information (no <acronym>ELF</acronym> file format, for "
"example). This kind of low-level control is achieved at link time through "
"special control flags passed to the linker. For example, the text section of "
"the program is set to be located at address <literal>0x600</literal>. In "
"practice this means that <filename>boot0</filename> must be loaded to memory "
"address <literal>0x600</literal> in order to function properly."
msgstr ""
"Note que o <filename>boot0.S</filename> arquivo de origem é montado "
"<quote>como é</quote> : instruções são traduzidas uma a uma para binário, "
"sem informações adicionais (sem formato de arquivo <acronym>ELF</acronym>, "
"por exemplo). Esse tipo de controle de baixo nível é obtido no momento do "
"link por meio de sinalizadores de controle especiais passados ​​para o "
"vinculador. Por exemplo, a seção de texto do programa está configurada para "
"estar localizada no enderço <literal>0x600</literal>. Na prática, isso "
"significa que <filename>boot0</filename> deve ser carregado no endereço de "
"memória <literal>0x600</literal> para funcionar corretamente. "

#. (itstool) path: sect1/para
#: book.translate.xml:568
msgid ""
"It is worth looking at the <filename>Makefile</filename> for "
"<filename>boot0</filename> (<filename>sys/boot/i386/boot0/Makefile</"
"filename>), as it defines some of the run-time behavior of <filename>boot0</"
"filename>. For instance, if a terminal connected to the serial port (COM1) "
"is used for I/O, the macro <literal>SIO</literal> must be defined (<literal>-"
"DSIO</literal>). <literal>-DPXE</literal> enables boot through <acronym>PXE</"
"acronym> by pressing <keycap>F6</keycap>. Additionally, the program defines "
"a set of <emphasis>flags</emphasis> that allow further modification of its "
"behavior. All of this is illustrated in the <filename>Makefile</filename>. "
"For example, look at the linker directives which command the linker to start "
"the text section at address <literal>0x600</literal>, and to build the "
"output file <quote>as is</quote> (strip out any file formatting):"
msgstr ""
"Vale a pena olhar para o <filename>Makefile</filename> para <filename>boot0</"
"filename> (<filename>sys/boot/i386/boot0/Makefile</filename>), uma vez que "
"define um pouco do comportamento em tempo de execução de <filename>boot0</"
"filename>. Por exemplo, se um terminal conectado à porta serial (COM1) for "
"usado para E/S, a macro <literal>SIO</literal> deve ser definido (<literal>-"
"DSIO</literal>). <literal>-DPXE</literal> permite inicializar através do "
"<acronym>PXE</acronym> pressionando <keycap> F6 </keycap>. Além disso, o "
"programa define um conjunto de <emphasis>bandeiras</emphasis> que permitem "
"modificações adicionais de seu comportamento. Tudo isso é ilustrado no "
"<filename>Makefile</filename>. Por exemplo, observe as diretivas do "
"vinculador que comandam o vinculador para iniciar a seção de texto no "
"endereço <literal>0x600</literal> e para construir o arquivo de saída "
"<quote>como é</quote> (tira qualquer formatação de arquivo): "

#. (itstool) path: figure/title
#: book.translate.xml:587
msgid "<filename>sys/boot/i386/boot0/Makefile</filename>"
msgstr " <filename>sys/boot/i386/boot0/Makefile</filename>"

#. (itstool) path: figure/programlisting
#: book.translate.xml:589
#, no-wrap
msgid ""
"      BOOT_BOOT0_ORG?=0x600\n"
"      LDFLAGS=-e start -Ttext ${BOOT_BOOT0_ORG} \\\n"
"      -Wl,-N,-S,--oformat,binary"
msgstr ""
"      BOOT_BOOT0_ORG?=0x600\n"
"      LDFLAGS=-e start -Ttext ${BOOT_BOOT0_ORG} \\\n"
"      -Wl,-N,-S,--oformat,binary"

#. (itstool) path: sect1/para
#: book.translate.xml:594
msgid ""
"Let us now start our study of the <acronym>MBR</acronym>, or "
"<filename>boot0</filename>, starting where execution begins."
msgstr ""
"Vamos começar agora nosso estudo do <acronym>MBR</acronym>, ou "
"<filename>boot0</filename>, começando onde a execução começa. "

#. (itstool) path: note/para
#: book.translate.xml:599
msgid ""
"Some modifications have been made to some instructions in favor of better "
"exposition. For example, some macros are expanded, and some macro tests are "
"omitted when the result of the test is known. This applies to all of the "
"code examples shown."
msgstr ""
"Algumas modificações foram feitas em algumas instruções em favor de uma "
"melhor exposição. Por exemplo, algumas macros são expandidas e alguns testes "
"de macro são omitidos quando o resultado do teste é conhecido. Isso se "
"aplica a todos os exemplos de código mostrados."

#. (itstool) path: figure/title
#: book.translate.xml:607 book.translate.xml:635 book.translate.xml:702
#: book.translate.xml:732 book.translate.xml:760 book.translate.xml:804
#: book.translate.xml:823 book.translate.xml:841 book.translate.xml:911
msgid "<filename>sys/boot/i386/boot0/boot0.S</filename>"
msgstr " <filename>sys/boot/i386/boot0/boot0.S</filename> "

#. (itstool) path: figure/programlisting
#: book.translate.xml:609
#, no-wrap
msgid ""
"start:\n"
"      cld\t\t\t# String ops inc\n"
"      xorw %ax,%ax\t\t# Zero\n"
"      movw %ax,%es\t\t# Address\n"
"      movw %ax,%ds\t\t#  data\n"
"      movw %ax,%ss\t\t# Set up\n"
"      movw 0x7c00,%sp\t\t#  stack"
msgstr ""
"start:\n"
"      cld\t\t\t# String ops inc\n"
"      xorw %ax,%ax\t\t# Zero\n"
"      movw %ax,%es\t\t# Address\n"
"      movw %ax,%ds\t\t#  data\n"
"      movw %ax,%ss\t\t# Set up\n"
"      movw 0x7c00,%sp\t\t#  stack"

#. (itstool) path: footnote/para
#: book.translate.xml:623
msgid ""
"When in doubt, we refer the reader to the official Intel manuals, which "
"describe the exact semantics for each instruction: <link xlink:href=\"http://"
"www.intel.com/content/www/us/en/processors/architectures-software-developer-"
"manuals.html\"/>."
msgstr ""
"Em caso de dúvida, encaminhamos o leitor para os manuais oficiais da Intel, "
"que descrevem a semântica exata de cada instrução: <link xlink:href=\"http://"
"www.intel.com/content/www/us/en/processors/architectures-software-developer-"
"manuals.html\"/>."

#. (itstool) path: sect1/para
#: book.translate.xml:618
msgid ""
"This first block of code is the entry point of the program. It is where the "
"<acronym>BIOS</acronym> transfers control. First, it makes sure that the "
"string operations autoincrement its pointer operands (the <literal>cld</"
"literal> instruction) <_:footnote-1/>. Then, as it makes no assumption about "
"the state of the segment registers, it initializes them. Finally, it sets "
"the stack pointer register (<literal>%sp</literal>) to address "
"<literal>0x7c00</literal>, so we have a working stack."
msgstr ""
"Este primeiro bloco de código é o ponto de entrada do programa. É onde o "
"<acronym>BIOS</acronym> transfere o controle. Primeiro, ele garante que as "
"operações de string autoincrementem seus operandos de ponteiro (o "
"<literal>cld</literal> instrução) <_:footnote-1/>. Então, como não faz "
"nenhuma suposição sobre o estado dos registradores de segmento, ele os "
"inicializa. Finalmente, define o registrador de ponteiro da pilha (<literal>"
"%sp</literal>) endereçar <literal>0x7c00</literal> , então temos uma pilha "
"de trabalho."

#. (itstool) path: sect1/para
#: book.translate.xml:631
msgid ""
"The next block is responsible for the relocation and subsequent jump to the "
"relocated code."
msgstr ""
"O próximo bloco é responsável pela realocação e posterior salto para o "
"código realocado."

#. (itstool) path: figure/programlisting
#: book.translate.xml:637
#, no-wrap
msgid ""
"      movw $0x7c00,%si\t# Source\n"
"      movw $0x600,%di\t\t# Destination\n"
"      movw $512,%cx\t\t# Word count\n"
"      rep\t\t\t# Relocate\n"
"      movsb\t\t\t#  code\n"
"      movw %di,%bp\t\t# Address variables\n"
"      movb $16,%cl\t\t# Words to clear\n"
"      rep\t\t\t# Zero\n"
"      stosb\t\t\t#  them\n"
"      incb -0xe(%di)\t\t# Set the S field to 1\n"
"      jmp main-0x7c00+0x600\t# Jump to relocated code"
msgstr ""
"      movw $0x7c00,%si\t# Source\n"
"      movw $0x600,%di\t\t# Destination\n"
"      movw $512,%cx\t\t# Word count\n"
"      rep\t\t\t# Relocate\n"
"      movsb\t\t\t#  code\n"
"      movw %di,%bp\t\t# Address variables\n"
"      movb $16,%cl\t\t# Words to clear\n"
"      rep\t\t\t# Zero\n"
"      stosb\t\t\t#  them\n"
"      incb -0xe(%di)\t\t# Set the S field to 1\n"
"      jmp main-0x7c00+0x600\t# Jump to relocated code"

#. (itstool) path: sect1/para
#: book.translate.xml:650
msgid ""
"Because <filename>boot0</filename> is loaded by the <acronym>BIOS</acronym> "
"to address <literal>0x7C00</literal>, it copies itself to address "
"<literal>0x600</literal> and then transfers control there (recall that it "
"was linked to execute at address <literal>0x600</literal>). The source "
"address, <literal>0x7c00</literal>, is copied to register <literal>%si</"
"literal>. The destination address, <literal>0x600</literal>, to register "
"<literal>%di</literal>. The number of bytes to copy, <literal>512</literal> "
"(the program's size), is copied to register <literal>%cx</literal>. Next, "
"the <literal>rep</literal> instruction repeats the instruction that follows, "
"that is, <literal>movsb</literal>, the number of times dictated by the "
"<literal>%cx</literal> register. The <literal>movsb</literal> instruction "
"copies the byte pointed to by <literal>%si</literal> to the address pointed "
"to by <literal>%di</literal>. This is repeated another 511 times. On each "
"repetition, both the source and destination registers, <literal>%si</"
"literal> and <literal>%di</literal>, are incremented by one. Thus, upon "
"completion of the 512-byte copy, <literal>%di</literal> has the value "
"<literal>0x600</literal>+<literal>512</literal>= <literal>0x800</literal>, "
"and <literal>%si</literal> has the value <literal>0x7c00</literal>"
"+<literal>512</literal>= <literal>0x7e00</literal>; we have thus completed "
"the code <emphasis>relocation</emphasis>."
msgstr ""
"Porque <filename>boot0</filename> é carregado pelo <acronym>BIOS</acronym> "
"para endereçar <literal>0x7C00</literal>, copia-se para endereçar "
"<literal>0x600</literal> e depois transfere o controle para lá (lembre-se de "
"que estava ligado para executar no endereço <literal>0x600</literal>. O "
"endereço de origem, <literal>0x7c00</literal>, é copiado para se registrar "
"<literal>%si</literal>. O endereço de destino, <literal>0x600</literal>, "
"registrar <literal>%di</literal>. O número de bytes para copiar, "
"<literal>512</literal> (tamanho do programa), é copiado para registrar "
"<literal>%cx</literal>. Em seguida, a instrução <literal>rep</literal> "
"repete a instrução que se segue, isto é, <literal>movsb</literal>, o número "
"de vezes ditado pelo registrador <literal>%cx</literal>. A instrução "
"<literal>movsb</literal> copia o byte apontado por <literal>%si</literal> "
"para o endereço apontado por <literal>%di</literal>. Isso é repetido mais "
"511 vezes. Em cada repetição, os registros de origem e destino, <literal>"
"%si</literal> e <literal>%di</literal>, são incrementados por um. Assim, "
"após a conclusão da cópia de 512 bytes, <literal>%di</literal> tem o valor "
"<literal>0x600</literal> + <literal>512</literal> = <literal>0x800</literal> "
"e <literal>%si</literal> tem o valor <literal>0x7c00</literal> + "
"<literal>512</literal> = <literal>0x7e00</literal>; assim, completamos o "
"código de <emphasis>relocação</emphasis>."

#. (itstool) path: sect1/para
#: book.translate.xml:676
msgid ""
"Next, the destination register <literal>%di</literal> is copied to <literal>"
"%bp</literal>. <literal>%bp</literal> gets the value <literal>0x800</"
"literal>. The value <literal>16</literal> is copied to <literal>%cl</"
"literal> in preparation for a new string operation (like our previous "
"<literal>movsb</literal>). Now, <literal>stosb</literal> is executed 16 "
"times. This instruction copies a <literal>0</literal> value to the address "
"pointed to by the destination register (<literal>%di</literal>, which is "
"<literal>0x800</literal>), and increments it. This is repeated another 15 "
"times, so <literal>%di</literal> ends up with value <literal>0x810</"
"literal>. Effectively, this clears the address range <literal>0x800</"
"literal>-<literal>0x80f</literal>. This range is used as a (fake) partition "
"table for writing the <acronym>MBR</acronym> back to disk. Finally, the "
"sector field for the <acronym>CHS</acronym> addressing of this fake "
"partition is given the value 1 and a jump is made to the main function from "
"the relocated code. Note that until this jump to the relocated code, any "
"reference to an absolute address was avoided."
msgstr ""
"Em seguida, o registro de destino <literal>%di</literal> é copiado para "
"<literal>%bp</literal>. <literal>%bp</literal> Obtém o valor <literal>0x800</"
"literal>. O valor que <literal>16</literal> é copiado para <literal>%cl</"
"literal> em preparação para uma nova operação de string (como a nossa "
"anterior <literal>movsb</literal>). Agora, <literal>stosb</literal> é "
"executado 16 vezes. Esta instrução copia um valor <literal>0</literal> para "
"o endereço indicado pelo registo de destino (<literal>%di</literal>, que é "
"<literal>0x800</literal>) e incrementa-o. Isso é repetido mais 15 vezes, "
"então <literal>%di</literal> acaba com valor <literal>0x810</literal>. "
"Efetivamente, isso limpa o intervalo de endereços <literal>0x800</literal> - "
"<literal>0x80f</literal>. Esse intervalo é usado como uma tabela de "
"partições (falsa) para gravar o <acronym>MBR de</acronym> volta no disco. "
"Finalmente, o campo setorial para o endereçamento <acronym>CHS</acronym> "
"desta partição falsa recebe o valor 1 e um salto é feito para a função "
"principal a partir do código realocado. Note que até este salto para o "
"código realocado, qualquer referência a um endereço absoluto foi evitada. "

#. (itstool) path: sect1/para
#: book.translate.xml:697
msgid ""
"The following code block tests whether the drive number provided by the "
"<acronym>BIOS</acronym> should be used, or the one stored in "
"<filename>boot0</filename>."
msgstr ""
"O bloco de código a seguir testa se o número da unidade fornecido pelo "
"<acronym>BIOS</acronym> deve ser usado ou aquele armazenado <filename>boot0</"
"filename>."

#. (itstool) path: figure/programlisting
#: book.translate.xml:704
#, no-wrap
msgid ""
"main:\n"
"      testb $SETDRV,-69(%bp)\t# Set drive number?\n"
"      jnz disable_update\t# Yes\n"
"      testb %dl,%dl\t\t# Drive number valid?\n"
"      js save_curdrive\t\t# Possibly (0x80 set)"
msgstr ""
"main:\n"
"      testb $SETDRV,-69(%bp)\t# Set drive number?\n"
"      jnz disable_update\t# Yes\n"
"      testb %dl,%dl\t\t# Drive number valid?\n"
"      js save_curdrive\t\t# Possibly (0x80 set)"

#. (itstool) path: sect1/para
#: book.translate.xml:711
msgid ""
"This code tests the <literal>SETDRV</literal> bit (<literal>0x20</literal>) "
"in the <emphasis>flags</emphasis> variable. Recall that register <literal>"
"%bp</literal> points to address location <literal>0x800</literal>, so the "
"test is done to the <emphasis>flags</emphasis> variable at address "
"<literal>0x800</literal>-<literal>69</literal>= <literal>0x7bb</literal>. "
"This is an example of the type of modifications that can be done to "
"<filename>boot0</filename>. The <literal>SETDRV</literal> flag is not set by "
"default, but it can be set in the <filename>Makefile</filename>. When set, "
"the drive number stored in the <acronym>MBR</acronym> is used instead of the "
"one provided by the <acronym>BIOS</acronym>. We assume the defaults, and "
"that the <acronym>BIOS</acronym> provided a valid drive number, so we jump "
"to <literal>save_curdrive</literal>."
msgstr ""
"Este código testa o bit (<literal>0x20</literal>) de <literal>SETDRV</"
"literal> na varíavel <emphasis>flags</emphasis>. Lembre-se de que o "
"registrador <literal>%bp</literal> aponta para endereço local "
"<literal>0x800</literal>, então o teste é feito para a vairável "
"<emphasis>flags</emphasis> no endereço <literal>0x800</literal>-<literal>69</"
"literal>=<literal>0x7bb</literal>. Este é um exemplo do tipo de modificações "
"que podem ser feitas para <filename>boot0</filename>. O flag de "
"<literal>SETDRV</literal> não é definido por padrão, mas pode ser definido "
"no <filename>Makefile</filename>. Quando definido, o número da unidade "
"armazenado no <acronym>MBR</acronym> é usado em vez daquele fornecido pelo "
"<acronym>BIOS</acronym>. Nós assumimos os padrões, e que a <acronym>BIOS</"
"acronym> forneceu um número de drive válido, então pulamos para "
"<literal>save_curdrive</literal>."

#. (itstool) path: sect1/para
#: book.translate.xml:727
msgid ""
"The next block saves the drive number provided by the <acronym>BIOS</"
"acronym>, and calls <literal>putn</literal> to print a new line on the "
"screen."
msgstr ""
"O próximo bloco salva o número da unidade fornecido pelo <acronym>BIOS</"
"acronym> e as chamadas <literal>putn</literal> para imprimir uma nova linha "
"na tela."

#. (itstool) path: figure/programlisting
#: book.translate.xml:734
#, no-wrap
msgid ""
"save_curdrive:\n"
"      movb %dl, (%bp)\t\t# Save drive number\n"
"      pushw %dx\t\t\t# Also in the stack\n"
"#ifdef\tTEST\t/* test code, print internal bios drive */\n"
"      rolb $1, %dl\n"
"      movw $drive, %si\n"
"      call putkey\n"
"#endif\n"
"      callw putn\t\t# Print a newline"
msgstr ""
"save_curdrive:\n"
"      movb %dl, (%bp)\t\t# Save drive number\n"
"      pushw %dx\t\t\t# Also in the stack\n"
"#ifdef\tTEST\t/* test code, print internal bios drive */\n"
"      rolb $1, %dl\n"
"      movw $drive, %si\n"
"      call putkey\n"
"#endif\n"
"      callw putn\t\t# Print a newline"

#. (itstool) path: sect1/para
#: book.translate.xml:745
msgid ""
"Note that we assume <varname>TEST</varname> is not defined, so the "
"conditional code in it is not assembled and will not appear in our "
"executable <filename>boot0</filename>."
msgstr ""
"Note que assumimos <varname>TESTE</varname> como não definida, então o "
"código condicional nele não é montado e não aparecerá em nosso executável de "
"<filename>boot0</filename>."

#. (itstool) path: sect1/para
#: book.translate.xml:749
msgid ""
"Our next block implements the actual scanning of the partition table. It "
"prints to the screen the partition type for each of the four entries in the "
"partition table. It compares each type with a list of well-known operating "
"system file systems. Examples of recognized partition types are "
"<acronym>NTFS</acronym> (<trademark class=\"registered\">Windows</"
"trademark>, ID 0x7), <literal>ext2fs</literal> (<trademark class=\"registered"
"\">Linux</trademark>, ID 0x83), and, of course, <literal>ffs</literal>/"
"<literal>ufs2</literal> (FreeBSD, ID 0xa5). The implementation is fairly "
"simple."
msgstr ""
"Nosso próximo bloco implementa a varredura real da tabela de partições. Ela "
"imprime na tela o tipo de partição para cada uma das quatro entradas na "
"tabela de partições. Ele compara cada tipo com uma lista de sistemas de "
"arquivos conhecidos do sistema operacional. Exemplos de tipos de partição "
"reconhecidos são <acronym>NTFS</acronym> (<trademark class=\"registered"
"\">Windows</trademark> , ID 0x7), <literal>ext2fs</literal> (<trademark "
"class=\"registered\">Linux</trademark> , ID 0x83) e, claro, <literal>ffs</"
"literal>/<literal>ufs2</literal> (FreeBSD, ID 0xa5). A implementação é "
"bastante simples."

#. (itstool) path: figure/programlisting
#: book.translate.xml:762
#, no-wrap
msgid ""
"      movw $(partbl+0x4),%bx\t# Partition table (+4)\n"
"      xorw %dx,%dx\t\t# Item number\n"
"\n"
"read_entry:\n"
"      movb %ch,-0x4(%bx)\t# Zero active flag (ch == 0)\n"
"      btw %dx,_FLAGS(%bp)\t# Entry enabled?\n"
"      jnc next_entry\t\t# No\n"
"      movb (%bx),%al\t\t# Load type\n"
"      test %al, %al\t\t# skip empty partition\n"
"      jz next_entry\n"
"      movw $bootable_ids,%di\t# Lookup tables\n"
"      movb $(TLEN+1),%cl\t# Number of entries\n"
"      repne\t\t\t# Locate\n"
"      scasb\t\t\t#  type\n"
"      addw $(TLEN-1), %di\t# Adjust\n"
"      movb (%di),%cl\t\t# Partition\n"
"      addw %cx,%di\t\t#  description\n"
"      callw putx\t\t# Display it\n"
"\n"
"next_entry:\n"
"      incw %dx\t\t\t# Next item\n"
"      addb $0x10,%bl\t\t# Next entry\n"
"      jnc read_entry\t\t# Till done"
msgstr ""
"      movw $(partbl+0x4),%bx\t# Partition table (+4)\n"
"      xorw %dx,%dx\t\t# Item number\n"
"\n"
"read_entry:\n"
"      movb %ch,-0x4(%bx)\t# Zero active flag (ch == 0)\n"
"      btw %dx,_FLAGS(%bp)\t# Entry enabled?\n"
"      jnc next_entry\t\t# No\n"
"      movb (%bx),%al\t\t# Load type\n"
"      test %al, %al\t\t# skip empty partition\n"
"      jz next_entry\n"
"      movw $bootable_ids,%di\t# Lookup tables\n"
"      movb $(TLEN+1),%cl\t# Number of entries\n"
"      repne\t\t\t# Locate\n"
"      scasb\t\t\t#  type\n"
"      addw $(TLEN-1), %di\t# Adjust\n"
"      movb (%di),%cl\t\t# Partition\n"
"      addw %cx,%di\t\t#  description\n"
"      callw putx\t\t# Display it\n"
"\n"
"next_entry:\n"
"      incw %dx\t\t\t# Next item\n"
"      addb $0x10,%bl\t\t# Next entry\n"
"      jnc read_entry\t\t# Till done"

#. (itstool) path: sect1/para
#: book.translate.xml:787
msgid ""
"It is important to note that the active flag for each entry is cleared, so "
"after the scanning, <emphasis>no</emphasis> partition entry is active in our "
"memory copy of <filename>boot0</filename>. Later, the active flag will be "
"set for the selected partition. This ensures that only one active partition "
"exists if the user chooses to write the changes back to disk."
msgstr ""
"É importante observar que a flag ativa de cada entrada é apagada, portanto, "
"após a varredura, <emphasis>nenhuma</emphasis> entrada de partição está "
"ativa em nossa cópia da memória de <filename>boot0</filename>. Mais tarde, a "
"flag ativa será definida para a partição selecionada. Isso garante que "
"apenas uma partição ativa existiré se o usuário optar por gravar as "
"alterações novamente no disco. "

#. (itstool) path: sect1/para
#: book.translate.xml:795
msgid ""
"The next block tests for other drives. At startup, the <acronym>BIOS</"
"acronym> writes the number of drives present in the computer to address "
"<literal>0x475</literal>. If there are any other drives present, "
"<filename>boot0</filename> prints the current drive to screen. The user may "
"command <filename>boot0</filename> to scan partitions on another drive later."
msgstr ""
"O próximo bloco testa as outras unidades. Na inicialização, a <acronym>BIOS</"
"acronym> grava o número de unidades presentes no computador para o endereço "
"<literal>0x475</literal> . Se houver outras unidades presentes, "
"<filename>boot0</filename> imprime a unidade atual na tela. O usuário pode "
"comandar <filename>boot0</filename> para varrer partições em outra unidade "
"depois. "

#. (itstool) path: figure/programlisting
#: book.translate.xml:806
#, no-wrap
msgid ""
"      popw %ax\t\t\t# Drive number\n"
"      subb $0x79,%al\t\t# Does next\n"
"      cmpb 0x475,%al\t\t#  drive exist? (from BIOS?)\n"
"      jb print_drive\t\t# Yes\n"
"      decw %ax\t\t\t# Already drive 0?\n"
"      jz print_prompt\t\t# Yes"
msgstr ""
"      popw %ax\t\t\t# Drive number\n"
"      subb $0x79,%al\t\t# Does next\n"
"      cmpb 0x475,%al\t\t#  drive exist? (from BIOS?)\n"
"      jb print_drive\t\t# Yes\n"
"      decw %ax\t\t\t# Already drive 0?\n"
"      jz print_prompt\t\t# Yes"

#. (itstool) path: sect1/para
#: book.translate.xml:814
msgid ""
"We make the assumption that a single drive is present, so the jump to "
"<literal>print_drive</literal> is not performed. We also assume nothing "
"strange happened, so we jump to <literal>print_prompt</literal>."
msgstr ""
"Supomos que uma única unidade está presente, então o salto para "
"<literal>print_drive</literal> não é executado. Nós também assumimos que "
"nada de estranho aconteceu, então nós pulamos para <literal>print_prompt</"
"literal>. "

#. (itstool) path: sect1/para
#: book.translate.xml:819
msgid ""
"This next block just prints out a prompt followed by the default option:"
msgstr "Este próximo bloco apenas imprime um prompt seguido pela opção padrão:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:825
#, no-wrap
msgid ""
"print_prompt:\n"
"      movw $prompt,%si\t\t# Display\n"
"      callw putstr\t\t#  prompt\n"
"      movb _OPT(%bp),%dl\t# Display\n"
"      decw %si\t\t\t#  default\n"
"      callw putkey\t\t#  key\n"
"      jmp start_input\t\t# Skip beep"
msgstr ""
"print_prompt:\n"
"      movw $prompt,%si\t\t# Display\n"
"      callw putstr\t\t#  prompt\n"
"      movb _OPT(%bp),%dl\t# Display\n"
"      decw %si\t\t\t#  default\n"
"      callw putkey\t\t#  key\n"
"      jmp start_input\t\t# Skip beep"

#. (itstool) path: sect1/para
#: book.translate.xml:834
msgid ""
"Finally, a jump is performed to <literal>start_input</literal>, where the "
"<acronym>BIOS</acronym> services are used to start a timer and for reading "
"user input from the keyboard; if the timer expires, the default option will "
"be selected:"
msgstr ""
"Finalmente, um salto é realizado para <literal>start_input</literal> , onde "
"os serviços da <acronym>BIOS</acronym> são usados ​​para iniciar um timer e "
"para ler a entrada do usuário a partir do teclado; se o temporizador "
"expirar, a opção padrão será selecionada: "

#. (itstool) path: figure/programlisting
#: book.translate.xml:843
#, no-wrap
msgid ""
"start_input:\n"
"      xorb %ah,%ah\t\t# BIOS: Get\n"
"      int $0x1a\t\t\t#  system time\n"
"      movw %dx,%di\t\t# Ticks when\n"
"      addw _TICKS(%bp),%di\t#  timeout\n"
"read_key:\n"
"      movb $0x1,%ah\t\t# BIOS: Check\n"
"      int $0x16\t\t\t#  for keypress\n"
"      jnz got_key\t\t# Have input\n"
"      xorb %ah,%ah\t\t# BIOS: int 0x1a, 00\n"
"      int $0x1a\t\t\t#  get system time\n"
"      cmpw %di,%dx\t\t# Timeout?\n"
"      jb read_key\t\t# No"
msgstr ""
"start_input:\n"
"      xorb %ah,%ah\t\t# BIOS: Get\n"
"      int $0x1a\t\t\t#  system time\n"
"      movw %dx,%di\t\t# Ticks when\n"
"      addw _TICKS(%bp),%di\t#  timeout\n"
"read_key:\n"
"      movb $0x1,%ah\t\t# BIOS: Check\n"
"      int $0x16\t\t\t#  for keypress\n"
"      jnz got_key\t\t# Have input\n"
"      xorb %ah,%ah\t\t# BIOS: int 0x1a, 00\n"
"      int $0x1a\t\t\t#  get system time\n"
"      cmpw %di,%dx\t\t# Timeout?\n"
"      jb read_key\t\t# No"

#. (itstool) path: sect1/para
#: book.translate.xml:858
#, fuzzy
#| msgid ""
#| "An interrupt is requested with number <literal>0x1a</literal> and "
#| "argument <literal>0</literal> in register <literal>%ah</literal>. The "
#| "<acronym>BIOS</acronym> has a predefined set of services, requested by "
#| "applications as software-generated interrupts through the <literal>int</"
#| "literal> instruction and receiving arguments in registers (in this case, "
#| "<literal>%ah</literal>). Here, particularly, we are requesting the number "
#| "of clock ticks since last midnight; this value is computed by the "
#| "<acronym>BIOS</acronym> through the <acronym>RTC</acronym> (Real Time "
#| "Clock). This clock can be programmed to work at frequencies ranging from "
#| "2 Hz to 8192 Hz. The <acronym>BIOS</acronym> sets it to 18.2 Hz at "
#| "startup. When the request is satisfied, a 32-bit result is returned by "
#| "the <acronym>BIOS</acronym> in registers <literal>%cx</literal> and "
#| "<literal>%dx</literal> (lower bytes in <literal>%dx</literal>). This "
#| "result (the <literal>%dx</literal> part) is copied to register <literal>"
#| "%di</literal>, and the value of the <varname>TICKS</varname> variable is "
#| "added to <literal>%di</literal>. This variable resides in "
#| "<filename>boot0</filename> at offset <literal>_TICKS</literal> (a "
#| "negative value) from register <literal>%bp</literal> (which, recall, "
#| "points to <literal>0x800</literal>). The default value of this variable "
#| "is <literal>0xb6</literal> (182 in decimal). Now, the idea is that "
#| "<filename>boot0</filename> constantly requests the time from the "
#| "<acronym>BIOS</acronym>, and when the value returned in register <literal>"
#| "%dx</literal> is greater than the value stored in <literal>%di</literal>, "
#| "the time is up and the default selection will be made. Since the RTC "
#| "ticks 18.2 times per second, this condition will be met after 10 seconds "
#| "(this default behavior can be changed in the <filename>Makefile</"
#| "filename>). Until this time has passed, <filename>boot0</filename> "
#| "continually asks the <acronym>BIOS</acronym> for any user input; this is "
#| "done through <literal>int 0x16</literal>, argument <literal>1</literal> "
#| "in <literal>%ah</literal>."
msgid ""
"An interrupt is requested with number <literal>0x1a</literal> and argument "
"<literal>0</literal> in register <literal>%ah</literal>. The <acronym>BIOS</"
"acronym> has a predefined set of services, requested by applications as "
"software-generated interrupts through the <literal>int</literal> instruction "
"and receiving arguments in registers (in this case, <literal>%ah</literal>). "
"Here, particularly, we are requesting the number of clock ticks since last "
"midnight; this value is computed by the <acronym>BIOS</acronym> through the "
"<acronym>RTC</acronym> (Real Time Clock). This clock can be programmed to "
"work at frequencies ranging from 2 Hz to 8192 Hz. The <acronym>BIOS</"
"acronym> sets it to 18.2 Hz at startup. When the request is satisfied, a 32-"
"bit result is returned by the <acronym>BIOS</acronym> in registers <literal>"
"%cx</literal> and <literal>%dx</literal> (lower bytes in <literal>%dx</"
"literal>). This result (the <literal>%dx</literal> part) is copied to "
"register <literal>%di</literal>, and the value of the <varname>TICKS</"
"varname> variable is added to <literal>%di</literal>. This variable resides "
"in <filename>boot0</filename> at offset <literal>_TICKS</literal> (a "
"negative value) from register <literal>%bp</literal> (which, recall, points "
"to <literal>0x800</literal>). The default value of this variable is "
"<literal>0xb6</literal> (182 in decimal). Now, the idea is that "
"<filename>boot0</filename> constantly requests the time from the "
"<acronym>BIOS</acronym>, and when the value returned in register <literal>"
"%dx</literal> is greater than the value stored in <literal>%di</literal>, "
"the time is up and the default selection will be made. Since the RTC ticks "
"18.2 times per second, this condition will be met after 10 seconds (this "
"default behavior can be changed in the <filename>Makefile</filename>). Until "
"this time has passed, <filename>boot0</filename> continually asks the "
"<acronym>BIOS</acronym> for any user input; this is done through "
"<literal>int 0x16</literal>, argument <literal>1</literal> in <literal>%ah</"
"literal>."
msgstr ""
"Uma interrupção é solicitada com o número <literal>0x1a</literal> e "
"argumento <literal> </literal> no registrador <literal>%ah</literal>. A "
"<acronym>BIOS</acronym> possui um conjunto predefinido de serviços, "
"solicitados pelos aplicativos como interrupções geradas por software através "
"de uma instrução <literal>int</literal> e receber argumentos nos "
"registradores (neste caso, <literal>%ah</literal>). Aqui, particularmente, "
"estamos solicitando o número de pulsos de clock desde a última meia-noite; "
"esse valor é computado pela <acronym>BIOS</acronym> por meio do "
"<acronym>RTC</acronym> (Real Time Clock). Este clock pode ser programado "
"para funcionar em frequências que variam de 2 Hz a 8192 Hz. A <acronym>BIOS</"
"acronym> define isso a 18,2 Hz na inicialização. Quando a solicitação é "
"satisfeita, um resultado de 32 bits é retornado pela <acronym>BIOS</acronym> "
"em registradores <literal>%cx</literal> e <literal>%dx</literal> (bytes "
"inferiores em <literal>%dx</literal> ). Este resultado (a parte <literal>"
"%dx</literal>) é copiado para registrador <literal>%di</literal> e o valor "
"das variáveis <varname>TICKS</varname>  � adicionado ao <literal>%di</"
"literal> . Esta variável reside em <filename>boot0</filename> no "
"deslocamento <literal>_TICKS</literal> (um valor negativo) do registrador "
"<literal>%pb</literal> (que, lembre-se, aponta para <literal>0x800</"
"literal> ). O valor padrão desta variável é <literal>0xb6</literal> (182 em "
"decimal). Agora, a ideia é que <filename>boot0</filename> constantemente "
"solicita o tempo da <acronym>BIOS</acronym>, e quando o valor retornado no "
"registro <literal>%dx</literal> é maior que o valor armazenado em <literal>"
"%di</literal>, o tempo acabou e a seleção padrão será feita. Como o RTC é de "
"18,2 vezes por segundo, essa condição será atendida após 10 segundos (esse "
"comportamento padrão pode ser alterado no <filename>Makefile</filename> ). "
"Até que esse tempo tenha passado <filename>boot0</filename> continuamente "
"pede à <acronym>BIOS</acronym> por qualquer entrada do usuário; isso é feito "
"através <literal>int 0x16</literal> argumento <literal>1</literal> em "
"<literal>%ah</literal>."

#. (itstool) path: sect1/para
#: book.translate.xml:895
msgid ""
"Whether a key was pressed or the time expired, subsequent code validates the "
"selection. Based on the selection, the register <literal>%si</literal> is "
"set to point to the appropriate partition entry in the partition table. This "
"new selection overrides the previous default one. Indeed, it becomes the new "
"default. Finally, the ACTIVE flag of the selected partition is set. If it "
"was enabled at compile time, the in-memory version of <filename>boot0</"
"filename> with these modified values is written back to the <acronym>MBR</"
"acronym> on disk. We leave the details of this implementation to the reader."
msgstr ""
"Se uma tecla foi pressionada ou o tempo expirou, o código subsequente valida "
"a seleção. Com base na seleção, o registro <literal>%si</literal> é definido "
"para apontar para a entrada de partição apropriada na tabela de partições. "
"Essa nova seleção substitui a padrão anterior. De fato, ele se torna a novo "
"padrão. Por fim, a flag ACTIVE da partição selecionada é definida. Se foi "
"habilitada enquanto compilava, a versão em memória do <filename>boot0</"
"filename> com esses valores modificados é gravada de volta na <acronym>MBR</"
"acronym> no disco. Deixamos os detalhes desta implementação para o leitor."

#. (itstool) path: sect1/para
#: book.translate.xml:907
msgid ""
"We now end our study with the last code block from the <filename>boot0</"
"filename> program:"
msgstr ""
"Agora terminamos nosso estudo com o último bloco de código do programa "
"<filename>boot0</filename>:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:913
#, no-wrap
msgid ""
"      movw $0x7c00,%bx\t\t# Address for read\n"
"      movb $0x2,%ah\t\t# Read sector\n"
"      callw intx13\t\t#  from disk\n"
"      jc beep\t\t\t# If error\n"
"      cmpw $0xaa55,0x1fe(%bx)\t# Bootable?\n"
"      jne beep\t\t\t# No\n"
"      pushw %si\t\t\t# Save ptr to selected part.\n"
"      callw putn\t\t# Leave some space\n"
"      popw %si\t\t\t# Restore, next stage uses it\n"
"      jmp *%bx\t\t\t# Invoke bootstrap"
msgstr ""
"      movw $0x7c00,%bx\t\t# Address for read\n"
"      movb $0x2,%ah\t\t# Read sector\n"
"      callw intx13\t\t#  from disk\n"
"      jc beep\t\t\t# If error\n"
"      cmpw $0xaa55,0x1fe(%bx)\t# Bootable?\n"
"      jne beep\t\t\t# No\n"
"      pushw %si\t\t\t# Save ptr to selected part.\n"
"      callw putn\t\t# Leave some space\n"
"      popw %si\t\t\t# Restore, next stage uses it\n"
"      jmp *%bx\t\t\t# Invoke bootstrap"

#. (itstool) path: sect1/para
#: book.translate.xml:925
msgid ""
"Recall that <literal>%si</literal> points to the selected partition entry. "
"This entry tells us where the partition begins on disk. We assume, of "
"course, that the partition selected is actually a FreeBSD slice."
msgstr ""
"Lembre-se que <literal>%si</literal> aponta para a entrada da partição "
"selecionada. Esta entrada nos diz onde a partição começa no disco. Nós "
"assumimos, é claro, que a partição selecionada é na verdade uma fatia do "
"FreeBSD. "

#. (itstool) path: note/para
#: book.translate.xml:931
msgid ""
"From now on, we will favor the use of the technically more accurate term "
"<quote>slice</quote> rather than <quote>partition</quote>."
msgstr ""
"A partir de agora, favoreceremos o uso do termo tecnicamente mais preciso "
"<quote>slice</quote> ao invés de <quote>partição</quote>."

#. (itstool) path: sect1/para
#: book.translate.xml:936
msgid ""
"The transfer buffer is set to <literal>0x7c00</literal> (register <literal>"
"%bx</literal>), and a read for the first sector of the FreeBSD slice is "
"requested by calling <literal>intx13</literal>. We assume that everything "
"went okay, so a jump to <literal>beep</literal> is not performed. In "
"particular, the new sector read must end with the magic sequence "
"<literal>0xaa55</literal>. Finally, the value at <literal>%si</literal> (the "
"pointer to the selected partition table) is preserved for use by the next "
"stage, and a jump is performed to address <literal>0x7c00</literal>, where "
"execution of our next stage (the just-read block) is started."
msgstr ""
"O buffer de transferência está definido para <literal>0x7c00</literal> "
"(registrador <literal>%bx</literal> ), e uma leitura para o primeiro setor "
"da slice do FreeBSD é solicitada chamando <literal>intx13</literal> . Nós "
"assumimos que tudo correu bem, então um salto para o <literal>beep</literal> "
"não é executado. Em particular, o novo setor lido deve terminar com a "
"sequência mágica <literal>0xaa55</literal>. Finalmente, o valor em <literal>"
"%si</literal> (o ponteiro para a tabela de partições selecionada) é "
"preservado para uso pelo próximo estágio, e um salto é executado para o "
"endereço <literal>0x7c00</literal> , onde a execução do nosso próximo "
"estágio (o bloco de apenas-leitura) é iniciado. "

#. (itstool) path: sect1/title
#: book.translate.xml:950
msgid "<literal>boot1</literal> Stage"
msgstr "Etapa <literal>boot1</literal>"

#. (itstool) path: sect1/para
#: book.translate.xml:952
msgid "So far we have gone through the following sequence:"
msgstr "Até agora nós passamos pela seguinte sequência:"

#. (itstool) path: listitem/para
#: book.translate.xml:956
msgid ""
"The <acronym>BIOS</acronym> did some early hardware initialization, "
"including the <acronym>POST</acronym>. The <acronym>MBR</acronym> "
"(<filename>boot0</filename>) was loaded from absolute disk sector one to "
"address <literal>0x7c00</literal>. Execution control was passed to that "
"location."
msgstr ""
"A <acronym>BIOS</acronym> fez algumas inicializações de hardware, incluindo "
"o <acronym>POST</acronym> . O <acronym>MBR</acronym> (<filename>boot0</"
"filename>) foi carregado a partir do primeiro setor de disco absoluto para "
"endereço <literal>0x7c00</literal> . O controle de execução foi passado para "
"essa localização."

#. (itstool) path: listitem/para
#: book.translate.xml:965
msgid ""
"<filename>boot0</filename> relocated itself to the location it was linked to "
"execute (<literal>0x600</literal>), followed by a jump to continue execution "
"at the appropriate place. Finally, <filename>boot0</filename> loaded the "
"first disk sector from the FreeBSD slice to address <literal>0x7c00</"
"literal>. Execution control was passed to that location."
msgstr ""
"<filename>boot0</filename> realocado para o local que estava lincado para "
"executar (<literal>0x600</literal>), seguido por um salto para continuar a "
"execução no local apropriado. Finalmente, <filename>boot0</filename> "
"carregou o primeiro setor de disco da slice do FreeBSD para endereço "
"<literal>0x7c00</literal>. O controle de execução foi passado para essa "
"localização."

#. (itstool) path: footnote/para
#: book.translate.xml:989
msgid ""
"There is a file <filename>/boot/boot1</filename>, but it is not the written "
"to the beginning of the FreeBSD slice. Instead, it is concatenated with "
"<filename>boot2</filename> to form <filename>boot</filename>, which "
"<emphasis>is</emphasis> written to the beginning of the FreeBSD slice and "
"read at boot time."
msgstr ""
"Existe um arquivo <filename> / boot / boot1 </filename> , mas não é o "
"escrito para o começo da fatia do FreeBSD. Em vez disso, é concatenado com "
"<filename> boot2 </filename> formar <filename> bota </filename>, o qual "
"<emphasis> é </emphasis> escrito para o inicio da fatia do FreeBSD e lido no "
"momento da inicialização. "

#. (itstool) path: sect1/para
#: book.translate.xml:975
msgid ""
"<filename>boot1</filename> is the next step in the boot-loading sequence. It "
"is the first of three boot stages. Note that we have been dealing "
"exclusively with disk sectors. Indeed, the <acronym>BIOS</acronym> loads the "
"absolute first sector, while <filename>boot0</filename> loads the first "
"sector of the FreeBSD slice. Both loads are to address <literal>0x7c00</"
"literal>. We can conceptually think of these disk sectors as containing the "
"files <filename>boot0</filename> and <filename>boot1</filename>, "
"respectively, but in reality this is not entirely true for <filename>boot1</"
"filename>. Strictly speaking, unlike <filename>boot0</filename>, "
"<filename>boot1</filename> is not part of the boot blocks <_:footnote-1/>. "
"Instead, a single, full-blown file, <filename>boot</filename> (<filename>/"
"boot/boot</filename>), is what ultimately is written to disk. This file is a "
"combination of <filename>boot1</filename>, <filename>boot2</filename> and "
"the <literal>Boot Extender</literal> (or <acronym>BTX</acronym>). This "
"single file is greater in size than a single sector (greater than 512 "
"bytes). Fortunately, <filename>boot1</filename> occupies <emphasis>exactly</"
"emphasis> the first 512 bytes of this single file, so when <filename>boot0</"
"filename> loads the first sector of the FreeBSD slice (512 bytes), it is "
"actually loading <filename>boot1</filename> and transferring control to it."
msgstr ""
"<filename>boot1</filename> é o próximo passo na sequência de carregamento de "
"inicialização. É o primeiro de três estágios de inicialização. Observe que "
"estamos lidando exclusivamente com setores de disco. De fato, a "
"<acronym>BIOS</acronym> carrega o primeiro setor absoluto, enquanto "
"<filename>boot0</filename> carrega o primeiro setor da fatia do FreeBSD. "
"Ambas as carregamentos são para endereçar <literal>0x7c00</literal>. Podemos "
"conceitualmente pensar nesses setores de disco como contendo os arquivos "
"<filename>boot0</filename> e <filename>boot1</filename>, respectivamente, "
"mas na realidade isso não é inteiramente verdade para <filename>boot1</"
"filename>. Estritamente falando, diferentemente de <filename>boot0</"
"filename> , <filename>boot1</filename> não faz parte dos blocos de "
"inicialização <_:footnote-1/>. Em vez disso, um único arquivo completo, "
"<filename>boot</filename> (<filename>/boot/boot</filename>), é o que "
"finalmente é gravado em disco. Este arquivo é uma combinação de "
"<filename>boot1</filename> , <filename>boot2</filename> e o <literal>Boot "
"Extender</literal> (ou <acronym>BTX</acronym>). Este arquivo único é maior "
"em tamanho do que um único setor (maior que 512 bytes). Felizmente, "
"<filename>boot1</filename> ocupa <emphasis>exatamente</emphasis> os "
"primeiros 512 bytes deste arquivo único, então quando <filename>boot0</"
"filename> carrega o primeiro setor da fatia do FreeBSD (512 bytes), ele está "
"realmente carregando <filename>boot1</filename> e transferindo o controle "
"para ele."

#. (itstool) path: sect1/para
#: book.translate.xml:1009
msgid ""
"The main task of <filename>boot1</filename> is to load the next boot stage. "
"This next stage is somewhat more complex. It is composed of a server called "
"the <quote>Boot Extender</quote>, or <acronym>BTX</acronym>, and a client, "
"called <filename>boot2</filename>. As we will see, the last boot stage, "
"<filename>loader</filename>, is also a client of the <acronym>BTX</acronym> "
"server."
msgstr ""
"A principal tarefa de <filename>boot1</filename> é carregar o próximo "
"estágio de inicialização. Este próximo estágio é um pouco mais complexo. É "
"composto por um servidor chamado <quote>Boot Extender</quote>, ou "
"<acronym>BTX</acronym>, e um cliente, chamado <filename>boot2</filename> . "
"Como veremos, o último estágio de inicialização <filename>loader</filename> "
"é também um cliente do servidor <acronym>BTX</acronym>."

#. (itstool) path: sect1/para
#: book.translate.xml:1017
msgid ""
"Let us now look in detail at what exactly is done by <filename>boot1</"
"filename>, starting like we did for <filename>boot0</filename>, at its entry "
"point:"
msgstr ""
"Vamos agora olhar em detalhes para o que exatamente é feito por "
"<filename>boot1</filename> , começando como fizemos para <filename>boot0</"
"filename> , no seu ponto de entrada:"

#. (itstool) path: figure/title
#: book.translate.xml:1022 book.translate.xml:1033 book.translate.xml:1073
#: book.translate.xml:1118 book.translate.xml:1153 book.translate.xml:1180
#: book.translate.xml:1209 book.translate.xml:1316
msgid "<filename>sys/boot/i386/boot2/boot1.S</filename>"
msgstr "<filename>sys/boot/i386/boot2/boot1.S</filename>"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1024
#, no-wrap
msgid ""
"start:\n"
"\tjmp main"
msgstr ""
"start:\n"
"\tjmp main"

#. (itstool) path: sect1/para
#: book.translate.xml:1028
msgid ""
"The entry point at <literal>start</literal> simply jumps past a special data "
"area to the label <literal>main</literal>, which in turn looks like this:"
msgstr ""
"O ponto de entrada em <literal>start</literal> simplesmente passa por uma "
"área de dados especial para o rótulo <literal>main</literal>, que por sua "
"vez se parece com isso:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1035
#, no-wrap
msgid ""
"main:\n"
"      cld\t\t\t# String ops inc\n"
"      xor %cx,%cx\t\t# Zero\n"
"      mov %cx,%es\t\t# Address\n"
"      mov %cx,%ds\t\t#  data\n"
"      mov %cx,%ss\t\t# Set up\n"
"      mov $start,%sp\t\t#  stack\n"
"      mov %sp,%si\t\t# Source\n"
"      mov $0x700,%di\t\t# Destination\n"
"      incb %ch\t\t\t# Word count\n"
"      rep\t\t\t# Copy\n"
"      movsw\t\t\t#  code"
msgstr ""
"main:\n"
"      cld\t\t\t# String ops inc\n"
"      xor %cx,%cx\t\t# Zero\n"
"      mov %cx,%es\t\t# Address\n"
"      mov %cx,%ds\t\t#  data\n"
"      mov %cx,%ss\t\t# Set up\n"
"      mov $start,%sp\t\t#  stack\n"
"      mov %sp,%si\t\t# Source\n"
"      mov $0x700,%di\t\t# Destination\n"
"      incb %ch\t\t\t# Word count\n"
"      rep\t\t\t# Copy\n"
"      movsw\t\t\t#  code"

#. (itstool) path: sect1/para
#: book.translate.xml:1049
msgid ""
"Just like <filename>boot0</filename>, this code relocates <filename>boot1</"
"filename>, this time to memory address <literal>0x700</literal>. However, "
"unlike <filename>boot0</filename>, it does not jump there. <filename>boot1</"
"filename> is linked to execute at address <literal>0x7c00</literal>, "
"effectively where it was loaded in the first place. The reason for this "
"relocation will be discussed shortly."
msgstr ""
"Assim como <filename>boot0</filename> , este código realoca <filename>boot1</"
"filename>, desta vez para o endereço de memória <literal>0x700</literal> . "
"No entanto, ao contrário de <filename>boot0</filename> , não salta para lá. "
"<filename>boot1</filename> é lincado para executar no endereço "
"<literal>0x7c00</literal> , efetivamente onde foi carregado em primeiro "
"lugar. A razão para essa realocação será discutida em breve."

#. (itstool) path: footnote/para
#: book.translate.xml:1062
msgid ""
"Actually we did pass a pointer to the slice entry in register <literal>%si</"
"literal>. However, <filename>boot1</filename> does not assume that it was "
"loaded by <filename>boot0</filename> (perhaps some other <acronym>MBR</"
"acronym> loaded it, and did not pass this information), so it assumes "
"nothing."
msgstr ""
"Na verdade nós passamos um ponteiro para a entrada da fatia no registro "
"<literal>%si</literal>. Contudo, <filename>boot1</filename> não assume que "
"foi carregado por <filename>boot0</filename> (talvez algum outro "
"<acronym>MBR</acronym> tenha carregado e não tenha passado essa informação), "
"por isso não assume nada."

#. (itstool) path: sect1/para
#: book.translate.xml:1058
msgid ""
"Next comes a loop that looks for the FreeBSD slice. Although "
"<filename>boot0</filename> loaded <filename>boot1</filename> from the "
"FreeBSD slice, no information was passed to it about this <_:footnote-1/>, "
"so <filename>boot1</filename> must rescan the partition table to find where "
"the FreeBSD slice starts. Therefore it rereads the <acronym>MBR</acronym>:"
msgstr ""
"Em seguida vem um loop que procura a fatia do FreeBSD. Embora "
"<filename>boot0</filename> carregue <filename>boot1</filename> da fatia do "
"FreeBSD, nenhuma informação foi passada para ele sobre isso <_:footnote-1/>, "
"então <filename>boot1</filename> deve varrer novamente a tabela de partições "
"para encontrar onde a fatia do FreeBSD iniciou. Por isso, releia o "
"<acronym>MBR</acronym>: "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1075
#, no-wrap
msgid ""
"      mov $part4,%si\t\t# Partition\n"
"      cmpb $0x80,%dl\t\t# Hard drive?\n"
"      jb main.4\t\t\t# No\n"
"      movb $0x1,%dh\t\t# Block count\n"
"      callw nread\t\t# Read MBR"
msgstr ""
"      mov $part4,%si\t\t# Partition\n"
"      cmpb $0x80,%dl\t\t# Hard drive?\n"
"      jb main.4\t\t\t# No\n"
"      movb $0x1,%dh\t\t# Block count\n"
"      callw nread\t\t# Read MBR"

#. (itstool) path: sect1/para
#: book.translate.xml:1082
msgid ""
"In the code above, register <literal>%dl</literal> maintains information "
"about the boot device. This is passed on by the <acronym>BIOS</acronym> and "
"preserved by the <acronym>MBR</acronym>. Numbers <literal>0x80</literal> and "
"greater tells us that we are dealing with a hard drive, so a call is made to "
"<literal>nread</literal>, where the <acronym>MBR</acronym> is read. "
"Arguments to <literal>nread</literal> are passed through <literal>%si</"
"literal> and <literal>%dh</literal>. The memory address at label "
"<literal>part4</literal> is copied to <literal>%si</literal>. This memory "
"address holds a <quote>fake partition</quote> to be used by <literal>nread</"
"literal>. The following is the data in the fake partition:"
msgstr ""
"No código acima, o registro <literal>%dl</literal> mantém informações sobre "
"o dispositivo de inicialização. Isso é transmitido pelo <acronym>BIOS</"
"acronym> e preservado pelo <acronym>MBR</acronym>. Os números <literal>0x80</"
"literal> e maiores nos dizem que estamos lidando com um disco rígido, então "
"uma chamada é feita para <literal>nread</literal>, onde o <acronym>MBR</"
"acronym> é lido. Argumentos para <literal>nread</literal> são passados ​​"
"através de <literal>%si</literal> e <literal>%dh</literal>. O endereço de "
"memória no rótulo <literal>part4</literal> é copiado para <literal>%si</"
"literal>. Este endereço de memória contém uma <quote>partição falsa</quote> "
"a ser usada por <literal>nread</literal>. A seguir estão os dados na "
"partição falsa:"

#. (itstool) path: figure/title
#: book.translate.xml:1098 book.translate.xml:1392 book.translate.xml:1405
#: book.translate.xml:1437 book.translate.xml:1478
msgid "<filename>sys/boot/i386/boot2/Makefile</filename>"
msgstr " <filename>sys/boot/i386/boot2/Makefile</filename> "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1100
#, no-wrap
msgid ""
"      part4:\n"
"\t.byte 0x80, 0x00, 0x01, 0x00\n"
"\t.byte 0xa5, 0xfe, 0xff, 0xff\n"
"\t.byte 0x00, 0x00, 0x00, 0x00\n"
"\t.byte 0x50, 0xc3, 0x00, 0x00"
msgstr ""
"      part4:\n"
"\t.byte 0x80, 0x00, 0x01, 0x00\n"
"\t.byte 0xa5, 0xfe, 0xff, 0xff\n"
"\t.byte 0x00, 0x00, 0x00, 0x00\n"
"\t.byte 0x50, 0xc3, 0x00, 0x00"

#. (itstool) path: sect1/para
#: book.translate.xml:1107
msgid ""
"In particular, the <acronym>LBA</acronym> for this fake partition is "
"hardcoded to zero. This is used as an argument to the <acronym>BIOS</"
"acronym> for reading absolute sector one from the hard drive. Alternatively, "
"CHS addressing could be used. In this case, the fake partition holds "
"cylinder 0, head 0 and sector 1, which is equivalent to absolute sector one."
msgstr ""
"Em particular, o <acronym>LBA</acronym> para essa partição falsa é "
"codificado para zero. Isso é usado como um argumento para a <acronym>BIOS</"
"acronym> para ler o setor absoluto do disco rigido. Alternativamente, o "
"endereçamento CHS pode ser usado. Nesse caso, a partição falsa mantém "
"cilindro 0, cabeça 0 e setor 1, o que equivale ao setor absoluto um."

#. (itstool) path: sect1/para
#: book.translate.xml:1114
msgid "Let us now proceed to take a look at <literal>nread</literal>:"
msgstr "Vamos agora dar uma olhada em <literal>nread</literal>:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1120
#, no-wrap
msgid ""
"nread:\n"
"      mov $0x8c00,%bx\t\t# Transfer buffer\n"
"      mov 0x8(%si),%ax\t\t# Get\n"
"      mov 0xa(%si),%cx\t\t#  LBA\n"
"      push %cs\t\t\t# Read from\n"
"      callw xread.1\t\t#  disk\n"
"      jnc return\t\t# If success, return"
msgstr ""
"nread:\n"
"      mov $0x8c00,%bx\t\t# Transfer buffer\n"
"      mov 0x8(%si),%ax\t\t# Get\n"
"      mov 0xa(%si),%cx\t\t#  LBA\n"
"      push %cs\t\t\t# Read from\n"
"      callw xread.1\t\t#  disk\n"
"      jnc return\t\t# If success, return"

#. (itstool) path: footnote/para
#: book.translate.xml:1132
msgid "In the context of 16-bit real mode, a word is 2 bytes."
msgstr "No contexto do modo real de 16 bits, uma palavra é de 2 bytes."

#. (itstool) path: sect1/para
#: book.translate.xml:1129
msgid ""
"Recall that <literal>%si</literal> points to the fake partition. The word <_:"
"footnote-1/> at offset <literal>0x8</literal> is copied to register <literal>"
"%ax</literal> and word at offset <literal>0xa</literal> to <literal>%cx</"
"literal>. They are interpreted by the <acronym>BIOS</acronym> as the lower 4-"
"byte value denoting the LBA to be read (the upper four bytes are assumed to "
"be zero). Register <literal>%bx</literal> holds the memory address where the "
"<acronym>MBR</acronym> will be loaded. The instruction pushing <literal>%cs</"
"literal> onto the stack is very interesting. In this context, it "
"accomplishes nothing. However, as we will see shortly, <filename>boot2</"
"filename>, in conjunction with the <acronym>BTX</acronym> server, also uses "
"<literal>xread.1</literal>. This mechanism will be discussed in the next "
"section."
msgstr ""
"Lembre-se que <literal>%si</literal> aponta para a partição falsa. A palavra "
"<_:footnote-1/> no offset <literal>0x8</literal> é copiada para o "
"registrador <literal>%ax</literal> e palavra no offset <literal>0xa</"
"literal> para <literal>%cx</literal> . Eles são interpretados pela "
"<acronym>BIOS</acronym> como o valor inferior de 4 bytes que indica o LBA a "
"ser lido (os quatro bytes superiores são considerados como zero). "
"Registrador <literal>%bx</literal> mantém o endereço de memória onde o "
"<acronym>MBR</acronym> será carregado. A instrução pushing <literal>%cs</"
"literal> na pilha é muito interessante. Neste contexto, não realiza nada. No "
"entanto, como veremos em breve, <filename>boot2</filename> , em conjunto com "
"o servidor <acronym>BTX</acronym> , também usa <literal>xread.1</literal> . "
"Esse mecanismo será discutido na próxima seção."

#. (itstool) path: sect1/para
#: book.translate.xml:1148
msgid ""
"The code at <literal>xread.1</literal> further calls the <literal>read</"
"literal> function, which actually calls the <acronym>BIOS</acronym> asking "
"for the disk sector:"
msgstr ""
"O código em <literal>xread.1</literal> ainda chama a função <literal>read</"
"literal>, que realmente chama a <acronym>BIOS</acronym> pedindo o setor de "
"disco:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1155
#, no-wrap
msgid ""
"xread.1:\n"
"\tpushl $0x0\t\t#  absolute\n"
"\tpush %cx\t\t#  block\n"
"\tpush %ax\t\t#  number\n"
"\tpush %es\t\t# Address of\n"
"\tpush %bx\t\t#  transfer buffer\n"
"\txor %ax,%ax\t\t# Number of\n"
"\tmovb %dh,%al\t\t#  blocks to\n"
"\tpush %ax\t\t#  transfer\n"
"\tpush $0x10\t\t# Size of packet\n"
"\tmov %sp,%bp\t\t# Packet pointer\n"
"\tcallw read\t\t# Read from disk\n"
"\tlea 0x10(%bp),%sp\t# Clear stack\n"
"\tlret\t\t\t# To far caller"
msgstr ""
"xread.1:\n"
"\tpushl $0x0\t\t#  absolute\n"
"\tpush %cx\t\t#  block\n"
"\tpush %ax\t\t#  number\n"
"\tpush %es\t\t# Address of\n"
"\tpush %bx\t\t#  transfer buffer\n"
"\txor %ax,%ax\t\t# Number of\n"
"\tmovb %dh,%al\t\t#  blocks to\n"
"\tpush %ax\t\t#  transfer\n"
"\tpush $0x10\t\t# Size of packet\n"
"\tmov %sp,%bp\t\t# Packet pointer\n"
"\tcallw read\t\t# Read from disk\n"
"\tlea 0x10(%bp),%sp\t# Clear stack\n"
"\tlret\t\t\t# To far caller"

#. (itstool) path: sect1/para
#: book.translate.xml:1171
msgid ""
"Note the long return instruction at the end of this block. This instruction "
"pops out the <literal>%cs</literal> register pushed by <literal>nread</"
"literal>, and returns. Finally, <literal>nread</literal> also returns."
msgstr ""
"Observe a instrução de retorno longa no final deste bloco. Esta instrução "
"mostra o registrador <literal>%cs</literal> pego por <literal>nread</"
"literal> e retorna. Finalmente, <literal>nread</literal> também retorna."

#. (itstool) path: sect1/para
#: book.translate.xml:1176
msgid ""
"With the <acronym>MBR</acronym> loaded to memory, the actual loop for "
"searching the FreeBSD slice begins:"
msgstr ""
"Com o <acronym>MBR</acronym> carregado na memória, o loop real para procurar "
"a fatia do FreeBSD começa:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1182
#, no-wrap
msgid ""
"\tmov $0x1,%cx\t\t # Two passes\n"
"main.1:\n"
"\tmov $0x8dbe,%si # Partition table\n"
"\tmovb $0x1,%dh\t\t # Partition\n"
"main.2:\n"
"\tcmpb $0xa5,0x4(%si)\t # Our partition type?\n"
"\tjne main.3\t\t # No\n"
"\tjcxz main.5\t\t # If second pass\n"
"\ttestb $0x80,(%si)\t # Active?\n"
"\tjnz main.5\t\t # Yes\n"
"main.3:\n"
"\tadd $0x10,%si\t\t # Next entry\n"
"\tincb %dh\t\t # Partition\n"
"\tcmpb $0x5,%dh\t\t # In table?\n"
"\tjb main.2\t\t # Yes\n"
"\tdec %cx\t\t\t # Do two\n"
"\tjcxz main.1\t\t #  passes"
msgstr ""
"\tmov $0x1,%cx\t\t # Two passes\n"
"main.1:\n"
"\tmov $0x8dbe,%si # Partition table\n"
"\tmovb $0x1,%dh\t\t # Partition\n"
"main.2:\n"
"\tcmpb $0xa5,0x4(%si)\t # Our partition type?\n"
"\tjne main.3\t\t # No\n"
"\tjcxz main.5\t\t # If second pass\n"
"\ttestb $0x80,(%si)\t # Active?\n"
"\tjnz main.5\t\t # Yes\n"
"main.3:\n"
"\tadd $0x10,%si\t\t # Next entry\n"
"\tincb %dh\t\t # Partition\n"
"\tcmpb $0x5,%dh\t\t # In table?\n"
"\tjb main.2\t\t # Yes\n"
"\tdec %cx\t\t\t # Do two\n"
"\tjcxz main.1\t\t #  passes"

#. (itstool) path: sect1/para
#: book.translate.xml:1201
msgid ""
"If a FreeBSD slice is identified, execution continues at <literal>main.5</"
"literal>. Note that when a FreeBSD slice is found <literal>%si</literal> "
"points to the appropriate entry in the partition table, and <literal>%dh</"
"literal> holds the partition number. We assume that a FreeBSD slice is "
"found, so we continue execution at <literal>main.5</literal>:"
msgstr ""
"Se uma fatia do FreeBSD for identificada, a execução continua em "
"<literal>main.5</literal> . Note que quando uma fatia do FreeBSD é "
"encontrada <literal>%si</literal> aponta para a entrada apropriada na tabela "
"de partições e <literal>%dh</literal> mantém o número da partição. Nós "
"assumimos que uma fatia do FreeBSD é encontrada, então continuamos a "
"execução em <literal>main.5</literal>:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1211
#, no-wrap
msgid ""
"main.5:\n"
"\tmov %dx,0x900\t\t\t   # Save args\n"
"\tmovb $0x10,%dh\t\t\t   # Sector count\n"
"\tcallw nread\t\t\t   # Read disk\n"
"\tmov $0x9000,%bx\t\t\t   # BTX\n"
"\tmov 0xa(%bx),%si\t\t   # Get BTX length and set\n"
"\tadd %bx,%si\t\t\t   #  %si to start of boot2.bin\n"
"\tmov $0xc000,%di\t\t\t   # Client page 2\n"
"\tmov $0xa200,%cx\t\t\t   # Byte\n"
"\tsub %si,%cx\t\t\t   #  count\n"
"\trep\t\t\t\t   # Relocate\n"
"\tmovsb\t\t\t\t   #  client"
msgstr ""
"main.5:\n"
"\tmov %dx,0x900\t\t\t   # Save args\n"
"\tmovb $0x10,%dh\t\t\t   # Sector count\n"
"\tcallw nread\t\t\t   # Read disk\n"
"\tmov $0x9000,%bx\t\t\t   # BTX\n"
"\tmov 0xa(%bx),%si\t\t   # Get BTX length and set\n"
"\tadd %bx,%si\t\t\t   #  %si to start of boot2.bin\n"
"\tmov $0xc000,%di\t\t\t   # Client page 2\n"
"\tmov $0xa200,%cx\t\t\t   # Byte\n"
"\tsub %si,%cx\t\t\t   #  count\n"
"\trep\t\t\t\t   # Relocate\n"
"\tmovsb\t\t\t\t   #  client"

#. (itstool) path: sect1/para
#: book.translate.xml:1225
msgid ""
"Recall that at this point, register <literal>%si</literal> points to the "
"FreeBSD slice entry in the <acronym>MBR</acronym> partition table, so a call "
"to <literal>nread</literal> will effectively read sectors at the beginning "
"of this partition. The argument passed on register <literal>%dh</literal> "
"tells <literal>nread</literal> to read 16 disk sectors. Recall that the "
"first 512 bytes, or the first sector of the FreeBSD slice, coincides with "
"the <filename>boot1</filename> program. Also recall that the file written to "
"the beginning of the FreeBSD slice is not <filename>/boot/boot1</filename>, "
"but <filename>/boot/boot</filename>. Let us look at the size of these files "
"in the filesystem:"
msgstr ""
"Lembre-se que neste momento, o registrador <literal>%si</literal> aponta "
"para a entrada da fatia do FreeBSD na tabela de partição <acronym>MBR</"
"acronym> , então uma chamada para <literal>nread</literal> efetivamente lerá "
"setores no início desta partição. O argumento passou no registrador <literal>"
"%dh</literal> diz ao <literal>nread</literal> para ler 16 setores de disco. "
"Lembre-se que os primeiros 512 bytes, ou o primeiro setor da fatia do "
"FreeBSD, coincide com o programa <filename>boot1</filename>. Lembre-se "
"também que o arquivo gravado no início da fatia do FreeBSD não é <filename>/"
"boot/boot1</filename> , mas <filename>/boot/boot</filename> . Vamos ver o "
"tamanho desses arquivos no sistema de arquivos:"

#. (itstool) path: sect1/screen
#. (itstool) id: book.translate.xml#boot-boot1-filesize
#: book.translate.xml:1238
#, no-wrap
msgid ""
"-r--r--r--  1 root  wheel   512B Jan  8 00:15 /boot/boot0\n"
"-r--r--r--  1 root  wheel   512B Jan  8 00:15 /boot/boot1\n"
"-r--r--r--  1 root  wheel   7.5K Jan  8 00:15 /boot/boot2\n"
"-r--r--r--  1 root  wheel   8.0K Jan  8 00:15 /boot/boot"
msgstr ""
"-r--r--r--  1 root  wheel   512B Jan  8 00:15 /boot/boot0\n"
"-r--r--r--  1 root  wheel   512B Jan  8 00:15 /boot/boot1\n"
"-r--r--r--  1 root  wheel   7.5K Jan  8 00:15 /boot/boot2\n"
"-r--r--r--  1 root  wheel   8.0K Jan  8 00:15 /boot/boot"

#. (itstool) path: sect1/para
#: book.translate.xml:1243
msgid ""
"Both <filename>boot0</filename> and <filename>boot1</filename> are 512 bytes "
"each, so they fit <emphasis>exactly</emphasis> in one disk sector. "
"<filename>boot2</filename> is much bigger, holding both the <acronym>BTX</"
"acronym> server and the <filename>boot2</filename> client. Finally, a file "
"called simply <filename>boot</filename> is 512 bytes larger than "
"<filename>boot2</filename>. This file is a concatenation of <filename>boot1</"
"filename> and <filename>boot2</filename>. As already noted, <filename>boot0</"
"filename> is the file written to the absolute first disk sector (the "
"<acronym>MBR</acronym>), and <filename>boot</filename> is the file written "
"to the first sector of the FreeBSD slice; <filename>boot1</filename> and "
"<filename>boot2</filename> are <emphasis>not</emphasis> written to disk. The "
"command used to concatenate <filename>boot1</filename> and <filename>boot2</"
"filename> into a single <filename>boot</filename> is merely <command>cat "
"boot1 boot2 &gt; boot</command>."
msgstr ""
"Ambos <filename>boot0</filename> e <filename>boot1</filename> são 512 bytes "
"cada, então eles se encaixam <emphasis>exatamente</emphasis> em um setor de "
"disco. <filename>boot2</filename> é muito maior, mantendo tanto o servidor "
"<acronym>BTX</acronym> quanto o cliente <filename>boot2</filename>. "
"Finalmente, um arquivo chamado simplesmente de <filename>boot</filename> é "
"512 bytes maior que <filename>boot2</filename> . Este arquivo é uma "
"concatenação de <filename>boot1</filename> e <filename>boot2</filename> . "
"Como já foi dito, <filename>boot0</filename> é o arquivo gravado no primeiro "
"setor de disco absoluto (o <acronym>MBR</acronym>) e <filename>boot</"
"filename> é o arquivo escrito no primeiro setor da fatia do FreeBSD; "
"<filename>boot1</filename> e <filename>boot2</filename> <emphasis>não</"
"emphasis> são escritos em disco. O comando usado para concatenar "
"<filename>boot1</filename> e <filename>boot2</filename> em um único "
"<filename>boot</filename> é meramente <command>cat boot1 boot2&gt; boot</"
"command>."

#. (itstool) path: footnote/para
#: book.translate.xml:1271
msgid "512*16=8192 bytes, exactly the size of <filename>boot</filename>"
msgstr "512*16=8192 bytes, exatamente o tamanho de <filename>boot</filename>"

#. (itstool) path: sect1/para
#: book.translate.xml:1263
msgid ""
"So <filename>boot1</filename> occupies exactly the first 512 bytes of "
"<filename>boot</filename> and, because <filename>boot</filename> is written "
"to the first sector of the FreeBSD slice, <filename>boot1</filename> fits "
"exactly in this first sector. Because <literal>nread</literal> reads the "
"first 16 sectors of the FreeBSD slice, it effectively reads the entire "
"<filename>boot</filename> file <_:footnote-1/>. We will see more details "
"about how <filename>boot</filename> is formed from <filename>boot1</"
"filename> and <filename>boot2</filename> in the next section."
msgstr ""
"Assim <filename>boot1</filename> ocupa exatamente os primeiros 512 bytes de "
"<filename>boot</filename> e porque <filename>boot</filename> é escrito para "
"o primeiro setor da fatia do FreeBSD, <filename>boot1</filename> cabe "
"exatamente neste primeiro setor. Porque <literal>nread</literal> lê os "
"primeiros 16 setores da fatia do FreeBSD, lê efetivamente toda o arquivo "
"<filename>boot</filename> <_:footnote-1/>. Vamos ver mais detalhes sobre "
"como <filename>boot</filename> é formado a partir de <filename>boot1</"
"filename> e <filename>boot2</filename> na próxima seção."

#. (itstool) path: footnote/para
#: book.translate.xml:1287
msgid ""
"Historically known as <quote>disklabel</quote>. If you ever wondered where "
"FreeBSD stored this information, it is in this region. See "
"<citerefentry><refentrytitle>bsdlabel</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>"
msgstr ""
"Historicamente conhecido como <quote>disklabel</quote> . Se você já se "
"perguntou onde o FreeBSD armazenou esta informação, está nesta região. Veja "
"<citerefentry><refentrytitle>bsdlabel</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>"

#. (itstool) path: sect1/para
#: book.translate.xml:1277
msgid ""
"Recall that <literal>nread</literal> uses memory address <literal>0x8c00</"
"literal> as the transfer buffer to hold the sectors read. This address is "
"conveniently chosen. Indeed, because <filename>boot1</filename> belongs to "
"the first 512 bytes, it ends up in the address range <literal>0x8c00</"
"literal>-<literal>0x8dff</literal>. The 512 bytes that follows (range "
"<literal>0x8e00</literal>-<literal>0x8fff</literal>) is used to store the "
"<emphasis>bsdlabel</emphasis> <_:footnote-1/>."
msgstr ""
"Lembre-se que <literal>nread</literal> usa endereço de memória "
"<literal>0x8c00</literal> como o buffer de transferência para manter os "
"setores lidos. Este endereço é convenientemente escolhido. De fato, porque "
"<filename>boot1</filename> pertence aos primeiros 512 bytes, acaba na faixa "
"de endereços <literal>0x8c00</literal>-<literal>0x8dff</literal> . Os 512 "
"bytes seguintes (intervalo <literal>0x8e00</literal>-<literal>0x8fff</"
"literal>) é usado para armazenar <emphasis>bsdlabel</emphasis> <_:footnote-1/"
">."

#. (itstool) path: sect1/para
#: book.translate.xml:1291
msgid ""
"Starting at address <literal>0x9000</literal> is the beginning of the "
"<acronym>BTX</acronym> server, and immediately following is the "
"<filename>boot2</filename> client. The <acronym>BTX</acronym> server acts as "
"a kernel, and executes in protected mode in the most privileged level. In "
"contrast, the <acronym>BTX</acronym> clients (<filename>boot2</filename>, "
"for example), execute in user mode. We will see how this is accomplished in "
"the next section. The code after the call to <literal>nread</literal> "
"locates the beginning of <filename>boot2</filename> in the memory buffer, "
"and copies it to memory address <literal>0xc000</literal>. This is because "
"the <acronym>BTX</acronym> server arranges <filename>boot2</filename> to "
"execute in a segment starting at <literal>0xa000</literal>. We explore this "
"in detail in the following section."
msgstr ""
"Começando no endereço <literal>0x9000</literal> é o começo do servidor "
"<acronym>BTX</acronym> , e imediatamente a seguir é o cliente "
"<filename>boot2</filename>. O servidor <acronym>BTX</acronym> atua como um "
"kernel e é executado no modo protegido no nível mais privilegiado. Em "
"contraste, os clientes <acronym>BTX</acronym> (<filename>boot2</filename> , "
"por exemplo), executam no modo de usuário. Vamos ver como isso é feito na "
"próxima seção. O código após a chamada para <literal>nread</literal> "
"localiza o começo de <filename>boot2</filename> no buffer de memória e copia "
"para o endereço de memória <literal>0xc000</literal>. Isso ocorre porque o "
"servidor <acronym>BTX</acronym> organiza <filename>boot2</filename> para "
"executar em um segmento a partir de <literal>0xa000</literal> . Nés "
"exploramos isso em detalhes na seção seguinte."

#. (itstool) path: footnote/para
#: book.translate.xml:1310
msgid ""
"This is necessary for legacy reasons. Interested readers should see <link "
"xlink:href=\"http://en.wikipedia.org/wiki/A20_line\"/>."
msgstr ""
"Isso é necessário por razões de legado. Os leitores interessados ​​devem ver "
"<link xlink:href=\"http://en.wikipedia.org/wiki/A20_line\"/> "

#. (itstool) path: sect1/para
#: book.translate.xml:1307
msgid ""
"The last code block of <filename>boot1</filename> enables access to memory "
"above 1MB <_:footnote-1/> and concludes with a jump to the starting point of "
"the <acronym>BTX</acronym> server:"
msgstr ""
"O último bloco de código de <filename>boot1</filename> permite o acesso à "
"memória acima de 1MB <_:footnote-1/> e conclui com um salto para o ponto de "
"partida do servidor <acronym>BTX</acronym>:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1318
#, no-wrap
msgid ""
"seta20:\n"
"\tcli\t\t\t# Disable interrupts\n"
"seta20.1:\n"
"\tdec %cx\t\t\t# Timeout?\n"
"\tjz seta20.3\t\t# Yes\n"
"\n"
"\tinb $0x64,%al\t\t# Get status\n"
"\ttestb $0x2,%al\t\t# Busy?\n"
"\tjnz seta20.1\t\t# Yes\n"
"\tmovb $0xd1,%al\t\t# Command: Write\n"
"\toutb %al,$0x64\t\t#  output port\n"
"seta20.2:\n"
"\tinb $0x64,%al\t\t# Get status\n"
"\ttestb $0x2,%al\t\t# Busy?\n"
"\tjnz seta20.2\t\t# Yes\n"
"\tmovb $0xdf,%al\t\t# Enable\n"
"\toutb %al,$0x60\t\t#  A20\n"
"seta20.3:\n"
"\tsti\t\t\t# Enable interrupts\n"
"\tjmp 0x9010\t\t# Start BTX"
msgstr ""
"seta20:\n"
"\tcli\t\t\t# Disable interrupts\n"
"seta20.1:\n"
"\tdec %cx\t\t\t# Timeout?\n"
"\tjz seta20.3\t\t# Yes\n"
"\n"
"\tinb $0x64,%al\t\t# Get status\n"
"\ttestb $0x2,%al\t\t# Busy?\n"
"\tjnz seta20.1\t\t# Yes\n"
"\tmovb $0xd1,%al\t\t# Command: Write\n"
"\toutb %al,$0x64\t\t#  output port\n"
"seta20.2:\n"
"\tinb $0x64,%al\t\t# Get status\n"
"\ttestb $0x2,%al\t\t# Busy?\n"
"\tjnz seta20.2\t\t# Yes\n"
"\tmovb $0xdf,%al\t\t# Enable\n"
"\toutb %al,$0x60\t\t#  A20\n"
"seta20.3:\n"
"\tsti\t\t\t# Enable interrupts\n"
"\tjmp 0x9010\t\t# Start BTX"

#. (itstool) path: sect1/para
#: book.translate.xml:1340
msgid "Note that right before the jump, interrupts are enabled."
msgstr "Note que logo antes do salto, as interrupções estão habilitadas."

#. (itstool) path: sect1/title
#: book.translate.xml:1345
#, fuzzy
msgid "The <acronym>BTX</acronym> Server"
msgstr "O servidor <acronym>BTX</acronym>"

#. (itstool) path: sect1/para
#: book.translate.xml:1347
#, fuzzy
msgid ""
"Next in our boot sequence is the <acronym>BTX</acronym> Server. Let us "
"quickly remember how we got here:"
msgstr ""
"O pr�ximo passo na nossa seq��ncia de inicializa��o � o servidor "
"<acronym>BTX</acronym> . Vamos lembrar rapidamente como chegamos aqui:"

#. (itstool) path: listitem/para
#: book.translate.xml:1353
#, fuzzy
msgid ""
"The <acronym>BIOS</acronym> loads the absolute sector one (the <acronym>MBR</"
"acronym>, or <filename>boot0</filename>), to address <literal>0x7c00</"
"literal> and jumps there."
msgstr ""
"O <acronym>BIOS</acronym> carrega o setor absoluto (o <acronym>MBR</"
"acronym> , ou <filename> boot0 </filename> ), endere�ar <literal> 0x7c00 </"
"literal> e pula l�. "

#. (itstool) path: listitem/para
#: book.translate.xml:1360
#, fuzzy
msgid ""
"<filename>boot0</filename> relocates itself to <literal>0x600</literal>, the "
"address it was linked to execute, and jumps over there. It then reads the "
"first sector of the FreeBSD slice (which consists of <filename>boot1</"
"filename>) into address <literal>0x7c00</literal> and jumps over there."
msgstr ""
" <filename> boot0 </filename> se muda para <literal> 0x600 </literal> , o "
"endere�o que estava ligado para executar e salta para l�. Ele ent�o l� o "
"primeiro setor da fatia do FreeBSD (que consiste em <filename> boot1 </"
"filename> ) no endere�o <literal> 0x7c00 </literal> e pula ali "

#. (itstool) path: listitem/para
#: book.translate.xml:1369
#, fuzzy
msgid ""
"<filename>boot1</filename> loads the first 16 sectors of the FreeBSD slice "
"into address <literal>0x8c00</literal>. This 16 sectors, or 8192 bytes, is "
"the whole file <filename>boot</filename>. The file is a concatenation of "
"<filename>boot1</filename> and <filename>boot2</filename>. <filename>boot2</"
"filename>, in turn, contains the <acronym>BTX</acronym> server and the "
"<filename>boot2</filename> client. Finally, a jump is made to address "
"<literal>0x9010</literal>, the entry point of the <acronym>BTX</acronym> "
"server."
msgstr ""
" <filename> boot1 </filename> carrega os primeiros 16 setores da fatia do "
"FreeBSD no endere�o <literal> 0x8c00 </literal> . Este 16 setores, ou 8192 "
"bytes, � o arquivo inteiro <filename> bota </filename> . O arquivo � uma "
"concatena��o de <filename> boot1 </filename> e <filename> boot2 </"
"filename> . <filename> boot2 </filename> , por sua vez, cont�m o servidor "
"<acronym>BTX</acronym> eo <filename> boot2 </filename> cliente. Finalmente, "
"um salto � feito para abordar <literal> 0x9010 </literal> , o ponto de "
"entrada do servidor <acronym>BTX</acronym> . "

#. (itstool) path: sect1/para
#: book.translate.xml:1382
#, fuzzy
msgid ""
"Before studying the <acronym>BTX</acronym> Server in detail, let us further "
"review how the single, all-in-one <filename>boot</filename> file is created. "
"The way <filename>boot</filename> is built is defined in its "
"<filename>Makefile</filename> (<filename>/usr/src/sys/boot/i386/boot2/"
"Makefile</filename>). Let us look at the rule that creates the "
"<filename>boot</filename> file:"
msgstr ""
"Antes de estudar o <acronym>BTX</acronym> Server detalhadamente, vamos "
"revisar ainda mais como o single, all-in-one <filename> bota </filename> "
"arquivo � criado. O caminho <filename> bota </filename> � constru�do � "
"definido em sua <filename> Makefile </filename> ( <filename> / usr / src / "
"sys / boot / i386 / boot2 / Makefile </filename> ). Vamos olhar para a regra "
"que cria o <filename> bota </filename> Arquivo:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1394
#, no-wrap
msgid ""
"      boot: boot1 boot2\n"
"\tcat boot1 boot2 &gt; boot"
msgstr ""
"      boot: boot1 boot2\n"
"\tcat boot1 boot2 &gt; boot"

#. (itstool) path: sect1/para
#: book.translate.xml:1398
#, fuzzy
msgid ""
"This tells us that <filename>boot1</filename> and <filename>boot2</filename> "
"are needed, and the rule simply concatenates them to produce a single file "
"called <filename>boot</filename>. The rules for creating <filename>boot1</"
"filename> are also quite simple:"
msgstr ""
"Isso nos diz que <filename> boot1 </filename> e <filename> boot2 </filename> "
"s�o necess�rios, e a regra simplesmente concatena-os para produzir um �nico "
"arquivo chamado <filename> bota </filename> . As regras para criar "
"<filename> boot1 </filename> tamb�m s�o bastante simples: "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1407
#, no-wrap
msgid ""
"      boot1: boot1.out\n"
"\tobjcopy -S -O binary boot1.out boot1\n"
"\n"
"      boot1.out: boot1.o\n"
"\tld -e start -Ttext 0x7c00 -o boot1.out boot1.o"
msgstr ""
"      boot1: boot1.out\n"
"\tobjcopy -S -O binary boot1.out boot1\n"
"\n"
"      boot1.out: boot1.o\n"
"\tld -e start -Ttext 0x7c00 -o boot1.out boot1.o"

#. (itstool) path: sect1/para
#: book.translate.xml:1414
#, fuzzy
msgid ""
"To apply the rule for creating <filename>boot1</filename>, <filename>boot1."
"out</filename> must be resolved. This, in turn, depends on the existence of "
"<filename>boot1.o</filename>. This last file is simply the result of "
"assembling our familiar <filename>boot1.S</filename>, without linking. Now, "
"the rule for creating <filename>boot1.out</filename> is applied. This tells "
"us that <filename>boot1.o</filename> should be linked with <literal>start</"
"literal> as its entry point, and starting at address <literal>0x7c00</"
"literal>. Finally, <filename>boot1</filename> is created from "
"<filename>boot1.out</filename> applying the appropriate rule. This rule is "
"the <filename>objcopy</filename> command applied to <filename>boot1.out</"
"filename>. Note the flags passed to <filename>objcopy</filename>: <literal>-"
"S</literal> tells it to strip all relocation and symbolic information; "
"<literal>-O binary</literal> indicates the output format, that is, a simple, "
"unformatted binary file."
msgstr ""
"Para aplicar a regra para criar <filename> boot1 </filename> , <filename> "
"boot1.out </filename> deve ser resolvido. Isso, por sua vez, depende da "
"exist�ncia de <filename> boot1.o </filename> . Este �ltimo arquivo � "
"simplesmente o resultado da montagem de nosso familiar <filename> boot1.S </"
"filename> , sem vincular. Agora, a regra para criar <filename> boot1.out </"
"filename> � aplicado. Isso nos diz que <filename> boot1.o </filename> deve "
"estar ligado a <literal> come�ar </literal> como seu ponto de entrada, e "
"come�ando no endere�o <literal> 0x7c00 </literal> . Finalmente, <filename> "
"boot1 </filename> � criado a partir de <filename> boot1.out </filename> "
"aplicar a regra apropriada. Esta regra � a <filename> objcopy </filename> "
"comando aplicado a <filename> boot1.out </filename> . Observe as bandeiras "
"passadas para <filename> objcopy </filename> : <literal> -S </literal> diz "
"para remover toda a reloca��o e informa��es simb�licas; <literal> Bin�rio -O "
"</literal> indica o formato de sa�da, isto �, um arquivo bin�rio simples e "
"n�o formatado. "

#. (itstool) path: sect1/para
#: book.translate.xml:1433
#, fuzzy
msgid ""
"Having <filename>boot1</filename>, let us take a look at how "
"<filename>boot2</filename> is constructed:"
msgstr ""
"Tendo <filename> boot1 </filename> , vamos dar uma olhada em como <filename> "
"boot2 </filename> � constru�do:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1439
#, no-wrap
msgid ""
"      boot2: boot2.ld\n"
"\t@set -- `ls -l boot2.ld`; x=$$((7680-$$5)); \\\n"
"\t    echo \"$$x bytes available\"; test $$x -ge 0\n"
"\tdd if=boot2.ld of=boot2 obs=7680 conv=osync\n"
"\n"
"      boot2.ld: boot2.ldr boot2.bin ../btx/btx/btx\n"
"\tbtxld -v -E 0x2000 -f bin -b ../btx/btx/btx -l boot2.ldr \\\n"
"\t    -o boot2.ld -P 1 boot2.bin\n"
"\n"
"      boot2.ldr:\n"
"\tdd if=/dev/zero of=boot2.ldr bs=512 count=1\n"
"\n"
"      boot2.bin: boot2.out\n"
"\tobjcopy -S -O binary boot2.out boot2.bin\n"
"\n"
"      boot2.out: ../btx/lib/crt0.o boot2.o sio.o\n"
"\tld -Ttext 0x2000 -o boot2.out\n"
"\n"
"      boot2.o: boot2.s\n"
"\t${CC} ${ACFLAGS} -c boot2.s\n"
"\n"
"      boot2.s: boot2.c boot2.h ${.CURDIR}/../../common/ufsread.c\n"
"\t${CC} ${CFLAGS} -S -o boot2.s.tmp ${.CURDIR}/boot2.c\n"
"\tsed -e '/align/d' -e '/nop/d' \"MISSING\" boot2.s.tmp &gt; boot2.s\n"
"\trm -f boot2.s.tmp\n"
"\n"
"      boot2.h: boot1.out\n"
"\t${NM} -t d ${.ALLSRC} | awk '/([0-9])+ T xread/ \\\n"
"\t    { x = $$1 - ORG1; \\\n"
"\t    printf(\"#define XREADORG %#x\\n\", REL1 + x) }' \\\n"
"\t    ORG1=`printf \"%d\" ${ORG1}` \\\n"
"\t    REL1=`printf \"%d\" ${REL1}` &gt; ${.TARGET}"
msgstr ""
"      boot2: boot2.ld\n"
"\t@set -- `ls -l boot2.ld`; x=$$((7680-$$5)); \\\n"
"\t    echo \"$$x bytes available\"; test $$x -ge 0\n"
"\tdd if=boot2.ld of=boot2 obs=7680 conv=osync\n"
"\n"
"      boot2.ld: boot2.ldr boot2.bin ../btx/btx/btx\n"
"\tbtxld -v -E 0x2000 -f bin -b ../btx/btx/btx -l boot2.ldr \\\n"
"\t    -o boot2.ld -P 1 boot2.bin\n"
"\n"
"      boot2.ldr:\n"
"\tdd if=/dev/zero of=boot2.ldr bs=512 count=1\n"
"\n"
"      boot2.bin: boot2.out\n"
"\tobjcopy -S -O binary boot2.out boot2.bin\n"
"\n"
"      boot2.out: ../btx/lib/crt0.o boot2.o sio.o\n"
"\tld -Ttext 0x2000 -o boot2.out\n"
"\n"
"      boot2.o: boot2.s\n"
"\t${CC} ${ACFLAGS} -c boot2.s\n"
"\n"
"      boot2.s: boot2.c boot2.h ${.CURDIR}/../../common/ufsread.c\n"
"\t${CC} ${CFLAGS} -S -o boot2.s.tmp ${.CURDIR}/boot2.c\n"
"\tsed -e '/align/d' -e '/nop/d' \"MISSING\" boot2.s.tmp &gt; boot2.s\n"
"\trm -f boot2.s.tmp\n"
"\n"
"      boot2.h: boot1.out\n"
"\t${NM} -t d ${.ALLSRC} | awk '/([0-9])+ T xread/ \\\n"
"\t    { x = $$1 - ORG1; \\\n"
"\t    printf(\"#define XREADORG %#x\\n\", REL1 + x) }' \\\n"
"\t    ORG1=`printf \"%d\" ${ORG1}` \\\n"
"\t    REL1=`printf \"%d\" ${REL1}` &gt; ${.TARGET}"

#. (itstool) path: sect1/para
#: book.translate.xml:1473
#, fuzzy
msgid ""
"The mechanism for building <filename>boot2</filename> is far more elaborate. "
"Let us point out the most relevant facts. The dependency list is as follows:"
msgstr ""
"O mecanismo de constru��o <filename> boot2 </filename> � muito mais "
"elaborado. Vamos mostrar os fatos mais relevantes. A lista de depend�ncias � "
"a seguinte: "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1480
#, no-wrap
msgid ""
"      boot2: boot2.ld\n"
"      boot2.ld: boot2.ldr boot2.bin ${BTXDIR}/btx/btx\n"
"      boot2.bin: boot2.out\n"
"      boot2.out: ${BTXDIR}/lib/crt0.o boot2.o sio.o\n"
"      boot2.o: boot2.s\n"
"      boot2.s: boot2.c boot2.h ${.CURDIR}/../../common/ufsread.c\n"
"      boot2.h: boot1.out"
msgstr ""
"      boot2: boot2.ld\n"
"      boot2.ld: boot2.ldr boot2.bin ${BTXDIR}/btx/btx\n"
"      boot2.bin: boot2.out\n"
"      boot2.out: ${BTXDIR}/lib/crt0.o boot2.o sio.o\n"
"      boot2.o: boot2.s\n"
"      boot2.s: boot2.c boot2.h ${.CURDIR}/../../common/ufsread.c\n"
"      boot2.h: boot1.out"

#. (itstool) path: sect1/para
#: book.translate.xml:1489
#, fuzzy
msgid ""
"Note that initially there is no header file <filename>boot2.h</filename>, "
"but its creation depends on <filename>boot1.out</filename>, which we already "
"have. The rule for its creation is a bit terse, but the important thing is "
"that the output, <filename>boot2.h</filename>, is something like this:"
msgstr ""
"Note que inicialmente n�o h� arquivo de cabe�alho <filename> boot2.h </"
"filename> , mas a sua cria��o depende <filename> boot1.out </filename> que "
"j� temos. A regra para sua cria��o � um pouco concisa, mas o importante � "
"que a sa�da, <filename> boot2.h </filename> � algo assim: "

#. (itstool) path: figure/title
#: book.translate.xml:1497
#, fuzzy
msgid "<filename>sys/boot/i386/boot2/boot2.h</filename>"
msgstr " <filename> sys / boot / i386 / boot2 / boot2.h </filename> "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1499
#, fuzzy, no-wrap
#| msgid ""
#| "\n"
#| "      #define XREADORG 0x725"
msgid "#define XREADORG 0x725"
msgstr ""
"\n"
"      #define XREADORG 0x725"

#. (itstool) path: sect1/para
#: book.translate.xml:1502
#, fuzzy
msgid ""
"Recall that <filename>boot1</filename> was relocated (i.e., copied from "
"<literal>0x7c00</literal> to <literal>0x700</literal>). This relocation will "
"now make sense, because as we will see, the <acronym>BTX</acronym> server "
"reclaims some memory, including the space where <filename>boot1</filename> "
"was originally loaded. However, the <acronym>BTX</acronym> server needs "
"access to <filename>boot1</filename>'s <literal>xread</literal> function; "
"this function, according to the output of <filename>boot2.h</filename>, is "
"at location <literal>0x725</literal>. Indeed, the <acronym>BTX</acronym> "
"server uses the <literal>xread</literal> function from <filename>boot1</"
"filename>'s relocated code. This function is now accessible from within the "
"<filename>boot2</filename> client."
msgstr ""
"Lembre-se que <filename> boot1 </filename> foi realocado (ou seja, copiado "
"de <literal> 0x7c00 </literal> para <literal> 0x700 </literal> ). Essa "
"realoca��o far� agora sentido, porque, como veremos, o servidor "
"<acronym>BTX</acronym> recupera alguma mem�ria, incluindo o espa�o onde "
"<filename> boot1 </filename> foi originalmente carregado. No entanto, o "
"servidor <acronym>BTX</acronym> precisa de acesso a <filename> boot1 </"
"filename> ';s <literal> xread </literal> fun��o; esta fun��o, de acordo com "
"a sa�da de <filename> boot2.h </filename> est� no local <literal> 0x725 </"
"literal> . De fato, o servidor <acronym>BTX</acronym> usa o <literal> xread "
"</literal> fun��o de <filename> boot1 </filename> c�digo realocado. Esta "
"fun��o est� agora acess�vel a partir do <filename> boot2 </filename> cliente."

#. (itstool) path: sect1/para
#: book.translate.xml:1519
#, fuzzy
msgid ""
"We next build <filename>boot2.s</filename> from files <filename>boot2.h</"
"filename>, <filename>boot2.c</filename> and <filename>/usr/src/sys/boot/"
"common/ufsread.c</filename>. The rule for this is to compile the code in "
"<filename>boot2.c</filename> (which includes <filename>boot2.h</filename> "
"and <filename>ufsread.c</filename>) into assembly code. Having "
"<filename>boot2.s</filename>, the next rule assembles <filename>boot2.s</"
"filename>, creating the object file <filename>boot2.o</filename>. The next "
"rule directs the linker to link various files (<filename>crt0.o</filename>, "
"<filename>boot2.o</filename> and <filename>sio.o</filename>). Note that the "
"output file, <filename>boot2.out</filename>, is linked to execute at address "
"<literal>0x2000</literal>. Recall that <filename>boot2</filename> will be "
"executed in user mode, within a special user segment set up by the "
"<acronym>BTX</acronym> server. This segment starts at <literal>0xa000</"
"literal>. Also, remember that the <filename>boot2</filename> portion of "
"<filename>boot</filename> was copied to address <literal>0xc000</literal>, "
"that is, offset <literal>0x2000</literal> from the start of the user "
"segment, so <filename>boot2</filename> will work properly when we transfer "
"control to it. Next, <filename>boot2.bin</filename> is created from "
"<filename>boot2.out</filename> by stripping its symbols and format "
"information; boot2.bin is a <emphasis>raw</emphasis> binary. Now, note that "
"a file <filename>boot2.ldr</filename> is created as a 512-byte file full of "
"zeros. This space is reserved for the bsdlabel."
msgstr ""
"Em seguida, constru�mos <filename> boot2.s </filename> de arquivos "
"<filename> boot2.h </filename> , <filename> boot2.c </filename> e "
"<filename> /usr/src/sys/boot/common/ufsread.c </filename> . A regra para "
"isso � compilar o c�digo em <filename> boot2.c </filename> (que inclui "
"<filename> boot2.h </filename> e <filename> ufsread.c </filename> ) no "
"c�digo de montagem. Tendo <filename> boot2.s </filename> , a pr�xima regra � "
"montada <filename> boot2.s </filename> , criando o arquivo objeto <filename> "
"boot2.o </filename> . A pr�xima regra direciona o vinculador para vincular "
"v�rios arquivos ( <filename> crt0.o </filename> , <filename> boot2.o </"
"filename> e <filename> sio.o </filename> ). Note que o arquivo de sa�da, "
"<filename> boot2.out </filename> , est� ligado para executar no endere�o "
"<literal> 0x2000 </literal> . Lembre-se de que <filename> boot2 </filename> "
"ser� executado no modo de usu�rio, dentro de um segmento de usu�rio especial "
"configurado pelo servidor <acronym>BTX</acronym> . Este segmento come�a em "
"<literal> 0xa000 </literal> . Al�m disso, lembre-se de que <filename> boot2 "
"</filename> por��o de <filename> bota </filename> foi copiado para endere�ar "
"<literal> 0xc000 </literal> , isto �, offset <literal> 0x2000 </literal> "
"desde o in�cio do segmento de usu�rio, ent�o <filename> boot2 </filename> "
"funcionar� corretamente quando transferirmos o controle para ele. Pr�ximo, "
"<filename> boot2.bin </filename> � criado a partir de <filename> boot2.out </"
"filename> descascando seus s�mbolos e formando informa��es; boot2.bin � um "
"<emphasis> cru </emphasis> bin�rio. Agora, observe que um arquivo <filename> "
"boot2.ldr </filename> � criado como um arquivo de 512 bytes cheio de zeros. "
"Este espa�o � reservado para o bsdlabel. "

#. (itstool) path: sect1/para
#: book.translate.xml:1548
#, fuzzy
msgid ""
"Now that we have files <filename>boot1</filename>, <filename>boot2.bin</"
"filename> and <filename>boot2.ldr</filename>, only the <acronym>BTX</"
"acronym> server is missing before creating the all-in-one <filename>boot</"
"filename> file. The <acronym>BTX</acronym> server is located in <filename>/"
"usr/src/sys/boot/i386/btx/btx</filename>; it has its own <filename>Makefile</"
"filename> with its own set of rules for building. The important thing to "
"notice is that it is also compiled as a <emphasis>raw</emphasis> binary, and "
"that it is linked to execute at address <literal>0x9000</literal>. The "
"details can be found in <filename>/usr/src/sys/boot/i386/btx/btx/Makefile</"
"filename>."
msgstr ""
"Agora que temos arquivos <filename> boot1 </filename> , <filename> boot2.bin "
"</filename> e <filename> boot2.ldr </filename> , apenas o servidor "
"<acronym>BTX</acronym> est� ausente antes de criar o all-in-one <filename> "
"bota </filename> Arquivo. O servidor <acronym>BTX</acronym> est� localizado "
"em <filename> / usr / src / sys / boot / i386 / btx / btx </filename> ; tem "
"o seu pr�prio <filename> Makefile </filename> com seu pr�prio conjunto de "
"regras para a constru��o. O importante � notar que tamb�m � compilado como "
"um <emphasis> cru </emphasis> bin�rio, e que est� ligado para executar no "
"endere�o <literal> 0x9000 </literal> . Os detalhes podem ser encontrados em "
"<filename> / usr / src / sys / boot / i386 / btx / btx / Makefile </"
"filename> "

#. (itstool) path: sect1/para
#: book.translate.xml:1562
#, fuzzy
msgid ""
"Having the files that comprise the <filename>boot</filename> program, the "
"final step is to <emphasis>merge</emphasis> them. This is done by a special "
"program called <filename>btxld</filename> (source located in <filename>/usr/"
"src/usr.sbin/btxld</filename>). Some arguments to this program include the "
"name of the output file (<filename>boot</filename>), its entry point "
"(<literal>0x2000</literal>) and its file format (raw binary). The various "
"files are finally merged by this utility into the file <filename>boot</"
"filename>, which consists of <filename>boot1</filename>, <filename>boot2</"
"filename>, the <literal>bsdlabel</literal> and the <acronym>BTX</acronym> "
"server. This file, which takes exactly 16 sectors, or 8192 bytes, is what is "
"actually written to the beginning of the FreeBSD slice during installation. "
"Let us now proceed to study the <acronym>BTX</acronym> server program."
msgstr ""
"Tendo os arquivos que comp�em o <filename> bota </filename> programa, o "
"passo final � <emphasis> fundir </emphasis> eles. Isso � feito por um "
"programa especial chamado <filename> btxld </filename> (fonte localizada em "
"<filename> /usr/src/usr.sbin/btxld </filename> ). Alguns argumentos para "
"este programa incluem o nome do arquivo de sa�da ( <filename> bota </"
"filename> ), o seu ponto de entrada ( <literal> 0x2000 </literal> ) e seu "
"formato de arquivo (bin�rio bruto). Os v�rios arquivos s�o finalmente "
"mesclados por esse utilit�rio no arquivo <filename> bota </filename> , que "
"consiste em <filename> boot1 </filename> , <filename> boot2 </filename> , a "
"<literal> bsdlabel </literal> e o servidor <acronym>BTX</acronym> . Este "
"arquivo, que leva exatamente 16 setores, ou 8192 bytes, � o que realmente � "
"gravado no in�cio da fatia do FreeBSD durante a instala��o. Vamos agora "
"continuar a estudar o programa do servidor <acronym>BTX</acronym> . "

#. (itstool) path: sect1/para
#: book.translate.xml:1581
#, fuzzy
msgid ""
"The <acronym>BTX</acronym> server prepares a simple environment and switches "
"from 16-bit real mode to 32-bit protected mode, right before passing control "
"to the client. This includes initializing and updating the following data "
"structures:"
msgstr ""
"O servidor <acronym>BTX</acronym> prepara um ambiente simples e alterna do "
"modo real de 16 bits para o modo protegido de 32 bits, antes de passar o "
"controle para o cliente. Isso inclui inicializar e atualizar as seguintes "
"estruturas de dados:"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:1587
#, fuzzy
msgid "<primary>virtual v86 mode</primary>"
msgstr " <primary> modo virtual v86 </primary> "

#. (itstool) path: listitem/para
#: book.translate.xml:1590
#, fuzzy
msgid ""
"Modifies the <literal>Interrupt Vector Table (IVT)</literal>. The "
"<acronym>IVT</acronym> provides exception and interrupt handlers for Real-"
"Mode code."
msgstr ""
"Modifica o <literal> Tabela de vetores de interrup��o (IVT) </literal> . O "
"<acronym>IVT</acronym> fornece manipuladores de exce��o e interrup��o para o "
"c�digo de modo real. "

#. (itstool) path: listitem/para
#: book.translate.xml:1597
#, fuzzy
msgid ""
"The <literal>Interrupt Descriptor Table (IDT)</literal> is created. Entries "
"are provided for processor exceptions, hardware interrupts, two system calls "
"and V86 interface. The IDT provides exception and interrupt handlers for "
"Protected-Mode code."
msgstr ""
"O <literal> Tabela de descritores de interrup��o (IDT) </literal> � criado. "
"Entradas s�o fornecidas para exce��es de processador, interrup��es de "
"hardware, duas chamadas de sistema e interface V86. O IDT fornece "
"manipuladores de exce��o e interrup��o para o c�digo de modo protegido. "

#. (itstool) path: listitem/para
#: book.translate.xml:1605
#, fuzzy
msgid ""
"A <literal>Task-State Segment (TSS)</literal> is created. This is necessary "
"because the processor works in the <emphasis>least</emphasis> privileged "
"level when executing the client (<filename>boot2</filename>), but in the "
"<emphasis>most</emphasis> privileged level when executing the <acronym>BTX</"
"acronym> server."
msgstr ""
"UMA <literal> Segmento Estado-tarefa (TSS) </literal> � criado. Isso � "
"necess�rio porque o processador funciona no <emphasis> menos </emphasis> "
"n�vel privilegiado ao executar o cliente ( <filename> boot2 </filename> ), "
"mas no <emphasis> a maioria </emphasis> n�vel privilegiado ao executar o "
"servidor <acronym>BTX</acronym> . "

#. (itstool) path: footnote/para
#: book.translate.xml:1619
#, fuzzy
msgid ""
"Real-mode code and data are necessary when switching back to real mode from "
"protected mode, as suggested by the Intel manuals."
msgstr ""
"C�digo e dados de modo real s�o necess�rios ao retornar ao modo real a "
"partir do modo protegido, conforme sugerido pelos manuais da Intel."

#. (itstool) path: listitem/para
#: book.translate.xml:1614
#, fuzzy
msgid ""
"The <acronym>GDT</acronym> (Global Descriptor Table) is set up. Entries "
"(descriptors) are provided for supervisor code and data, user code and data, "
"and real-mode code and data. <_:footnote-1/>"
msgstr ""
"A <acronym>GDT</acronym> (Global Descriptor Table) est� configurada. "
"Entradas (descritores) s�o fornecidas para c�digo de supervisor e dados, "
"c�digo de usu�rio e dados, e c�digo e dados em modo real. <_: Footnote-1 />"

#. (itstool) path: sect1/para
#: book.translate.xml:1625
#, fuzzy
msgid ""
"Let us now start studying the actual implementation. Recall that "
"<filename>boot1</filename> made a jump to address <literal>0x9010</literal>, "
"the <acronym>BTX</acronym> server's entry point. Before studying program "
"execution there, note that the <acronym>BTX</acronym> server has a special "
"header at address range <literal>0x9000-0x900f</literal>, right before its "
"entry point. This header is defined as follows:"
msgstr ""
"Vamos agora come�ar a estudar a implementa��o real. Lembre-se que <filename> "
"boot1 </filename> fez um salto para abordar <literal> 0x9010 </literal> , o "
"ponto de entrada do servidor <acronym>BTX</acronym> . Antes de estudar a "
"execu��o do programa, observe que o servidor <acronym>BTX</acronym> possui "
"um cabe�alho especial na faixa de endere�os <literal> 0x9000-0x900f </"
"literal> , antes do seu ponto de entrada. Esse cabe�alho � definido da "
"seguinte maneira: "

#. (itstool) path: figure/title
#: book.translate.xml:1634 book.translate.xml:1665 book.translate.xml:1694
#: book.translate.xml:1735 book.translate.xml:1763 book.translate.xml:1834
#: book.translate.xml:1860 book.translate.xml:1911
msgid "<filename>sys/boot/i386/btx/btx/btx.S</filename>"
msgstr "<filename>sys/boot/i386/btx/btx/btx.S</filename>"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1636
#, no-wrap
msgid ""
"start:\t\t\t\t\t\t# Start of code\n"
"/*\n"
" * BTX header.\n"
" */\n"
"btx_hdr:\t.byte 0xeb\t\t\t# Machine ID\n"
"\t\t.byte 0xe\t\t\t# Header size\n"
"\t\t.ascii \"BTX\"\t\t\t# Magic\n"
"\t\t.byte 0x1\t\t\t# Major version\n"
"\t\t.byte 0x2\t\t\t# Minor version\n"
"\t\t.byte BTX_FLAGS\t\t\t# Flags\n"
"\t\t.word PAG_CNT-MEM_ORG&gt;&gt;0xc\t# Paging control\n"
"\t\t.word break-start\t\t# Text size\n"
"\t\t.long 0x0\t\t\t# Entry address"
msgstr ""
"start:\t\t\t\t\t\t# Start of code\n"
"/*\n"
" * BTX header.\n"
" */\n"
"btx_hdr:\t.byte 0xeb\t\t\t# Machine ID\n"
"\t\t.byte 0xe\t\t\t# Header size\n"
"\t\t.ascii \"BTX\"\t\t\t# Magic\n"
"\t\t.byte 0x1\t\t\t# Major version\n"
"\t\t.byte 0x2\t\t\t# Minor version\n"
"\t\t.byte BTX_FLAGS\t\t\t# Flags\n"
"\t\t.word PAG_CNT-MEM_ORG&gt;&gt;0xc\t# Paging control\n"
"\t\t.word break-start\t\t# Text size\n"
"\t\t.long 0x0\t\t\t# Entry address"

#. (itstool) path: sect1/para
#: book.translate.xml:1651
#, fuzzy
msgid ""
"Note the first two bytes are <literal>0xeb</literal> and <literal>0xe</"
"literal>. In the IA-32 architecture, these two bytes are interpreted as a "
"relative jump past the header into the entry point, so in theory, "
"<filename>boot1</filename> could jump here (address <literal>0x9000</"
"literal>) instead of address <literal>0x9010</literal>. Note that the last "
"field in the <acronym>BTX</acronym> header is a pointer to the client's "
"(<filename>boot2</filename>) entry point. This field is patched at link time."
msgstr ""
"Note que os dois primeiros bytes s�o <literal> 0xeb </literal> e <literal> "
"0xe </literal> . Na arquitetura IA-32, esses dois bytes s�o interpretados "
"como um salto relativo ap�s o cabe�alho para o ponto de entrada, ent�o, em "
"teoria, <filename> boot1 </filename> poderia pular aqui (endere�o <literal> "
"0x9000 </literal> ) em vez de endere�o <literal> 0x9010 </literal> . Observe "
"que o �ltimo campo no cabe�alho <acronym>BTX</acronym> � um ponteiro para o "
"cliente ( <filename> boot2 </filename> ) ponto de entrada. Este campo � "
"corrigido no momento do link. "

#. (itstool) path: sect1/para
#: book.translate.xml:1661
#, fuzzy
msgid ""
"Immediately following the header is the <acronym>BTX</acronym> server's "
"entry point:"
msgstr ""
"Imediatamente ap�s o cabe�alho � o ponto de entrada do servidor "
"<acronym>BTX</acronym> :"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1667
#, no-wrap
msgid ""
"/*\n"
" * Initialization routine.\n"
" */\n"
"init:\t\tcli\t\t\t\t# Disable interrupts\n"
"\t\txor %ax,%ax\t\t\t# Zero/segment\n"
"\t\tmov %ax,%ss\t\t\t# Set up\n"
"\t\tmov $0x1800,%sp\t\t#  stack\n"
"\t\tmov %ax,%es\t\t\t# Address\n"
"\t\tmov %ax,%ds\t\t\t#  data\n"
"\t\tpushl $0x2\t\t\t# Clear\n"
"\t\tpopfl\t\t\t\t#  flags"
msgstr ""
"/*\n"
" * Initialization routine.\n"
" */\n"
"init:\t\tcli\t\t\t\t# Disable interrupts\n"
"\t\txor %ax,%ax\t\t\t# Zero/segment\n"
"\t\tmov %ax,%ss\t\t\t# Set up\n"
"\t\tmov $0x1800,%sp\t\t#  stack\n"
"\t\tmov %ax,%es\t\t\t# Address\n"
"\t\tmov %ax,%ds\t\t\t#  data\n"
"\t\tpushl $0x2\t\t\t# Clear\n"
"\t\tpopfl\t\t\t\t#  flags"

#. (itstool) path: sect1/para
#: book.translate.xml:1680
#, fuzzy
msgid ""
"This code disables interrupts, sets up a working stack (starting at address "
"<literal>0x1800</literal>) and clears the flags in the EFLAGS register. Note "
"that the <literal>popfl</literal> instruction pops out a doubleword (4 "
"bytes) from the stack and places it in the EFLAGS register. Because the "
"value actually popped is <literal>2</literal>, the EFLAGS register is "
"effectively cleared (IA-32 requires that bit 2 of the EFLAGS register always "
"be 1)."
msgstr ""
"Esse c�digo desabilita as interrup��es, configura uma pilha de trabalho "
"(iniciando no endere�o <literal> 0x1800 </literal> ) e apaga as bandeiras no "
"registro EFLAGS. Note que o <literal> popfl </literal> A instru��o extrai "
"uma palavra dupla (4 bytes) da pilha e a coloca no registro EFLAGS. Porque o "
"valor realmente estourou � <literal> 2 </literal> , o registro EFLAGS � "
"efetivamente limpo (o IA-32 requer que o bit 2 do registro EFLAGS seja "
"sempre 1). "

#. (itstool) path: sect1/para
#: book.translate.xml:1689
#, fuzzy
msgid ""
"Our next code block clears (sets to <literal>0</literal>) the memory range "
"<literal>0x5e00-0x8fff</literal>. This range is where the various data "
"structures will be created:"
msgstr ""
"Nosso pr�ximo bloco de c�digo � apagado <literal> 0 </literal> ) o intervalo "
"de mem�ria <literal> 0x5e00-0x8fff </literal> . Este intervalo � onde as "
"v�rias estruturas de dados ser�o criadas: "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1696
#, no-wrap
msgid ""
"/*\n"
" * Initialize memory.\n"
" */\n"
"\t\tmov $0x5e00,%di\t\t# Memory to initialize\n"
"\t\tmov $(0x9000-0x5e00)/2,%cx\t# Words to zero\n"
"\t\trep\t\t\t\t# Zero-fill\n"
"\t\tstosw\t\t\t\t#  memory"
msgstr ""
"/*\n"
" * Initialize memory.\n"
" */\n"
"\t\tmov $0x5e00,%di\t\t# Memory to initialize\n"
"\t\tmov $(0x9000-0x5e00)/2,%cx\t# Words to zero\n"
"\t\trep\t\t\t\t# Zero-fill\n"
"\t\tstosw\t\t\t\t#  memory"

#. (itstool) path: sect1/para
#: book.translate.xml:1705
#, fuzzy
msgid ""
"Recall that <filename>boot1</filename> was originally loaded to address "
"<literal>0x7c00</literal>, so, with this memory initialization, that copy "
"effectively disappeared. However, also recall that <filename>boot1</"
"filename> was relocated to <literal>0x700</literal>, so <emphasis>that</"
"emphasis> copy is still in memory, and the <acronym>BTX</acronym> server "
"will make use of it."
msgstr ""
"Lembre-se que <filename> boot1 </filename> foi originalmente carregado para "
"resolver <literal> 0x7c00 </literal> Assim, com esta inicializa��o de "
"mem�ria, essa c�pia efetivamente desapareceu. No entanto, lembre-se tamb�m "
"que <filename> boot1 </filename> foi transferido para <literal> 0x700 </"
"literal> , assim <emphasis> aquele </emphasis> a c�pia ainda est� na "
"mem�ria, e o servidor <acronym>BTX</acronym> far� uso dela. "

#. (itstool) path: sect1/para
#: book.translate.xml:1713
msgid ""
"Next, the real-mode <acronym>IVT</acronym> (Interrupt Vector Table is "
"updated. The <acronym>IVT</acronym> is an array of segment/offset pairs for "
"exception and interrupt handlers. The <acronym>BIOS</acronym> normally maps "
"hardware interrupts to interrupt vectors <literal>0x8</literal> to "
"<literal>0xf</literal> and <literal>0x70</literal> to <literal>0x77</"
"literal> but, as will be seen, the 8259A Programmable Interrupt Controller, "
"the chip controlling the actual mapping of hardware interrupts to interrupt "
"vectors, is programmed to remap these interrupt vectors from "
"<literal>0x8-0xf</literal> to <literal>0x20-0x27</literal> and from "
"<literal>0x70-0x77</literal> to <literal>0x28-0x2f</literal>. Thus, "
"interrupt handlers are provided for interrupt vectors <literal>0x20-0x2f</"
"literal>. The reason the <acronym>BIOS</acronym>-provided handlers are not "
"used directly is because they work in 16-bit real mode, but not 32-bit "
"protected mode. Processor mode will be switched to 32-bit protected mode "
"shortly. However, the <acronym>BTX</acronym> server sets up a mechanism to "
"effectively use the handlers provided by the <acronym>BIOS</acronym>:"
msgstr ""
"Em seguida, a <acronym>IVT</acronym> em modo real (Tabela de Vetores de "
"Interrupções) é atualizado. O <acronym>IVT</acronym> é uma matriz de pares "
"de segmento/deslocamento para manipuladores de exceção e interrupções. A "
"<acronym>BIOS</acronym> normalmente mapeia interrupções de hardware para "
"vetores de interrupção <literal>0x8</literal> para <literal>0xf</literal> e "
"<literal>0x70</literal> para <literal>0x77</literal> mas, como será visto, o "
"Controlador de Interrupção Programável 8259A, o chip que controla o "
"mapeamento real de interrupções de hardware para vetores de interrupção, é "
"programado para remapear esses vetores de interrupção de <literal>0x8-0xf</"
"literal> para <literal>0x20-0x27</literal> e de <literal>0x70-0x77</literal> "
"para <literal>0x28-0x2f</literal> . Assim, manipuladores de interrupção são "
"fornecidos para vetores de interrupção <literal>0x20-0x2f</literal>. A razão "
"pela qual os manipuladores fornecidos pela <acronym>BIOS</acronym> não são "
"usados ​​diretamente é porque eles funcionam no modo real de 16 bits, mas não "
"no modo protegido de 32 bits. O modo do processador será alternado para o "
"modo protegido de 32 bits em breve. No entanto, o servidor <acronym>BTX</"
"acronym> define um mecanismo para usar efetivamente os manipuladores "
"fornecidos pela <acronym>BIOS</acronym>:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1737
#, no-wrap
msgid ""
"/*\n"
" * Update real mode IDT for reflecting hardware interrupts.\n"
" */\n"
"\t\tmov $intr20,%bx\t\t\t# Address first handler\n"
"\t\tmov $0x10,%cx\t\t\t# Number of handlers\n"
"\t\tmov $0x20*4,%di\t\t\t# First real mode IDT entry\n"
"init.0:\t\tmov %bx,(%di)\t\t\t# Store IP\n"
"\t\tinc %di\t\t\t\t# Address next\n"
"\t\tinc %di\t\t\t\t#  entry\n"
"\t\tstosw\t\t\t\t# Store CS\n"
"\t\tadd $4,%bx\t\t\t# Next handler\n"
"\t\tloop init.0\t\t\t# Next IRQ"
msgstr ""
"/*\n"
" * Update real mode IDT for reflecting hardware interrupts.\n"
" */\n"
"\t\tmov $intr20,%bx\t\t\t# Address first handler\n"
"\t\tmov $0x10,%cx\t\t\t# Number of handlers\n"
"\t\tmov $0x20*4,%di\t\t\t# First real mode IDT entry\n"
"init.0:\t\tmov %bx,(%di)\t\t\t# Store IP\n"
"\t\tinc %di\t\t\t\t# Address next\n"
"\t\tinc %di\t\t\t\t#  entry\n"
"\t\tstosw\t\t\t\t# Store CS\n"
"\t\tadd $4,%bx\t\t\t# Next handler\n"
"\t\tloop init.0\t\t\t# Next IRQ"

#. (itstool) path: sect1/para
#: book.translate.xml:1751
msgid ""
"The next block creates the <acronym>IDT</acronym> (Interrupt Descriptor "
"Table). The <acronym>IDT</acronym> is analogous, in protected mode, to the "
"<acronym>IVT</acronym> in real mode. That is, the <acronym>IDT</acronym> "
"describes the various exception and interrupt handlers used when the "
"processor is executing in protected mode. In essence, it also consists of an "
"array of segment/offset pairs, although the structure is somewhat more "
"complex, because segments in protected mode are different than in real mode, "
"and various protection mechanisms apply:"
msgstr ""
"O próximo bloco cria o <acronym>IDT</acronym> (Interrupt Descriptor Table). "
"O <acronym>IDT</acronym> é análogo, no modo protegido, ao <acronym>IVT</"
"acronym> em modo real. Ou seja, o <acronym>IDT</acronym> descreve os vários "
"manipuladores de exceção e interrupções usados ​​quando o processador está "
"executando em modo protegido. Em essência, ele também consiste em uma matriz "
"de pares segmento/deslocadores, embora a estrutura seja um pouco mais "
"complexa, porque os segmentos no modo protegido são diferentes do modo real, "
"e vários mecanismos de proteção se aplicam: "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1765
#, no-wrap
msgid ""
"/*\n"
" * Create IDT.\n"
" */\n"
"\t\tmov $0x5e00,%di\t\t\t# IDT's address\n"
"\t\tmov $idtctl,%si\t\t\t# Control string\n"
"init.1:\t\tlodsb\t\t\t\t# Get entry\n"
"\t\tcbw\t\t\t\t#  count\n"
"\t\txchg %ax,%cx\t\t\t#  as word\n"
"\t\tjcxz init.4\t\t\t# If done\n"
"\t\tlodsb\t\t\t\t# Get segment\n"
"\t\txchg %ax,%dx\t\t\t#  P:DPL:type\n"
"\t\tlodsw\t\t\t\t# Get control\n"
"\t\txchg %ax,%bx\t\t\t#  set\n"
"\t\tlodsw\t\t\t\t# Get handler offset\n"
"\t\tmov $SEL_SCODE,%dh\t\t# Segment selector\n"
"init.2:\t\tshr %bx\t\t\t\t# Handle this int?\n"
"\t\tjnc init.3\t\t\t# No\n"
"\t\tmov %ax,(%di)\t\t\t# Set handler offset\n"
"\t\tmov %dh,0x2(%di)\t\t#  and selector\n"
"\t\tmov %dl,0x5(%di)\t\t# Set P:DPL:type\n"
"\t\tadd $0x4,%ax\t\t\t# Next handler\n"
"init.3:\t\tlea 0x8(%di),%di\t\t# Next entry\n"
"\t\tloop init.2\t\t\t# Till set done\n"
"\t\tjmp init.1\t\t\t# Continue"
msgstr ""
"/*\n"
" * Create IDT.\n"
" */\n"
"\t\tmov $0x5e00,%di\t\t\t# IDT's address\n"
"\t\tmov $idtctl,%si\t\t\t# Control string\n"
"init.1:\t\tlodsb\t\t\t\t# Get entry\n"
"\t\tcbw\t\t\t\t#  count\n"
"\t\txchg %ax,%cx\t\t\t#  as word\n"
"\t\tjcxz init.4\t\t\t# If done\n"
"\t\tlodsb\t\t\t\t# Get segment\n"
"\t\txchg %ax,%dx\t\t\t#  P:DPL:type\n"
"\t\tlodsw\t\t\t\t# Get control\n"
"\t\txchg %ax,%bx\t\t\t#  set\n"
"\t\tlodsw\t\t\t\t# Get handler offset\n"
"\t\tmov $SEL_SCODE,%dh\t\t# Segment selector\n"
"init.2:\t\tshr %bx\t\t\t\t# Handle this int?\n"
"\t\tjnc init.3\t\t\t# No\n"
"\t\tmov %ax,(%di)\t\t\t# Set handler offset\n"
"\t\tmov %dh,0x2(%di)\t\t#  and selector\n"
"\t\tmov %dl,0x5(%di)\t\t# Set P:DPL:type\n"
"\t\tadd $0x4,%ax\t\t\t# Next handler\n"
"init.3:\t\tlea 0x8(%di),%di\t\t# Next entry\n"
"\t\tloop init.2\t\t\t# Till set done\n"
"\t\tjmp init.1\t\t\t# Continue"

#. (itstool) path: sect1/para
#: book.translate.xml:1791
msgid ""
"Each entry in the <literal>IDT</literal> is 8 bytes long. Besides the "
"segment/offset information, they also describe the segment type, privilege "
"level, and whether the segment is present in memory or not. The construction "
"is such that interrupt vectors from <literal>0</literal> to <literal>0xf</"
"literal> (exceptions) are handled by function <literal>intx00</literal>; "
"vector <literal>0x10</literal> (also an exception) is handled by "
"<literal>intx10</literal>; hardware interrupts, which are later configured "
"to start at interrupt vector <literal>0x20</literal> all the way to "
"interrupt vector <literal>0x2f</literal>, are handled by function "
"<literal>intx20</literal>. Lastly, interrupt vector <literal>0x30</literal>, "
"which is used for system calls, is handled by <literal>intx30</literal>, and "
"vectors <literal>0x31</literal> and <literal>0x32</literal> are handled by "
"<literal>intx31</literal>. It must be noted that only descriptors for "
"interrupt vectors <literal>0x30</literal>, <literal>0x31</literal> and "
"<literal>0x32</literal> are given privilege level 3, the same privilege "
"level as the <filename>boot2</filename> client, which means the client can "
"execute a software-generated interrupt to this vectors through the "
"<literal>int</literal> instruction without failing (this is the way "
"<filename>boot2</filename> use the services provided by the <acronym>BTX</"
"acronym> server). Also, note that <emphasis>only</emphasis> software-"
"generated interrupts are protected from code executing in lesser privilege "
"levels. Hardware-generated interrupts and processor-generated exceptions are "
"<emphasis>always</emphasis> handled adequately, regardless of the actual "
"privileges involved."
msgstr ""
"Cada entrada no <literal>IDT</literal> tem 8 bytes de comprimento. Além das "
"informações de segmento/deslocamento, elas também descrevem o tipo de "
"segmento, nível de privilégio e se o segmento está presente na memória ou "
"não. A construção é tal que vetores de interrupção de <literal>0</literal> "
"para <literal>0xf</literal> (exceções) são manipulados por função "
"<literal>intx00</literal>; vetor <literal>0x10</literal> (também uma "
"exceção) é manipulado por <literal>intx10</literal>; interrupções de "
"hardware, que são configuradas posteriormente para iniciar no vetor de "
"interrupção <literal>0x20</literal> de toda forma para o vetor interrupção "
"<literal>0x2f</literal> , são manipulados pela função <literal>intx20</"
"literal>. Por fim, vetor de interrupção <literal>0x30</literal>, que é usado "
"para chamadas do sistema, é manipulado por <literal>intx30</literal> e "
"vetores <literal>0x31</literal> e <literal>0x32</literal> são manipulados "
"por <literal>intx31</literal>. Deve-se notar que apenas descritores para "
"vetores de interrupção <literal>0x30</literal> , <literal>0x31</literal> e "
"<literal>0x32</literal> recebem o nível de privilégio 3, o mesmo nível de "
"privilégio que o cliente <filename>boot2</filename>, o que significa que o "
"cliente pode executar uma interrupção gerada por software para esses vetores "
"através da instrução <literal>int</literal> sem falhar (este é o modo como o "
"<filename>boot2</filename> usa os serviços fornecidos pelo servidor "
"<acronym>BTX</acronym>). Além disso, note que <emphasis>apenas</emphasis> "
"interrupções geradas por software são protegidas do código sendo executado "
"em níveis de privilégios menores. Interrupções geradas por hardware e "
"exceções geradas pelo processador <emphasis>sempre</emphasis> são manuseado "
"de forma adequada, independentemente dos privilégios reais envolvidos. "

#. (itstool) path: sect1/para
#: book.translate.xml:1821
msgid ""
"The next step is to initialize the <acronym>TSS</acronym> (Task-State "
"Segment). The <acronym>TSS</acronym> is a hardware feature that helps the "
"operating system or executive software implement multitasking functionality "
"through process abstraction. The IA-32 architecture demands the creation and "
"use of <emphasis>at least</emphasis> one <acronym>TSS</acronym> if "
"multitasking facilities are used or different privilege levels are defined. "
"Because the <filename>boot2</filename> client is executed in privilege level "
"3, but the <acronym>BTX</acronym> server does in privilege level 0, a "
"<acronym>TSS</acronym> must be defined:"
msgstr ""
"O próximo passo é inicializar o <acronym>TSS</acronym> (Task-State Segment). "
"O <acronym>TSS</acronym> é um recurso de hardware que ajuda o sistema "
"operacional ou o software executivo a implementar a funcionalidade "
"multitarefa por meio da abstração do processo. A arquitetura IA-32 exige a "
"criação e o uso de <emphasis>ao menos</emphasis> um <acronym>TSS</acronym> "
"se forem usados ​​recursos multitarefa ou se forem definidos níveis de "
"privilégios diferentes. Porque o  cliente <filename>boot2</filename> é "
"executado no nível de privilégio 3, mas o servidor <acronym>BTX</acronym> "
"executado no nível de privilégio 0, um <acronym>TSS</acronym> deve ser "
"definido:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1836
#, no-wrap
msgid ""
"/*\n"
" * Initialize TSS.\n"
" */\n"
"init.4:\t\tmovb $_ESP0H,TSS_ESP0+1(%di)\t# Set ESP0\n"
"\t\tmovb $SEL_SDATA,TSS_SS0(%di)\t# Set SS0\n"
"\t\tmovb $_TSSIO,TSS_MAP(%di)\t# Set I/O bit map base"
msgstr ""
"/*\n"
" * Initialize TSS.\n"
" */\n"
"init.4:\t\tmovb $_ESP0H,TSS_ESP0+1(%di)\t# Set ESP0\n"
"\t\tmovb $SEL_SDATA,TSS_SS0(%di)\t# Set SS0\n"
"\t\tmovb $_TSSIO,TSS_MAP(%di)\t# Set I/O bit map base"

#. (itstool) path: sect1/para
#: book.translate.xml:1844
msgid ""
"Note that a value is given for the Privilege Level 0 stack pointer and stack "
"segment in the <acronym>TSS</acronym>. This is needed because, if an "
"interrupt or exception is received while executing <filename>boot2</"
"filename> in Privilege Level 3, a change to Privilege Level 0 is "
"automatically performed by the processor, so a new working stack is needed. "
"Finally, the I/O Map Base Address field of the <acronym>TSS</acronym> is "
"given a value, which is a 16-bit offset from the beginning of the "
"<acronym>TSS</acronym> to the I/O Permission Bitmap and the Interrupt "
"Redirection Bitmap."
msgstr ""
"Note que um valor é dado para o ponteiro da pilha de Privilégio de Nível 0 e "
"segmento da pilha no <acronym>TSS</acronym> . Isso é necessário porque, se "
"uma interrupção ou exceção for recebida durante o <filename>boot2</filename> "
"estiver executando no Privilege de Nível 3, uma alteração no Privilege de "
"Nível 0 é executada automaticamente pelo processador, portanto, é necessária "
"uma nova pilha de trabalho. Finalmente, o campo Map Base Addess de I/O do "
"<acronym>TSS</acronym> recebe um valor, que é um deslocamento de 16 bits "
"desde o início do <acronym>TSS</acronym> até o Bitmap de Permissão de I/O e "
"o Bitmap de Redirecionamento de Interrupções. "

#. (itstool) path: sect1/para
#: book.translate.xml:1855
msgid ""
"After the <acronym>IDT</acronym> and <acronym>TSS</acronym> are created, the "
"processor is ready to switch to protected mode. This is done in the next "
"block:"
msgstr ""
"Depois que o <acronym>IDT</acronym> e o <acronym>TSS</acronym> são criados, "
"o processador está pronto para mudar para o modo protegido. Isso é feito no "
"próximo bloco:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1862
#, no-wrap
msgid ""
"/*\n"
" * Bring up the system.\n"
" */\n"
"\t\tmov $0x2820,%bx\t\t\t# Set protected mode\n"
"\t\tcallw setpic\t\t\t#  IRQ offsets\n"
"\t\tlidt idtdesc\t\t\t# Set IDT\n"
"\t\tlgdt gdtdesc\t\t\t# Set GDT\n"
"\t\tmov %cr0,%eax\t\t\t# Switch to protected\n"
"\t\tinc %ax\t\t\t\t#  mode\n"
"\t\tmov %eax,%cr0\t\t\t#\n"
"\t\tljmp $SEL_SCODE,$init.8\t\t# To 32-bit code\n"
"\t\t.code32\n"
"init.8:\t\txorl %ecx,%ecx\t\t\t# Zero\n"
"\t\tmovb $SEL_SDATA,%cl\t\t# To 32-bit\n"
"\t\tmovw %cx,%ss\t\t\t#  stack"
msgstr ""
"/*\n"
" * Bring up the system.\n"
" */\n"
"\t\tmov $0x2820,%bx\t\t\t# Set protected mode\n"
"\t\tcallw setpic\t\t\t#  IRQ offsets\n"
"\t\tlidt idtdesc\t\t\t# Set IDT\n"
"\t\tlgdt gdtdesc\t\t\t# Set GDT\n"
"\t\tmov %cr0,%eax\t\t\t# Switch to protected\n"
"\t\tinc %ax\t\t\t\t#  mode\n"
"\t\tmov %eax,%cr0\t\t\t#\n"
"\t\tljmp $SEL_SCODE,$init.8\t\t# To 32-bit code\n"
"\t\t.code32\n"
"init.8:\t\txorl %ecx,%ecx\t\t\t# Zero\n"
"\t\tmovb $SEL_SDATA,%cl\t\t# To 32-bit\n"
"\t\tmovw %cx,%ss\t\t\t#  stack"

#. (itstool) path: sect1/para
#: book.translate.xml:1879
#, fuzzy
msgid ""
"First, a call is made to <literal>setpic</literal> to program the 8259A "
"<acronym>PIC</acronym> (Programmable Interrupt Controller). This chip is "
"connected to multiple hardware interrupt sources. Upon receiving an "
"interrupt from a device, it signals the processor with the appropriate "
"interrupt vector. This can be customized so that specific interrupts are "
"associated with specific interrupt vectors, as explained before. Next, the "
"<acronym>IDTR</acronym> (Interrupt Descriptor Table Register) and "
"<acronym>GDTR</acronym> (Global Descriptor Table Register) are loaded with "
"the instructions <literal>lidt</literal> and <literal>lgdt</literal>, "
"respectively. These registers are loaded with the base address and limit "
"address for the <acronym>IDT</acronym> and <acronym>GDT</acronym>. The "
"following three instructions set the Protection Enable (PE) bit of the "
"<literal>%cr0</literal> register. This effectively switches the processor to "
"32-bit protected mode. Next, a long jump is made to <literal>init.8</"
"literal> using segment selector SEL_SCODE, which selects the Supervisor Code "
"Segment. The processor is effectively executing in CPL 0, the most "
"privileged level, after this jump. Finally, the Supervisor Data Segment is "
"selected for the stack by assigning the segment selector SEL_SDATA to the "
"<literal>%ss</literal> register. This data segment also has a privilege "
"level of <literal>0</literal>."
msgstr ""
"Primeiro, uma chamada � feita para <literal> setpic </literal> para "
"programar o 8259A <acronym>PIC</acronym> (Programmable Interrupt "
"Controller). Este chip est� conectado a v�rias fontes de interrup��o de "
"hardware. Ao receber uma interrup��o de um dispositivo, ele sinaliza ao "
"processador o vetor de interrup��o apropriado. Isso pode ser personalizado "
"para que interrup��es espec�ficas sejam associadas a vetores de interrup��o "
"espec�ficos, conforme explicado anteriormente. Em seguida, o <acronym>IDTR</"
"acronym> (Registro da Tabela de Descritores de Interrup��es) e o "
"<acronym>GDTR</acronym> (Registro da Tabela de Descritores Globais) s�o "
"carregados com as instru��es <literal> lidt </literal> e <literal> lgdt </"
"literal> , respectivamente. Esses registros s�o carregados com o endere�o "
"base e o endere�o limite para o <acronym>IDT</acronym> e o <acronym>GDT</"
"acronym> . As tr�s instru��es a seguir definem o bit Protection Enable (PE) "
"do <literal> % cr0 </literal> registo. Isso efetivamente alterna o "
"processador para o modo protegido de 32 bits. Em seguida, um longo salto � "
"feito para <literal> init.8 </literal> usando o seletor de segmento "
"SEL_SCODE, que seleciona o segmento de c�digo de supervisor. O processador "
"est� efetivamente executando em CPL 0, o n�vel mais privilegiado, ap�s esse "
"salto. Finalmente, o Segmento de Dados do Supervisor � selecionado para a "
"pilha, atribuindo o seletor de segmento SEL_SDATA <literal> % ss </literal> "
"registo. Esse segmento de dados tamb�m tem um n�vel de privil�gio de "
"<literal> 0 </literal> "

#. (itstool) path: sect1/para
#: book.translate.xml:1904
#, fuzzy
msgid ""
"Our last code block is responsible for loading the <acronym>TR</acronym> "
"(Task Register) with the segment selector for the <acronym>TSS</acronym> we "
"created earlier, and setting the User Mode environment before passing "
"execution control to the <filename>boot2</filename> client."
msgstr ""
"Nosso �ltimo bloco de c�digo � respons�vel por carregar o <acronym>TR</"
"acronym> (Task Register) com o seletor de segmento para o <acronym>TSS</"
"acronym> que criamos anteriormente e configurar o ambiente do Modo de "
"Usu�rio antes de passar o controle de execu��o para o <filename> boot2 </"
"filename> cliente."

#. (itstool) path: figure/programlisting
#: book.translate.xml:1913
#, no-wrap
msgid ""
"/*\n"
" * Launch user task.\n"
" */\n"
"\t\tmovb $SEL_TSS,%cl\t\t# Set task\n"
"\t\tltr %cx\t\t\t\t#  register\n"
"\t\tmovl $0xa000,%edx\t\t# User base address\n"
"\t\tmovzwl %ss:BDA_MEM,%eax\t\t# Get free memory\n"
"\t\tshll $0xa,%eax\t\t\t# To bytes\n"
"\t\tsubl $ARGSPACE,%eax\t\t# Less arg space\n"
"\t\tsubl %edx,%eax\t\t\t# Less base\n"
"\t\tmovb $SEL_UDATA,%cl\t\t# User data selector\n"
"\t\tpushl %ecx\t\t\t# Set SS\n"
"\t\tpushl %eax\t\t\t# Set ESP\n"
"\t\tpush $0x202\t\t\t# Set flags (IF set)\n"
"\t\tpush $SEL_UCODE\t\t\t# Set CS\n"
"\t\tpushl btx_hdr+0xc\t\t# Set EIP\n"
"\t\tpushl %ecx\t\t\t# Set GS\n"
"\t\tpushl %ecx\t\t\t# Set FS\n"
"\t\tpushl %ecx\t\t\t# Set DS\n"
"\t\tpushl %ecx\t\t\t# Set ES\n"
"\t\tpushl %edx\t\t\t# Set EAX\n"
"\t\tmovb $0x7,%cl\t\t\t# Set remaining\n"
"init.9:\t\tpush $0x0\t\t\t#  general\n"
"\t\tloop init.9\t\t\t#  registers\n"
"\t\tpopa\t\t\t\t#  and initialize\n"
"\t\tpopl %es\t\t\t# Initialize\n"
"\t\tpopl %ds\t\t\t#  user\n"
"\t\tpopl %fs\t\t\t#  segment\n"
"\t\tpopl %gs\t\t\t#  registers\n"
"\t\tiret\t\t\t\t# To user mode"
msgstr ""
"/*\n"
" * Launch user task.\n"
" */\n"
"\t\tmovb $SEL_TSS,%cl\t\t# Set task\n"
"\t\tltr %cx\t\t\t\t#  register\n"
"\t\tmovl $0xa000,%edx\t\t# User base address\n"
"\t\tmovzwl %ss:BDA_MEM,%eax\t\t# Get free memory\n"
"\t\tshll $0xa,%eax\t\t\t# To bytes\n"
"\t\tsubl $ARGSPACE,%eax\t\t# Less arg space\n"
"\t\tsubl %edx,%eax\t\t\t# Less base\n"
"\t\tmovb $SEL_UDATA,%cl\t\t# User data selector\n"
"\t\tpushl %ecx\t\t\t# Set SS\n"
"\t\tpushl %eax\t\t\t# Set ESP\n"
"\t\tpush $0x202\t\t\t# Set flags (IF set)\n"
"\t\tpush $SEL_UCODE\t\t\t# Set CS\n"
"\t\tpushl btx_hdr+0xc\t\t# Set EIP\n"
"\t\tpushl %ecx\t\t\t# Set GS\n"
"\t\tpushl %ecx\t\t\t# Set FS\n"
"\t\tpushl %ecx\t\t\t# Set DS\n"
"\t\tpushl %ecx\t\t\t# Set ES\n"
"\t\tpushl %edx\t\t\t# Set EAX\n"
"\t\tmovb $0x7,%cl\t\t\t# Set remaining\n"
"init.9:\t\tpush $0x0\t\t\t#  general\n"
"\t\tloop init.9\t\t\t#  registers\n"
"\t\tpopa\t\t\t\t#  and initialize\n"
"\t\tpopl %es\t\t\t# Initialize\n"
"\t\tpopl %ds\t\t\t#  user\n"
"\t\tpopl %fs\t\t\t#  segment\n"
"\t\tpopl %gs\t\t\t#  registers\n"
"\t\tiret\t\t\t\t# To user mode"

#. (itstool) path: sect1/para
#: book.translate.xml:1945
#, fuzzy
msgid ""
"Note that the client's environment include a stack segment selector and "
"stack pointer (registers <literal>%ss</literal> and <literal>%esp</"
"literal>). Indeed, once the <acronym>TR</acronym> is loaded with the "
"appropriate stack segment selector (instruction <literal>ltr</literal>), the "
"stack pointer is calculated and pushed onto the stack along with the stack's "
"segment selector. Next, the value <literal>0x202</literal> is pushed onto "
"the stack; it is the value that the EFLAGS will get when control is passed "
"to the client. Also, the User Mode code segment selector and the client's "
"entry point are pushed. Recall that this entry point is patched in the "
"<acronym>BTX</acronym> header at link time. Finally, segment selectors "
"(stored in register <literal>%ecx</literal>) for the segment registers "
"<literal>%gs, %fs, %ds and %es</literal> are pushed onto the stack, along "
"with the value at <literal>%edx</literal> (<literal>0xa000</literal>). Keep "
"in mind the various values that have been pushed onto the stack (they will "
"be popped out shortly). Next, values for the remaining general purpose "
"registers are also pushed onto the stack (note the <literal>loop</literal> "
"that pushes the value <literal>0</literal> seven times). Now, values will be "
"started to be popped out of the stack. First, the <literal>popa</literal> "
"instruction pops out of the stack the latest seven values pushed. They are "
"stored in the general purpose registers in order <literal>%edi, %esi, %ebp, "
"%ebx, %edx, %ecx, %eax</literal>. Then, the various segment selectors pushed "
"are popped into the various segment registers. Five values still remain on "
"the stack. They are popped when the <literal>iret</literal> instruction is "
"executed. This instruction first pops the value that was pushed from the "
"<acronym>BTX</acronym> header. This value is a pointer to <filename>boot2</"
"filename>'s entry point. It is placed in the register <literal>%eip</"
"literal>, the instruction pointer register. Next, the segment selector for "
"the User Code Segment is popped and copied to register <literal>%cs</"
"literal>. Remember that this segment's privilege level is 3, the least "
"privileged level. This means that we must provide values for the stack of "
"this privilege level. This is why the processor, besides further popping the "
"value for the EFLAGS register, does two more pops out of the stack. These "
"values go to the stack pointer (<literal>%esp</literal>) and the stack "
"segment (<literal>%ss</literal>). Now, execution continues at "
"<literal>boot0</literal>'s entry point."
msgstr ""
"Note que o ambiente do cliente inclui um seletor de segmento de pilha e "
"ponteiro de pilha (registros <literal> % ss </literal> e <literal> % esp </"
"literal> ). Na verdade, uma vez que o <acronym>TR</acronym> � carregado com "
"o seletor de segmento de pilha apropriado (instru��o <literal> ltr </"
"literal> ), o ponteiro da pilha � calculado e colocado na pilha junto com o "
"seletor de segmento da pilha. Em seguida, o valor <literal> 0x202 </literal> "
"� empurrado para a pilha; � o valor que o EFLAGS obter� quando o controle "
"for passado para o cliente. Al�m disso, o seletor de segmento de c�digo do "
"modo de usu�rio e o ponto de entrada do cliente s�o pressionados. Lembre-se "
"de que esse ponto de entrada � corrigido no cabe�alho <acronym>BTX</acronym> "
"no momento do link. Finalmente, os seletores de segmento (armazenados no "
"registrador <literal> % ecx </literal> ) para os registros de segmento "
"<literal> % gs,% fs,% ds e% es </literal> s�o empurrados para a pilha, "
"juntamente com o valor em <literal> % edx </literal> ( <literal> 0xa000 </"
"literal> ). Tenha em mente os v�rios valores que foram colocados na pilha "
"(eles ser�o exibidos em breve). Em seguida, os valores dos demais "
"registradores de prop�sito geral tamb�m s�o colocados na pilha (observe "
"<literal> la�o </literal> que empurra o valor <literal> 0 </literal> sete "
"vezes). Agora, os valores ser�o iniciados para serem removidos da pilha. "
"Primeiro, o <literal> popa </literal> instru��o sai da pilha os �ltimos sete "
"valores empurrados. Eles s�o armazenados nos registros de prop�sito geral "
"para <literal> % edi,% esi,% ebp,% ebx,% edx,% ecx,% eax </literal> . Em "
"seguida, os v�rios seletores de segmento pressionados s�o exibidos nos "
"v�rios registros de segmento. Cinco valores ainda permanecem na pilha. Eles "
"s�o popped quando o <literal> iret </literal> instru��o � executada. Esta "
"instru��o primeiro mostra o valor que foi empurrado do cabe�alho "
"<acronym>BTX</acronym> . Este valor � um ponteiro para <filename> boot2 </"
"filename> ponto de entrada. Ele � colocado no registro <literal> % eip </"
"literal> , o registrador de ponteiros de instru��o. Em seguida, o seletor de "
"segmento do segmento de c�digo do usu�rio � exibido e copiado para registro "
"<literal> % cs </literal> . Lembre-se de que o n�vel de privil�gio deste "
"segmento � 3, o n�vel menos privilegiado. Isso significa que devemos "
"fornecer valores para a pilha desse n�vel de privil�gio. � por isso que o "
"processador, al�m de aumentar o valor do registrador EFLAGS, faz mais dois "
"pops da pilha. Esses valores v�o para o ponteiro da pilha ( <literal> % esp "
"</literal> ) e o segmento da pilha ( <literal> % ss </literal> ). Agora, a "
"execu��o continua em <literal> boot0 </literal> ponto de entrada. "

#. (itstool) path: sect1/para
#: book.translate.xml:1991
#, fuzzy
msgid ""
"It is important to note how the User Code Segment is defined. This segment's "
"<emphasis>base address</emphasis> is set to <literal>0xa000</literal>. This "
"means that code memory addresses are <emphasis>relative</emphasis> to "
"address 0xa000; if code being executed is fetched from address "
"<literal>0x2000</literal>, the <emphasis>actual</emphasis> memory addressed "
"is <literal>0xa000+0x2000=0xc000</literal>."
msgstr ""
"� importante observar como o segmento de c�digo do usu�rio � definido. Esse "
"segmento � <emphasis> endere�o base </emphasis> est� configurado para "
"<literal> 0xa000 </literal> . Isso significa que os endere�os de mem�ria de "
"c�digo s�o <emphasis> relativo </emphasis> para endere�ar 0xa000; se o "
"c�digo que est� sendo executado for buscado no endere�o <literal> 0x2000 </"
"literal> , a <emphasis> real </emphasis> mem�ria endere�ada � <literal> "
"0xa000 + 0x2000 = 0xc000 </literal> "

#. (itstool) path: sect1/title
#: book.translate.xml:2002
msgid "<application>boot2</application> Stage"
msgstr "Etapa <application>boot2</application>"

#. (itstool) path: sect1/para
#: book.translate.xml:2004
#, fuzzy
msgid ""
"<literal>boot2</literal> defines an important structure, <literal>struct "
"bootinfo</literal>. This structure is initialized by <literal>boot2</"
"literal> and passed to the loader, and then further to the kernel. Some "
"nodes of this structures are set by <literal>boot2</literal>, the rest by "
"the loader. This structure, among other information, contains the kernel "
"filename, <acronym>BIOS</acronym> harddisk geometry, <acronym>BIOS</acronym> "
"drive number for boot device, physical memory available, <literal>envp</"
"literal> pointer etc. The definition for it is:"
msgstr ""
" <literal> boot2 </literal> define uma estrutura importante, <literal> "
"struct bootinfo </literal> . Essa estrutura � inicializada por <literal> "
"boot2 </literal> e passou para o carregador e depois para o kernel. Alguns "
"n�s desta estrutura s�o definidos por <literal> boot2 </literal> , o resto "
"pelo carregador. Esta estrutura, entre outras informa��es, cont�m o nome do "
"arquivo do kernel, <acronym>BIOS</acronym> geometria disco r�gido, n�mero da "
"unidade <acronym>BIOS</acronym> para dispositivo de inicializa��o, mem�ria "
"f�sica dispon�vel, <literal> envp </literal> ponteiro etc. A defini��o para "
"isso �: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2015
#, no-wrap
msgid ""
"<filename>/usr/include/machine/bootinfo.h:</filename>\n"
"struct bootinfo {\n"
"\tu_int32_t\tbi_version;\n"
"\tu_int32_t\tbi_kernelname;\t\t/* represents a char * */\n"
"\tu_int32_t\tbi_nfs_diskless;\t/* struct nfs_diskless * */\n"
"\t\t\t\t/* End of fields that are always present. */\n"
"#define\tbi_endcommon\tbi_n_bios_used\n"
"\tu_int32_t\tbi_n_bios_used;\n"
"\tu_int32_t\tbi_bios_geom[N_BIOS_GEOM];\n"
"\tu_int32_t\tbi_size;\n"
"\tu_int8_t\tbi_memsizes_valid;\n"
"\tu_int8_t\tbi_bios_dev;\t\t/* bootdev BIOS unit number */\n"
"\tu_int8_t\tbi_pad[2];\n"
"\tu_int32_t\tbi_basemem;\n"
"\tu_int32_t\tbi_extmem;\n"
"\tu_int32_t\tbi_symtab;\t\t/* struct symtab * */\n"
"\tu_int32_t\tbi_esymtab;\t\t/* struct symtab * */\n"
"\t\t\t\t/* Items below only from advanced bootloader */\n"
"\tu_int32_t\tbi_kernend;\t\t/* end of kernel space */\n"
"\tu_int32_t\tbi_envp;\t\t/* environment */\n"
"\tu_int32_t\tbi_modulep;\t\t/* preloaded modules */\n"
"};"
msgstr ""
"<filename>/usr/include/machine/bootinfo.h:</filename>\n"
"struct bootinfo {\n"
"\tu_int32_t\tbi_version;\n"
"\tu_int32_t\tbi_kernelname;\t\t/* represents a char * */\n"
"\tu_int32_t\tbi_nfs_diskless;\t/* struct nfs_diskless * */\n"
"\t\t\t\t/* End of fields that are always present. */\n"
"#define\tbi_endcommon\tbi_n_bios_used\n"
"\tu_int32_t\tbi_n_bios_used;\n"
"\tu_int32_t\tbi_bios_geom[N_BIOS_GEOM];\n"
"\tu_int32_t\tbi_size;\n"
"\tu_int8_t\tbi_memsizes_valid;\n"
"\tu_int8_t\tbi_bios_dev;\t\t/* bootdev BIOS unit number */\n"
"\tu_int8_t\tbi_pad[2];\n"
"\tu_int32_t\tbi_basemem;\n"
"\tu_int32_t\tbi_extmem;\n"
"\tu_int32_t\tbi_symtab;\t\t/* struct symtab * */\n"
"\tu_int32_t\tbi_esymtab;\t\t/* struct symtab * */\n"
"\t\t\t\t/* Items below only from advanced bootloader */\n"
"\tu_int32_t\tbi_kernend;\t\t/* end of kernel space */\n"
"\tu_int32_t\tbi_envp;\t\t/* environment */\n"
"\tu_int32_t\tbi_modulep;\t\t/* preloaded modules */\n"
"};"

#. (itstool) path: sect1/para
#: book.translate.xml:2038
#, fuzzy
msgid ""
"<literal>boot2</literal> enters into an infinite loop waiting for user "
"input, then calls <function>load()</function>. If the user does not press "
"anything, the loop breaks by a timeout, so <function>load()</function> will "
"load the default file (<filename>/boot/loader</filename>). Functions "
"<function>ino_t lookup(char *filename)</function> and <function>int "
"xfsread(ino_t inode, void *buf, size_t nbyte)</function> are used to read "
"the content of a file into memory. <filename>/boot/loader</filename> is an "
"<acronym>ELF</acronym> binary, but where the <acronym>ELF</acronym> header "
"is prepended with <filename>a.out</filename>'s <literal>struct exec</"
"literal> structure. <function>load()</function> scans the loader's ELF "
"header, loading the content of <filename>/boot/loader</filename> into "
"memory, and passing the execution to the loader's entry:"
msgstr ""
" <literal> boot2 </literal> entra em um loop infinito esperando por entrada "
"do usu�rio, ent�o chama <function> carga() </function> . Se o usu�rio n�o "
"pressionar nada, o loop ser� interrompido por um tempo limite, <function> "
"carga() </function> ir� carregar o arquivo padr�o ( <filename> / boot / "
"loader </filename> ). Fun��es <function> pesquisa ino_t (char * filename) </"
"function> e <function> int xfsread (inodo_t inode, void * buf, tamanho_t "
"nbyte) </function> s�o usados ​​para ler o conte�do de um arquivo na mem�ria. "
"<filename> / boot / loader </filename> � um bin�rio <acronym>ELF</acronym> , "
"mas onde o cabe�alho <acronym>ELF</acronym> � prefixado com <filename> a.out "
"</filename> ';s <literal> struct exec </literal> estrutura. <function> "
"carga() </function> varre o cabe�alho ELF do carregador, carregando o "
"conte�do do <filename> / boot / loader </filename> na mem�ria e passando a "
"execu��o para a entrada do carregador: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2055
#, no-wrap
msgid ""
"<filename>sys/boot/i386/boot2/boot2.c:</filename>\n"
"    __exec((caddr_t)addr, RB_BOOTINFO | (opts &amp; RBX_MASK),\n"
"\t   MAKEBOOTDEV(dev_maj[dsk.type], 0, dsk.slice, dsk.unit, dsk.part),\n"
"\t   0, 0, 0, VTOP(&amp;bootinfo));"
msgstr ""
"<filename>sys/boot/i386/boot2/boot2.c:</filename>\n"
"    __exec((caddr_t)addr, RB_BOOTINFO | (opts &amp; RBX_MASK),\n"
"\t   MAKEBOOTDEV(dev_maj[dsk.type], 0, dsk.slice, dsk.unit, dsk.part),\n"
"\t   0, 0, 0, VTOP(&amp;bootinfo));"

#. (itstool) path: sect1/title
#: book.translate.xml:2062
msgid "<application>loader</application> Stage"
msgstr "<application>loader</application> Stage"

#. (itstool) path: sect1/para
#: book.translate.xml:2064
#, fuzzy
msgid ""
"<application>loader</application> is a <acronym>BTX</acronym> client as "
"well. I will not describe it here in detail, there is a comprehensive man "
"page written by Mike Smith, <citerefentry><refentrytitle>loader</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>. The underlying "
"mechanisms and <acronym>BTX</acronym> were discussed above."
msgstr ""
" <application> carregador </application> � um cliente <acronym>BTX</acronym> "
"tamb�m. Eu n�o vou descrev�-lo aqui em detalhes, h� uma manpage abrangente "
"escrito por Mike Smith, <citerefentry><refentrytitle> carregador </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> . Os mecanismos "
"subjacentes e <acronym>BTX</acronym> foram discutidos acima \""

#. (itstool) path: sect1/para
#: book.translate.xml:2070
#, fuzzy
msgid ""
"The main task for the loader is to boot the kernel. When the kernel is "
"loaded into memory, it is being called by the loader:"
msgstr ""
"A tarefa principal do carregador � inicializar o kernel. Quando o kernel � "
"carregado na mem�ria, ele est� sendo chamado pelo carregador:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2074
#, no-wrap
msgid ""
"<filename>sys/boot/common/boot.c:</filename>\n"
"    /* Call the exec handler from the loader matching the kernel */\n"
"    module_formats[km-&gt;m_loader]-&gt;l_exec(km);"
msgstr ""
"<filename>sys/boot/common/boot.c:</filename>\n"
"    /* Call the exec handler from the loader matching the kernel */\n"
"    module_formats[km-&gt;m_loader]-&gt;l_exec(km);"

#. (itstool) path: sect1/title
#: book.translate.xml:2080
msgid "Kernel Initialization"
msgstr "Inicialização do Kernel"

#. (itstool) path: sect1/para
#: book.translate.xml:2082
#, fuzzy
msgid ""
"Let us take a look at the command that links the kernel. This will help "
"identify the exact location where the loader passes execution to the kernel. "
"This location is the kernel's actual entry point."
msgstr ""
"Vamos dar uma olhada no comando que liga o kernel. Isso ajudar� a "
"identificar a localiza��o exata onde o carregador passa a execu��o para o "
"kernel. Esta localiza��o � o ponto de entrada real do kernel."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2087
#, no-wrap
msgid ""
"<filename>sys/conf/Makefile.i386:</filename>\n"
"ld -elf -Bdynamic -T /usr/src/sys/conf/ldscript.i386  -export-dynamic \\\n"
"-dynamic-linker /red/herring -o kernel -X locore.o \\\n"
"&lt;lots of kernel .o files&gt;"
msgstr ""
"<filename>sys/conf/Makefile.i386:</filename>\n"
"ld -elf -Bdynamic -T /usr/src/sys/conf/ldscript.i386  -export-dynamic \\\n"
"-dynamic-linker /red/herring -o kernel -X locore.o \\\n"
"&lt;lots of kernel .o files&gt;"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:2092
msgid "<primary>ELF</primary>"
msgstr "<primary>ELF</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:2093
#, fuzzy
msgid ""
"A few interesting things can be seen here. First, the kernel is an ELF "
"dynamically linked binary, but the dynamic linker for kernel is <filename>/"
"red/herring</filename>, which is definitely a bogus file. Second, taking a "
"look at the file <filename>sys/conf/ldscript.i386</filename> gives an idea "
"about what <application>ld</application> options are used when compiling a "
"kernel. Reading through the first few lines, the string"
msgstr ""
"Algumas coisas interessantes podem ser vistas aqui. Primeiro, o kernel � um "
"bin�rio ELF dinamicamente vinculado, mas o vinculador din�mico para o kernel "
"� <filename> / vermelho / arenque </filename> , que � definitivamente um "
"arquivo falso. Em segundo lugar, dando uma olhada no arquivo <filename> "
"sys / conf / ldscript.i386 </filename> d� uma ideia sobre o que "
"<application> ld </application> op��es s�o usadas ao compilar um kernel. "
"Lendo as primeiras linhas, a string "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2102
#, no-wrap
msgid ""
"<filename>sys/conf/ldscript.i386:</filename>\n"
"ENTRY(btext)"
msgstr ""
"<filename>sys/conf/ldscript.i386:</filename>\n"
"ENTRY(btext)"

#. (itstool) path: sect1/para
#: book.translate.xml:2105
#, fuzzy
msgid ""
"says that a kernel's entry point is the symbol `btext'. This symbol is "
"defined in <filename>locore.s</filename>:"
msgstr ""
"diz que o ponto de entrada de um kernel � o s�mbolo\" btext \". Este s�mbolo "
"� definido em <filename> locore.s </filename> : "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2108
#, no-wrap
msgid ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"\t.text\n"
"/**********************************************************************\n"
" *\n"
" * This is where the bootblocks start us, set the ball rolling...\n"
" *\n"
" */\n"
"NON_GPROF_ENTRY(btext)"
msgstr ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"\t.text\n"
"/**********************************************************************\n"
" *\n"
" * This is where the bootblocks start us, set the ball rolling...\n"
" *\n"
" */\n"
"NON_GPROF_ENTRY(btext)"

#. (itstool) path: sect1/para
#: book.translate.xml:2117
#, fuzzy
msgid ""
"First, the register EFLAGS is set to a predefined value of 0x00000002. Then "
"all the segment registers are initialized:"
msgstr ""
"Primeiro, o registrador EFLAGS � configurado para um valor predefinido de "
"0x00000002. Ent�o todos os registradores de segmento s�o inicializados:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2121
#, no-wrap
msgid ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"/* Don't trust what the BIOS gives for eflags. */\n"
"\tpushl\t$PSL_KERNEL\n"
"\tpopfl\n"
"\n"
"/*\n"
" * Don't trust what the BIOS gives for %fs and %gs.  Trust the bootstrap\n"
" * to set %cs, %ds, %es and %ss.\n"
" */\n"
"\tmov\t%ds, %ax\n"
"\tmov\t%ax, %fs\n"
"\tmov\t%ax, %gs"
msgstr ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"/* Don't trust what the BIOS gives for eflags. */\n"
"\tpushl\t$PSL_KERNEL\n"
"\tpopfl\n"
"\n"
"/*\n"
" * Don't trust what the BIOS gives for %fs and %gs.  Trust the bootstrap\n"
" * to set %cs, %ds, %es and %ss.\n"
" */\n"
"\tmov\t%ds, %ax\n"
"\tmov\t%ax, %fs\n"
"\tmov\t%ax, %gs"

#. (itstool) path: sect1/para
#: book.translate.xml:2134
#, fuzzy
msgid ""
"btext calls the routines <function>recover_bootinfo()</function>, "
"<function>identify_cpu()</function>, <function>create_pagetables()</"
"function>, which are also defined in <filename>locore.s</filename>. Here is "
"a description of what they do:"
msgstr ""
"btext chama as rotinas <function> recover_bootinfo () </function> , "
"<function> identify_cpu () </function> , <function> create_pagetables () </"
"function> , que tamb�m s�o definidos em <filename> locore.s </filename> . "
"Aqui est� uma descri��o do que eles fazem: "

#. (itstool) path: row/entry
#: book.translate.xml:2145
msgid "<function>recover_bootinfo</function>"
msgstr "<function>recover_bootinfo</function>"

#. (itstool) path: row/entry
#: book.translate.xml:2146
#, fuzzy
msgid ""
"This routine parses the parameters to the kernel passed from the bootstrap. "
"The kernel may have been booted in 3 ways: by the loader, described above, "
"by the old disk boot blocks, or by the old diskless boot procedure. This "
"function determines the booting method, and stores the <literal>struct "
"bootinfo</literal> structure into the kernel memory."
msgstr ""
"Esta rotina analisa os par�metros para o kernel passado a partir do "
"bootstrap. O kernel pode ter sido inicializado de 3 maneiras: pelo "
"carregador, descrito acima, pelos blocos de inicializa��o de disco antigos "
"ou pelo antigo procedimento de inicializa��o sem disco. Essa fun��o "
"determina o m�todo de inicializa��o, e armazena o <literal> struct bootinfo "
"</literal> estrutura na mem�ria do kernel. "

#. (itstool) path: row/entry
#: book.translate.xml:2156
msgid "<function>identify_cpu</function>"
msgstr "<function>identify_cpu</function>"

#. (itstool) path: row/entry
#: book.translate.xml:2157
#, fuzzy
msgid ""
"This functions tries to find out what CPU it is running on, storing the "
"value found in a variable <varname>_cpu</varname>."
msgstr ""
"Esta fun��o tenta descobrir em qual CPU ela est� rodando, armazenando o "
"valor encontrado em uma vari�vel <varname> _CPU </varname> "

#. (itstool) path: row/entry
#: book.translate.xml:2163
msgid "<function>create_pagetables</function>"
msgstr "<function>create_pagetables</function>"

#. (itstool) path: row/entry
#: book.translate.xml:2164
#, fuzzy
msgid ""
"This function allocates and fills out a Page Table Directory at the top of "
"the kernel memory area."
msgstr ""
"Esta fun��o aloca e preenche um Diret�rio de Tabelas de P�ginas no topo da "
"�rea de mem�ria do kernel."

#. (itstool) path: sect1/para
#: book.translate.xml:2171
#, fuzzy
msgid "The next steps are enabling VME, if the CPU supports it:"
msgstr "Os pr�ximos passos s�o habilitar o VME, se a CPU suportar:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2174
#, no-wrap
msgid ""
"\ttestl\t$CPUID_VME, R(_cpu_feature)\n"
"\tjz\t1f\n"
"\tmovl\t%cr4, %eax\n"
"\torl\t$CR4_VME, %eax\n"
"\tmovl\t%eax, %cr4"
msgstr ""
"\ttestl\t$CPUID_VME, R(_cpu_feature)\n"
"\tjz\t1f\n"
"\tmovl\t%cr4, %eax\n"
"\torl\t$CR4_VME, %eax\n"
"\tmovl\t%eax, %cr4"

#. (itstool) path: sect1/para
#: book.translate.xml:2180
#, fuzzy
msgid "Then, enabling paging:"
msgstr "Ent�o, habilitando pagina��o:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2182
#, no-wrap
msgid ""
"/* Now enable paging */\n"
"\tmovl\tR(_IdlePTD), %eax\n"
"\tmovl\t%eax,%cr3\t\t\t/* load ptd addr into mmu */\n"
"\tmovl\t%cr0,%eax\t\t\t/* get control word */\n"
"\torl\t$CR0_PE|CR0_PG,%eax\t\t/* enable paging */\n"
"\tmovl\t%eax,%cr0\t\t\t/* and let's page NOW! */"
msgstr ""
"/* Now enable paging */\n"
"\tmovl\tR(_IdlePTD), %eax\n"
"\tmovl\t%eax,%cr3\t\t\t/* load ptd addr into mmu */\n"
"\tmovl\t%cr0,%eax\t\t\t/* get control word */\n"
"\torl\t$CR0_PE|CR0_PG,%eax\t\t/* enable paging */\n"
"\tmovl\t%eax,%cr0\t\t\t/* and let's page NOW! */"

#. (itstool) path: sect1/para
#: book.translate.xml:2189
#, fuzzy
msgid ""
"The next three lines of code are because the paging was set, so the jump is "
"needed to continue the execution in virtualized address space:"
msgstr ""
"As pr�ximas tr�s linhas de c�digo s�o porque a pagina��o foi definida, "
"portanto, o salto � necess�rio para continuar a execu��o no espa�o de "
"endere�o virtualizado:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2193
#, no-wrap
msgid ""
"\tpushl\t$begin\t\t\t\t/* jump to high virtualized address */\n"
"\tret\n"
"\n"
"/* now running relocated at KERNBASE where the system is linked to run */\n"
"begin:"
msgstr ""
"\tpushl\t$begin\t\t\t\t/* jump to high virtualized address */\n"
"\tret\n"
"\n"
"/* now running relocated at KERNBASE where the system is linked to run */\n"
"begin:"

#. (itstool) path: sect1/para
#: book.translate.xml:2199
#, fuzzy
msgid ""
"The function <function>init386()</function> is called with a pointer to the "
"first free physical page, after that <function>mi_startup()</function>. "
"<function>init386</function> is an architecture dependent initialization "
"function, and <function>mi_startup()</function> is an architecture "
"independent one (the 'mi_' prefix stands for Machine Independent). The "
"kernel never returns from <function>mi_startup()</function>, and by calling "
"it, the kernel finishes booting:"
msgstr ""
"A fun��o <function> init386 () </function> � chamado com um ponteiro para a "
"primeira p�gina f�sica livre, depois disso <function> mi_startup () </"
"function> . <function> init386 </function> � uma fun��o de inicializa��o "
"dependente da arquitetura e <function> mi_startup () </function> � uma "
"arquitetura independente (o prefixo ';mi_'; significa Independente da "
"M�quina). O kernel nunca retorna de <function> mi_startup () </function> e, "
"ao cham�-lo, o kernel conclui a inicializa��o: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2208
#, no-wrap
msgid ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"\tmovl\tphysfree, %esi\n"
"\tpushl\t%esi\t\t\t\t/* value of first for init386(first) */\n"
"\tcall\t_init386\t\t\t/* wire 386 chip for unix operation */\n"
"\tcall\t_mi_startup\t\t\t/* autoconfiguration, mountroot etc */\n"
"\thlt\t\t/* never returns to here */"
msgstr ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"\tmovl\tphysfree, %esi\n"
"\tpushl\t%esi\t\t\t\t/* value of first for init386(first) */\n"
"\tcall\t_init386\t\t\t/* wire 386 chip for unix operation */\n"
"\tcall\t_mi_startup\t\t\t/* autoconfiguration, mountroot etc */\n"
"\thlt\t\t/* never returns to here */"

#. (itstool) path: sect2/title
#: book.translate.xml:2216
#, fuzzy
msgid "<function>init386()</function>"
msgstr " <function> init386 () </function> "

#. (itstool) path: sect2/para
#: book.translate.xml:2218
#, fuzzy
msgid ""
"<function>init386()</function> is defined in <filename>sys/i386/i386/machdep."
"c</filename> and performs low-level initialization specific to the i386 "
"chip. The switch to protected mode was performed by the loader. The loader "
"has created the very first task, in which the kernel continues to operate. "
"Before looking at the code, consider the tasks the processor must complete "
"to initialize protected mode execution:"
msgstr ""
" <function> init386 () </function> � definido em <filename> sys / i386 / "
"i386 / machdep.c </filename> e executa inicializa��o de baixo n�vel "
"espec�fica para o chip i386. A mudan�a para o modo protegido foi realizada "
"pelo carregador. O carregador criou a primeira tarefa, na qual o kernel "
"continua a operar. Antes de examinar o c�digo, considere as tarefas que o "
"processador deve concluir para inicializar a execu��o do modo protegido: "

#. (itstool) path: listitem/para
#: book.translate.xml:2229
#, fuzzy
msgid ""
"Initialize the kernel tunable parameters, passed from the bootstrapping "
"program."
msgstr ""
"Inicialize os par�metros ajust�veis ​​do kernel, passados ​​do programa de "
"bootstrapping."

#. (itstool) path: listitem/para
#: book.translate.xml:2234
#, fuzzy
msgid "Prepare the GDT."
msgstr "Prepare o GDT."

#. (itstool) path: listitem/para
#: book.translate.xml:2238
#, fuzzy
msgid "Prepare the IDT."
msgstr "Prepare o IDT."

#. (itstool) path: listitem/para
#: book.translate.xml:2242
#, fuzzy
msgid "Initialize the system console."
msgstr "Inicialize o console do sistema."

#. (itstool) path: listitem/para
#: book.translate.xml:2246
#, fuzzy
msgid "Initialize the DDB, if it is compiled into kernel."
msgstr "Inicialize o DDB, se ele for compilado no kernel."

#. (itstool) path: listitem/para
#: book.translate.xml:2251
#, fuzzy
msgid "Initialize the TSS."
msgstr "Inicialize o TSS."

#. (itstool) path: listitem/para
#: book.translate.xml:2255
#, fuzzy
msgid "Prepare the LDT."
msgstr "Prepare o LDT."

#. (itstool) path: listitem/para
#: book.translate.xml:2259
#, fuzzy
msgid "Set up proc0's pcb."
msgstr "Configure o pcb do proc0."

#. (itstool) path: sect2/indexterm
#: book.translate.xml:2263
#, fuzzy
msgid "<primary>parameters</primary>"
msgstr " <primary> Par�metros </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:2264
#, fuzzy
msgid ""
"<function>init386()</function> initializes the tunable parameters passed "
"from bootstrap by setting the environment pointer (envp) and calling "
"<function>init_param1()</function>. The envp pointer has been passed from "
"loader in the <literal>bootinfo</literal> structure:"
msgstr ""
" <function> init386 () </function> inicializa os par�metros ajust�veis ​​"
"passados ​​do bootstrap definindo o ponteiro de ambiente (envp) e chamando "
"<function> init_param1 () </function> . O ponteiro envp foi passado do "
"carregador no <literal> bootinfo </literal> estrutura:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2270
#, no-wrap
msgid ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\t\tkern_envp = (caddr_t)bootinfo.bi_envp + KERNBASE;\n"
"\n"
"\t/* Init basic tunables, hz etc */\n"
"\tinit_param1();"
msgstr ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\t\tkern_envp = (caddr_t)bootinfo.bi_envp + KERNBASE;\n"
"\n"
"\t/* Init basic tunables, hz etc */\n"
"\tinit_param1();"

#. (itstool) path: sect2/para
#: book.translate.xml:2276
#, fuzzy
msgid ""
"<function>init_param1()</function> is defined in <filename>sys/kern/"
"subr_param.c</filename>. That file has a number of sysctls, and two "
"functions, <function>init_param1()</function> and <function>init_param2()</"
"function>, that are called from <function>init386()</function>:"
msgstr ""
" <function> init_param1 () </function> � definido em <filename> sys / kern / "
"subr_param.c </filename> . Esse arquivo tem um n�mero de sysctls e duas "
"fun��es, <function> init_param1 () </function> e <function> init_param2 () </"
"function> , que s�o chamados de <function> init386 () </function> : "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2283
#, no-wrap
msgid ""
"<filename>sys/kern/subr_param.c:</filename>\n"
"\thz = HZ;\n"
"\tTUNABLE_INT_FETCH(\"kern.hz\", &amp;hz);"
msgstr ""
"<filename>sys/kern/subr_param.c:</filename>\n"
"\thz = HZ;\n"
"\tTUNABLE_INT_FETCH(\"kern.hz\", &amp;hz);"

#. (itstool) path: sect2/para
#: book.translate.xml:2287
#, fuzzy
msgid ""
"TUNABLE_&lt;typename&gt;_FETCH is used to fetch the value from the "
"environment:"
msgstr ""
"TUNABLE_ &lt;typename&gt; _FETCH � usado para buscar o valor do ambiente:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2290
#, no-wrap
msgid ""
"<filename>/usr/src/sys/sys/kernel.h:</filename>\n"
"#define\tTUNABLE_INT_FETCH(path, var)\tgetenv_int((path), (var))"
msgstr ""
"<filename>/usr/src/sys/sys/kernel.h:</filename>\n"
"#define\tTUNABLE_INT_FETCH(path, var)\tgetenv_int((path), (var))"

#. (itstool) path: sect2/para
#: book.translate.xml:2293
#, fuzzy
msgid ""
"Sysctl <literal>kern.hz</literal> is the system clock tick. Additionally, "
"these sysctls are set by <function>init_param1()</function>: <literal>kern."
"maxswzone, kern.maxbcache, kern.maxtsiz, kern.dfldsiz, kern.maxdsiz, kern."
"dflssiz, kern.maxssiz, kern.sgrowsiz</literal>."
msgstr ""
"Sysctl <literal> kern.hz </literal> � o tick do rel�gio do sistema. Al�m "
"disso, esses sysctls s�o definidos por <function> init_param1 () </"
"function> : <literal> kern.maxswzone, kern.maxbcache, kern.maxtsiz, kern."
"dfldsiz, kern.maxdsiz, kern.dflssiz, kern.maxssiz, kern.sgrowsiz </literal> "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:2299
#, fuzzy
msgid "<primary>Global Descriptors Table (GDT)</primary>"
msgstr " <primary> Tabela de Descritores Globais (GDT) </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:2303
#, fuzzy
msgid ""
"Then <function>init386()</function> prepares the Global Descriptors Table "
"(GDT). Every task on an x86 is running in its own virtual address space, and "
"this space is addressed by a segment:offset pair. Say, for instance, the "
"current instruction to be executed by the processor lies at CS:EIP, then the "
"linear virtual address for that instruction would be <quote>the virtual "
"address of code segment CS</quote> + EIP. For convenience, segments begin at "
"virtual address 0 and end at a 4Gb boundary. Therefore, the instruction's "
"linear virtual address for this example would just be the value of EIP. "
"Segment registers such as CS, DS etc are the selectors, i.e., indexes, into "
"GDT (to be more precise, an index is not a selector itself, but the INDEX "
"field of a selector). FreeBSD's GDT holds descriptors for 15 selectors per "
"CPU:"
msgstr ""
"Ent�o <function> init386 () </function> prepara a Tabela de Descritores "
"Globais (GDT). Toda tarefa em um x86 est� sendo executada em seu pr�prio "
"espa�o de endere�o virtual e esse espa�o � endere�ado por um par segmento: "
"offset. Digamos, por exemplo, que a instru��o atual a ser executada pelo "
"processador esteja em CS: EIP, ent�o o endere�o virtual linear para aquela "
"instru��o seria <quote> o endere�o virtual do segmento de c�digo CS </quote> "
"+ EIP. Por conveni�ncia, os segmentos come�am no endere�o virtual 0 e "
"terminam em um limite de 4 Gb. Portanto, o endere�o virtual linear da "
"instru��o para este exemplo seria apenas o valor de EIP. Registros de "
"segmento como CS, DS etc. s�o os seletores, isto �, �ndices, em GDT (para "
"ser mais preciso, um �ndice n�o � um seletor em si, mas o campo INDEX de um "
"seletor). O GDT do FreeBSD possui descritores para 15 seletores por CPU: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2319
#, no-wrap
msgid ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"union descriptor gdt[NGDT * MAXCPU];\t/* global descriptor table */\n"
"\n"
"<filename>sys/i386/include/segments.h:</filename>\n"
"/*\n"
" * Entries in the Global Descriptor Table (GDT)\n"
" */\n"
"#define\tGNULL_SEL\t0\t/* Null Descriptor */\n"
"#define\tGCODE_SEL\t1\t/* Kernel Code Descriptor */\n"
"#define\tGDATA_SEL\t2\t/* Kernel Data Descriptor */\n"
"#define\tGPRIV_SEL\t3\t/* SMP Per-Processor Private Data */\n"
"#define\tGPROC0_SEL\t4\t/* Task state process slot zero and up */\n"
"#define\tGLDT_SEL\t5\t/* LDT - eventually one per process */\n"
"#define\tGUSERLDT_SEL\t6\t/* User LDT */\n"
"#define\tGTGATE_SEL\t7\t/* Process task switch gate */\n"
"#define\tGBIOSLOWMEM_SEL\t8\t/* BIOS low memory access (must be entry 8) */\n"
"#define\tGPANIC_SEL\t9\t/* Task state to consider panic from */\n"
"#define GBIOSCODE32_SEL\t10\t/* BIOS interface (32bit Code) */\n"
"#define GBIOSCODE16_SEL\t11\t/* BIOS interface (16bit Code) */\n"
"#define GBIOSDATA_SEL\t12\t/* BIOS interface (Data) */\n"
"#define GBIOSUTIL_SEL\t13\t/* BIOS interface (Utility) */\n"
"#define GBIOSARGS_SEL\t14\t/* BIOS interface (Arguments) */"
msgstr ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"union descriptor gdt[NGDT * MAXCPU];\t/* global descriptor table */\n"
"\n"
"<filename>sys/i386/include/segments.h:</filename>\n"
"/*\n"
" * Entries in the Global Descriptor Table (GDT)\n"
" */\n"
"#define\tGNULL_SEL\t0\t/* Null Descriptor */\n"
"#define\tGCODE_SEL\t1\t/* Kernel Code Descriptor */\n"
"#define\tGDATA_SEL\t2\t/* Kernel Data Descriptor */\n"
"#define\tGPRIV_SEL\t3\t/* SMP Per-Processor Private Data */\n"
"#define\tGPROC0_SEL\t4\t/* Task state process slot zero and up */\n"
"#define\tGLDT_SEL\t5\t/* LDT - eventually one per process */\n"
"#define\tGUSERLDT_SEL\t6\t/* User LDT */\n"
"#define\tGTGATE_SEL\t7\t/* Process task switch gate */\n"
"#define\tGBIOSLOWMEM_SEL\t8\t/* BIOS low memory access (must be entry 8) */\n"
"#define\tGPANIC_SEL\t9\t/* Task state to consider panic from */\n"
"#define GBIOSCODE32_SEL\t10\t/* BIOS interface (32bit Code) */\n"
"#define GBIOSCODE16_SEL\t11\t/* BIOS interface (16bit Code) */\n"
"#define GBIOSDATA_SEL\t12\t/* BIOS interface (Data) */\n"
"#define GBIOSUTIL_SEL\t13\t/* BIOS interface (Utility) */\n"
"#define GBIOSARGS_SEL\t14\t/* BIOS interface (Arguments) */"

#. (itstool) path: sect2/para
#: book.translate.xml:2342
#, fuzzy
msgid ""
"Note that those #defines are not selectors themselves, but just a field "
"INDEX of a selector, so they are exactly the indices of the GDT. for "
"example, an actual selector for the kernel code (GCODE_SEL) has the value "
"0x08."
msgstr ""
"Note que esses #defines n�o s�o seletores, mas apenas um campo INDEX de um "
"seletor, ent�o eles s�o exatamente os �ndices do GDT. Por exemplo, um "
"seletor real para o c�digo do kernel (GCODE_SEL) tem o valor 0x08."

#. (itstool) path: sect2/indexterm
#: book.translate.xml:2347
msgid "<primary>Interrupt Descriptor Table (IDT)</primary>"
msgstr "<primary>Interrupt Descriptor Table (IDT)</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:2349
#, fuzzy
msgid ""
"The next step is to initialize the Interrupt Descriptor Table (IDT). This "
"table is referenced by the processor when a software or hardware interrupt "
"occurs. For example, to make a system call, user application issues the "
"<literal>INT 0x80</literal> instruction. This is a software interrupt, so "
"the processor's hardware looks up a record with index 0x80 in the IDT. This "
"record points to the routine that handles this interrupt, in this particular "
"case, this will be the kernel's syscall gate. The IDT may have a maximum of "
"256 (0x100) records. The kernel allocates NIDT records for the IDT, where "
"NIDT is the maximum (256):"
msgstr ""
"O pr�ximo passo � inicializar a Tabela de Descritores de Interrup��es (IDT). "
"Essa tabela � referenciada pelo processador quando ocorre uma interrup��o de "
"software ou hardware. Por exemplo, para fazer uma chamada de sistema, o "
"aplicativo de usu�rio emite a <literal> INT 0x80 </literal> instru��o. Esta "
"� uma interrup��o de software, portanto, o hardware do processador procura "
"um registro com o �ndice 0x80 no IDT. Este registro aponta para a rotina que "
"lida com esta interrup��o, neste caso particular, este ser� o syscall do "
"kernel. O IDT pode ter um m�ximo de 256 (0x100) registros. O kernel aloca "
"registros NIDT para o IDT, onde NIDT � o m�ximo (256): "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2361
#, no-wrap
msgid ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"static struct gate_descriptor idt0[NIDT];\n"
"struct gate_descriptor *idt = &amp;idt0[0];\t/* interrupt descriptor table */"
msgstr ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"static struct gate_descriptor idt0[NIDT];\n"
"struct gate_descriptor *idt = &amp;idt0[0];\t/* interrupt descriptor table */"

#. (itstool) path: sect2/para
#: book.translate.xml:2365
#, fuzzy
msgid ""
"For each interrupt, an appropriate handler is set. The syscall gate for "
"<literal>INT 0x80</literal> is set as well:"
msgstr ""
"Para cada interrup��o, um manipulador apropriado � definido. O syscall gate "
"para <literal> INT 0x80 </literal> est� definido tamb�m: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2369
#, no-wrap
msgid ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\tsetidt(0x80, &amp;IDTVEC(int0x80_syscall),\n"
"\t\t\tSDT_SYS386TGT, SEL_UPL, GSEL(GCODE_SEL, SEL_KPL));"
msgstr ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\tsetidt(0x80, &amp;IDTVEC(int0x80_syscall),\n"
"\t\t\tSDT_SYS386TGT, SEL_UPL, GSEL(GCODE_SEL, SEL_KPL));"

#. (itstool) path: sect2/para
#: book.translate.xml:2373
#, fuzzy
msgid ""
"So when a userland application issues the <literal>INT 0x80</literal> "
"instruction, control will transfer to the function "
"<function>_Xint0x80_syscall</function>, which is in the kernel code segment "
"and will be executed with supervisor privileges."
msgstr ""
"Ent�o, quando um aplicativo userland emite o <literal> INT 0x80 </literal> "
"instru��o, controle ir� transferir para a fun��o <function> "
"_Xint0x80_syscall </function> , que est� no segmento de c�digo do kernel e "
"ser� executado com privil�gios de supervisor. "

#. (itstool) path: sect2/para
#: book.translate.xml:2379
#, fuzzy
msgid "Console and DDB are then initialized:"
msgstr "Console e DDB s�o inicializados:"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:2380
msgid "<primary>DDB</primary>"
msgstr "<primary>DDB</primary>"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2382
#, no-wrap
msgid ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\tcninit();\n"
"/* skipped */\n"
"#ifdef DDB\n"
"\tkdb_init();\n"
"\tif (boothowto &amp; RB_KDB)\n"
"\t\tDebugger(\"Boot flags requested debugger\");\n"
"#endif"
msgstr ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\tcninit();\n"
"/* skipped */\n"
"#ifdef DDB\n"
"\tkdb_init();\n"
"\tif (boothowto &amp; RB_KDB)\n"
"\t\tDebugger(\"Boot flags requested debugger\");\n"
"#endif"

#. (itstool) path: sect2/para
#: book.translate.xml:2391
#, fuzzy
msgid ""
"The Task State Segment is another x86 protected mode structure, the TSS is "
"used by the hardware to store task information when a task switch occurs."
msgstr ""
"O segmento de estado da tarefa � outra estrutura de modo protegido x86, o "
"TSS � usado pelo hardware para armazenar informa��es de tarefa quando ocorre "
"uma altern��ncia de tarefa."

#. (itstool) path: sect2/para
#: book.translate.xml:2395
#, fuzzy
msgid ""
"The Local Descriptors Table is used to reference userland code and data. "
"Several selectors are defined to point to the LDT, they are the system call "
"gates and the user code and data selectors:"
msgstr ""
"A Tabela de Descritores Locais � usada para referenciar c�digos e dados da "
"terra do usu�rio. V�rios seletores s�o definidos para apontar para o LDT, "
"eles s�o as portas de chamada do sistema e os seletores de c�digo e dados do "
"usu�rio:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2400
#, no-wrap
msgid ""
"<filename>/usr/include/machine/segments.h:</filename>\n"
"#define\tLSYS5CALLS_SEL\t0\t/* forced by intel BCS */\n"
"#define\tLSYS5SIGR_SEL\t1\n"
"#define\tL43BSDCALLS_SEL\t2\t/* notyet */\n"
"#define\tLUCODE_SEL\t3\n"
"#define\tLSOL26CALLS_SEL\t4\t/* Solaris &gt;= 2.6 system call gate */\n"
"#define\tLUDATA_SEL\t5\n"
"/* separate stack, es,fs,gs sels ? */\n"
"/* #define\tLPOSIXCALLS_SEL\t5*/\t/* notyet */\n"
"#define LBSDICALLS_SEL\t16\t/* BSDI system call gate */\n"
"#define NLDT\t\t(LBSDICALLS_SEL + 1)"
msgstr ""
"<filename>/usr/include/machine/segments.h:</filename>\n"
"#define\tLSYS5CALLS_SEL\t0\t/* forced by intel BCS */\n"
"#define\tLSYS5SIGR_SEL\t1\n"
"#define\tL43BSDCALLS_SEL\t2\t/* notyet */\n"
"#define\tLUCODE_SEL\t3\n"
"#define\tLSOL26CALLS_SEL\t4\t/* Solaris &gt;= 2.6 system call gate */\n"
"#define\tLUDATA_SEL\t5\n"
"/* separate stack, es,fs,gs sels ? */\n"
"/* #define\tLPOSIXCALLS_SEL\t5*/\t/* notyet */\n"
"#define LBSDICALLS_SEL\t16\t/* BSDI system call gate */\n"
"#define NLDT\t\t(LBSDICALLS_SEL + 1)"

#. (itstool) path: sect2/para
#: book.translate.xml:2412
#, fuzzy
msgid ""
"Next, proc0's Process Control Block (<literal>struct pcb</literal>) "
"structure is initialized. proc0 is a <literal>struct proc</literal> "
"structure that describes a kernel process. It is always present while the "
"kernel is running, therefore it is declared as global:"
msgstr ""
"Em seguida, o bloco de controle de processo do proc0 ( <literal> pcb struct "
"</literal> ) estrutura � inicializada. proc0 � um <literal> struct proc </"
"literal> estrutura que descreve um processo do kernel. Est� sempre presente "
"enquanto o kernel est� rodando, portanto � declarado como global: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2418
#, no-wrap
msgid ""
"<filename>sys/kern/kern_init.c:</filename>\n"
"    struct\tproc proc0;"
msgstr ""
"<filename>sys/kern/kern_init.c:</filename>\n"
"    struct\tproc proc0;"

#. (itstool) path: sect2/para
#: book.translate.xml:2421
#, fuzzy
msgid ""
"The structure <literal>struct pcb</literal> is a part of a proc structure. "
"It is defined in <filename>/usr/include/machine/pcb.h</filename> and has a "
"process's information specific to the i386 architecture, such as registers "
"values."
msgstr ""
"A estrutura <literal> pcb struct </literal> faz parte de uma estrutura proc. "
"Est� definido em <filename> /usr/include/machine/pcb.h </filename> e possui "
"uma informa��o espec�fica do processo para a arquitetura i386, como valores "
"de registros. "

#. (itstool) path: sect2/title
#: book.translate.xml:2429
msgid "<function>mi_startup()</function>"
msgstr "<function>mi_startup()</function>"

#. (itstool) path: sect2/para
#: book.translate.xml:2431
#, fuzzy
msgid ""
"This function performs a bubble sort of all the system initialization "
"objects and then calls the entry of each object one by one:"
msgstr ""
"Esta fun��o executa um tipo de bolha de todos os objetos de inicializa��o do "
"sistema e, em seguida, chama a entrada de cada objeto, um por um:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2435
#, no-wrap
msgid ""
"<filename>sys/kern/init_main.c:</filename>\n"
"\tfor (sipp = sysinit; *sipp; sipp++) {\n"
"\n"
"\t\t/* ... skipped ... */\n"
"\n"
"\t\t/* Call function */\n"
"\t\t(*((*sipp)-&gt;func))((*sipp)-&gt;udata);\n"
"\t\t/* ... skipped ... */\n"
"\t}"
msgstr ""
"<filename>sys/kern/init_main.c:</filename>\n"
"\tfor (sipp = sysinit; *sipp; sipp++) {\n"
"\n"
"\t\t/* ... skipped ... */\n"
"\n"
"\t\t/* Call function */\n"
"\t\t(*((*sipp)-&gt;func))((*sipp)-&gt;udata);\n"
"\t\t/* ... skipped ... */\n"
"\t}"

#. (itstool) path: sect2/para
#: book.translate.xml:2445
#, fuzzy
msgid ""
"Although the sysinit framework is described in the <link xlink:href="
"\"@@URL_RELPREFIX@@/doc/en_US.ISO8859-1/books/developers-handbook"
"\">Developers' Handbook</link>, I will discuss the internals of it."
msgstr ""
"Embora o framework sysinit seja descrito no <link xlink:href="
"\"@@URL_RELPREFIX@@/doc/en_US.ISO8859-1/books/developers-handbook\"> Manual "
"dos Desenvolvedores </link> , Vou discutir os aspectos internos dele. "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:2448
msgid "<primary>sysinit objects</primary>"
msgstr "<primary>sysinit objects</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:2449
#, fuzzy
msgid ""
"Every system initialization object (sysinit object) is created by calling a "
"SYSINIT() macro. Let us take as example an <literal>announce</literal> "
"sysinit object. This object prints the copyright message:"
msgstr ""
"Todo objeto de inicializa��o do sistema (objeto sysinit) � criado chamando "
"uma macro SYSINIT (). Vamos tomar como exemplo <literal> anunciar </literal> "
"objeto sysinit. Este objeto imprime a mensagem de direitos autorais: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2454
#, no-wrap
msgid ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static void\n"
"print_caddr_t(void *data __unused)\n"
"{\n"
"\tprintf(\"%s\", (char *)data);\n"
"}\n"
"SYSINIT(announce, SI_SUB_COPYRIGHT, SI_ORDER_FIRST, print_caddr_t, copyright)"
msgstr ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static void\n"
"print_caddr_t(void *data __unused)\n"
"{\n"
"\tprintf(\"%s\", (char *)data);\n"
"}\n"
"SYSINIT(announce, SI_SUB_COPYRIGHT, SI_ORDER_FIRST, print_caddr_t, copyright)"

#. (itstool) path: sect2/para
#: book.translate.xml:2462
#, fuzzy
msgid ""
"The subsystem ID for this object is SI_SUB_COPYRIGHT (0x0800001), which "
"comes right after the SI_SUB_CONSOLE (0x0800000). So, the copyright message "
"will be printed out first, just after the console initialization."
msgstr ""
"O ID do subsistema para este objeto � SI_SUB_COPYRIGHT (0x0800001), que vem "
"logo ap�s o SI_SUB_CONSOLE (0x0800000). Assim, a mensagem de copyright ser� "
"impressa primeiro, logo ap�s a inicializa��o do console."

#. (itstool) path: sect2/para
#: book.translate.xml:2467
#, fuzzy
msgid ""
"Let us take a look at what exactly the macro <literal>SYSINIT()</literal> "
"does. It expands to a <literal>C_SYSINIT()</literal> macro. The "
"<literal>C_SYSINIT()</literal> macro then expands to a static "
"<literal>struct sysinit</literal> structure declaration with another "
"<literal>DATA_SET</literal> macro call:"
msgstr ""
"Vamos dar uma olhada no que exatamente a macro <literal> SYSINIT () </"
"literal> faz. Ele se expande para um <literal> C_SYSINIT () </literal> "
"macro. o <literal> C_SYSINIT () </literal> macro, em seguida, se expande "
"para uma est�tica <literal> struct sysinit </literal> declara��o de "
"estrutura com outro <literal> DATA_SET </literal> chamada macro: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2474
#, no-wrap
msgid ""
"<filename>/usr/include/sys/kernel.h:</filename>\n"
"      #define C_SYSINIT(uniquifier, subsystem, order, func, ident) \\\n"
"      static struct sysinit uniquifier ## _sys_init = { \\ subsystem, \\\n"
"      order, \\ func, \\ ident \\ }; \\ DATA_SET(sysinit_set,uniquifier ##\n"
"      _sys_init);\n"
"\n"
"#define\tSYSINIT(uniquifier, subsystem, order, func, ident)\t\\\n"
"\tC_SYSINIT(uniquifier, subsystem, order,\t\t\t\\\n"
"\t(sysinit_cfunc_t)(sysinit_nfunc_t)func, (void *)ident)"
msgstr ""
"<filename>/usr/include/sys/kernel.h:</filename>\n"
"      #define C_SYSINIT(uniquifier, subsystem, order, func, ident) \\\n"
"      static struct sysinit uniquifier ## _sys_init = { \\ subsystem, \\\n"
"      order, \\ func, \\ ident \\ }; \\ DATA_SET(sysinit_set,uniquifier ##\n"
"      _sys_init);\n"
"\n"
"#define\tSYSINIT(uniquifier, subsystem, order, func, ident)\t\\\n"
"\tC_SYSINIT(uniquifier, subsystem, order,\t\t\t\\\n"
"\t(sysinit_cfunc_t)(sysinit_nfunc_t)func, (void *)ident)"

#. (itstool) path: sect2/para
#: book.translate.xml:2484
#, fuzzy
msgid ""
"The <literal>DATA_SET()</literal> macro expands to a <literal>MAKE_SET()</"
"literal>, and that macro is the point where all the sysinit magic is hidden:"
msgstr ""
"O <literal> DATA_SET () </literal> macro se expande para um <literal> "
"MAKE_SET () </literal> e essa macro � o ponto onde toda a magia sysinit est� "
"escondida: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2488
#, no-wrap
msgid ""
"<filename>/usr/include/linker_set.h:</filename>\n"
"#define MAKE_SET(set, sym)\t\t\t\t\t\t\\\n"
"\tstatic void const * const __set_##set##_sym_##sym = &amp;sym;\t\\\n"
"\t__asm(\".section .set.\" #set \",\\\"aw\\\"\");\t\t\t\t\\\n"
"\t__asm(\".long \" #sym);\t\t\t\t\t\t\\\n"
"\t__asm(\".previous\")\n"
"#endif\n"
"#define TEXT_SET(set, sym) MAKE_SET(set, sym)\n"
"#define DATA_SET(set, sym) MAKE_SET(set, sym)"
msgstr ""
"<filename>/usr/include/linker_set.h:</filename>\n"
"#define MAKE_SET(set, sym)\t\t\t\t\t\t\\\n"
"\tstatic void const * const __set_##set##_sym_##sym = &amp;sym;\t\\\n"
"\t__asm(\".section .set.\" #set \",\\\"aw\\\"\");\t\t\t\t\\\n"
"\t__asm(\".long \" #sym);\t\t\t\t\t\t\\\n"
"\t__asm(\".previous\")\n"
"#endif\n"
"#define TEXT_SET(set, sym) MAKE_SET(set, sym)\n"
"#define DATA_SET(set, sym) MAKE_SET(set, sym)"

#. (itstool) path: sect2/para
#: book.translate.xml:2498
#, fuzzy
msgid "In our case, the following declaration will occur:"
msgstr "No nosso caso, a seguinte declara��o ir� ocorrer:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2500
#, no-wrap
msgid ""
"static struct sysinit announce_sys_init = {\n"
"\tSI_SUB_COPYRIGHT,\n"
"\tSI_ORDER_FIRST,\n"
"\t(sysinit_cfunc_t)(sysinit_nfunc_t)  print_caddr_t,\n"
"\t(void *) copyright\n"
"};\n"
"\n"
"static void const *const __set_sysinit_set_sym_announce_sys_init =\n"
"    &amp;announce_sys_init;\n"
"__asm(\".section .set.sysinit_set\" \",\\\"aw\\\"\");\n"
"__asm(\".long \" \"announce_sys_init\");\n"
"__asm(\".previous\");"
msgstr ""
"static struct sysinit announce_sys_init = {\n"
"\tSI_SUB_COPYRIGHT,\n"
"\tSI_ORDER_FIRST,\n"
"\t(sysinit_cfunc_t)(sysinit_nfunc_t)  print_caddr_t,\n"
"\t(void *) copyright\n"
"};\n"
"\n"
"static void const *const __set_sysinit_set_sym_announce_sys_init =\n"
"    &amp;announce_sys_init;\n"
"__asm(\".section .set.sysinit_set\" \",\\\"aw\\\"\");\n"
"__asm(\".long \" \"announce_sys_init\");\n"
"__asm(\".previous\");"

#. (itstool) path: sect2/para
#: book.translate.xml:2513
#, fuzzy
msgid ""
"The first <literal>__asm</literal> instruction will create an ELF section "
"within the kernel's executable. This will happen at kernel link time. The "
"section will have the name <literal>.set.sysinit_set</literal>. The content "
"of this section is one 32-bit value, the address of announce_sys_init "
"structure, and that is what the second <literal>__asm</literal> is. The "
"third <literal>__asm</literal> instruction marks the end of a section. If a "
"directive with the same section name occurred before, the content, i.e., the "
"32-bit value, will be appended to the existing section, so forming an array "
"of 32-bit pointers."
msgstr ""
"O primeiro <literal> __asm </literal> instru��o ir� criar uma se��o ELF "
"dentro do execut�vel do kernel. Isso acontecer� no momento do link do "
"kernel. A se��o ter� o nome <literal> .set.sysinit_set </literal> . O "
"conte�do desta se��o � um valor de 32 bits, o endere�o da estrutura "
"announce_sys_init, e � isso que o segundo <literal> __asm </literal> �. O "
"terceiro <literal> __asm </literal> instru��o marca o fim de uma se��o. Se "
"uma diretiva com o mesmo nome de se��o ocorreu antes, o conte�do, ou seja, o "
"valor de 32 bits, ser� anexado � se��o existente, formando assim uma matriz "
"de ponteiros de 32 bits. "

#. (itstool) path: sect2/para
#: book.translate.xml:2526
#, fuzzy
msgid ""
"Running <application>objdump</application> on a kernel binary, you may "
"notice the presence of such small sections:"
msgstr ""
"Corrida <application> objdump </application> em um bin�rio do kernel, voc� "
"pode notar a presen�a de se��es t�o pequenas: "

#. (itstool) path: sect2/screen
#: book.translate.xml:2530
#, no-wrap
msgid ""
"<prompt>%</prompt> <userinput>objdump -h /kernel</userinput>\n"
"  7 .set.cons_set 00000014  c03164c0  c03164c0  002154c0  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
"  8 .set.kbddriver_set 00000010  c03164d4  c03164d4  002154d4  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
"  9 .set.scrndr_set 00000024  c03164e4  c03164e4  002154e4  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 10 .set.scterm_set 0000000c  c0316508  c0316508  00215508  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 11 .set.sysctl_set 0000097c  c0316514  c0316514  00215514  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 12 .set.sysinit_set 00000664  c0316e90  c0316e90  00215e90  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA"
msgstr ""
"<prompt>%</prompt> <userinput>objdump -h /kernel</userinput>\n"
"  7 .set.cons_set 00000014  c03164c0  c03164c0  002154c0  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
"  8 .set.kbddriver_set 00000010  c03164d4  c03164d4  002154d4  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
"  9 .set.scrndr_set 00000024  c03164e4  c03164e4  002154e4  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 10 .set.scterm_set 0000000c  c0316508  c0316508  00215508  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 11 .set.sysctl_set 0000097c  c0316514  c0316514  00215514  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 12 .set.sysinit_set 00000664  c0316e90  c0316e90  00215e90  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA"

#. (itstool) path: sect2/para
#: book.translate.xml:2544
#, fuzzy
msgid ""
"This screen dump shows that the size of .set.sysinit_set section is 0x664 "
"bytes, so <literal>0x664/sizeof(void *)</literal> sysinit objects are "
"compiled into the kernel. The other sections such as <literal>.set."
"sysctl_set</literal> represent other linker sets."
msgstr ""
"Este dump de tela mostra que o tamanho da se��o .set.sysinit_set � 0x664 "
"bytes, ent�o <literal> 0x664 / sizeof (void *) </literal> objetos sysinit "
"s�o compilados no kernel. As outras se��es, como <literal> .set.sysctl_set </"
"literal> representam outros conjuntos de linkers. "

#. (itstool) path: sect2/para
#: book.translate.xml:2550
#, fuzzy
msgid ""
"By defining a variable of type <literal>struct linker_set</literal> the "
"content of <literal>.set.sysinit_set</literal> section will be "
"<quote>collected</quote> into that variable:"
msgstr ""
"Definindo uma vari�vel do tipo <literal> struct linker_set </literal> o "
"conte�do de <literal> .set.sysinit_set </literal> se��o ser� <quote> "
"coletado </quote> para essa vari�vel: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2555
#, no-wrap
msgid ""
"<filename>sys/kern/init_main.c:</filename>\n"
"      extern struct linker_set sysinit_set; /* XXX */"
msgstr ""
"<filename>sys/kern/init_main.c:</filename>\n"
"      extern struct linker_set sysinit_set; /* XXX */"

#. (itstool) path: sect2/para
#: book.translate.xml:2558
#, fuzzy
msgid "The <literal>struct linker_set</literal> is defined as follows:"
msgstr ""
"O <literal> struct linker_set </literal> � definido da seguinte forma: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2561
#, no-wrap
msgid ""
"<filename>/usr/include/linker_set.h:</filename>\n"
"  struct linker_set {\n"
"\tint\tls_length;\n"
"\tvoid\t*ls_items[1];\t\t/* really ls_length of them, trailing NULL */\n"
"};"
msgstr ""
"<filename>/usr/include/linker_set.h:</filename>\n"
"  struct linker_set {\n"
"\tint\tls_length;\n"
"\tvoid\t*ls_items[1];\t\t/* really ls_length of them, trailing NULL */\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:2567
#, fuzzy
msgid ""
"The first node will be equal to the number of a sysinit objects, and the "
"second node will be a NULL-terminated array of pointers to them."
msgstr ""
"O primeiro n� ser� igual ao n�mero de objetos sysinit, e o segundo n� ser� "
"uma matriz terminada em NULL de ponteiros para eles."

#. (itstool) path: sect2/para
#: book.translate.xml:2571
#, fuzzy
msgid ""
"Returning to the <function>mi_startup()</function> discussion, it is must be "
"clear now, how the sysinit objects are being organized. The "
"<function>mi_startup()</function> function sorts them and calls each. The "
"very last object is the system scheduler:"
msgstr ""
"Voltando ao <function> mi_startup () </function> discuss�o, � preciso estar "
"claro agora, como os objetos sysinit est�o sendo organizados. o <function> "
"mi_startup () </function> fun��o classifica-los e chama cada um. O �ltimo "
"objeto � o agendador do sistema: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2577
#, no-wrap
msgid ""
"<filename>/usr/include/sys/kernel.h:</filename>\n"
"enum sysinit_sub_id {\n"
"\tSI_SUB_DUMMY\t\t= 0x0000000,\t/* not executed; for linker*/\n"
"\tSI_SUB_DONE\t\t= 0x0000001,\t/* processed*/\n"
"\tSI_SUB_CONSOLE\t\t= 0x0800000,\t/* console*/\n"
"\tSI_SUB_COPYRIGHT\t= 0x0800001,\t/* first use of console*/\n"
"...\n"
"\tSI_SUB_RUN_SCHEDULER\t= 0xfffffff\t/* scheduler: no return*/\n"
"};"
msgstr ""
"<filename>/usr/include/sys/kernel.h:</filename>\n"
"enum sysinit_sub_id {\n"
"\tSI_SUB_DUMMY\t\t= 0x0000000,\t/* not executed; for linker*/\n"
"\tSI_SUB_DONE\t\t= 0x0000001,\t/* processed*/\n"
"\tSI_SUB_CONSOLE\t\t= 0x0800000,\t/* console*/\n"
"\tSI_SUB_COPYRIGHT\t= 0x0800001,\t/* first use of console*/\n"
"...\n"
"\tSI_SUB_RUN_SCHEDULER\t= 0xfffffff\t/* scheduler: no return*/\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:2587
#, fuzzy
msgid ""
"The system scheduler sysinit object is defined in the file <filename>sys/vm/"
"vm_glue.c</filename>, and the entry point for that object is "
"<function>scheduler()</function>. That function is actually an infinite "
"loop, and it represents a process with PID 0, the swapper process. The proc0 "
"structure, mentioned before, is used to describe it."
msgstr ""
"O objeto sysinit do planejador do sistema � definido no arquivo <filename> "
"sys / vm / vm_glue.c </filename> , e o ponto de entrada para esse objeto � "
"<function> Agendador() </function> . Essa fun��o � na verdade um loop "
"infinito e representa um processo com PID 0, o processo de swapper. A "
"estrutura proc0, mencionada anteriormente, � usada para descrev�-la. "

#. (itstool) path: sect2/para
#: book.translate.xml:2594
#, fuzzy
msgid ""
"The first user process, called <emphasis>init</emphasis>, is created by the "
"sysinit object <literal>init</literal>:"
msgstr ""
"O primeiro processo do usu�rio, chamado <emphasis> nisso </emphasis> , � "
"criado pelo objeto sysinit <literal> nisso </literal> : "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2598
#, no-wrap
msgid ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static void\n"
"create_init(const void *udata __unused)\n"
"{\n"
"\tint error;\n"
"\tint s;\n"
"\n"
"\ts = splhigh();\n"
"\terror = fork1(&amp;proc0, RFFDG | RFPROC, &amp;initproc);\n"
"\tif (error)\n"
"\t\tpanic(\"cannot fork init: %d\\n\", error);\n"
"\tinitproc-&gt;p_flag |= P_INMEM | P_SYSTEM;\n"
"\tcpu_set_fork_handler(initproc, start_init, NULL);\n"
"\tremrunqueue(initproc);\n"
"\tsplx(s);\n"
"}\n"
"SYSINIT(init,SI_SUB_CREATE_INIT, SI_ORDER_FIRST, create_init, NULL)"
msgstr ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static void\n"
"create_init(const void *udata __unused)\n"
"{\n"
"\tint error;\n"
"\tint s;\n"
"\n"
"\ts = splhigh();\n"
"\terror = fork1(&amp;proc0, RFFDG | RFPROC, &amp;initproc);\n"
"\tif (error)\n"
"\t\tpanic(\"cannot fork init: %d\\n\", error);\n"
"\tinitproc-&gt;p_flag |= P_INMEM | P_SYSTEM;\n"
"\tcpu_set_fork_handler(initproc, start_init, NULL);\n"
"\tremrunqueue(initproc);\n"
"\tsplx(s);\n"
"}\n"
"SYSINIT(init,SI_SUB_CREATE_INIT, SI_ORDER_FIRST, create_init, NULL)"

#. (itstool) path: sect2/para
#: book.translate.xml:2616
#, fuzzy
msgid ""
"The <function>create_init()</function> allocates a new process by calling "
"<function>fork1()</function>, but does not mark it runnable. When this new "
"process is scheduled for execution by the scheduler, the "
"<function>start_init()</function> will be called. That function is defined "
"in <filename>init_main.c</filename>. It tries to load and exec the "
"<filename>init</filename> binary, probing <filename>/sbin/init</filename> "
"first, then <filename>/sbin/oinit</filename>, <filename>/sbin/init.bak</"
"filename>, and finally <filename>/stand/sysinstall</filename>:"
msgstr ""
"O <function> create_init () </function> aloca um novo processo chamando "
"<function> fork1 () </function> , mas n�o o marca execut�vel. Quando este "
"novo processo � agendado para execu��o pelo agendador, o <function> "
"start_init () </function> ser� chamado. Essa fun��o � definida em <filename> "
"init_main.c </filename> . Ele tenta carregar e executar o <filename> nisso </"
"filename> bin�rio, sondando <filename> / sbin / init </filename> primeiro, "
"ent�o <filename> / sbin / oinit </filename> , <filename> /sbin/init.bak </"
"filename> , e finalmente <filename> / stand / sysinstall </filename> : "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2628
#, no-wrap
msgid ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static char init_path[MAXPATHLEN] =\n"
"#ifdef\tINIT_PATH\n"
"    __XSTRING(INIT_PATH);\n"
"#else\n"
"    \"/sbin/init:/sbin/oinit:/sbin/init.bak:/stand/sysinstall\";\n"
"#endif"
msgstr ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static char init_path[MAXPATHLEN] =\n"
"#ifdef\tINIT_PATH\n"
"    __XSTRING(INIT_PATH);\n"
"#else\n"
"    \"/sbin/init:/sbin/oinit:/sbin/init.bak:/stand/sysinstall\";\n"
"#endif"

#. (itstool) path: chapter/title
#: book.translate.xml:2647
#, fuzzy
msgid "Locking Notes"
msgstr "Notas de Bloqueio"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2649
msgid "<primary>SMP Next Generation Project</primary>"
msgstr "<primary>SMP Next Generation Project</primary>"

#. (itstool) path: chapter/para
#: book.translate.xml:2653
#, fuzzy
msgid ""
"<emphasis>This chapter is maintained by the FreeBSD SMP Next Generation "
"Project.</emphasis>"
msgstr ""
" <emphasis> Este cap�tulo � mantido pelo projeto FreeBSD SMP Next "
"Generation. </emphasis> "

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2656
msgid "<primary>locking</primary>"
msgstr "<primary>locking</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2657
msgid "<primary>multi-processing</primary>"
msgstr "<primary>multi-processing</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2658
msgid "<primary>mutexes</primary>"
msgstr "<primary>mutexes</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2659
msgid "<primary>lockmgr</primary>"
msgstr "<primary>lockmgr</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2660
msgid "<primary>atomic operations</primary>"
msgstr "<primary>atomic operations</primary>"

#. (itstool) path: chapter/para
#: book.translate.xml:2661
#, fuzzy
msgid ""
"This document outlines the locking used in the FreeBSD kernel to permit "
"effective multi-processing within the kernel. Locking can be achieved via "
"several means. Data structures can be protected by mutexes or "
"<citerefentry><refentrytitle>lockmgr</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> locks. A few variables are protected simply by "
"always using atomic operations to access them."
msgstr ""
"Este documento descreve o bloqueio usado no kernel do FreeBSD para permitir "
"um multiprocessamento efetivo dentro do kernel. O bloqueio pode ser "
"alcan�ado atrav�s de v�rios meios. As estruturas de dados podem ser "
"protegidas por mutexes ou <citerefentry><refentrytitle> lockmgr </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> fechaduras. Algumas "
"vari�veis ​​s�o protegidas simplesmente por usar sempre opera��es at�micas "
"para acess�-las. "

#. (itstool) path: sect1/title
#: book.translate.xml:2669
msgid "Mutexes"
msgstr "Mutexes"

#. (itstool) path: sect1/para
#: book.translate.xml:2671
#, fuzzy
msgid ""
"A mutex is simply a lock used to guarantee mutual exclusion. Specifically, a "
"mutex may only be owned by one entity at a time. If another entity wishes to "
"obtain a mutex that is already owned, it must wait until the mutex is "
"released. In the FreeBSD kernel, mutexes are owned by processes."
msgstr ""
"Um mutex � simplesmente um bloqueio usado para garantir a exclus�o m�tua. "
"Especificamente, um mutex s� pode pertencer a uma entidade por vez. Se outra "
"entidade desejar obter um mutex que j� � de propriedade, ele deve aguardar "
"at� que o mutex seja liberado. No kernel do FreeBSD, os mutexes s�o de "
"propriedade de processos. "

#. (itstool) path: sect1/para
#: book.translate.xml:2677
#, fuzzy
msgid ""
"Mutexes may be recursively acquired, but they are intended to be held for a "
"short period of time. Specifically, one may not sleep while holding a mutex. "
"If you need to hold a lock across a sleep, use a "
"<citerefentry><refentrytitle>lockmgr</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> lock."
msgstr ""
"Mutexes podem ser recursivamente adquiridos, mas eles devem ser mantidos por "
"um curto per�odo de tempo. Especificamente, um n�o pode dormir enquanto "
"segura um mutex. Se voc� precisar segurar uma trava atrav�s de um sono, use "
"um <citerefentry><refentrytitle> lockmgr </refentrytitle><manvolnum> 9 </"
"manvolnum></citerefentry> bloqueio \""

#. (itstool) path: sect1/para
#: book.translate.xml:2682
#, fuzzy
msgid "Each mutex has several properties of interest:"
msgstr "Cada mutex tem v�rias propriedades de interesse:"

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2686 book.translate.xml:2780 book.translate.xml:2938
#, fuzzy
msgid "Variable Name"
msgstr "Nome vari�vel"

#. (itstool) path: listitem/para
#: book.translate.xml:2688
#, fuzzy
msgid "The name of the <type>struct mtx</type> variable in the kernel source."
msgstr "O nome do <type> struct mtx </type> vari�vel na fonte do kernel. "

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2694 book.translate.xml:2781
msgid "Logical Name"
msgstr "Nome Lógico"

#. (itstool) path: listitem/para
#: book.translate.xml:2696
#, fuzzy
msgid ""
"The name of the mutex assigned to it by <function>mtx_init</function>. This "
"name is displayed in KTR trace messages and witness errors and warnings and "
"is used to distinguish mutexes in the witness code."
msgstr ""
"O nome do mutex atribu�do a ele por <function> mtx_init </function> . Esse "
"nome � exibido em mensagens de rastreamento KTR e testemunha de erros e "
"avisos e � usado para distinguir mutexes no c�digo da testemunha. "

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2704 book.translate.xml:2782
msgid "Type"
msgstr "Tipo"

#. (itstool) path: listitem/para
#: book.translate.xml:2706
#, fuzzy
msgid ""
"The type of the mutex in terms of the <constant>MTX_*</constant> flags. The "
"meaning for each flag is related to its meaning as documented in "
"<citerefentry><refentrytitle>mutex</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry>."
msgstr ""
"O tipo do mutex em termos de <constant> MTX_ * </constant> bandeiras. O "
"significado para cada bandeira est� relacionado ao seu significado conforme "
"documentado em <citerefentry><refentrytitle> mutex </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> "

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2713 book.translate.xml:2871
msgid "<constant>MTX_DEF</constant>"
msgstr "<constant>MTX_DEF</constant>"

#. (itstool) path: listitem/para
#: book.translate.xml:2715
#, fuzzy
msgid "A sleep mutex"
msgstr "Um mutex do sono"

#. (itstool) path: varlistentry/term
#: book.translate.xml:2720
msgid "<constant>MTX_SPIN</constant>"
msgstr "<constant>MTX_SPIN</constant>"

#. (itstool) path: listitem/para
#: book.translate.xml:2722
#, fuzzy
msgid "A spin mutex"
msgstr "Um mutex spin"

#. (itstool) path: varlistentry/term
#: book.translate.xml:2727
msgid "<constant>MTX_RECURSE</constant>"
msgstr "<constant>MTX_RECURSE</constant>"

#. (itstool) path: listitem/para
#: book.translate.xml:2729
#, fuzzy
msgid "This mutex is allowed to recurse."
msgstr "Esse mutex pode recorrer."

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2737 book.translate.xml:2783 book.translate.xml:2939
#, fuzzy
msgid "Protectees"
msgstr "Protegidos"

#. (itstool) path: listitem/para
#: book.translate.xml:2739
#, fuzzy
msgid ""
"A list of data structures or data structure members that this entry "
"protects. For data structure members, the name will be in the form of "
"<varname remap=\"structname\">structure name</varname>.<varname remap="
"\"structfield\">member name</varname>."
msgstr ""
"Uma lista de estruturas de dados ou membros da estrutura de dados que esta "
"entrada protege. Para membros da estrutura de dados, o nome estar� na forma "
"de <varname remap=\"structname\"> nome da estrutura </varname> . <varname "
"remap=\"structfield\"> nome do membro </varname> "

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2746 book.translate.xml:2784
#, fuzzy
msgid "Dependent Functions"
msgstr "Fun��es dependentes"

#. (itstool) path: listitem/para
#: book.translate.xml:2748
#, fuzzy
msgid "Functions that can only be called if this mutex is held."
msgstr "Fun��es que s� podem ser chamadas se este mutex for mantido."

#. (itstool) path: table/title
#: book.translate.xml:2755
#, fuzzy
msgid "Mutex List"
msgstr "Lista Mutex"

#. (itstool) path: table/indexterm
#: book.translate.xml:2757
msgid "<primary>locks</primary> <secondary>sched_lock</secondary>"
msgstr "<primary>locks</primary> <secondary>sched_lock</secondary>"

#. (itstool) path: table/indexterm
#: book.translate.xml:2762
msgid "<primary>locks</primary> <secondary>vm86pcb_lock</secondary>"
msgstr "<primary>locks</primary> <secondary>vm86pcb_lock</secondary>"

#. (itstool) path: table/indexterm
#: book.translate.xml:2767
msgid "<primary>locks</primary> <secondary>Giant</secondary>"
msgstr "<primary>locks</primary> <secondary>Giant</secondary>"

#. (itstool) path: table/indexterm
#: book.translate.xml:2772
msgid "<primary>locks</primary> <secondary>callout_lock</secondary>"
msgstr "<primary>locks</primary> <secondary>callout_lock</secondary>"

#. (itstool) path: row/entry
#: book.translate.xml:2791
#, fuzzy
msgid "sched_lock"
msgstr "sched_lock"

#. (itstool) path: row/entry
#: book.translate.xml:2792
#, fuzzy
msgid "<quote>sched lock</quote>"
msgstr " <quote> bloqueio de programa��o </quote> "

#. (itstool) path: row/entry
#: book.translate.xml:2794 book.translate.xml:2894
msgid "<constant>MTX_SPIN</constant> | <constant>MTX_RECURSE</constant>"
msgstr "<constant>MTX_SPIN</constant> | <constant>MTX_RECURSE</constant>"

#. (itstool) path: row/entry
#: book.translate.xml:2797
msgid ""
"<varname>_gmonparam</varname>, <varname>cnt.v_swtch</varname>, "
"<varname>cp_time</varname>, <varname>curpriority</varname>, <varname remap="
"\"structname\">mtx</varname>.<varname remap=\"structfield\">mtx_blocked</"
"varname>, <varname remap=\"structname\">mtx</varname>.<varname remap="
"\"structfield\">mtx_contested</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_procq</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_slpq</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_sflag</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_stat</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_estcpu</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_cpticks</varname> <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_pctcpu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_wchan</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_wmesg</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_swtime</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_slptime</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_runtime</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_uu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_su</varname>, "
"<varname remap=\"structname\">proc</varname>.<varname remap=\"structfield"
"\">p_iu</varname>, <varname remap=\"structname\">proc</varname>.<varname "
"remap=\"structfield\">p_uticks</varname>, <varname remap=\"structname"
"\">proc</varname>.<varname remap=\"structfield\">p_sticks</varname>, "
"<varname remap=\"structname\">proc</varname>.<varname remap=\"structfield"
"\">p_iticks</varname>, <varname remap=\"structname\">proc</varname>.<varname "
"remap=\"structfield\">p_oncpu</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_lastcpu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_rqindex</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_heldmtx</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_blocked</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_mtxname</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_contested</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_priority</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_usrpri</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_nativepri</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_nice</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_rtprio</"
"varname>, <varname>pscnt</varname>, <varname>slpque</varname>, "
"<varname>itqueuebits</varname>, <varname>itqueues</varname>, "
"<varname>rtqueuebits</varname>, <varname>rtqueues</varname>, "
"<varname>queuebits</varname>, <varname>queues</varname>, "
"<varname>idqueuebits</varname>, <varname>idqueues</varname>, "
"<varname>switchtime</varname>, <varname>switchticks</varname>"
msgstr ""
"<varname>_gmonparam</varname>, <varname>cnt.v_swtch</varname>, "
"<varname>cp_time</varname>, <varname>curpriority</varname>, <varname remap="
"\"structname\">mtx</varname>.<varname remap=\"structfield\">mtx_blocked</"
"varname>, <varname remap=\"structname\">mtx</varname>.<varname remap="
"\"structfield\">mtx_contested</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_procq</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_slpq</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_sflag</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_stat</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_estcpu</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_cpticks</varname> <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_pctcpu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_wchan</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_wmesg</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_swtime</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_slptime</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_runtime</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_uu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_su</varname>, "
"<varname remap=\"structname\">proc</varname>.<varname remap=\"structfield"
"\">p_iu</varname>, <varname remap=\"structname\">proc</varname>.<varname "
"remap=\"structfield\">p_uticks</varname>, <varname remap=\"structname"
"\">proc</varname>.<varname remap=\"structfield\">p_sticks</varname>, "
"<varname remap=\"structname\">proc</varname>.<varname remap=\"structfield"
"\">p_iticks</varname>, <varname remap=\"structname\">proc</varname>.<varname "
"remap=\"structfield\">p_oncpu</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_lastcpu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_rqindex</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_heldmtx</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_blocked</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_mtxname</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_contested</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_priority</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_usrpri</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_nativepri</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_nice</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_rtprio</"
"varname>, <varname>pscnt</varname>, <varname>slpque</varname>, "
"<varname>itqueuebits</varname>, <varname>itqueues</varname>, "
"<varname>rtqueuebits</varname>, <varname>rtqueues</varname>, "
"<varname>queuebits</varname>, <varname>queues</varname>, "
"<varname>idqueuebits</varname>, <varname>idqueues</varname>, "
"<varname>switchtime</varname>, <varname>switchticks</varname>"

#. (itstool) path: row/entry
#: book.translate.xml:2846
msgid ""
"<function>setrunqueue</function>, <function>remrunqueue</function>, "
"<function>mi_switch</function>, <function>chooseproc</function>, "
"<function>schedclock</function>, <function>resetpriority</function>, "
"<function>updatepri</function>, <function>maybe_resched</function>, "
"<function>cpu_switch</function>, <function>cpu_throw</function>, "
"<function>need_resched</function>, <function>resched_wanted</function>, "
"<function>clear_resched</function>, <function>aston</function>, "
"<function>astoff</function>, <function>astpending</function>, "
"<function>calcru</function>, <function>proc_compare</function>"
msgstr ""
"<function>setrunqueue</function>, <function>remrunqueue</function>, "
"<function>mi_switch</function>, <function>chooseproc</function>, "
"<function>schedclock</function>, <function>resetpriority</function>, "
"<function>updatepri</function>, <function>maybe_resched</function>, "
"<function>cpu_switch</function>, <function>cpu_throw</function>, "
"<function>need_resched</function>, <function>resched_wanted</function>, "
"<function>clear_resched</function>, <function>aston</function>, "
"<function>astoff</function>, <function>astpending</function>, "
"<function>calcru</function>, <function>proc_compare</function>"

#. (itstool) path: row/entry
#: book.translate.xml:2869
msgid "vm86pcb_lock"
msgstr "vm86pcb_lock"

#. (itstool) path: row/entry
#: book.translate.xml:2870
#, fuzzy
msgid "<quote>vm86pcb lock</quote>"
msgstr " <quote> bloqueio vm86pcb </quote> "

#. (itstool) path: row/entry
#: book.translate.xml:2873
#, fuzzy
msgid "<varname>vm86pcb</varname>"
msgstr " <varname> vm86pcb </varname> "

#. (itstool) path: row/entry
#: book.translate.xml:2875
#, fuzzy
msgid "<function>vm86_bioscall</function>"
msgstr " <function> vm86_bioscall </function> "

#. (itstool) path: row/entry
#: book.translate.xml:2881
#, fuzzy
msgid "Giant"
msgstr "Gigante"

#. (itstool) path: row/entry
#: book.translate.xml:2882
#, fuzzy
msgid "<quote>Giant</quote>"
msgstr " <quote> Gigante </quote> "

#. (itstool) path: row/entry
#: book.translate.xml:2883
#, fuzzy
msgid "<constant>MTX_DEF</constant> | <constant>MTX_RECURSE</constant>"
msgstr " <constant> MTX_DEF </constant> | <constant> MTX_RECURSE </constant> "

#. (itstool) path: row/entry
#: book.translate.xml:2886
#, fuzzy
msgid "nearly everything"
msgstr "quase tudo"

#. (itstool) path: row/entry
#: book.translate.xml:2887
#, fuzzy
msgid "lots"
msgstr "grande quantidade"

#. (itstool) path: row/entry
#: book.translate.xml:2892
#, fuzzy
msgid "callout_lock"
msgstr "callout_lock"

#. (itstool) path: row/entry
#: book.translate.xml:2893
#, fuzzy
msgid "<quote>callout lock</quote>"
msgstr " <quote> bloqueio de texto explicativo </quote> "

#. (itstool) path: row/entry
#: book.translate.xml:2897
#, fuzzy
msgid ""
"<varname>callfree</varname>, <varname>callwheel</varname>, "
"<varname>nextsoftcheck</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_itcallout</varname>, <varname "
"remap=\"structname\">proc</varname>.<varname remap=\"structfield"
"\">p_slpcallout</varname>, <varname>softticks</varname>, <varname>ticks</"
"varname>"
msgstr ""
" <varname> callfree </varname> , <varname> volante </varname> , <varname> "
"nextsoftcheck </varname> , <varname remap=\"structname\"> proc </varname> . "
"<varname remap=\"structfield\"> p_itcallout </varname> , <varname remap="
"\"structname\"> proc </varname> . <varname remap=\"structfield\"> "
"p_slpcallout </varname> , <varname> softticks </varname> , <varname> "
"carrapatos </varname> "

#. (itstool) path: sect1/title
#: book.translate.xml:2913
#, fuzzy
msgid "Shared Exclusive Locks"
msgstr "Bloqueios exclusivos compartilhados"

#. (itstool) path: sect1/para
#: book.translate.xml:2915
#, fuzzy
msgid ""
"These locks provide basic reader-writer type functionality and may be held "
"by a sleeping process. Currently they are backed by "
"<citerefentry><refentrytitle>lockmgr</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry>."
msgstr ""
"Esses bloqueios fornecem funcionalidade b�sica do tipo leitor-gravador e "
"podem ser mantidos por um processo de suspens�o. Atualmente, eles s�o "
"protegidos por <citerefentry><refentrytitle> lockmgr </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:2918
msgid "<primary>locks</primary> <secondary>shared exclusive</secondary>"
msgstr "<primary>locks</primary> <secondary>shared exclusive</secondary>"

#. (itstool) path: table/title
#: book.translate.xml:2924
#, fuzzy
msgid "Shared Exclusive Lock List"
msgstr "Lista de bloqueio exclusiva compartilhada"

#. (itstool) path: table/indexterm
#: book.translate.xml:2926
msgid "<primary>locks</primary> <secondary>allproc_lock</secondary>"
msgstr "<primary>locks</primary> <secondary>allproc_lock</secondary>"

#. (itstool) path: table/indexterm
#: book.translate.xml:2930
msgid "<primary>locks</primary> <secondary>proctree_lock</secondary>"
msgstr "<primary>locks</primary> <secondary>proctree_lock</secondary>"

#. (itstool) path: row/entry
#: book.translate.xml:2944
msgid "<varname>allproc_lock</varname>"
msgstr "<varname>allproc_lock</varname>"

#. (itstool) path: row/entry
#: book.translate.xml:2945
msgid ""
"<varname>allproc</varname> <varname>zombproc</varname> <varname>pidhashtbl</"
"varname> <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_list</varname> <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_hash</varname> <varname>nextpid</"
"varname>"
msgstr ""
"<varname>allproc</varname> <varname>zombproc</varname> <varname>pidhashtbl</"
"varname> <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_list</varname> <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_hash</varname> <varname>nextpid</"
"varname>"

#. (itstool) path: row/entry
#: book.translate.xml:2955
msgid "<varname>proctree_lock</varname>"
msgstr "<varname>proctree_lock</varname>"

#. (itstool) path: row/entry
#: book.translate.xml:2956
#, fuzzy
msgid ""
"<varname remap=\"structname\">proc</varname>.<varname remap=\"structfield"
"\">p_children</varname> <varname remap=\"structname\">proc</varname>."
"<varname remap=\"structfield\">p_sibling</varname>"
msgstr ""
" <varname remap=\"structname\"> proc </varname> . <varname remap="
"\"structfield\"> p_children </varname><varname remap=\"structname\"> proc </"
"varname> . <varname remap=\"structfield\"> p_sibling </varname> "

#. (itstool) path: sect1/title
#: book.translate.xml:2966
#, fuzzy
msgid "Atomically Protected Variables"
msgstr "Vari�veis ​​Atomicamente Protegidas"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:2968
msgid "<primary>atomically protected variables</primary>"
msgstr "<primary>atomically protected variables</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:2972
#, fuzzy
msgid ""
"An atomically protected variable is a special variable that is not protected "
"by an explicit lock. Instead, all data accesses to the variables use special "
"atomic operations as described in <citerefentry><refentrytitle>atomic</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>. Very few variables "
"are treated this way, although other synchronization primitives such as "
"mutexes are implemented with atomically protected variables."
msgstr ""
"Uma vari�vel atomicamente protegida � uma vari�vel especial que n�o � "
"protegida por um bloqueio expl�cito. Em vez disso, todos os acessos a dados "
"para as vari�veis ​​usam opera��es at�micas especiais, como descrito em "
"<citerefentry><refentrytitle> at�mico </refentrytitle><manvolnum> 9 </"
"manvolnum></citerefentry> . Muito poucas vari�veis ​​s�o tratadas dessa "
"maneira, embora outras primitivas de sincroniza��o, como mutexes, sejam "
"implementadas com vari�veis ​​protegidas atomicamente. "

#. (itstool) path: listitem/para
#: book.translate.xml:2982
msgid ""
"<varname remap=\"structname\">mtx</varname>.<varname remap=\"structfield"
"\">mtx_lock</varname>"
msgstr ""
"<varname remap=\"structname\">mtx</varname>.<varname remap=\"structfield"
"\">mtx_lock</varname>"

#. (itstool) path: chapter/title
#: book.translate.xml:2995
msgid "Kernel Objects"
msgstr "Objetos do Kernel"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2997
msgid "<primary>Kernel Objects</primary>"
msgstr "<primary>Kernel Objects</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2998
msgid "<primary>Object-Oriented</primary>"
msgstr "<primary>Object-Oriented</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2999
msgid "<primary>binary compatibility</primary>"
msgstr "<primary>binary compatibility</primary>"

#. (itstool) path: chapter/para
#: book.translate.xml:3000
#, fuzzy
msgid ""
"Kernel Objects, or <firstterm>Kobj</firstterm> provides an object-oriented C "
"programming system for the kernel. As such the data being operated on "
"carries the description of how to operate on it. This allows operations to "
"be added and removed from an interface at run time and without breaking "
"binary compatibility."
msgstr ""
"Objetos do Kernel, ou <firstterm> Kobj </firstterm> fornece um sistema de "
"programa��o C orientado a objeto para o kernel. Como tal, os dados que est�o "
"sendo operados cont�m a descri��o de como oper�-lo. Isso permite que as "
"opera��es sejam adicionadas e removidas de uma interface em tempo de "
"execu��o e sem quebrar a compatibilidade bin�ria. "

#. (itstool) path: sect1/title
#: book.translate.xml:3008 book.translate.xml:4125
msgid "Terminology"
msgstr "Terminologia"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:3010
msgid "<primary>object</primary>"
msgstr "<primary>object</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:3011
msgid "<primary>method</primary>"
msgstr "<primary>method</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:3012
msgid "<primary>class</primary>"
msgstr "<primary>class</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:3013
msgid "<primary>interface</primary>"
msgstr "<primary>interface</primary>"

#. (itstool) path: varlistentry/term
#: book.translate.xml:3017
msgid "Object"
msgstr "Objeto"

#. (itstool) path: listitem/para
#: book.translate.xml:3018
#, fuzzy
msgid "A set of data - data structure - data allocation."
msgstr "Um conjunto de dados - estrutura de dados - aloca��o de dados."

#. (itstool) path: varlistentry/term
#: book.translate.xml:3023
msgid "Method"
msgstr "Método"

#. (itstool) path: listitem/para
#: book.translate.xml:3025
#, fuzzy
msgid "An operation - function."
msgstr "Uma opera��o - fun��o."

#. (itstool) path: varlistentry/term
#: book.translate.xml:3029
#, fuzzy
msgid "Class"
msgstr "Classe"

#. (itstool) path: listitem/para
#: book.translate.xml:3031
#, fuzzy
msgid "One or more methods."
msgstr "Um ou mais m�todos."

#. (itstool) path: varlistentry/term
#. (itstool) path: sect2/title
#: book.translate.xml:3035 book.translate.xml:4187
#, fuzzy
msgid "Interface"
msgstr "Interface"

#. (itstool) path: listitem/para
#: book.translate.xml:3037
#, fuzzy
msgid "A standard set of one or more methods."
msgstr "Um conjunto padr�o de um ou mais m�todos."

#. (itstool) path: sect1/title
#: book.translate.xml:3044
#, fuzzy
msgid "Kobj Operation"
msgstr "Opera��o Kobj"

#. (itstool) path: sect1/para
#: book.translate.xml:3046
#, fuzzy
msgid ""
"Kobj works by generating descriptions of methods. Each description holds a "
"unique id as well as a default function. The description's address is used "
"to uniquely identify the method within a class' method table."
msgstr ""
"O Kobj funciona gerando descri��es de m�todos. Cada descri��o possui um ID "
"�nico, bem como uma fun��o padr�o. O endere�o da descri��o � usado para "
"identificar exclusivamente o m�todo dentro da tabela de m�todos de uma "
"classe."

#. (itstool) path: sect1/para
#: book.translate.xml:3051
#, fuzzy
msgid ""
"A class is built by creating a method table associating one or more "
"functions with method descriptions. Before use the class is compiled. The "
"compilation allocates a cache and associates it with the class. A unique id "
"is assigned to each method description within the method table of the class "
"if not already done so by another referencing class compilation. For every "
"method to be used a function is generated by script to qualify arguments and "
"automatically reference the method description for a lookup. The generated "
"function looks up the method by using the unique id associated with the "
"method description as a hash into the cache associated with the object's "
"class. If the method is not cached the generated function proceeds to use "
"the class' table to find the method. If the method is found then the "
"associated function within the class is used; otherwise, the default "
"function associated with the method description is used."
msgstr ""
"Uma classe � constru�da criando uma tabela de m�todos associando uma ou mais "
"fun��es com descri��es de m�todos. Antes de usar, a classe � compilada. A "
"compila��o aloca um cache e o associa � classe. Um ID �nico � atribu�do a "
"cada descri��o de m�todo dentro do m�todo. tabela da classe, se ainda n�o "
"tiver sido feita por outra compila��o de classe de refer�ncia.Para cada "
"m�todo a ser usado, uma fun��o � gerada pelo script para qualificar "
"argumentos e automaticamente referenciar a descri��o do m�todo para uma "
"pesquisa.A fun��o gerada procura o m�todo usando a ID �nico associado � "
"descri��o do m�todo como um hash no cache associado � classe do objeto.Se o "
"m�todo n�o � armazenado em cache, a fun��o gerada continua a usar a tabela "
"da classe para localizar o m�todo.Se o m�todo for encontrado, a fun��o "
"associada a classe � usada, caso contr�rio, a fun��o padr�o associada � "
"descri��o do m�todo � usada. "

#. (itstool) path: sect1/para
#: book.translate.xml:3068
#, fuzzy
msgid "These indirections can be visualized as the following:"
msgstr "Essas indire��es podem ser visualizadas da seguinte forma:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:3071
#, no-wrap
msgid "object-&gt;cache&lt;-&gt;class"
msgstr "object-&gt;cache&lt;-&gt;class"

#. (itstool) path: sect1/title
#: book.translate.xml:3076
#, fuzzy
msgid "Using Kobj"
msgstr "Usando o Kobj"

#. (itstool) path: sect2/title
#: book.translate.xml:3079
#, fuzzy
msgid "Structures"
msgstr "Estruturas"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3081
#, no-wrap
msgid "struct kobj_method"
msgstr "struct kobj_method"

#. (itstool) path: sect2/title
#: book.translate.xml:3085
#, fuzzy
msgid "Functions"
msgstr "Fun��es"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3087
#, no-wrap
msgid ""
"void kobj_class_compile(kobj_class_t cls);\n"
"void kobj_class_compile_static(kobj_class_t cls, kobj_ops_t ops);\n"
"void kobj_class_free(kobj_class_t cls);\n"
"kobj_t kobj_create(kobj_class_t cls, struct malloc_type *mtype, int mflags);\n"
"void kobj_init(kobj_t obj, kobj_class_t cls);\n"
"void kobj_delete(kobj_t obj, struct malloc_type *mtype);"
msgstr ""
"void kobj_class_compile(kobj_class_t cls);\n"
"void kobj_class_compile_static(kobj_class_t cls, kobj_ops_t ops);\n"
"void kobj_class_free(kobj_class_t cls);\n"
"kobj_t kobj_create(kobj_class_t cls, struct malloc_type *mtype, int mflags);\n"
"void kobj_init(kobj_t obj, kobj_class_t cls);\n"
"void kobj_delete(kobj_t obj, struct malloc_type *mtype);"

#. (itstool) path: sect2/title
#. (itstool) path: sect3/title
#: book.translate.xml:3096 book.translate.xml:4196
#, fuzzy
msgid "Macros"
msgstr "Macros"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3098
#, no-wrap
msgid ""
"KOBJ_CLASS_FIELDS\n"
"KOBJ_FIELDS\n"
"DEFINE_CLASS(name, methods, size)\n"
"KOBJMETHOD(NAME, FUNC)"
msgstr ""
"KOBJ_CLASS_FIELDS\n"
"KOBJ_FIELDS\n"
"DEFINE_CLASS(name, methods, size)\n"
"KOBJMETHOD(NAME, FUNC)"

#. (itstool) path: sect2/title
#. (itstool) path: sect3/title
#: book.translate.xml:3105 book.translate.xml:4190
#, fuzzy
msgid "Headers"
msgstr "Cabe�alhos"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3107
#, no-wrap
msgid ""
"&lt;sys/param.h&gt;\n"
"&lt;sys/kobj.h&gt;"
msgstr ""
"&lt;sys/param.h&gt;\n"
"&lt;sys/kobj.h&gt;"

#. (itstool) path: sect2/title
#: book.translate.xml:3112
#, fuzzy
msgid "Creating an Interface Template"
msgstr "Criando um modelo de interface"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3114
#, fuzzy
msgid "<primary>Kernel Objects</primary> <secondary>interface</secondary>"
msgstr ""
" <primary> Objetos do Kernel </primary><secondary> interface </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3117
#, fuzzy
msgid ""
"The first step in using Kobj is to create an Interface. Creating the "
"interface involves creating a template that the script <filename>src/sys/"
"kern/makeobjops.pl</filename> can use to generate the header and code for "
"the method declarations and method lookup functions."
msgstr ""
"O primeiro passo para usar o Kobj � criar uma interface. Criar a interface "
"envolve criar um modelo que o script <filename> src / sys / kern / "
"makeobjops.pl </filename> pode usar para gerar o cabe�alho e c�digo para as "
"declara��es de m�todo e fun��es de pesquisa de m�todo. "

#. (itstool) path: sect2/para
#: book.translate.xml:3124
#, fuzzy
msgid ""
"Within this template the following keywords are used: <literal>#include</"
"literal>, <literal>INTERFACE</literal>, <literal>CODE</literal>, "
"<literal>METHOD</literal>, <literal>STATICMETHOD</literal>, and "
"<literal>DEFAULT</literal>."
msgstr ""
"Nesse modelo, as seguintes palavras-chave s�o usadas: <literal> #incluir </"
"literal> , <literal> INTERFACE </literal> , <literal> C�DIGO </literal> , "
"<literal> M�TODO </literal> , <literal> STATICMETHOD </literal> e <literal> "
"PADR�O </literal> "

#. (itstool) path: sect2/para
#: book.translate.xml:3130
#, fuzzy
msgid ""
"The <literal>#include</literal> statement and what follows it is copied "
"verbatim to the head of the generated code file."
msgstr ""
"O <literal> #incluir </literal> declara��o e o que se segue � copiado "
"textualmente para a cabe�a do arquivo de c�digo gerado. "

#. (itstool) path: sect2/para
#: book.translate.xml:3134 book.translate.xml:3143 book.translate.xml:3151
#: book.translate.xml:3164 book.translate.xml:3180 book.translate.xml:3217
msgid "For example:"
msgstr "Por exemplo:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3136
#, no-wrap
msgid "#include &lt;sys/foo.h&gt;"
msgstr "#include &lt;sys/foo.h&gt;"

#. (itstool) path: sect2/para
#: book.translate.xml:3138
#, fuzzy
msgid ""
"The <literal>INTERFACE</literal> keyword is used to define the interface "
"name. This name is concatenated with each method name as [interface "
"name]_[method name]. Its syntax is INTERFACE [interface name];."
msgstr ""
"O <literal> INTERFACE </literal> palavra-chave � usada para definir o nome "
"da interface. Este nome � concatenado com cada nome de m�todo como [nome da "
"interface] _ [nome do m�todo]. Sua sintaxe � INTERFACE [nome da interface] ;"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3145
#, no-wrap
msgid "INTERFACE foo;"
msgstr "INTERFACE foo;"

#. (itstool) path: sect2/para
#: book.translate.xml:3147
#, fuzzy
msgid ""
"The <literal>CODE</literal> keyword copies its arguments verbatim into the "
"code file. Its syntax is <literal>CODE { [whatever] };</literal>"
msgstr ""
"O <literal> C�DIGO </literal> A palavra-chave copia seus argumentos "
"literalmente no arquivo de c�digo. Sua sintaxe � <literal> CODE {[qualquer "
"que seja]}; </literal> "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3153
#, no-wrap
msgid ""
"CODE {\n"
"\tstruct foo * foo_alloc_null(struct bar *)\n"
"\t{\n"
"\t\treturn NULL;\n"
"}\n"
"};"
msgstr ""
"CODE {\n"
"\tstruct foo * foo_alloc_null(struct bar *)\n"
"\t{\n"
"\t\treturn NULL;\n"
"}\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:3160
#, fuzzy
msgid ""
"The <literal>METHOD</literal> keyword describes a method. Its syntax is "
"<literal>METHOD [return type] [method name] { [object [, arguments]] };</"
"literal>"
msgstr ""
"O <literal> M�TODO </literal> palavra-chave descreve um m�todo. Sua sintaxe "
"� <literal> M�TODO [tipo de retorno] [nome do m�todo] {[objeto [, "
"argumentos]]}; </literal> "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3166
#, no-wrap
msgid ""
"METHOD int bar {\n"
"\tstruct object *;\n"
"\tstruct foo *;\n"
"\tstruct bar;\n"
"};"
msgstr ""
"METHOD int bar {\n"
"\tstruct object *;\n"
"\tstruct foo *;\n"
"\tstruct bar;\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:3172
#, fuzzy
msgid ""
"The <literal>DEFAULT</literal> keyword may follow the <literal>METHOD</"
"literal> keyword. It extends the <literal>METHOD</literal> key word to "
"include the default function for method. The extended syntax is "
"<literal>METHOD [return type] [method name] { [object; [other arguments]] }"
"DEFAULT [default function];</literal>"
msgstr ""
"O <literal> PADR�O </literal> palavra-chave pode seguir o <literal> M�TODO </"
"literal> palavra chave. Estende o <literal> M�TODO </literal> palavra-chave "
"para incluir a fun��o padr�o para o m�todo. A sintaxe estendida � <literal> "
"M�TODO [tipo de retorno] [nome do m�todo] {[objeto; [outros argumentos]]} "
"PADR�O [fun��o padr�o]; </literal> "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3182
#, no-wrap
msgid ""
"METHOD int bar {\n"
"\tstruct object *;\n"
"\tstruct foo *;\n"
"\tint bar;\n"
"} DEFAULT foo_hack;"
msgstr ""
"METHOD int bar {\n"
"\tstruct object *;\n"
"\tstruct foo *;\n"
"\tint bar;\n"
"} DEFAULT foo_hack;"

#. (itstool) path: sect2/para
#: book.translate.xml:3188
#, fuzzy
msgid ""
"The <literal>STATICMETHOD</literal> keyword is used like the "
"<literal>METHOD</literal> keyword except the kobj data is not at the head of "
"the object structure so casting to kobj_t would be incorrect. Instead "
"<literal>STATICMETHOD</literal> relies on the Kobj data being referenced as "
"'ops'. This is also useful for calling methods directly out of a class's "
"method table."
msgstr ""
"O <literal> STATICMETHOD </literal> palavra-chave � usada como o <literal> "
"M�TODO </literal> a palavra-chave, exceto os dados do kobj, n�o est� na "
"cabe�a da estrutura do objeto, portanto, converter para kobj_t seria "
"incorreto. Em vez de <literal> STATICMETHOD </literal> depende dos dados do "
"Kobj sendo referenciados como ';ops';. Isso tamb�m � �til para chamar "
"m�todos diretamente da tabela de m�todos de uma classe. "

#. (itstool) path: sect2/para
#: book.translate.xml:3195
msgid "Other complete examples:"
msgstr "Outros exemplos completos:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3197
#, no-wrap
msgid ""
"src/sys/kern/bus_if.m\n"
"src/sys/kern/device_if.m"
msgstr ""
"src/sys/kern/bus_if.m\n"
"src/sys/kern/device_if.m"

#. (itstool) path: sect2/title
#: book.translate.xml:3203
msgid "Creating a Class"
msgstr "Criando uma classe"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3205
msgid "<primary>Kernel Objects</primary> <secondary>class</secondary>"
msgstr "<primary>Kernel Objects</primary> <secondary>class</secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:3208
#, fuzzy
msgid ""
"The second step in using Kobj is to create a class. A class consists of a "
"name, a table of methods, and the size of objects if Kobj's object handling "
"facilities are used. To create the class use the macro "
"<function>DEFINE_CLASS()</function>. To create the method table create an "
"array of kobj_method_t terminated by a NULL entry. Each non-NULL entry may "
"be created using the macro <function>KOBJMETHOD()</function>."
msgstr ""
"O segundo passo para usar o Kobj � criar uma classe. Uma classe consiste em "
"um nome, uma tabela de m�todos e o tamanho dos objetos se os recursos de "
"manipula��o de objetos do Kobj forem usados. Para criar a classe use a macro "
"<function> DEFINE_CLASS () </function> . Para criar a tabela de m�todos, "
"crie uma matriz de kobj_method_t terminada por uma entrada NULL. Cada "
"entrada n�o-NULL pode ser criada usando a macro <function> KOBJMETHOD () </"
"function> "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3219
#, no-wrap
msgid ""
"DEFINE_CLASS(fooclass, foomethods, sizeof(struct foodata));\n"
"\n"
"kobj_method_t foomethods[] = {\n"
"\tKOBJMETHOD(bar_doo, foo_doo),\n"
"\tKOBJMETHOD(bar_foo, foo_foo),\n"
"\t{ NULL, NULL}\n"
"};"
msgstr ""
"DEFINE_CLASS(fooclass, foomethods, sizeof(struct foodata));\n"
"\n"
"kobj_method_t foomethods[] = {\n"
"\tKOBJMETHOD(bar_doo, foo_doo),\n"
"\tKOBJMETHOD(bar_foo, foo_foo),\n"
"\t{ NULL, NULL}\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:3227
#, fuzzy
msgid ""
"The class must be <quote>compiled</quote>. Depending on the state of the "
"system at the time that the class is to be initialized a statically "
"allocated cache, <quote>ops table</quote> have to be used. This can be "
"accomplished by declaring a <varname remap=\"structname\">struct kobj_ops</"
"varname> and using <function>kobj_class_compile_static();</function> "
"otherwise, <function>kobj_class_compile()</function> should be used."
msgstr ""
"A aula deve ser <quote> compilado </quote> . Dependendo do estado do sistema "
"no momento em que a classe ser� inicializada, um cache alocado "
"estaticamente, <quote> mesa de opera��es </quote> tem que ser usado. Isso "
"pode ser feito declarando um <varname remap=\"structname\"> struct kobj_ops "
"</varname> e usando <function> kobj_class_compile_static (); </function> de "
"outra forma, <function> kobj_class_compile () </function> deve ser usado."

#. (itstool) path: sect2/title
#: book.translate.xml:3237
msgid "Creating an Object"
msgstr "Criando um Objeto"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3239
msgid "<primary>Kernel Objects</primary> <secondary>object</secondary>"
msgstr "<primary>Kernel Objects</primary> <secondary>object</secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:3242
#, fuzzy
msgid ""
"The third step in using Kobj involves how to define the object. Kobj object "
"creation routines assume that Kobj data is at the head of an object. If this "
"in not appropriate you will have to allocate the object yourself and then "
"use <function>kobj_init()</function> on the Kobj portion of it; otherwise, "
"you may use <function>kobj_create()</function> to allocate and initialize "
"the Kobj portion of the object automatically. <function>kobj_init()</"
"function> may also be used to change the class that an object uses."
msgstr ""
"A terceira etapa no uso do Kobj envolve como definir o objeto. As rotinas de "
"cria��o de objetos do Kobj assumem que os dados do Kobj est�o na cabe�a de "
"um objeto. Se isso n�o for apropriado, voc� ter� que alocar o objeto e usar "
"<function> kobj_init () </function> na por��o de Kobj; caso contr�rio, voc� "
"pode usar <function> kobj_create () </function> para alocar e inicializar a "
"parte Kobj do objeto automaticamente. <function> kobj_init () </function> "
"tamb�m pode ser usado para alterar a classe que um objeto usa. "

#. (itstool) path: sect2/para
#: book.translate.xml:3252
#, fuzzy
msgid "To integrate Kobj into the object you should use the macro KOBJ_FIELDS."
msgstr "Para integrar o Kobj no objeto voc� deve usar a macro KOBJ_FIELDS."

#. (itstool) path: sect2/para
#: book.translate.xml:3255
msgid "For example"
msgstr "Por exemplo"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3257
#, no-wrap
msgid ""
"struct foo_data {\n"
"\tKOBJ_FIELDS;\n"
"\tfoo_foo;\n"
"\tfoo_bar;\n"
"};"
msgstr ""
"struct foo_data {\n"
"\tKOBJ_FIELDS;\n"
"\tfoo_foo;\n"
"\tfoo_bar;\n"
"};"

#. (itstool) path: sect2/title
#: book.translate.xml:3265
msgid "Calling Methods"
msgstr "Métodos de Chamada"

#. (itstool) path: sect2/para
#: book.translate.xml:3267
#, fuzzy
msgid ""
"The last step in using Kobj is to simply use the generated functions to use "
"the desired method within the object's class. This is as simple as using the "
"interface name and the method name with a few modifications. The interface "
"name should be concatenated with the method name using a '_' between them, "
"all in upper case."
msgstr ""
"O �ltimo passo para usar o Kobj � simplesmente usar as fun��es geradas para "
"usar o m�todo desejado dentro da classe do objeto. Isso � t�o simples quanto "
"usar o nome da interface e o nome do m�todo com algumas modifica��es. O nome "
"da interface deve ser concatenado com o nome do m�todo usando um ';_'; entre "
"eles, tudo em mai�sculas. "

#. (itstool) path: sect2/para
#: book.translate.xml:3274
#, fuzzy
msgid ""
"For example, if the interface name was foo and the method was bar then the "
"call would be:"
msgstr ""
"Por exemplo, se o nome da interface fosse foo e o m�todo fosse bar, a "
"chamada seria:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3277
#, no-wrap
msgid "[return value = ] FOO_BAR(object [, other parameters]);"
msgstr "[return value = ] FOO_BAR(object [, other parameters]);"

#. (itstool) path: sect2/title
#: book.translate.xml:3282
msgid "Cleaning Up"
msgstr "Limpando"

#. (itstool) path: sect2/para
#: book.translate.xml:3284
#, fuzzy
msgid ""
"When an object allocated through <function>kobj_create()</function> is no "
"longer needed <function>kobj_delete()</function> may be called on it, and "
"when a class is no longer being used <function>kobj_class_free()</function> "
"may be called on it."
msgstr ""
"Quando um objeto alocado atrav�s <function> kobj_create () </function> n�o � "
"mais necess�rio <function> kobj_delete () </function> pode ser chamado, e "
"quando uma aula n�o est� mais sendo usada <function> kobj_class_free () </"
"function> pode ser chamado. "

#. (itstool) path: info/title
#: book.translate.xml:3301
msgid "The Jail Subsystem"
msgstr "O Subsistema da Jail"

#. (itstool) path: affiliation/address
#: book.translate.xml:3309
#, no-wrap
msgid ""
"\n"
"\t  <email>evms@cs.bu.edu</email>\n"
"\t"
msgstr ""
"\n"
"\t  <email>evms@cs.bu.edu</email>\n"
"\t"

#. (itstool) path: info/author
#: book.translate.xml:3303
msgid ""
"<personname> <firstname>Evan</firstname> <surname>Sarmiento</surname> </"
"personname> <affiliation> <_:address-1/> </affiliation>"
msgstr ""
"<personname> <firstname>Evan</firstname> <surname>Sarmiento</surname> </"
"personname> <affiliation> <_:address-1/> </affiliation>"

#. (itstool) path: info/copyright
#: book.translate.xml:3314
msgid ""
"<year>2001</year> <holder role=\"mailto:evms@cs.bu.edu\">Evan Sarmiento</"
"holder>"
msgstr ""
"<year>2001</year> <holder role=\"mailto:evms@cs.bu.edu\">Evan Sarmiento</"
"holder>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:3320
msgid "<primary>security</primary>"
msgstr "<primary>security</primary>"

#. (itstool) path: chapter/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:3321 book.translate.xml:15468
msgid "<primary>Jail</primary>"
msgstr "<primary>Jail</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:3322
msgid "<primary>root</primary>"
msgstr "<primary>root</primary>"

#. (itstool) path: chapter/para
#: book.translate.xml:3324
#, fuzzy
msgid ""
"On most <trademark class=\"registered\">UNIX</trademark> systems, "
"<literal>root</literal> has omnipotent power. This promotes insecurity. If "
"an attacker gained <literal>root</literal> on a system, he would have every "
"function at his fingertips. In FreeBSD there are sysctls which dilute the "
"power of <literal>root</literal>, in order to minimize the damage caused by "
"an attacker. Specifically, one of these functions is called <literal>secure "
"levels</literal>. Similarly, another function which is present from FreeBSD "
"4.0 and onward, is a utility called <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>. <application>Jail</"
"application> chroots an environment and sets certain restrictions on "
"processes which are forked within the <application>jail</application>. For "
"example, a jailed process cannot affect processes outside the "
"<application>jail</application>, utilize certain system calls, or inflict "
"any damage on the host environment."
msgstr ""
"Na maioria <trademark class=\"registered\"> UNIX </trademark> sistemas, "
"<literal> raiz </literal> tem poder onipotente. Isso promove inseguran�a. Se "
"um atacante ganhou <literal> raiz </literal> em um sistema, ele teria todas "
"as fun��es na ponta dos dedos. No FreeBSD existem sysctls que diluem o poder "
"de <literal> raiz </literal> , a fim de minimizar os danos causados ​​por um "
"invasor. Especificamente, uma dessas fun��es � chamada <literal> n�veis "
"seguros </literal> . Similarmente, outra fun��o presente no FreeBSD 4.0 e em "
"diante, � um utilit�rio chamado <citerefentry><refentrytitle> cadeia </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> . <application> "
"Cadeia </application> chroots um ambiente e define certas restri��es em "
"processos que s�o bifurcados dentro do <application> cadeia </application> . "
"Por exemplo, um processo preso n�o pode afetar processos fora do "
"<application> cadeia </application> , utilizar determinadas chamadas do "
"sistema ou causar danos ao ambiente do host. "

#. (itstool) path: chapter/para
#: book.translate.xml:3339
#, fuzzy
msgid ""
"<application>Jail</application> is becoming the new security model. People "
"are running potentially vulnerable servers such as <application>Apache</"
"application>, <application>BIND</application>, and <application>sendmail</"
"application> within jails, so that if an attacker gains <literal>root</"
"literal> within the <application>jail</application>, it is only an "
"annoyance, and not a devastation. This article mainly focuses on the "
"internals (source code) of <application>jail</application>. For information "
"on how to set up a jail see the <link xlink:href=\"@@URL_RELPREFIX@@/doc/"
"en_US.ISO8859-1/books/handbook/jails.html\">handbook entry on jails</link>."
msgstr ""
" <application> Cadeia </application> est� se tornando o novo modelo de "
"seguran�a. As pessoas est�o executando servidores potencialmente "
"vulner�veis, como <application> Apache </application> , <application> LIGAR "
"</application> e <application> enviar correio </application> dentro de "
"cadeias, de modo que se um atacante ganha <literal> raiz </literal> dentro "
"do <application> cadeia </application> , � apenas um aborrecimento e n�o uma "
"devasta��o. Este artigo foca principalmente os internos (c�digo fonte) de "
"<application> cadeia </application> . Para obter informa��es sobre como "
"configurar uma cadeia, consulte o <link xlink:href=\"@@URL_RELPREFIX@@/doc/"
"en_US.ISO8859-1/books/handbook/jails.html\"> entrada do manual nas cadeias </"
"link> "

#. (itstool) path: sect1/title
#: book.translate.xml:3352
msgid "Architecture"
msgstr "Arquitetura"

#. (itstool) path: sect1/para
#: book.translate.xml:3354
#, fuzzy
msgid ""
"<application>Jail</application> consists of two realms: the userland "
"program, <citerefentry><refentrytitle>jail</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>, and the code implemented within the kernel: the "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> system call and associated restrictions. I will be discussing "
"the userland program and then how <application>jail</application> is "
"implemented within the kernel."
msgstr ""
" <application> Cadeia </application> consiste em dois reinos: o programa "
"userland, <citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 8 "
"</manvolnum></citerefentry> , eo c�digo implementado dentro do kernel: o "
"<citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> chamada do sistema e restri��es associadas. Eu "
"estarei discutindo o programa userland e, em seguida, como <application> "
"cadeia </application> � implementado dentro do kernel. "

#. (itstool) path: sect2/title
#: book.translate.xml:3362
#, fuzzy
msgid "Userland Code"
msgstr "C�digo da Terra de Usu�rio"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3364
msgid "<primary>Jail</primary> <secondary>Userland Program</secondary>"
msgstr "<primary>Jail</primary> <secondary>Userland Program</secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:3367
#, fuzzy
msgid ""
"The source for the userland <application>jail</application> is located in "
"<filename>/usr/src/usr.sbin/jail</filename>, consisting of one file, "
"<filename>jail.c</filename>. The program takes these arguments: the path of "
"the <application>jail</application>, hostname, IP address, and the command "
"to be executed."
msgstr ""
"A fonte para a terra do usu�rio <application> cadeia </application> est� "
"localizado em <filename> /usr/src/usr.sbin/jail </filename> , consistindo de "
"um arquivo, <filename> jail.c </filename> . O programa pega esses "
"argumentos: o caminho do <application> cadeia </application> , hostname, "
"endere�o IP e o comando a ser executado. "

#. (itstool) path: sect3/title
#: book.translate.xml:3375
msgid "Data Structures"
msgstr "Estruturas de dados"

#. (itstool) path: sect3/para
#: book.translate.xml:3377
#, fuzzy
msgid ""
"In <filename>jail.c</filename>, the first thing I would note is the "
"declaration of an important structure <literal>struct jail j;</literal> "
"which was included from <filename>/usr/include/sys/jail.h</filename>."
msgstr ""
"Dentro <filename> jail.c </filename> , a primeira coisa que eu gostaria de "
"observar � a declara��o de uma estrutura importante <literal> struct jail j; "
"</literal> que foi inclu�do a partir de <filename> /usr/include/sys/jail.h </"
"filename> "

#. (itstool) path: sect3/para
#: book.translate.xml:3382
#, fuzzy
msgid "The definition of the <literal>jail</literal> structure is:"
msgstr "A defini��o do <literal> cadeia </literal> estrutura �: "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3385
#, no-wrap
msgid ""
"<filename>/usr/include/sys/jail.h</filename>:\n"
"\n"
"struct jail {\n"
"        u_int32_t       version;\n"
"        char            *path;\n"
"        char            *hostname;\n"
"        u_int32_t       ip_number;\n"
"};"
msgstr ""
"<filename>/usr/include/sys/jail.h</filename>:\n"
"\n"
"struct jail {\n"
"        u_int32_t       version;\n"
"        char            *path;\n"
"        char            *hostname;\n"
"        u_int32_t       ip_number;\n"
"};"

#. (itstool) path: sect3/para
#: book.translate.xml:3394
#, fuzzy
msgid ""
"As you can see, there is an entry for each of the arguments passed to the "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> program, and indeed, they are set during its execution."
msgstr ""
"Como voc� pode ver, h� uma entrada para cada um dos argumentos passados ​​para "
"o <citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 8 </"
"manvolnum></citerefentry> programa, e, de fato, eles s�o definidos durante a "
"sua execu��o \""

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3398
#, no-wrap
msgid ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>\n"
"char path[PATH_MAX];\n"
"...\n"
"if (realpath(argv[0], path) == NULL)\n"
"    err(1, \"realpath: %s\", argv[0]);\n"
"if (chdir(path) != 0)\n"
"    err(1, \"chdir: %s\", path);\n"
"memset(&amp;j, 0, sizeof(j));\n"
"j.version = 0;\n"
"j.path = path;\n"
"j.hostname = argv[1];"
msgstr ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>\n"
"char path[PATH_MAX];\n"
"...\n"
"if (realpath(argv[0], path) == NULL)\n"
"    err(1, \"realpath: %s\", argv[0]);\n"
"if (chdir(path) != 0)\n"
"    err(1, \"chdir: %s\", path);\n"
"memset(&amp;j, 0, sizeof(j));\n"
"j.version = 0;\n"
"j.path = path;\n"
"j.hostname = argv[1];"

#. (itstool) path: sect3/title
#: book.translate.xml:3412
#, fuzzy
msgid "Networking"
msgstr "Networking"

#. (itstool) path: sect3/para
#: book.translate.xml:3414
#, fuzzy
msgid ""
"One of the arguments passed to the <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry> program is an IP "
"address with which the <application>jail</application> can be accessed over "
"the network. <citerefentry><refentrytitle>jail</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry> translates the IP address given into host byte "
"order and then stores it in <literal>j</literal> (the <literal>jail</"
"literal> structure)."
msgstr ""
"Um dos argumentos passou para o <citerefentry><refentrytitle> cadeia </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> programa � um "
"endere�o IP com o qual o <application> cadeia </application> pode ser "
"acessado pela rede. <citerefentry><refentrytitle> cadeia </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> traduz o endere�o IP "
"dado em ordem de byte host e, em seguida, armazena em <literal> j </literal> "
"(a <literal> cadeia </literal> estrutura)."

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3421
#, no-wrap
msgid ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>:\n"
"struct in_addr in;\n"
"...\n"
"if (inet_aton(argv[2], &amp;in) == 0)\n"
"    errx(1, \"Could not make sense of ip-number: %s\", argv[2]);\n"
"j.ip_number = ntohl(in.s_addr);"
msgstr ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>:\n"
"struct in_addr in;\n"
"...\n"
"if (inet_aton(argv[2], &amp;in) == 0)\n"
"    errx(1, \"Could not make sense of ip-number: %s\", argv[2]);\n"
"j.ip_number = ntohl(in.s_addr);"

#. (itstool) path: sect3/para
#: book.translate.xml:3428
#, fuzzy
msgid ""
"The <citerefentry><refentrytitle>inet_aton</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry> function \"interprets the specified character "
"string as an Internet address, placing the address into the structure "
"provided.\" The <literal>ip_number</literal> member in the <literal>jail</"
"literal> structure is set only when the IP address placed onto the "
"<literal>in</literal> structure by <citerefentry><refentrytitle>inet_aton</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry> is translated into "
"host byte order by <citerefentry><refentrytitle>ntohl</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>."
msgstr ""
"O <citerefentry><refentrytitle> inet_aton </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> A fun��o \\ \"interpreta a cadeia de caracteres "
"especificada como um endere�o da Internet, colocando o endere�o na estrutura "
"fornecida. \" <literal> ip_number </literal> membro no <literal> cadeia </"
"literal> estrutura � definida apenas quando o endere�o IP colocado no "
"<literal> dentro </literal> estrutura por <citerefentry><refentrytitle> "
"inet_aton </refentrytitle><manvolnum> 3 </manvolnum></citerefentry> � "
"traduzido em ordem de byte host por <citerefentry><refentrytitle> ntohl </"
"refentrytitle><manvolnum> 3 </manvolnum></citerefentry> "

#. (itstool) path: sect3/title
#: book.translate.xml:3439
#, fuzzy
msgid "Jailing the Process"
msgstr "Prendendo o Processo"

#. (itstool) path: sect3/para
#: book.translate.xml:3441
#, fuzzy
msgid ""
"Finally, the userland program jails the process. <application>Jail</"
"application> now becomes an imprisoned process itself and then executes the "
"command given using <citerefentry><refentrytitle>execv</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>."
msgstr ""
"Finalmente, o programa userland reprime o processo. <application> Cadeia </"
"application> agora se torna um processo preso em si e, em seguida, executa o "
"comando dado usando <citerefentry><refentrytitle> execv </"
"refentrytitle><manvolnum> 3 </manvolnum></citerefentry> "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3446
#, no-wrap
msgid ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>\n"
"i = jail(&amp;j);\n"
"...\n"
"if (execv(argv[3], argv + 3) != 0)\n"
"    err(1, \"execv: %s\", argv[3]);"
msgstr ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>\n"
"i = jail(&amp;j);\n"
"...\n"
"if (execv(argv[3], argv + 3) != 0)\n"
"    err(1, \"execv: %s\", argv[3]);"

#. (itstool) path: sect3/para
#: book.translate.xml:3452
#, fuzzy
msgid ""
"As you can see, the <literal>jail()</literal> function is called, and its "
"argument is the <literal>jail</literal> structure which has been filled with "
"the arguments given to the program. Finally, the program you specify is "
"executed. I will now discuss how <application>jail</application> is "
"implemented within the kernel."
msgstr ""
"Como voc� pode ver, o <literal> cadeia() </literal> fun��o � chamada, e seu "
"argumento � o <literal> cadeia </literal> estrutura que foi preenchida com "
"os argumentos dados ao programa. Finalmente, o programa que voc� especifica "
"� executado. Agora vou discutir como <application> cadeia </application> � "
"implementado dentro do kernel. "

#. (itstool) path: sect2/title
#: book.translate.xml:3462
msgid "Kernel Space"
msgstr "Espaço do Kernel"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3464
msgid "<primary>Jail</primary> <secondary>Kernel Architecture</secondary>"
msgstr "<primary>Jail</primary> <secondary>Kernel Architecture</secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:3467
#, fuzzy
msgid ""
"We will now be looking at the file <filename>/usr/src/sys/kern/kern_jail.c</"
"filename>. This is the file where the <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> system call, "
"appropriate sysctls, and networking functions are defined."
msgstr ""
"Vamos agora olhar para o arquivo <filename> /usr/src/sys/kern/kern_jail.c </"
"filename> . Este � o arquivo onde o <citerefentry><refentrytitle> cadeia </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> chamada de sistema, "
"sysctls apropriados e fun��es de rede s�o definidos. "

#. (itstool) path: sect3/title
#: book.translate.xml:3473
msgid "Sysctls"
msgstr "Sysctls"

#. (itstool) path: sect3/indexterm
#: book.translate.xml:3475
msgid "<primary>sysctl</primary>"
msgstr "<primary>sysctl</primary>"

#. (itstool) path: sect3/para
#: book.translate.xml:3477
#, fuzzy
msgid "In <filename>kern_jail.c</filename>, the following sysctls are defined:"
msgstr ""
"Dentro <filename> kern_jail.c </filename> , os seguintes sysctls s�o "
"definidos: "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3480
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"int     jail_set_hostname_allowed = 1;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, set_hostname_allowed, CTLFLAG_RW,\n"
"    &amp;jail_set_hostname_allowed, 0,\n"
"    \"Processes in jail can set their hostnames\");\n"
"\n"
"int     jail_socket_unixiproute_only = 1;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, socket_unixiproute_only, CTLFLAG_RW,\n"
"    &amp;jail_socket_unixiproute_only, 0,\n"
"    \"Processes in jail are limited to creating UNIX/IPv4/route sockets only\");\n"
"\n"
"int     jail_sysvipc_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, sysvipc_allowed, CTLFLAG_RW,\n"
"    &amp;jail_sysvipc_allowed, 0,\n"
"    \"Processes in jail can use System V IPC primitives\");\n"
"\n"
"static int jail_enforce_statfs = 2;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, enforce_statfs, CTLFLAG_RW,\n"
"    &amp;jail_enforce_statfs, 0,\n"
"    \"Processes in jail cannot see all mounted file systems\");\n"
"\n"
"int    jail_allow_raw_sockets = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, allow_raw_sockets, CTLFLAG_RW,\n"
"    &amp;jail_allow_raw_sockets, 0,\n"
"    \"Prison root can create raw sockets\");\n"
"\n"
"int    jail_chflags_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, chflags_allowed, CTLFLAG_RW,\n"
"    &amp;jail_chflags_allowed, 0,\n"
"    \"Processes in jail can alter system file flags\");\n"
"\n"
"int     jail_mount_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, mount_allowed, CTLFLAG_RW,\n"
"    &amp;jail_mount_allowed, 0,\n"
"    \"Processes in jail can mount/unmount jail-friendly file systems\");"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"int     jail_set_hostname_allowed = 1;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, set_hostname_allowed, CTLFLAG_RW,\n"
"    &amp;jail_set_hostname_allowed, 0,\n"
"    \"Processes in jail can set their hostnames\");\n"
"\n"
"int     jail_socket_unixiproute_only = 1;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, socket_unixiproute_only, CTLFLAG_RW,\n"
"    &amp;jail_socket_unixiproute_only, 0,\n"
"    \"Processes in jail are limited to creating UNIX/IPv4/route sockets only\");\n"
"\n"
"int     jail_sysvipc_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, sysvipc_allowed, CTLFLAG_RW,\n"
"    &amp;jail_sysvipc_allowed, 0,\n"
"    \"Processes in jail can use System V IPC primitives\");\n"
"\n"
"static int jail_enforce_statfs = 2;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, enforce_statfs, CTLFLAG_RW,\n"
"    &amp;jail_enforce_statfs, 0,\n"
"    \"Processes in jail cannot see all mounted file systems\");\n"
"\n"
"int    jail_allow_raw_sockets = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, allow_raw_sockets, CTLFLAG_RW,\n"
"    &amp;jail_allow_raw_sockets, 0,\n"
"    \"Prison root can create raw sockets\");\n"
"\n"
"int    jail_chflags_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, chflags_allowed, CTLFLAG_RW,\n"
"    &amp;jail_chflags_allowed, 0,\n"
"    \"Processes in jail can alter system file flags\");\n"
"\n"
"int     jail_mount_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, mount_allowed, CTLFLAG_RW,\n"
"    &amp;jail_mount_allowed, 0,\n"
"    \"Processes in jail can mount/unmount jail-friendly file systems\");"

#. (itstool) path: sect3/para
#: book.translate.xml:3516
#, fuzzy
msgid ""
"Each of these sysctls can be accessed by the user through the "
"<citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> program. Throughout the kernel, these specific sysctls are "
"recognized by their name. For example, the name of the first sysctl is "
"<literal>security.jail.set_hostname_allowed</literal>."
msgstr ""
"Cada um desses sysctls pode ser acessado pelo usu�rio atrav�s do "
"<citerefentry><refentrytitle> sysctl </refentrytitle><manvolnum> 8 </"
"manvolnum></citerefentry> programa. Em todo o kernel, esses sysctls "
"espec�ficos s�o reconhecidos pelo nome. Por exemplo, o nome do primeiro "
"sysctl � <literal> security.jail.set_hostname_allowed </literal> "

#. (itstool) path: sect3/title
#: book.translate.xml:3524
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> System Call"
msgstr ""
" <citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> Chamada de sistema "

#. (itstool) path: sect3/para
#: book.translate.xml:3526
#, fuzzy
msgid ""
"Like all system calls, the <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> system call takes two "
"arguments, <literal>struct thread *td</literal> and <literal>struct "
"jail_args *uap</literal>. <literal>td</literal> is a pointer to the "
"<literal>thread</literal> structure which describes the calling thread. In "
"this context, <literal>uap</literal> is a pointer to the structure in which "
"a pointer to the <literal>jail</literal> structure passed by the userland "
"<filename>jail.c</filename> is contained. When I described the userland "
"program before, you saw that the <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> system call was given "
"a <literal>jail</literal> structure as its own argument."
msgstr ""
"Como todas as chamadas do sistema, o <citerefentry><refentrytitle> cadeia </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> chamada de sistema "
"leva dois argumentos, <literal> struct thread * td </literal> e <literal> "
"struct jail_args * uap </literal> . <literal> td </literal> � um ponteiro "
"para o <literal> fio </literal> estrutura que descreve o segmento de "
"chamada. Neste contexto, <literal> uap </literal> � um ponteiro para a "
"estrutura em que um ponteiro para o <literal> cadeia </literal> estrutura "
"passada pelo userland <filename> jail.c </filename> Est� contido. Quando eu "
"descrevi o programa userland antes, voc� viu que o "
"<citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> chamada de sistema foi dada uma <literal> cadeia </"
"literal> estrutura como seu pr�prio argumento \""

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3539
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"/*\n"
" * struct jail_args {\n"
" *  struct jail *jail;\n"
" * };\n"
" */\n"
"int\n"
"jail(struct thread *td, struct jail_args *uap)"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"/*\n"
" * struct jail_args {\n"
" *  struct jail *jail;\n"
" * };\n"
" */\n"
"int\n"
"jail(struct thread *td, struct jail_args *uap)"

#. (itstool) path: sect3/para
#: book.translate.xml:3548
#, fuzzy
msgid ""
"Therefore, <literal>uap-&gt;jail</literal> can be used to access the "
"<literal>jail</literal> structure which was passed to the system call. Next, "
"the system call copies the <literal>jail</literal> structure into kernel "
"space using the <citerefentry><refentrytitle>copyin</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> function. "
"<citerefentry><refentrytitle>copyin</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> takes three arguments: the address of the data which is to be "
"copied into kernel space, <literal>uap-&gt;jail</literal>, where to store "
"it, <literal>j</literal> and the size of the storage. The <literal>jail</"
"literal> structure pointed by <literal>uap-&gt;jail</literal> is copied into "
"kernel space and is stored in another <literal>jail</literal> structure, "
"<literal>j</literal>."
msgstr ""
"Assim sendo, <literal> uap-&gt; cadeia </literal> pode ser usado para "
"acessar o <literal> cadeia </literal> estrutura que foi passada para a "
"chamada do sistema. Em seguida, a chamada do sistema copia <literal> cadeia "
"</literal> estrutura no espa�o do kernel usando o "
"<citerefentry><refentrytitle> copiando </refentrytitle><manvolnum> 9 </"
"manvolnum></citerefentry> fun��o. <citerefentry><refentrytitle> copiando </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> leva tr�s "
"argumentos: o endere�o dos dados que devem ser copiados no espa�o do kernel, "
"<literal> uap-&gt; cadeia </literal> , onde armazen�-lo <literal> j </"
"literal> e o tamanho do armazenamento. o <literal> cadeia </literal> "
"estrutura apontada por <literal> uap-&gt; cadeia </literal> � copiado para o "
"espa�o do kernel e � armazenado em outro <literal> cadeia </literal> "
"estrutura, <literal> j </literal> "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3561
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"error = copyin(uap-&gt;jail, &amp;j, sizeof(j));"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"error = copyin(uap-&gt;jail, &amp;j, sizeof(j));"

#. (itstool) path: sect3/para
#: book.translate.xml:3564
#, fuzzy
msgid ""
"There is another important structure defined in <filename>jail.h</filename>. "
"It is the <literal>prison</literal> structure. The <literal>prison</literal> "
"structure is used exclusively within kernel space. Here is the definition of "
"the <literal>prison</literal> structure."
msgstr ""
"Existe outra estrutura importante definida em <filename> jail.h </"
"filename> . � o <literal> pris�o </literal> estrutura. o <literal> pris�o </"
"literal> estrutura � usada exclusivamente dentro do espa�o do kernel. Aqui "
"est� a defini��o do <literal> pris�o </literal> estrutura."

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3571
#, no-wrap
msgid ""
"<filename>/usr/include/sys/jail.h</filename>:\n"
"struct prison {\n"
"        LIST_ENTRY(prison) pr_list;                     /* (a) all prisons */\n"
"        int              pr_id;                         /* (c) prison id */\n"
"        int              pr_ref;                        /* (p) refcount */\n"
"        char             pr_path[MAXPATHLEN];           /* (c) chroot path */\n"
"        struct vnode    *pr_root;                       /* (c) vnode to rdir */\n"
"        char             pr_host[MAXHOSTNAMELEN];       /* (p) jail hostname */\n"
"        u_int32_t        pr_ip;                         /* (c) ip addr host */\n"
"        void            *pr_linux;                      /* (p) linux abi */\n"
"        int              pr_securelevel;                /* (p) securelevel */\n"
"        struct task      pr_task;                       /* (d) destroy task */\n"
"        struct mtx       pr_mtx;\n"
"      void            **pr_slots;                     /* (p) additional data */\n"
"};"
msgstr ""
"<filename>/usr/include/sys/jail.h</filename>:\n"
"struct prison {\n"
"        LIST_ENTRY(prison) pr_list;                     /* (a) all prisons */\n"
"        int              pr_id;                         /* (c) prison id */\n"
"        int              pr_ref;                        /* (p) refcount */\n"
"        char             pr_path[MAXPATHLEN];           /* (c) chroot path */\n"
"        struct vnode    *pr_root;                       /* (c) vnode to rdir */\n"
"        char             pr_host[MAXHOSTNAMELEN];       /* (p) jail hostname */\n"
"        u_int32_t        pr_ip;                         /* (c) ip addr host */\n"
"        void            *pr_linux;                      /* (p) linux abi */\n"
"        int              pr_securelevel;                /* (p) securelevel */\n"
"        struct task      pr_task;                       /* (d) destroy task */\n"
"        struct mtx       pr_mtx;\n"
"      void            **pr_slots;                     /* (p) additional data */\n"
"};"

#. (itstool) path: sect3/para
#: book.translate.xml:3587
#, fuzzy
msgid ""
"The <citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> system call then allocates memory for a "
"<literal>prison</literal> structure and copies data between the "
"<literal>jail</literal> and <literal>prison</literal> structure."
msgstr ""
"O <citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> chamada de sistema, em seguida, aloca mem�ria para "
"um <literal> pris�o </literal> estrutura e copia dados entre o <literal> "
"cadeia </literal> e <literal> pris�o </literal> estrutura."

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3592
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>:\n"
"MALLOC(pr, struct prison *, sizeof(*pr), M_PRISON, M_WAITOK | M_ZERO);\n"
"...\n"
"error = copyinstr(j.path, &amp;pr-&gt;pr_path, sizeof(pr-&gt;pr_path), 0);\n"
"if (error)\n"
"    goto e_killmtx;\n"
"...\n"
"error = copyinstr(j.hostname, &amp;pr-&gt;pr_host, sizeof(pr-&gt;pr_host), 0);\n"
"if (error)\n"
"     goto e_dropvnref;\n"
"pr-&gt;pr_ip = j.ip_number;"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>:\n"
"MALLOC(pr, struct prison *, sizeof(*pr), M_PRISON, M_WAITOK | M_ZERO);\n"
"...\n"
"error = copyinstr(j.path, &amp;pr-&gt;pr_path, sizeof(pr-&gt;pr_path), 0);\n"
"if (error)\n"
"    goto e_killmtx;\n"
"...\n"
"error = copyinstr(j.hostname, &amp;pr-&gt;pr_host, sizeof(pr-&gt;pr_host), 0);\n"
"if (error)\n"
"     goto e_dropvnref;\n"
"pr-&gt;pr_ip = j.ip_number;"

#. (itstool) path: sect3/para
#: book.translate.xml:3604
#, fuzzy
msgid ""
"Next, we will discuss another important system call "
"<citerefentry><refentrytitle>jail_attach</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>, which implements the function to put a process "
"into the <application>jail</application>."
msgstr ""
"Em seguida, discutiremos outra importante chamada do sistema "
"<citerefentry><refentrytitle> jail_attach </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> , que implementa a fun��o de colocar um processo "
"no <application> cadeia </application> "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3608
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>:\n"
"/*\n"
" * struct jail_attach_args {\n"
" *      int jid;\n"
" * };\n"
" */\n"
"int\n"
"jail_attach(struct thread *td, struct jail_attach_args *uap)"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>:\n"
"/*\n"
" * struct jail_attach_args {\n"
" *      int jid;\n"
" * };\n"
" */\n"
"int\n"
"jail_attach(struct thread *td, struct jail_attach_args *uap)"

#. (itstool) path: sect3/para
#: book.translate.xml:3617
#, fuzzy
msgid ""
"This system call makes the changes that can distinguish a jailed process "
"from those unjailed ones. To understand what "
"<citerefentry><refentrytitle>jail_attach</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> does for us, certain background information is "
"needed."
msgstr ""
"Esta chamada de sistema faz as mudan�as que podem distinguir um processo "
"preso daqueles que foram desencadeados. Para entender o que "
"<citerefentry><refentrytitle> jail_attach </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> para n�s, certas informa��es b�sicas s�o "
"necess�rias \""

#. (itstool) path: sect3/para
#: book.translate.xml:3622
#, fuzzy
msgid ""
"On FreeBSD, each kernel visible thread is identified by its <literal>thread</"
"literal> structure, while the processes are described by their "
"<literal>proc</literal> structures. You can find the definitions of the "
"<literal>thread</literal> and <literal>proc</literal> structure in "
"<filename>/usr/include/sys/proc.h</filename>. For example, the <literal>td</"
"literal> argument in any system call is actually a pointer to the calling "
"thread's <literal>thread</literal> structure, as stated before. The "
"<literal>td_proc</literal> member in the <literal>thread</literal> structure "
"pointed by <literal>td</literal> is a pointer to the <literal>proc</literal> "
"structure which represents the process that contains the thread represented "
"by <literal>td</literal>. The <literal>proc</literal> structure contains "
"members which can describe the owner's identity(<literal>p_ucred</literal>), "
"the process resource limits(<literal>p_limit</literal>), and so on. In the "
"<literal>ucred</literal> structure pointed by <literal>p_ucred</literal> "
"member in the <literal>proc</literal> structure, there is a pointer to the "
"<literal>prison</literal> structure(<literal>cr_prison</literal>)."
msgstr ""
"No FreeBSD, cada thread vis�vel do kernel � identificado por sua <literal> "
"fio </literal> estrutura, enquanto os processos s�o descritos por seus "
"<literal> proc </literal> estruturas. Voc� pode encontrar as defini��es do "
"<literal> fio </literal> e <literal> proc </literal> estrutura em "
"<filename> /usr/include/sys/proc.h </filename> . Por exemplo, o <literal> td "
"</literal> argumento em qualquer chamada do sistema � realmente um ponteiro "
"para o segmento de chamada <literal> fio </literal> estrutura, como dito "
"anteriormente. o <literal> td_proc </literal> membro no <literal> fio </"
"literal> estrutura apontada por <literal> td </literal> � um ponteiro para o "
"<literal> proc </literal> estrutura que representa o processo que cont�m o "
"segmento representado por <literal> td </literal> . o <literal> proc </"
"literal> estrutura cont�m membros que podem descrever a identidade do "
"propriet�rio ( <literal> p_ucred </literal> ), os limites de recursos do "
"processo ( <literal> p_limit </literal> ), e assim por diante. No <literal> "
"ucred </literal> estrutura apontada por <literal> p_ucred </literal> membro "
"no <literal> proc </literal> estrutura, h� um ponteiro para o <literal> "
"pris�o </literal> estrutura( <literal> cr_prison </literal> ) "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3646
#, fuzzy, no-wrap
msgid ""
"<filename>/usr/include/sys/proc.h:</filename>\n"
"struct thread {\n"
"    ...\n"
"    struct proc *td_proc;\n"
"    ...\n"
"};\n"
"struct proc {\n"
"    ...\n"
"    struct ucred *p_ucred;\n"
"    ...\n"
"};\n"
"<filename>/usr/include/sys/ucred.h</filename>\n"
"struct ucred {\n"
"    ...\n"
"    struct prison *cr_prison;\n"
"    ...\n"
"};"
msgstr ""
"<filename>/usr/include/sys/proc.h: </filename>\n"
"struct thread {\n"
"    ...\n"
"    struct proc *td_proc;\n"
"    ...\n"
"};\n"
"struct proc {\n"
"    ...\n"
"    struct ucred *p_ucred;\n"
"    ...\n"
"};\n"
"<filename>/usr/include/sys/ucred.h</filename>\n"
"struct ucred {\n"
"    ...\n"
"    struct prison *cr_prison;\n"
"    ...\n"
"};"

#. (itstool) path: sect3/para
#: book.translate.xml:3664
#, fuzzy
msgid ""
"In <filename>kern_jail.c</filename>, the function <literal>jail()</literal> "
"then calls function <literal>jail_attach()</literal> with a given "
"<literal>jid</literal>. And <literal>jail_attach()</literal> calls function "
"<literal>change_root()</literal> to change the root directory of the calling "
"process. The <literal>jail_attach()</literal> then creates a new "
"<literal>ucred</literal> structure, and attaches the newly created "
"<literal>ucred</literal> structure to the calling process after it has "
"successfully attached the <literal>prison</literal> structure to the "
"<literal>ucred</literal> structure. From then on, the calling process is "
"recognized as jailed. When the kernel routine <literal>jailed()</literal> is "
"called in the kernel with the newly created <literal>ucred</literal> "
"structure as its argument, it returns 1 to tell that the credential is "
"connected with a <application>jail</application>. The public ancestor "
"process of all the process forked within the <application>jail</"
"application>, is the process which runs <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>, as it calls the "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> system call. When a program is executed through "
"<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>, it inherits the jailed property of its parent's "
"<literal>ucred</literal> structure, therefore it has a jailed "
"<literal>ucred</literal> structure."
msgstr ""
"Dentro <filename> kern_jail.c </filename> , a fun��o <literal> cadeia() </"
"literal> ent�o chama a fun��o <literal> jail_attach () </literal> com um "
"dado <literal> jid </literal> . E <literal> jail_attach () </literal> chama "
"a fun��o <literal> change_root () </literal> para alterar o diret�rio raiz "
"do processo de chamada. o <literal> jail_attach () </literal> ent�o cria um "
"novo <literal> ucred </literal> estrutura e anexa o rec�m-criado <literal> "
"ucred </literal> estrutura para o processo de chamada depois de ter anexado "
"com sucesso o <literal> pris�o </literal> estrutura para o <literal> ucred </"
"literal> estrutura. A partir de ent�o, o processo de chamada � reconhecido "
"como encarcerado. Quando a rotina do kernel <literal> preso () </literal> � "
"chamado no kernel com o rec�m-criado <literal> ucred </literal> estrutura "
"como seu argumento, ele retorna 1 para dizer que a credencial est� conectada "
"<application> cadeia </application> . O processo ancestral p�blico de todo o "
"processo bifurcado dentro do <application> cadeia </application> � o "
"processo que executa <citerefentry><refentrytitle> cadeia </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> como ele chama "
"<citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> chamada do sistema. Quando um programa � executado "
"atrav�s de <citerefentry><refentrytitle> execve </refentrytitle><manvolnum> "
"2 </manvolnum></citerefentry> , herda a propriedade encarcerada de seus pais "
"<literal> ucred </literal> estrutura, portanto, tem uma pris�o <literal> "
"ucred </literal> estrutura."

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3690
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>\n"
"int\n"
"jail(struct thread *td, struct jail_args *uap)\n"
"{\n"
"...\n"
"    struct jail_attach_args jaa;\n"
"...\n"
"    error = jail_attach(td, &amp;jaa);\n"
"    if (error)\n"
"        goto e_dropprref;\n"
"...\n"
"}\n"
"\n"
"int\n"
"jail_attach(struct thread *td, struct jail_attach_args *uap)\n"
"{\n"
"    struct proc *p;\n"
"    struct ucred *newcred, *oldcred;\n"
"    struct prison *pr;\n"
"...\n"
"    p = td-&gt;td_proc;\n"
"...\n"
"    pr = prison_find(uap-&gt;jid);\n"
"...\n"
"    change_root(pr-&gt;pr_root, td);\n"
"...\n"
"    newcred-&gt;cr_prison = pr;\n"
"    p-&gt;p_ucred = newcred;\n"
"...\n"
"}"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>\n"
"int\n"
"jail(struct thread *td, struct jail_args *uap)\n"
"{\n"
"...\n"
"    struct jail_attach_args jaa;\n"
"...\n"
"    error = jail_attach(td, &amp;jaa);\n"
"    if (error)\n"
"        goto e_dropprref;\n"
"...\n"
"}\n"
"\n"
"int\n"
"jail_attach(struct thread *td, struct jail_attach_args *uap)\n"
"{\n"
"    struct proc *p;\n"
"    struct ucred *newcred, *oldcred;\n"
"    struct prison *pr;\n"
"...\n"
"    p = td-&gt;td_proc;\n"
"...\n"
"    pr = prison_find(uap-&gt;jid);\n"
"...\n"
"    change_root(pr-&gt;pr_root, td);\n"
"...\n"
"    newcred-&gt;cr_prison = pr;\n"
"    p-&gt;p_ucred = newcred;\n"
"...\n"
"}"

#. (itstool) path: sect3/para
#: book.translate.xml:3721
#, fuzzy
msgid ""
"When a process is forked from its parent process, the "
"<citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> system call uses <literal>crhold()</literal> to maintain the "
"credential for the newly forked process. It inherently keep the newly forked "
"child's credential consistent with its parent, so the child process is also "
"jailed."
msgstr ""
"Quando um processo � bifurcado de seu processo pai, o "
"<citerefentry><refentrytitle> garfo </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> utiliza��es de chamadas do sistema <literal> "
"crhold () </literal> para manter a credencial do processo rec�m-bifurcado. � "
"inerentemente manter a credencial da crian�a rec�m-bifurcada consistente com "
"seu pai, de modo que o processo filho tamb�m � preso \""

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3728
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_fork.c</filename>:\n"
"p2-&gt;p_ucred = crhold(td-&gt;td_ucred);\n"
"...\n"
"td2-&gt;td_ucred = crhold(p2-&gt;p_ucred);"
msgstr ""
"<filename>/usr/src/sys/kern/kern_fork.c</filename>:\n"
"p2-&gt;p_ucred = crhold(td-&gt;td_ucred);\n"
"...\n"
"td2-&gt;td_ucred = crhold(p2-&gt;p_ucred);"

#. (itstool) path: sect1/title
#: book.translate.xml:3737
#, fuzzy
msgid "Restrictions"
msgstr "Restri��es"

#. (itstool) path: sect1/para
#: book.translate.xml:3739
#, fuzzy
msgid ""
"Throughout the kernel there are access restrictions relating to jailed "
"processes. Usually, these restrictions only check whether the process is "
"jailed, and if so, returns an error. For example:"
msgstr ""
"Em todo o kernel existem restri��es de acesso relacionadas a processos "
"presos. Geralmente, essas restri��es apenas verificam se o processo est� "
"preso e, em caso afirmativo, retorna um erro. Por exemplo:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:3744
#, fuzzy, no-wrap
msgid ""
"if (jailed(td-&gt;td_ucred))\n"
"    return (EPERM);"
msgstr ""
"\n"
"if (jailed(td-&gt;td_ucred))\n"
"    return (EPERM);"

#. (itstool) path: sect2/title
#: book.translate.xml:3748
#, fuzzy
msgid "SysV IPC"
msgstr "SysV IPC"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3750
#, fuzzy
msgid "<primary>System V IPC</primary>"
msgstr " <primary> IPC do sistema V </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3752
#, fuzzy
msgid ""
"System V IPC is based on messages. Processes can send each other these "
"messages which tell them how to act. The functions which deal with messages "
"are: <citerefentry><refentrytitle>msgctl</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry>, <citerefentry><refentrytitle>msgget</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>msgsnd</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry> and <citerefentry><refentrytitle>msgrcv</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>. Earlier, I mentioned "
"that there were certain sysctls you could turn on or off in order to affect "
"the behavior of <application>jail</application>. One of these sysctls was "
"<literal>security.jail.sysvipc_allowed</literal>. By default, this sysctl is "
"set to 0. If it were set to 1, it would defeat the whole purpose of having a "
"<application>jail</application>; privileged users from the "
"<application>jail</application> would be able to affect processes outside "
"the jailed environment. The difference between a message and a signal is "
"that the message only consists of the signal number."
msgstr ""
"O IPC do sistema V � baseado em mensagens. Os processos podem enviar uns aos "
"outros mensagens que lhes dizem como agir. As fun��es que lidam com as "
"mensagens s�o: <citerefentry><refentrytitle> msgctl </"
"refentrytitle><manvolnum> 3 </manvolnum></citerefentry> , "
"<citerefentry><refentrytitle> msgget </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> , <citerefentry><refentrytitle> msgsnd </"
"refentrytitle><manvolnum> 3 </manvolnum></citerefentry> e "
"<citerefentry><refentrytitle> msgrcv </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> . Anteriormente, mencionei que havia certos "
"sysctls que voc� podia ativar ou desativar para afetar o comportamento de "
"<application> cadeia </application> . Um desses sysctls foi <literal> "
"security.jail.sysvipc_allowed </literal> . Por padr�o, este sysctl � "
"definido como 0. Se fosse definido como 1, ele derrotaria todo o prop�sito "
"de ter um <application> cadeia </application> ; usu�rios privilegiados do "
"<application> cadeia </application> seria capaz de afetar processos fora do "
"ambiente preso. A diferen�a entre uma mensagem e um sinal � que a mensagem "
"consiste apenas no n�mero do sinal. "

#. (itstool) path: sect2/para
#: book.translate.xml:3767
#, fuzzy
msgid "<filename>/usr/src/sys/kern/sysv_msg.c</filename>:"
msgstr " <filename> /usr/src/sys/kern/sysv_msg.c </filename> : "

#. (itstool) path: listitem/para
#: book.translate.xml:3771
#, fuzzy
msgid ""
"<literal>msgget(key, msgflg)</literal>: <literal>msgget</literal> returns "
"(and possibly creates) a message descriptor that designates a message queue "
"for use in other functions."
msgstr ""
" <literal> msgget (chave, msgflg) </literal> : <literal> msgget </literal> "
"retorna (e possivelmente cria) um descritor de mensagens que designa uma "
"fila de mensagens para uso em outras fun��es. "

#. (itstool) path: listitem/para
#: book.translate.xml:3778
#, fuzzy
msgid ""
"<literal>msgctl(msgid, cmd, buf)</literal>: Using this function, a process "
"can query the status of a message descriptor."
msgstr ""
" <literal> msgctl (msgid, cmd, buf) </literal> : Usando esta fun��o, um "
"processo pode consultar o status de um descritor de mensagem. "

#. (itstool) path: listitem/para
#: book.translate.xml:3784
#, fuzzy
msgid ""
"<literal>msgsnd(msgid, msgp, msgsz, msgflg)</literal>: <literal>msgsnd</"
"literal> sends a message to a process."
msgstr ""
" <literal> msgsnd (msgid, msgp, msgsz, msgflg) </literal> : <literal> msgsnd "
"</literal> envia uma mensagem para um processo \""

#. (itstool) path: listitem/para
#: book.translate.xml:3790
#, fuzzy
msgid ""
"<literal>msgrcv(msgid, msgp, msgsz, msgtyp, msgflg)</literal>: a process "
"receives messages using this function"
msgstr ""
" <literal> msgrid (msgid, msgp, msgsz, msgtyp, msgflg) </literal> : um "
"processo recebe mensagens usando esta fun��o "

#. (itstool) path: sect2/para
#: book.translate.xml:3796
#, fuzzy
msgid ""
"In each of the system calls corresponding to these functions, there is this "
"conditional:"
msgstr ""
"Em cada uma das chamadas do sistema correspondentes a estas fun��es, existe "
"esta condicional:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3799
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/sysv_msg.c</filename>:\n"
"if (!jail_sysvipc_allowed &amp;&amp; jailed(td-&gt;td_ucred))\n"
"    return (ENOSYS);"
msgstr ""
"<filename>/usr/src/sys/kern/sysv_msg.c</filename>:\n"
"if (!jail_sysvipc_allowed &amp;&amp; jailed(td-&gt;td_ucred))\n"
"    return (ENOSYS);"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3803
#, fuzzy
msgid "<primary>semaphores</primary>"
msgstr " <primary> sem�foros </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3805
#, fuzzy
msgid ""
"Semaphore system calls allow processes to synchronize execution by doing a "
"set of operations atomically on a set of semaphores. Basically semaphores "
"provide another way for processes lock resources. However, process waiting "
"on a semaphore, that is being used, will sleep until the resources are "
"relinquished. The following semaphore system calls are blocked inside a "
"<application>jail</application>: <citerefentry><refentrytitle>semget</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>semctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> and <citerefentry><refentrytitle>semop</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>."
msgstr ""
"Chamadas de sistema de sem�foro permitem que processos sincronizem a "
"execu��o executando um conjunto de opera��es atomicamente em um conjunto de "
"sem�foros. Basicamente, sem�foros fornecem outra maneira para recursos de "
"bloqueio de processos. No entanto, processo aguardando um sem�foro, que est� "
"sendo usado, ir� dormir at� os recursos As seguintes chamadas do sistema de "
"sem�foro est�o bloqueadas dentro <application> cadeia </application> : "
"<citerefentry><refentrytitle> semget </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> , <citerefentry><refentrytitle> semctl </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> e "
"<citerefentry><refentrytitle> semop </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> "

#. (itstool) path: sect2/para
#: book.translate.xml:3814
#, fuzzy
msgid "<filename>/usr/src/sys/kern/sysv_sem.c</filename>:"
msgstr " <filename> /usr/src/sys/kern/sysv_sem.c </filename> : "

#. (itstool) path: listitem/para
#: book.translate.xml:3818
#, fuzzy
msgid ""
"<literal>semctl(semid, semnum, cmd, ...)</literal>: <literal>semctl</"
"literal> does the specified <literal>cmd</literal> on the semaphore queue "
"indicated by <literal>semid</literal>."
msgstr ""
" <literal> semctl (semid, semnum, cmd, ...) </literal> : <literal> semctl </"
"literal> faz o especificado <literal> cmd </literal> na fila de sem�foros "
"indicada por <literal> semid </literal> "

#. (itstool) path: listitem/para
#: book.translate.xml:3824
#, fuzzy
msgid ""
"<literal>semget(key, nsems, flag)</literal>: <literal>semget</literal> "
"creates an array of semaphores, corresponding to <literal>key</literal>."
msgstr ""
" <literal> semget (chave, nsems, bandeira) </literal> : <literal> semget </"
"literal> cria uma matriz de sem�foros, correspondente a <literal> chave </"
"literal> "

#. (itstool) path: listitem/para
#: book.translate.xml:3828
#, fuzzy
msgid ""
"<literal>key and flag take on the same meaning as they do in msgget.</"
"literal>"
msgstr ""
" <literal> key e flag assumem o mesmo significado que no msgget. </literal> "

#. (itstool) path: listitem/para
#: book.translate.xml:3832
#, fuzzy
msgid ""
"<literal>semop(semid, array, nops)</literal>: <literal>semop</literal> "
"performs a group of operations indicated by <literal>array</literal>, to the "
"set of semaphores identified by <literal>semid</literal>."
msgstr ""
" <literal> semop (semid, array, nops) </literal> : <literal> semop </"
"literal> executa um grupo de opera��es indicado por <literal> array </"
"literal> , ao conjunto de sem�foros identificados por <literal> semid </"
"literal> "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3839
#, fuzzy
msgid "<primary>shared memory</primary>"
msgstr " <primary> memoria compartilhada </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3841
#, fuzzy
msgid ""
"System V IPC allows for processes to share memory. Processes can communicate "
"directly with each other by sharing parts of their virtual address space and "
"then reading and writing data stored in the shared memory. These system "
"calls are blocked within a jailed environment: "
"<citerefentry><refentrytitle>shmdt</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>, <citerefentry><refentrytitle>shmat</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>shmctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> and <citerefentry><refentrytitle>shmget</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>."
msgstr ""
"O System V IPC permite que os processos compartilhem mem�ria. Os processos "
"podem se comunicar diretamente compartilhando partes de seu espa�o de "
"endere�o virtual e depois lendo e gravando dados armazenados na mem�ria "
"compartilhada. Essas chamadas de sistema s�o bloqueadas em um ambiente "
"preso: <citerefentry><refentrytitle> shmdt </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> , <citerefentry><refentrytitle> shmat </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> , "
"<citerefentry><refentrytitle> shmctl </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> e <citerefentry><refentrytitle> shmget </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#. (itstool) path: sect2/para
#: book.translate.xml:3848
#, fuzzy
msgid "<filename>/usr/src/sys/kern/sysv_shm.c</filename>:"
msgstr " <filename> /usr/src/sys/kern/sysv_shm.c </filename> : "

#. (itstool) path: listitem/para
#: book.translate.xml:3851
#, fuzzy
msgid ""
"<literal>shmctl(shmid, cmd, buf)</literal>: <literal>shmctl</literal> does "
"various control operations on the shared memory region identified by "
"<literal>shmid</literal>."
msgstr ""
" <literal> shmctl (shmid, cmd, buf) </literal> : <literal> shmctl </literal> "
"faz v�rias opera��es de controle na regi�o de mem�ria compartilhada "
"identificada por <literal> shmid </literal> "

#. (itstool) path: listitem/para
#: book.translate.xml:3857
#, fuzzy
msgid ""
"<literal>shmget(key, size, flag)</literal>: <literal>shmget</literal> "
"accesses or creates a shared memory region of <literal>size</literal> bytes."
msgstr ""
" <literal> shmget (chave, tamanho, bandeira) </literal> : <literal> shmget </"
"literal> acessa ou cria uma regi�o de mem�ria compartilhada <literal> "
"Tamanho </literal> bytes. "

#. (itstool) path: listitem/para
#: book.translate.xml:3863
#, fuzzy
msgid ""
"<literal>shmat(shmid, addr, flag)</literal>: <literal>shmat</literal> "
"attaches a shared memory region identified by <literal>shmid</literal> to "
"the address space of a process."
msgstr ""
" <literal> shmat (shmid, addr, bandeira) </literal> : <literal> shmat </"
"literal> anexa uma regi�o de mem�ria compartilhada identificada <literal> "
"shmid </literal> para o espa�o de endere�o de um processo \""

#. (itstool) path: listitem/para
#: book.translate.xml:3869
#, fuzzy
msgid ""
"<literal>shmdt(addr)</literal>: <literal>shmdt</literal> detaches the shared "
"memory region previously attached at <literal>addr</literal>."
msgstr ""
" <literal> shmdt (addr) </literal> : <literal> shmdt </literal> separa a "
"regi�o de mem�ria compartilhada anteriormente conectada <literal> addr </"
"literal> "

#. (itstool) path: sect2/title
#: book.translate.xml:3878
#, fuzzy
msgid "Sockets"
msgstr "Tomadas"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3880
#, fuzzy
msgid "<primary>sockets</primary>"
msgstr " <primary> tomadas </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3882
#, fuzzy
msgid ""
"<application>Jail</application> treats the "
"<citerefentry><refentrytitle>socket</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> system call and related lower-level socket functions in a "
"special manner. In order to determine whether a certain socket is allowed to "
"be created, it first checks to see if the sysctl <literal>security.jail."
"socket_unixiproute_only</literal> is set. If set, sockets are only allowed "
"to be created if the family specified is either <literal>PF_LOCAL</literal>, "
"<literal>PF_INET</literal> or <literal>PF_ROUTE</literal>. Otherwise, it "
"returns an error."
msgstr ""
" <application> Cadeia </application> trata o <citerefentry><refentrytitle> "
"soquete </refentrytitle><manvolnum> 2 </manvolnum></citerefentry> chamada de "
"sistema e fun��es de soquete de n�vel inferior relacionadas de uma maneira "
"especial. Para determinar se um certo socket pode ser criado, ele primeiro "
"verifica se o sysctl <literal> security.jail.socket_unixiproute_only </"
"literal> est� definido. Se definido, os soquetes s� poder�o ser criados se a "
"fam�lia especificada for <literal> PF_LOCAL </literal> , <literal> PF_INET </"
"literal> ou <literal> PF_ROUTE </literal> . Caso contr�rio, retorna um erro. "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3893
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/uipc_socket.c</filename>:\n"
"int\n"
"socreate(int dom, struct socket **aso, int type, int proto,\n"
"    struct ucred *cred, struct thread *td)\n"
"{\n"
"    struct protosw *prp;\n"
"...\n"
"    if (jailed(cred) &amp;&amp; jail_socket_unixiproute_only &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_LOCAL &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_INET &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_ROUTE) {\n"
"        return (EPROTONOSUPPORT);\n"
"    }\n"
"...\n"
"}"
msgstr ""
"<filename>/usr/src/sys/kern/uipc_socket.c</filename>:\n"
"int\n"
"socreate(int dom, struct socket **aso, int type, int proto,\n"
"    struct ucred *cred, struct thread *td)\n"
"{\n"
"    struct protosw *prp;\n"
"...\n"
"    if (jailed(cred) &amp;&amp; jail_socket_unixiproute_only &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_LOCAL &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_INET &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_ROUTE) {\n"
"        return (EPROTONOSUPPORT);\n"
"    }\n"
"...\n"
"}"

#. (itstool) path: sect2/title
#: book.translate.xml:3911
#, fuzzy
msgid "Berkeley Packet Filter"
msgstr "Filtro de pacotes de Berkeley"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3913
#, fuzzy
msgid "<primary>Berkeley Packet Filter</primary>"
msgstr " <primary> Filtro de pacotes de Berkeley </primary> "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3914
#, fuzzy
msgid "<primary>data link layer</primary>"
msgstr " <primary> camada de enlace de dados </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3916
#, fuzzy
msgid ""
"The <application>Berkeley Packet Filter</application> provides a raw "
"interface to data link layers in a protocol independent fashion. "
"<application>BPF</application> is now controlled by the "
"<citerefentry><refentrytitle>devfs</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> whether it can be used in a jailed environment."
msgstr ""
"O <application> Filtro de pacotes de Berkeley </application> fornece uma "
"interface bruta para as camadas de enlace de dados de maneira independente "
"do protocolo. <application> BPF </application> agora � controlado pelo "
"<citerefentry><refentrytitle> devfs </refentrytitle><manvolnum> 8 </"
"manvolnum></citerefentry> se pode ser usado em um ambiente preso \""

#. (itstool) path: sect2/title
#: book.translate.xml:3925
#, fuzzy
msgid "Protocols"
msgstr "Protocolos"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3927
#, fuzzy
msgid "<primary>protocols</primary>"
msgstr " <primary> protocolos </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3929
#, fuzzy
msgid ""
"There are certain protocols which are very common, such as TCP, UDP, IP and "
"ICMP. IP and ICMP are on the same level: the network layer 2. There are "
"certain precautions which are taken in order to prevent a jailed process "
"from binding a protocol to a certain address only if the <literal>nam</"
"literal> parameter is set. <literal>nam</literal> is a pointer to a "
"<literal>sockaddr</literal> structure, which describes the address on which "
"to bind the service. A more exact definition is that <literal>sockaddr</"
"literal> \"may be used as a template for referring to the identifying tag "
"and length of each address\". In the function <literal>in_pcbbind_setup()</"
"literal>, <literal>sin</literal> is a pointer to a <literal>sockaddr_in</"
"literal> structure, which contains the port, address, length and domain "
"family of the socket which is to be bound. Basically, this disallows any "
"processes from <application>jail</application> to be able to specify the "
"address that does not belong to the <application>jail</application> in which "
"the calling process exists."
msgstr ""
"Existem certos protocolos que s�o muito comuns, como TCP, UDP, IP e ICMP. IP "
"e ICMP est�o no mesmo n�vel: a camada de rede 2. H� certas precau��es que "
"s�o tomadas para evitar que um processo preso seja vinculado. um protocolo "
"para um determinado endere�o apenas se o <literal> nam </literal> par�metro "
"est� definido. <literal> nam </literal> � um ponteiro para um <literal> "
"sockaddr </literal> estrutura, que descreve o endere�o no qual ligar o "
"servi�o. Uma defini��o mais exata � que <literal> sockaddr </literal> \\ "
"\"pode ​​ser usado como um modelo para referir-se � tag de identifica��o e "
"comprimento de cada endere�o \". Na fun��o <literal> in_pcbbind_setup () </"
"literal> , <literal> pecado </literal> � um ponteiro para um <literal> "
"sockaddr_in </literal> estrutura, que cont�m a porta, endere�o, comprimento "
"e fam�lia de dom�nio do socket que deve ser ligado. Basicamente, isso impede "
"qualquer processo de <application> cadeia </application> para poder "
"especificar o endere�o que n�o pertence ao <application> cadeia </"
"application> em que o processo de chamada existe. "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3950
#, no-wrap
msgid ""
"<filename>/usr/src/sys/netinet/in_pcb.c</filename>:\n"
"int\n"
"in_pcbbind_setup(struct inpcb *inp, struct sockaddr *nam, in_addr_t *laddrp,\n"
"    u_short *lportp, struct ucred *cred)\n"
"{\n"
"    ...\n"
"    struct sockaddr_in *sin;\n"
"    ...\n"
"    if (nam) {\n"
"        sin = (struct sockaddr_in *)nam;\n"
"        ...\n"
"        if (sin-&gt;sin_addr.s_addr != INADDR_ANY)\n"
"            if (prison_ip(cred, 0, &amp;sin-&gt;sin_addr.s_addr))\n"
"                return(EINVAL);\n"
"        ...\n"
"        if (lport) {\n"
"            ...\n"
"            if (prison &amp;&amp; prison_ip(cred, 0, &amp;sin-&gt;sin_addr.s_addr))\n"
"                return (EADDRNOTAVAIL);\n"
"            ...\n"
"        }\n"
"    }\n"
"    if (lport == 0) {\n"
"        ...\n"
"        if (laddr.s_addr != INADDR_ANY)\n"
"            if (prison_ip(cred, 0, &amp;laddr.s_addr))\n"
"                return (EINVAL);\n"
"        ...\n"
"    }\n"
"...\n"
"    if (prison_ip(cred, 0, &amp;laddr.s_addr))\n"
"        return (EINVAL);\n"
"...\n"
"}"
msgstr ""
"<filename>/usr/src/sys/netinet/in_pcb.c</filename>:\n"
"int\n"
"in_pcbbind_setup(struct inpcb *inp, struct sockaddr *nam, in_addr_t *laddrp,\n"
"    u_short *lportp, struct ucred *cred)\n"
"{\n"
"    ...\n"
"    struct sockaddr_in *sin;\n"
"    ...\n"
"    if (nam) {\n"
"        sin = (struct sockaddr_in *)nam;\n"
"        ...\n"
"        if (sin-&gt;sin_addr.s_addr != INADDR_ANY)\n"
"            if (prison_ip(cred, 0, &amp;sin-&gt;sin_addr.s_addr))\n"
"                return(EINVAL);\n"
"        ...\n"
"        if (lport) {\n"
"            ...\n"
"            if (prison &amp;&amp; prison_ip(cred, 0, &amp;sin-&gt;sin_addr.s_addr))\n"
"                return (EADDRNOTAVAIL);\n"
"            ...\n"
"        }\n"
"    }\n"
"    if (lport == 0) {\n"
"        ...\n"
"        if (laddr.s_addr != INADDR_ANY)\n"
"            if (prison_ip(cred, 0, &amp;laddr.s_addr))\n"
"                return (EINVAL);\n"
"        ...\n"
"    }\n"
"...\n"
"    if (prison_ip(cred, 0, &amp;laddr.s_addr))\n"
"        return (EINVAL);\n"
"...\n"
"}"

#. (itstool) path: sect2/para
#: book.translate.xml:3985
#, fuzzy
msgid ""
"You might be wondering what function <literal>prison_ip()</literal> does. "
"<literal>prison_ip()</literal> is given three arguments, a pointer to the "
"credential(represented by <literal>cred</literal>), any flags, and an IP "
"address. It returns 1 if the IP address does NOT belong to the "
"<application>jail</application> or 0 otherwise. As you can see from the "
"code, if it is indeed an IP address not belonging to the <application>jail</"
"application>, the protocol is not allowed to bind to that address."
msgstr ""
"Voc� pode estar se perguntando que fun��o <literal> prison_ip () </literal> "
"faz. <literal> prison_ip () </literal> � dado tr�s argumentos, um ponteiro "
"para a credencial (representado por <literal> cred </literal> ), qualquer "
"sinalizador e um endere�o IP. Ele retorna 1 se o endere�o IP N�O pertencer "
"ao <application> cadeia </application> ou 0 caso contr�rio. Como voc� pode "
"ver no c�digo, se � realmente um endere�o IP n�o pertencente ao "
"<application> cadeia </application> , o protocolo n�o tem permiss�o para "
"vincular a esse endere�o \""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3996
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"int\n"
"prison_ip(struct ucred *cred, int flag, u_int32_t *ip)\n"
"{\n"
"    u_int32_t tmp;\n"
"\n"
"    if (!jailed(cred))\n"
"        return (0);\n"
"    if (flag)\n"
"        tmp = *ip;\n"
"    else\n"
"        tmp = ntohl(*ip);\n"
"    if (tmp == INADDR_ANY) {\n"
"        if (flag)\n"
"            *ip = cred-&gt;cr_prison-&gt;pr_ip;\n"
"        else\n"
"            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);\n"
"        return (0);\n"
"    }\n"
"    if (tmp == INADDR_LOOPBACK) {\n"
"        if (flag)\n"
"            *ip = cred-&gt;cr_prison-&gt;pr_ip;\n"
"        else\n"
"            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);\n"
"        return (0);\n"
"    }\n"
"    if (cred-&gt;cr_prison-&gt;pr_ip != tmp)\n"
"        return (1);\n"
"    return (0);\n"
"}"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"int\n"
"prison_ip(struct ucred *cred, int flag, u_int32_t *ip)\n"
"{\n"
"    u_int32_t tmp;\n"
"\n"
"    if (!jailed(cred))\n"
"        return (0);\n"
"    if (flag)\n"
"        tmp = *ip;\n"
"    else\n"
"        tmp = ntohl(*ip);\n"
"    if (tmp == INADDR_ANY) {\n"
"        if (flag)\n"
"            *ip = cred-&gt;cr_prison-&gt;pr_ip;\n"
"        else\n"
"            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);\n"
"        return (0);\n"
"    }\n"
"    if (tmp == INADDR_LOOPBACK) {\n"
"        if (flag)\n"
"            *ip = cred-&gt;cr_prison-&gt;pr_ip;\n"
"        else\n"
"            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);\n"
"        return (0);\n"
"    }\n"
"    if (cred-&gt;cr_prison-&gt;pr_ip != tmp)\n"
"        return (1);\n"
"    return (0);\n"
"}"

#. (itstool) path: sect2/title
#: book.translate.xml:4029
#, fuzzy
msgid "Filesystem"
msgstr "Sistema de arquivo"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:4031
#, fuzzy
msgid "<primary>filesystem</primary>"
msgstr " <primary> sistema de arquivo </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:4033
#, fuzzy
msgid ""
"Even <literal>root</literal> users within the <application>jail</"
"application> are not allowed to unset or modify any file flags, such as "
"immutable, append-only, and undeleteable flags, if the securelevel is "
"greater than 0."
msgstr ""
"At� <literal> raiz </literal> usu�rios dentro do <application> cadeia </"
"application> n�o � permitido anular ou modificar qualquer sinalizador de "
"arquivo, como sinalizadores imut�veis, somente de anexa��o e n�o-"
"destac�veis, se o n�vel de seguran�a for maior que 0. "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:4039
#, no-wrap
msgid ""
"<filename>/usr/src/sys/ufs/ufs/ufs_vnops.c:</filename>\n"
"static int\n"
"ufs_setattr(ap)\n"
"    ...\n"
"{\n"
"    ...\n"
"        if (!priv_check_cred(cred, PRIV_VFS_SYSFLAGS, 0)) {\n"
"            if (ip-&gt;i_flags\n"
"                &amp; (SF_NOUNLINK | SF_IMMUTABLE | SF_APPEND)) {\n"
"                    error = securelevel_gt(cred, 0);\n"
"                    if (error)\n"
"                        return (error);\n"
"            }\n"
"            ...\n"
"        }\n"
"}\n"
"<filename>/usr/src/sys/kern/kern_priv.c</filename>\n"
"int\n"
"priv_check_cred(struct ucred *cred, int priv, int flags)\n"
"{\n"
"    ...\n"
"    error = prison_priv_check(cred, priv);\n"
"    if (error)\n"
"        return (error);\n"
"    ...\n"
"}\n"
"<filename>/usr/src/sys/kern/kern_jail.c</filename>\n"
"int\n"
"prison_priv_check(struct ucred *cred, int priv)\n"
"{\n"
"    ...\n"
"    switch (priv) {\n"
"    ...\n"
"    case PRIV_VFS_SYSFLAGS:\n"
"        if (jail_chflags_allowed)\n"
"            return (0);\n"
"        else\n"
"            return (EPERM);\n"
"    ...\n"
"    }\n"
"    ...\n"
"}"
msgstr ""
"<filename>/usr/src/sys/ufs/ufs/ufs_vnops.c:</filename>\n"
"static int\n"
"ufs_setattr(ap)\n"
"    ...\n"
"{\n"
"    ...\n"
"        if (!priv_check_cred(cred, PRIV_VFS_SYSFLAGS, 0)) {\n"
"            if (ip-&gt;i_flags\n"
"                &amp; (SF_NOUNLINK | SF_IMMUTABLE | SF_APPEND)) {\n"
"                    error = securelevel_gt(cred, 0);\n"
"                    if (error)\n"
"                        return (error);\n"
"            }\n"
"            ...\n"
"        }\n"
"}\n"
"<filename>/usr/src/sys/kern/kern_priv.c</filename>\n"
"int\n"
"priv_check_cred(struct ucred *cred, int priv, int flags)\n"
"{\n"
"    ...\n"
"    error = prison_priv_check(cred, priv);\n"
"    if (error)\n"
"        return (error);\n"
"    ...\n"
"}\n"
"<filename>/usr/src/sys/kern/kern_jail.c</filename>\n"
"int\n"
"prison_priv_check(struct ucred *cred, int priv)\n"
"{\n"
"    ...\n"
"    switch (priv) {\n"
"    ...\n"
"    case PRIV_VFS_SYSFLAGS:\n"
"        if (jail_chflags_allowed)\n"
"            return (0);\n"
"        else\n"
"            return (EPERM);\n"
"    ...\n"
"    }\n"
"    ...\n"
"}"

#. (itstool) path: chapter/title
#: book.translate.xml:4092
#, fuzzy
msgid "The SYSINIT Framework"
msgstr "O Framework SYSINIT"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:4094
#, fuzzy
msgid "<primary>SYSINIT</primary>"
msgstr " <primary> SYSINIT </primary> "

#. (itstool) path: chapter/indexterm
#: book.translate.xml:4097
#, fuzzy
msgid "<primary>dynamic initialization</primary>"
msgstr " <primary> inicializa��o din�mica </primary> "

#. (itstool) path: chapter/indexterm
#: book.translate.xml:4100
#, fuzzy
msgid "<primary>kernel initialization</primary> <secondary>dynamic</secondary>"
msgstr ""
" <primary> inicializa��o do kernel </primary><secondary> din�mico </"
"secondary> "

#. (itstool) path: chapter/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:4104 book.translate.xml:15529
#, fuzzy
msgid "<primary>kernel modules</primary>"
msgstr " <primary> m�dulos do kernel </primary> "

#. (itstool) path: chapter/indexterm
#: book.translate.xml:4107
#, fuzzy
msgid "<primary>kernel linker</primary>"
msgstr " <primary> linker de kernel </primary> "

#. (itstool) path: chapter/para
#: book.translate.xml:4111
#, fuzzy
msgid ""
"SYSINIT is the framework for a generic call sort and dispatch mechanism. "
"FreeBSD currently uses it for the dynamic initialization of the kernel. "
"SYSINIT allows FreeBSD's kernel subsystems to be reordered, and added, "
"removed, and replaced at kernel link time when the kernel or one of its "
"modules is loaded without having to edit a statically ordered initialization "
"routing and recompile the kernel. This system also allows kernel modules, "
"currently called <firstterm>KLD's</firstterm>, to be separately compiled, "
"linked, and initialized at boot time and loaded even later while the system "
"is already running. This is accomplished using the <quote>kernel linker</"
"quote> and <quote>linker sets</quote>."
msgstr ""
"SYSINIT � o framework para um mecanismo gen�rico de ordena��o e envio de "
"chamadas. O FreeBSD atualmente o utiliza para a inicializa��o din�mica do "
"kernel. SYSINIT permite que os subsistemas de kernel do FreeBSD sejam "
"reordenados, adicionados, removidos e substitu�dos no momento do link do "
"kernel quando o kernel ou um de seus m�dulos � carregado sem ter que editar "
"um roteamento de inicializa��o ordenado estaticamente e recompilar o kernel."
"Este sistema tamb�m permite m�dulos do kernel, atualmente chamados "
"<firstterm> KLD';s </firstterm> , para ser compilado, vinculado e "
"inicializado separadamente no momento da inicializa��o e carregado ainda "
"mais tarde enquanto o sistema j� est� em execu��o. Isso � feito usando o "
"<quote> linker de kernel </quote> e <quote> conjuntos de linkers </quote> "

#. (itstool) path: varlistentry/term
#: book.translate.xml:4129
#, fuzzy
msgid "Linker Set"
msgstr "Left Set"

#. (itstool) path: listitem/para
#: book.translate.xml:4131
#, fuzzy
msgid ""
"A linker technique in which the linker gathers statically declared data "
"throughout a program's source files into a single contiguously addressable "
"unit of data."
msgstr ""
"Uma t�cnica de linker na qual o linker re�ne dados estaticamente declarados "
"atrav�s dos arquivos de c�digo-fonte de um programa em uma �nica unidade de "
"dados contiguamente endere��vel."

#. (itstool) path: sect1/title
#: book.translate.xml:4141
#, fuzzy
msgid "SYSINIT Operation"
msgstr "Opera��o SYSINIT"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:4143
#, fuzzy
msgid "<primary>linker sets</primary>"
msgstr " <primary> conjuntos de linkers </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:4145
#, fuzzy
msgid ""
"SYSINIT relies on the ability of the linker to take static data declared at "
"multiple locations throughout a program's source and group it together as a "
"single contiguous chunk of data. This linker technique is called a "
"<quote>linker set</quote>. SYSINIT uses two linker sets to maintain two data "
"sets containing each consumer's call order, function, and a pointer to the "
"data to pass to that function."
msgstr ""
"O SYSINIT depende da capacidade do vinculador de obter dados est�ticos "
"declarados em v�rios locais ao longo da origem de um programa e agrup�-los "
"como um �nico bloco cont�guo de dados. Essa t�cnica de vinculador � chamada "
"de <quote> conjunto de linker </quote> . O SYSINIT usa dois conjuntos de "
"linkers para manter dois conjuntos de dados contendo cada ordem de chamada "
"do consumidor, fun��o e um ponteiro para os dados a serem passados ​​para essa "
"fun��o. "

#. (itstool) path: sect1/para
#: book.translate.xml:4153
#, fuzzy
msgid ""
"SYSINIT uses two priorities when ordering the functions for execution. The "
"first priority is a subsystem ID giving an overall order for SYSINIT's "
"dispatch of functions. Current predeclared ID's are in <filename>&lt;sys/"
"kernel.h&gt;</filename> in the enum list <literal>sysinit_sub_id</literal>. "
"The second priority used is an element order within the subsystem. Current "
"predeclared subsystem element orders are in <filename>&lt;sys/kernel.h&gt;</"
"filename> in the enum list <literal>sysinit_elem_order</literal>."
msgstr ""
"O SYSINIT usa duas prioridades ao ordenar as fun��es para execu��o. A "
"primeira prioridade � um ID de subsistema dando uma ordem geral para o "
"despacho de fun��es do SYSINIT. As IDs pr�-declaradas atuais est�o em "
"<filename> &lt;sys / kernel.h&gt; </filename> na lista enum <literal> "
"sysinit_sub_id </literal> . A segunda prioridade usada � uma ordem de "
"elemento no subsistema. As atuais ordens de elementos do subsistema pr�-"
"declarado est�o em <filename> &lt;sys / kernel.h&gt; </filename> na lista "
"enum <literal> sysinit_elem_order </literal> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:4164
#, fuzzy
msgid "<primary>pseudo-devices</primary>"
msgstr " <primary> pseudo-dispositivos </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:4166
#, fuzzy
msgid ""
"There are currently two uses for SYSINIT. Function dispatch at system "
"startup and kernel module loads, and function dispatch at system shutdown "
"and kernel module unload. Kernel subsystems often use system startup "
"SYSINIT's to initialize data structures, for example the process scheduling "
"subsystem uses a SYSINIT to initialize the run queue data structure. Device "
"drivers should avoid using <literal>SYSINIT()</literal> directly. Instead "
"drivers for real devices that are part of a bus structure should use "
"<literal>DRIVER_MODULE()</literal> to provide a function that detects the "
"device and, if it is present, initializes the device. It will do a few "
"things specific to devices and then call <literal>SYSINIT()</literal> "
"itself. For pseudo-devices, which are not part of a bus structure, use "
"<literal>DEV_MODULE()</literal>."
msgstr ""
"Existem atualmente dois usos para SYSINIT. O despacho de fun��es na "
"inicializa��o do sistema e do m�dulo kernel e o envio de fun��es no "
"desligamento do sistema e no m�dulo kernel descarregam. Os subsistemas "
"Kernel geralmente usam SYSINIT';s para inicializar estruturas de dados, por "
"exemplo, o subsistema de agendamento de processos SYSINIT para inicializar a "
"estrutura de dados da fila de execu��o.Os drivers de dispositivo devem "
"evitar o uso <literal> SYSINIT () </literal> diretamente. Em vez disso, os "
"drivers para dispositivos reais que fazem parte de uma estrutura de "
"barramento devem usar <literal> DRIVER_MODULE () </literal> para fornecer "
"uma fun��o que detecta o dispositivo e, se estiver presente, inicializa o "
"dispositivo. Ele far� algumas coisas espec�ficas para os dispositivos e, em "
"seguida, chamar� <literal> SYSINIT () </literal> em si. Para pseudo-"
"dispositivos, que n�o fazem parte de uma estrutura de barramento, use "
"<literal> DEV_MODULE () </literal> "

#. (itstool) path: sect1/title
#: book.translate.xml:4184
#, fuzzy
msgid "Using SYSINIT"
msgstr "Usando SYSINIT"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:4192
#, no-wrap
msgid "&lt;sys/kernel.h&gt;"
msgstr "&lt;sys/kernel.h&gt;"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:4198
#, no-wrap
msgid ""
"SYSINIT(uniquifier, subsystem, order, func, ident)\n"
"SYSUNINIT(uniquifier, subsystem, order, func, ident)"
msgstr ""
"SYSINIT(uniquifier, subsystem, order, func, ident)\n"
"SYSUNINIT(uniquifier, subsystem, order, func, ident)"

#. (itstool) path: sect2/title
#: book.translate.xml:4204
#, fuzzy
msgid "Startup"
msgstr "Comece"

#. (itstool) path: sect2/para
#: book.translate.xml:4206
#, fuzzy
msgid ""
"The <literal>SYSINIT()</literal> macro creates the necessary SYSINIT data in "
"SYSINIT's startup data set for SYSINIT to sort and dispatch a function at "
"system startup and module load. <literal>SYSINIT()</literal> takes a "
"uniquifier that SYSINIT uses to identify the particular function dispatch "
"data, the subsystem order, the subsystem element order, the function to "
"call, and the data to pass the function. All functions must take a constant "
"pointer argument."
msgstr ""
"O <literal> SYSINIT () </literal> macro cria os dados SYSINIT necess�rios no "
"conjunto de dados de inicializa��o do SYSINIT para SYSINIT para classificar "
"e despachar uma fun��o na inicializa��o do sistema e no carregamento do "
"m�dulo. <literal> SYSINIT () </literal> pega um uniquificador que SYSINIT "
"usa para identificar os dados de despacho da fun��o espec�fica, a ordem do "
"subsistema, a ordem do elemento do subsistema, a fun��o a ser chamada e os "
"dados para passar a fun��o. Todas as fun��es devem ter um argumento de "
"ponteiro constante. "

#. (itstool) path: example/title
#: book.translate.xml:4216
#, fuzzy
msgid "Example of a <literal>SYSINIT()</literal>"
msgstr "Exemplo de um <literal> SYSINIT () </literal> "

#. (itstool) path: example/programlisting
#: book.translate.xml:4218
#, fuzzy, no-wrap
#| msgid ""
#| "#include &lt;sys/kernel.h&gt;\n"
#| "\n"
#| "void foo_null(void *unused)\n"
#| "{\n"
#| "        foo_doo();\n"
#| "}\n"
#| "SYSINIT(foo, SI_SUB_FOO, SI_ORDER_FOO, foo_null, NULL);\n"
#| "\n"
#| "struct foo foo_voodoo = {\n"
#| "        FOO_VOODOO;\n"
#| "}\n"
#| "\n"
#| "void foo_arg(void *vdata)\n"
#| "{\n"
#| "        struct foo *foo = (struct foo *)vdata;\n"
#| "        foo_data(foo);\n"
#| "}\n"
#| "SYSINIT(bar, SI_SUB_FOO, SI_ORDER_FOO, foo_arg, &amp;foo_voodoo);\n"
#| "\t"
msgid ""
"#include &lt;sys/kernel.h&gt;\n"
"\n"
"void foo_null(void *unused)\n"
"{\n"
"        foo_doo();\n"
"}\n"
"SYSINIT(foo, SI_SUB_FOO, SI_ORDER_FOO, foo_null, NULL);\n"
"\n"
"struct foo foo_voodoo = {\n"
"        FOO_VOODOO;\n"
"}\n"
"\n"
"void foo_arg(void *vdata)\n"
"{\n"
"        struct foo *foo = (struct foo *)vdata;\n"
"        foo_data(foo);\n"
"}\n"
"SYSINIT(bar, SI_SUB_FOO, SI_ORDER_FOO, foo_arg, &amp;foo_voodoo);"
msgstr ""
"#include &lt;sys/kernel.h&gt;\n"
"\n"
"void foo_null(void *unused)\n"
"{\n"
"        foo_doo();\n"
"}\n"
"SYSINIT(foo, SI_SUB_FOO, SI_ORDER_FOO, foo_null, NULL);\n"
"\n"
"struct foo foo_voodoo = {\n"
"        FOO_VOODOO;\n"
"}\n"
"\n"
"void foo_arg(void *vdata)\n"
"{\n"
"        struct foo *foo = (struct foo *)vdata;\n"
"        foo_data(foo);\n"
"}\n"
"SYSINIT(bar, SI_SUB_FOO, SI_ORDER_FOO, foo_arg, &amp;foo_voodoo);\n"
"\t"

#. (itstool) path: sect2/para
#: book.translate.xml:4237
#, fuzzy
msgid ""
"Note that <literal>SI_SUB_FOO</literal> and <literal>SI_ORDER_FOO</literal> "
"need to be in the <literal>sysinit_sub_id</literal> and "
"<literal>sysinit_elem_order</literal> enum's as mentioned above. Either use "
"existing ones or add your own to the enum's. You can also use math for fine-"
"tuning the order a SYSINIT will run in. This example shows a SYSINIT that "
"needs to be run just barely before the SYSINIT's that handle tuning kernel "
"parameters."
msgstr ""
"Observe que <literal> SI_SUB_FOO </literal> e <literal> SI_ORDER_FOO </"
"literal> precisa estar no <literal> sysinit_sub_id </literal> e <literal> "
"sysinit_elem_order </literal> enum como mencionado acima. Use os existentes "
"ou adicione os seus aos do enum. Voc� tamb�m pode usar matem�tica para "
"ajustar a ordem na qual um SYSINIT ser� executado. Este exemplo mostra um "
"SYSINIT que precisa ser executado logo antes do SYSINIT tratar os par�metros "
"do kernel de ajuste. "

#. (itstool) path: example/title
#: book.translate.xml:4248
#, fuzzy
msgid "Example of Adjusting <literal>SYSINIT()</literal> Order"
msgstr "Exemplo de ajuste <literal> SYSINIT () </literal> Ordem"

#. (itstool) path: example/programlisting
#: book.translate.xml:4251
#, no-wrap
msgid ""
"static void\n"
"mptable_register(void *dummy __unused)\n"
"{\n"
"\n"
"\tapic_register_enumerator(&amp;mptable_enumerator);\n"
"}\n"
"\n"
"SYSINIT(mptable_register, SI_SUB_TUNABLES - 1, SI_ORDER_FIRST,\n"
"    mptable_register, NULL);"
msgstr ""
"static void\n"
"mptable_register(void *dummy __unused)\n"
"{\n"
"\n"
"\tapic_register_enumerator(&amp;mptable_enumerator);\n"
"}\n"
"\n"
"SYSINIT(mptable_register, SI_SUB_TUNABLES - 1, SI_ORDER_FIRST,\n"
"    mptable_register, NULL);"

#. (itstool) path: sect2/title
#: book.translate.xml:4264
#, fuzzy
msgid "Shutdown"
msgstr "Desligar"

#. (itstool) path: sect2/para
#: book.translate.xml:4266
#, fuzzy
msgid ""
"The <literal>SYSUNINIT()</literal> macro behaves similarly to the "
"<literal>SYSINIT()</literal> macro except that it adds the SYSINIT data to "
"SYSINIT's shutdown data set."
msgstr ""
"O <literal> SYSUNINIT () </literal> macro se comporta de forma semelhante ao "
"<literal> SYSINIT () </literal> macro, exceto que adiciona os dados SYSINIT "
"ao conjunto de dados de desligamento do SYSINIT. "

#. (itstool) path: example/title
#: book.translate.xml:4271
#, fuzzy
msgid "Example of a <literal>SYSUNINIT()</literal>"
msgstr "Exemplo de um <literal> SYSUNINIT () </literal> "

#. (itstool) path: example/programlisting
#: book.translate.xml:4273
#, fuzzy, no-wrap
#| msgid ""
#| "#include &lt;sys/kernel.h&gt;\n"
#| "\n"
#| "void foo_cleanup(void *unused)\n"
#| "{\n"
#| "        foo_kill();\n"
#| "}\n"
#| "SYSUNINIT(foobar, SI_SUB_FOO, SI_ORDER_FOO, foo_cleanup, NULL);\n"
#| "\n"
#| "struct foo_stack foo_stack = {\n"
#| "        FOO_STACK_VOODOO;\n"
#| "}\n"
#| "\n"
#| "void foo_flush(void *vdata)\n"
#| "{\n"
#| "}\n"
#| "SYSUNINIT(barfoo, SI_SUB_FOO, SI_ORDER_FOO, foo_flush, &amp;foo_stack);\n"
#| "\t"
msgid ""
"#include &lt;sys/kernel.h&gt;\n"
"\n"
"void foo_cleanup(void *unused)\n"
"{\n"
"        foo_kill();\n"
"}\n"
"SYSUNINIT(foobar, SI_SUB_FOO, SI_ORDER_FOO, foo_cleanup, NULL);\n"
"\n"
"struct foo_stack foo_stack = {\n"
"        FOO_STACK_VOODOO;\n"
"}\n"
"\n"
"void foo_flush(void *vdata)\n"
"{\n"
"}\n"
"SYSUNINIT(barfoo, SI_SUB_FOO, SI_ORDER_FOO, foo_flush, &amp;foo_stack);"
msgstr ""
"#include &lt;sys/kernel.h&gt;\n"
"\n"
"void foo_cleanup(void *unused)\n"
"{\n"
"        foo_kill();\n"
"}\n"
"SYSUNINIT(foobar, SI_SUB_FOO, SI_ORDER_FOO, foo_cleanup, NULL);\n"
"\n"
"struct foo_stack foo_stack = {\n"
"        FOO_STACK_VOODOO;\n"
"}\n"
"\n"
"void foo_flush(void *vdata)\n"
"{\n"
"}\n"
"SYSUNINIT(barfoo, SI_SUB_FOO, SI_ORDER_FOO, foo_flush, &amp;foo_stack);\n"
"\t"

#. (itstool) path: info/title
#: book.translate.xml:4330
#, fuzzy
msgid "The TrustedBSD MAC Framework"
msgstr "O framework MAC TrustedBSD"

#. (itstool) path: affiliation/address
#: book.translate.xml:4340
#, fuzzy, no-wrap
msgid ""
"\n"
"\t    <email>chris@FreeBSD.org</email>\n"
"\t  "
msgstr "<email>chris@FreeBSD.org</email>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:4333
#, fuzzy
msgid ""
"<personname> <firstname>Chris</firstname> <surname>Costello</surname> </"
"personname> <affiliation> <orgname>TrustedBSD Project</orgname> <_:address-1/"
"> </affiliation>"
msgstr ""
" <personname><firstname> Chris </firstname><surname> Costello </surname></"
"personname><affiliation><orgname> Projeto TrustedBSD </orgname> <_: "
"endere�o-1 /> </affiliation> "

#. (itstool) path: affiliation/address
#: book.translate.xml:4353
#, fuzzy, no-wrap
msgid ""
"\n"
"\t    <email>rwatson@FreeBSD.org</email>\n"
"\t  "
msgstr "<email>rwatson@FreeBSD.org</email>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:4346
#, fuzzy
msgid ""
"<personname> <firstname>Robert</firstname> <surname>Watson</surname> </"
"personname> <affiliation> <orgname>TrustedBSD Project</orgname> <_:address-1/"
"> </affiliation>"
msgstr ""
" <personname><firstname> Robert </firstname><surname> Watson </surname></"
"personname><affiliation><orgname> Projeto TrustedBSD </orgname> <_: "
"endere�o-1 /> </affiliation> "

#. (itstool) path: sect1/title
#: book.translate.xml:4362
#, fuzzy
msgid "MAC Documentation Copyright"
msgstr "Direitos autorais da documenta��o do MAC"

#. (itstool) path: sect1/para
#: book.translate.xml:4364
#, fuzzy
msgid ""
"This documentation was developed for the FreeBSD Project by Chris Costello "
"at Safeport Network Services and Network Associates Laboratories, the "
"Security Research Division of Network Associates, Inc. under DARPA/SPAWAR "
"contract N66001-01-C-8035 (<quote>CBOSS</quote>), as part of the DARPA CHATS "
"research program."
msgstr ""
"Esta documenta��o foi desenvolvida para o Projeto FreeBSD por Chris Costello "
"na Safeport Network Services e Network Associates Laboratories, a Divis�o de "
"Pesquisa de Seguran�a da Network Associates, Inc. sob contrato DARPA / "
"SPAWAR N66001-01-C-8035 ( <quote> CBOSS </quote> ), como parte do programa "
"de pesquisa DARPA CHATS. "

#. (itstool) path: sect1/para
#: book.translate.xml:4371
#, fuzzy
msgid ""
"Redistribution and use in source (SGML DocBook) and 'compiled' forms (SGML, "
"HTML, PDF, PostScript, RTF and so forth) with or without modification, are "
"permitted provided that the following conditions are met:"
msgstr ""
"Redistribui��o e uso em formul�rios de origem (SGML DocBook) e ';"
"compilados'; (SGML, HTML, PDF, PostScript, RTF e assim por diante) com ou "
"sem modifica��o, s�o permitidos desde que as seguintes condi��es sejam "
"atendidas:"

#. (itstool) path: listitem/para
#: book.translate.xml:4378
#, fuzzy
msgid ""
"Redistributions of source code (SGML DocBook) must retain the above "
"copyright notice, this list of conditions and the following disclaimer as "
"the first lines of this file unmodified."
msgstr ""
"As redistribui��es do c�digo-fonte (SGML DocBook) devem manter o aviso de "
"copyright acima, esta lista de condi��es e o aviso de isen��o de "
"responsabilidade a seguir, conforme as primeiras linhas deste arquivo n�o "
"sejam modificadas."

#. (itstool) path: important/para
#: book.translate.xml:4395
#, fuzzy
msgid ""
"THIS DOCUMENTATION IS PROVIDED BY THE NETWORKS ASSOCIATES TECHNOLOGY, INC "
"\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED "
"TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR "
"PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETWORKS ASSOCIATES TECHNOLOGY, "
"INC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR "
"CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF "
"SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS "
"INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN "
"CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) "
"ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF "
"THE POSSIBILITY OF SUCH DAMAGE."
msgstr ""
"ESTA DOCUMENTA��O � FORNECIDA PELA NETWORKS ASSOCIATES TECHNOLOGY, INC \" "
"COMO EST� \"\" E QUALQUER GARANTIA EXPRESSA OU IMPL�CITA, INCLUINDO, MAS N�O "
"SE LIMITANDO �S GARANTIAS IMPL�CITAS DE COMERCIALIZA��O E ADEQUA��O A UMA "
"FINALIDADE ESPEC�FICA, � REJEITADA. A NETWORKS ASSOCIATES TECHNOLOGY, INC � "
"RESPONS�VEL POR QUAISQUER DANOS DIRETOS, INDIRETOS, INCIDENTAIS, ESPECIAIS, "
"EXEMPLARES OU CONSEQ�ENCIAIS (INCLUINDO, MAS N�O SE LIMITANDO A, AQUISI��O "
"DE BENS OU SERVI�OS SUBSTITUTOS; PERDA DE USO, DADOS OU LUCROS; OU "
"INTERRUP��O DE NEG�CIOS) SEMPRE CAUSOU QUALQUER TEORIA DE RESPONSABILIDADE, "
"SEJA EM CONTRATO, RESPONSABILIDADE ESTRITA, OU DELITO (INCLUINDO NEGLIG�NCIA "
"OU DE OUTRA FORMA) DECORRENTE DE QUALQUER FORMA DO USO DESTA DOCUMENTA��O, "
"MESMO SE AVISADA DA POSSIBILIDADE DE TAIS DANOS. "

#. (itstool) path: sect1/para
#: book.translate.xml:4414
#, fuzzy
msgid ""
"FreeBSD includes experimental support for several mandatory access control "
"policies, as well as a framework for kernel security extensibility, the "
"TrustedBSD MAC Framework. The MAC Framework is a pluggable access control "
"framework, permitting new security policies to be easily linked into the "
"kernel, loaded at boot, or loaded dynamically at run-time. The framework "
"provides a variety of features to make it easier to implement new security "
"policies, including the ability to easily tag security labels (such as "
"confidentiality information) onto system objects."
msgstr ""
"O FreeBSD inclui suporte experimental para v�rias pol�ticas de controle de "
"acesso, bem como uma estrutura para extensibilidade de seguran�a do kernel, "
"o TrustedBSD MAC Framework. O MAC Framework � uma estrutura de controle de "
"acesso plug�vel, permitindo que novas pol�ticas de seguran�a sejam "
"facilmente vinculadas ao kernel na inicializa��o ou carregada dinamicamente "
"em tempo de execu��o. A estrutura fornece uma variedade de recursos para "
"facilitar a implementa��o de novas pol�ticas de seguran�a, incluindo a "
"capacidade de marcar facilmente r�tulos de seguran�a (como informa��es de "
"confidencialidade) em objetos do sistema. "

#. (itstool) path: sect1/para
#: book.translate.xml:4425
#, fuzzy
msgid ""
"This chapter introduces the MAC policy framework and provides documentation "
"for a sample MAC policy module."
msgstr ""
"Este cap�tulo apresenta a estrutura de pol�tica do MAC e fornece "
"documenta��o para um m�dulo de pol�tica MAC de amostra."

#. (itstool) path: sect1/title
#: book.translate.xml:4431 book.translate.xml:14933 book.translate.xml:16103
#: book.translate.xml:21732 book.translate.xml:22852
msgid "Introduction"
msgstr "Introdução"

#. (itstool) path: sect1/para
#: book.translate.xml:4433
#, fuzzy
msgid ""
"The TrustedBSD MAC framework provides a mechanism to allow the compile-time "
"or run-time extension of the kernel access control model. New system "
"policies may be implemented as kernel modules and linked to the kernel; if "
"multiple policy modules are present, their results will be composed. The MAC "
"Framework provides a variety of access control infrastructure services to "
"assist policy writers, including support for transient and persistent policy-"
"agnostic object security labels. This support is currently considered "
"experimental."
msgstr ""
"A estrutura MAC do TrustedBSD fornece um mecanismo para permitir a extens�o "
"em tempo de compila��o ou de tempo de execu��o do modelo de controle de "
"acesso do kernel. Novas pol�ticas do sistema podem ser implementadas como "
"m�dulos do kernel e vinculadas ao kernel; se houver v�rios m�dulos de "
"pol�tica, seus resultados O MAC Framework fornece uma variedade de servi�os "
"de infra-estrutura de controle de acesso para auxiliar os redatores de "
"pol�ticas, incluindo o suporte a r�tulos de seguran�a de objetos agn�sticos, "
"transit�rios e persistentes. Esse suporte � atualmente considerado "
"experimental. "

#. (itstool) path: sect1/para
#: book.translate.xml:4443
#, fuzzy
msgid ""
"This chapter provides information appropriate for developers of policy "
"modules, as well as potential consumers of MAC-enabled environments, to "
"learn about how the MAC Framework supports access control extension of the "
"kernel."
msgstr ""
"Este cap�tulo fornece informa��es apropriadas para desenvolvedores de "
"m�dulos de pol�ticas, bem como potenciais consumidores de ambientes "
"habilitados para MAC, para aprender sobre como o MAC Framework suporta a "
"extens�o de controle de acesso do kernel."

#. (itstool) path: sect1/title
#: book.translate.xml:4450
#, fuzzy
msgid "Policy Background"
msgstr "Hist�rico da Pol�tica"

#. (itstool) path: sect1/para
#: book.translate.xml:4452
#, fuzzy
msgid ""
"Mandatory Access Control (MAC), refers to a set of access control policies "
"that are mandatorily enforced on users by the operating system. MAC policies "
"may be contrasted with Discretionary Access Control (DAC) protections, by "
"which non-administrative users may (at their discretion) protect objects. In "
"traditional UNIX systems, DAC protections include file permissions and "
"access control lists; MAC protections include process controls preventing "
"inter-user debugging and firewalls. A variety of MAC policies have been "
"formulated by operating system designers and security researches, including "
"the Multi-Level Security (MLS) confidentiality policy, the Biba integrity "
"policy, Role-Based Access Control (RBAC), Domain and Type Enforcement (DTE), "
"and Type Enforcement (TE). Each model bases decisions on a variety of "
"factors, including user identity, role, and security clearance, as well as "
"security labels on objects representing concepts such as data sensitivity "
"and integrity."
msgstr ""
"Mandatory Access Control (MAC), refere-se a um conjunto de pol�ticas de "
"controle de acesso impostas obrigatoriamente aos usu�rios pelo sistema "
"operacional. As pol�ticas MAC podem ser contrastadas com as prote��es de "
"Controle de Acesso Discricion�rio (DAC), pelas quais usu�rios n�o "
"administrativos podem Em seus sistemas UNIX tradicionais, as prote��es do "
"DAC incluem permiss�es de arquivos e listas de controle de acesso, e as "
"prote��es MAC incluem controles de processo que impedem a depura��o entre "
"usu�rios e firewalls.Uma variedade de pol�ticas MAC foram formuladas por "
"projetistas de sistemas operacionais e pesquisas de seguran�a. incluindo a "
"pol�tica de confidencialidade Multi-Level Security (MLS), a pol�tica de "
"integridade Biba, RBAC (Role-Based Access Control), DTE (Domain and Type "
"Enforcement) e TE (Type Enforcement), cada modelo baseia as decis�es numa "
"variedade de fatores. , incluindo identidade de usu�rio, fun��o e "
"autoriza��o de seguran�a, bem como etiquetas de seguran�a em objetos que "
"representam conceitos como integridade e sensibilidade de dados. "

#. (itstool) path: sect1/para
#: book.translate.xml:4470
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework is capable of supporting policy modules that "
"implement all of these policies, as well as a broad class of system "
"hardening policies, which may use existing security attributes, such as user "
"and group IDs, as well as extended attributes on files, and other system "
"properties. In addition, despite the name, the MAC Framework can also be "
"used to implement purely discretionary policies, as policy modules are given "
"substantial flexibility in how they authorize protections."
msgstr ""
"O TrustedBSD MAC Framework � capaz de suportar m�dulos de pol�ticas que "
"implementam todas essas pol�ticas, bem como uma ampla classe de pol�ticas de "
"prote��o do sistema, que podem usar atributos de seguran�a existentes, como "
"IDs de usu�rios e grupos, bem como atributos estendidos em arquivos e outras "
"propriedades do sistema Al�m disso, apesar do nome, o MAC Framework tamb�m "
"pode ser usado para implementar pol�ticas puramente discricion�rias, uma vez "
"que os m�dulos de pol�ticas recebem uma flexibilidade substancial na forma "
"como autorizam prote��es \""

#. (itstool) path: sect1/title
#: book.translate.xml:4482
#, fuzzy
msgid "MAC Framework Kernel Architecture"
msgstr "Arquitetura do Kernel do MAC Framework"

#. (itstool) path: sect1/para
#: book.translate.xml:4484
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework permits kernel modules to extend the operating "
"system security policy, as well as providing infrastructure functionality "
"required by many access control modules. If multiple policies are "
"simultaneously loaded, the MAC Framework will usefully (for some definition "
"of useful) compose the results of the policies."
msgstr ""
"O TrustedBSD MAC Framework permite que os m�dulos do kernel estendam a "
"pol�tica de seguran�a do sistema operacional, bem como fornecem a "
"funcionalidade de infra-estrutura requerida por muitos m�dulos de controle "
"de acesso. Se v�rias pol�ticas forem carregadas simultaneamente, o MAC "
"Framework utilizar� (para alguma defini��o �til) resultados das pol�ticas \""

#. (itstool) path: sect2/title
#: book.translate.xml:4492
#, fuzzy
msgid "Kernel Elements"
msgstr "Elementos do Kernel"

#. (itstool) path: sect2/para
#: book.translate.xml:4494
#, fuzzy
msgid "The MAC Framework contains a number of kernel elements:"
msgstr "O MAC Framework cont�m v�rios elementos do kernel:"

#. (itstool) path: listitem/para
#: book.translate.xml:4499
#, fuzzy
msgid "Framework management interfaces"
msgstr "Interfaces de gerenciamento de estrutura"

#. (itstool) path: listitem/para
#: book.translate.xml:4502
#, fuzzy
msgid "Concurrency and synchronization primitives."
msgstr "Primitivas de sincroniza��o e simultaneidade."

#. (itstool) path: listitem/para
#: book.translate.xml:4505
#, fuzzy
msgid "Policy registration"
msgstr "Registo de pol�tica"

#. (itstool) path: listitem/para
#: book.translate.xml:4508
#, fuzzy
msgid "Extensible security label for kernel objects"
msgstr "Etiqueta de seguran�a extens�vel para objetos do kernel"

#. (itstool) path: listitem/para
#: book.translate.xml:4511
#, fuzzy
msgid "Policy entry point composition operators"
msgstr "Operadores de composi��o de ponto de entrada de pol�tica"

#. (itstool) path: listitem/para
#: book.translate.xml:4514
#, fuzzy
msgid "Label management primitives"
msgstr "Primitivos de gerenciamento de r�tulo"

#. (itstool) path: listitem/para
#: book.translate.xml:4517
#, fuzzy
msgid "Entry point API invoked by kernel services"
msgstr "API do ponto de entrada invocada pelos servi�os do kernel"

#. (itstool) path: listitem/para
#: book.translate.xml:4520
#, fuzzy
msgid "Entry point API to policy modules"
msgstr "API de ponto de entrada para m�dulos de pol�tica"

#. (itstool) path: listitem/para
#: book.translate.xml:4523
#, fuzzy
msgid ""
"Entry points implementations (policy life cycle, object life cycle/label "
"management, access control checks)."
msgstr ""
"Implementa��es de pontos de entrada (ciclo de vida da pol�tica, ciclo de "
"vida do objeto / gerenciamento de etiquetas, verifica��es de controle de "
"acesso)."

#. (itstool) path: listitem/para
#: book.translate.xml:4528
#, fuzzy
msgid "Policy-agnostic label-management system calls"
msgstr "Chamadas de sistema de gerenciamento de r�tulo agn�stico de pol�ticas"

#. (itstool) path: listitem/para
#: book.translate.xml:4531
#, fuzzy
msgid "<function>mac_syscall()</function> multiplex system call"
msgstr " <function> mac_syscall () </function> chamada do sistema multiplex "

#. (itstool) path: listitem/para
#: book.translate.xml:4535
#, fuzzy
msgid "Various security policies implemented as MAC policy modules"
msgstr ""
"V�rias pol�ticas de seguran�a implementadas como m�dulos de pol�tica MAC"

#. (itstool) path: sect2/title
#: book.translate.xml:4542
#, fuzzy
msgid "Framework Management Interfaces"
msgstr "Framework Management Interfaces"

#. (itstool) path: sect2/para
#: book.translate.xml:4544
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework may be directly managed using sysctl's, loader "
"tunables, and system calls."
msgstr ""
"O TrustedBSD MAC Framework pode ser gerenciado diretamente usando sysctl';s, "
"sintetizadores de carregador e chamadas do sistema."

#. (itstool) path: sect2/para
#: book.translate.xml:4547
#, fuzzy
msgid ""
"In most cases, sysctl's and loader tunables of the same name modify the same "
"parameters, and control behavior such as enforcement of protections relating "
"to various kernel subsystems. In addition, if MAC debugging support is "
"compiled into the kernel, several counters will be maintained tracking label "
"allocation. It is generally advisable that per-subsystem enforcement "
"controls not be used to control policy behavior in production environments, "
"as they broadly impact the operation of all active policies. Instead, per-"
"policy controls should be preferred, as they provide greater granularity and "
"greater operational consistency for policy modules."
msgstr ""
"Na maioria dos casos, sysctl';s e loaders sintoniz�veis ​​do mesmo nome "
"modificam os mesmos par�metros e controlam o comportamento, como a aplica��o "
"de prote��es relacionadas a v�rios subsistemas do kernel. Al�m disso, se o "
"suporte de depura��o MAC for compilado no kernel, v�rios contadores ser�o "
"mantidos. � geralmente aconselh�vel que os controles de fiscaliza��o por "
"subsistema n�o sejam usados ​​para controlar o comportamento de pol�ticas em "
"ambientes de produ��o, pois eles geralmente afetam a opera��o de todas as "
"pol�ticas ativas. granularidade e maior consist�ncia operacional para "
"m�dulos de pol�ticas. "

#. (itstool) path: sect2/para
#: book.translate.xml:4560
#, fuzzy
msgid ""
"Loading and unloading of policy modules is performed using the system module "
"management system calls and other system interfaces, including boot loader "
"variables; policy modules will have the opportunity to influence load and "
"unload events, including preventing undesired unloading of the policy."
msgstr ""
"O carregamento e descarregamento de m�dulos de pol�ticas � realizado usando "
"as chamadas do sistema de gerenciamento de m�dulos do sistema e outras "
"interfaces do sistema, incluindo vari�veis ​​do carregador de inicializa��o; "
"os m�dulos de pol�tica ter�o a oportunidade de influenciar a carga e "
"descarga de eventos, incluindo a preven��o de descarregamento indesejado da "
"pol�tica."

#. (itstool) path: sect2/title
#: book.translate.xml:4568
#, fuzzy
msgid "Policy List Concurrency and Synchronization"
msgstr "Concorr�ncia e Sincroniza��o da Lista de Pol�ticas"

#. (itstool) path: sect2/para
#: book.translate.xml:4570
#, fuzzy
msgid ""
"As the set of active policies may change at run-time, and the invocation of "
"entry points is non-atomic, synchronization is required to prevent loading "
"or unloading of policies while an entry point invocation is in progress, "
"freezing the set of active policies for the duration. This is accomplished "
"by means of a framework busy count: whenever an entry point is entered, the "
"busy count is incremented; whenever it is exited, the busy count is "
"decremented. While the busy count is elevated, policy list changes are not "
"permitted, and threads attempting to modify the policy list will sleep until "
"the list is not busy. The busy count is protected by a mutex, and a "
"condition variable is used to wake up sleepers waiting on policy list "
"modifications. One side effect of this synchronization model is that "
"recursion into the MAC Framework from within a policy module is permitted, "
"although not generally used."
msgstr ""
"Como o conjunto de pol�ticas ativas pode mudar em tempo de execu��o e a "
"invoca��o de pontos de entrada n�o � at�mica, a sincroniza��o � necess�ria "
"para impedir o carregamento ou descarregamento de pol�ticas enquanto uma "
"chamada de ponto de entrada est� em andamento, congelando o conjunto de "
"pol�ticas ativas Isso ocorre por meio de uma contagem ocupacional de "
"estrutura: sempre que um ponto de entrada � inserido, a contagem de ocupado "
"� incrementada e, quando ela � encerrada, a contagem de ocupado � diminu�da. "
"n�o permitido, e os segmentos que tentam modificar a lista de pol�ticas "
"ficar�o suspensos at� que a lista n�o esteja ocupada.A contagem ocupada � "
"protegida por um mutex e uma vari�vel de condi��o � usada para ativar os "
"travessas aguardando modifica��es na lista de pol�ticas. O modelo de "
"sincroniza��o � que a recurs�o no MAC Framework de dentro de um m�dulo de "
"pol�tica � permitida, embora n�o seja geralmente usada. "

#. (itstool) path: sect2/para
#: book.translate.xml:4587
#, fuzzy
msgid ""
"Various optimizations are used to reduce the overhead of the busy count, "
"including avoiding the full cost of incrementing and decrementing if the "
"list is empty or contains only static entries (policies that are loaded "
"before the system starts, and cannot be unloaded). A compile-time option is "
"also provided which prevents any change in the set of loaded policies at run-"
"time, which eliminates the mutex locking costs associated with supporting "
"dynamically loaded and unloaded policies as synchronization is no longer "
"required."
msgstr ""
"V�rias otimiza��es s�o usadas para reduzir a sobrecarga da contagem de "
"ocupa��es, evitando o custo total de incrementar e decrementar se a lista "
"estiver vazia ou contiver apenas entradas est�ticas (pol�ticas que s�o "
"carregadas antes do sistema ser iniciado e n�o podem ser descarregadas). "
"op��o de tempo de compila��o tamb�m � fornecida, o que elimina qualquer "
"altera��o no conjunto de pol�ticas carregadas em tempo de execu��o, o que "
"elimina os custos de bloqueio mutex associados ao suporte de pol�ticas "
"carregadas e descarregadas dinamicamente, j� que a sincroniza��o n�o � mais "
"necess�ria. "

#. (itstool) path: sect2/para
#: book.translate.xml:4598
#, fuzzy
msgid ""
"As the MAC Framework is not permitted to block in some entry points, a "
"normal sleep lock cannot be used; as a result, it is possible for the load "
"or unload attempt to block for a substantial period of time waiting for the "
"framework to become idle."
msgstr ""
"Como o MAC Framework n�o tem permiss�o para bloquear em alguns pontos de "
"entrada, n�o � poss�vel usar um bloqueio de sono normal; como resultado, � "
"poss�vel que a tentativa de carga ou descarga seja bloqueada por um per�odo "
"de tempo substancial esperando a estrutura se tornar ocioso \""

#. (itstool) path: sect2/title
#: book.translate.xml:4606
#, fuzzy
msgid "Label Synchronization"
msgstr "Label Synchronization"

#. (itstool) path: sect2/para
#: book.translate.xml:4608
#, fuzzy
msgid ""
"As kernel objects of interest may generally be accessed from more than one "
"thread at a time, and simultaneous entry of more than one thread into the "
"MAC Framework is permitted, security attribute storage maintained by the MAC "
"Framework is carefully synchronized. In general, existing kernel "
"synchronization on kernel object data is used to protect MAC Framework "
"security labels on the object: for example, MAC labels on sockets are "
"protected using the existing socket mutex. Likewise, semantics for "
"concurrent access are generally identical to those of the container objects: "
"for credentials, copy-on-write semantics are maintained for label contents "
"as with the remainder of the credential structure. The MAC Framework asserts "
"necessary locks on objects when invoked with an object reference. Policy "
"authors must be aware of these synchronization semantics, as they will "
"sometimes limit the types of accesses permitted on labels: for example, when "
"a read-only reference to a credential is passed to a policy via an entry "
"point, only read operations are permitted on the label state attached to the "
"credential."
msgstr ""
"Como os objetos de interesse do kernel geralmente podem ser acessados ​​de "
"mais de um thread de cada vez, e a entrada simult�nea de mais de um thread "
"no MAC Framework � permitida, o armazenamento de atributos de seguran�a "
"mantido pelo MAC Framework � cuidadosamente sincronizado. A sincroniza��o do "
"kernel nos dados do objeto kernel � usada para proteger os r�tulos de "
"seguran�a do MAC Framework no objeto: por exemplo, os r�tulos MAC nos "
"soquetes s�o protegidos usando o mutex de soquete existente Da mesma forma, "
"as sem�nticas para acesso simult�neo s�o geralmente id�nticas �quelas dos "
"objetos cont�ineres: credenciais, a sem�ntica de copy-on-write � mantida "
"para o conte�do da etiqueta como no restante da estrutura de credencial.O "
"MAC Framework afirma os bloqueios necess�rios em objetos quando invocado com "
"uma refer�ncia de objeto.Os autores da pol�tica devem estar cientes dessas "
"sem�nticas de sincroniza��o, pois elas �s vezes, limitar os tipos de acessos "
"permitidos nos r�tulos: por exemplo, quando uma refer�ncia somente leitura a "
"uma credencial � passada para uma pol�tica por meio de um ponto de entrada, "
"somente as opera��es de leitura s�o permitidas no estado da etiqueta anexado "
"� credencial. "

#. (itstool) path: sect2/title
#: book.translate.xml:4631
#, fuzzy
msgid "Policy Synchronization and Concurrency"
msgstr "Sincroniza��o e Concorr�ncia de Pol�ticas"

#. (itstool) path: sect2/para
#: book.translate.xml:4633
#, fuzzy
msgid ""
"Policy modules must be written to assume that many kernel threads may "
"simultaneously enter one more policy entry points due to the parallel and "
"preemptive nature of the FreeBSD kernel. If the policy module makes use of "
"mutable state, this may require the use of synchronization primitives within "
"the policy to prevent inconsistent views on that state resulting in "
"incorrect operation of the policy. Policies will generally be able to make "
"use of existing FreeBSD synchronization primitives for this purpose, "
"including mutexes, sleep locks, condition variables, and counting "
"semaphores. However, policies should be written to employ these primitives "
"carefully, respecting existing kernel lock orders, and recognizing that some "
"entry points are not permitted to sleep, limiting the use of primitives in "
"those entry points to mutexes and wakeup operations."
msgstr ""
"Os m�dulos de pol�tica devem ser escritos para assumir que muitos "
"encadeamentos do kernel podem inserir simultaneamente mais um ponto de "
"entrada de pol�tica devido � natureza paralela e preventiva do kernel do "
"FreeBSD. Se o m�dulo de pol�tica faz uso do estado mut�vel, isso pode exigir "
"o uso de primitivas de sincroniza��o dentro da pol�tica para evitar vis�es "
"inconsistentes sobre aquele estado resultando em opera��o incorreta da "
"pol�tica, geralmente as pol�ticas poder�o fazer uso das primitivas de "
"sincroniza��o existentes do FreeBSD para este prop�sito, incluindo mutexes, "
"travas de sono, vari�veis ​​de condi��o e sem�foros de contagem. as pol�ticas "
"devem ser escritas para empregar esses primitivos cuidadosamente, "
"respeitando os pedidos de bloqueio do kernel existentes, e reconhecendo que "
"alguns pontos de entrada n�o t�m permiss�o para dormir, limitando o uso de "
"primitivos nesses pontos de entrada para mutexes e opera��es de ativa��o. "

#. (itstool) path: sect2/para
#: book.translate.xml:4649
#, fuzzy
msgid ""
"When policy modules call out to other kernel subsystems, they will generally "
"need to release any in-policy locks in order to avoid violating the kernel "
"lock order or risking lock recursion. This will maintain policy locks as "
"leaf locks in the global lock order, helping to avoid deadlock."
msgstr ""
"Quando os m�dulos de pol�tica chamam outros subsistemas do kernel, eles "
"geralmente precisam liberar qualquer bloqueio na pol�tica para evitar violar "
"a ordem de bloqueio do kernel ou arriscar a recurs�o do bloqueio. Isso "
"manter� os bloqueios de pol�tica como bloqueios de folha na ordem de "
"bloqueio global. ajudando a evitar o impasse \""

#. (itstool) path: sect2/title
#: book.translate.xml:4657
#, fuzzy
msgid "Policy Registration"
msgstr "Registro de Pol�tica"

#. (itstool) path: sect2/para
#: book.translate.xml:4659
#, fuzzy
msgid ""
"The MAC Framework maintains two lists of active policies: a static list, and "
"a dynamic list. The lists differ only with regards to their locking "
"semantics: an elevated reference count is not required to make use of the "
"static list. When kernel modules containing MAC Framework policies are "
"loaded, the policy module will use <literal>SYSINIT</literal> to invoke a "
"registration function; when a policy module is unloaded, <literal>SYSINIT</"
"literal> will likewise invoke a de-registration function. Registration may "
"fail if a policy module is loaded more than once, if insufficient resources "
"are available for the registration (for example, the policy might require "
"labeling and insufficient labeling state might be available), or other "
"policy prerequisites might not be met (some policies may only be loaded "
"prior to boot). Likewise, de-registration may fail if a policy is flagged as "
"not unloadable."
msgstr ""
"O MAC Framework mant�m duas listas de pol�ticas ativas: uma lista est�tica e "
"uma lista din�mica. As listas diferem apenas em rela��o � sem�ntica de "
"bloqueio: uma contagem de refer�ncia elevada n�o � necess�ria para fazer uso "
"da lista est�tica. Quando os m�dulos do kernel cont�m Pol�ticas do MAC "
"Framework s�o carregadas, o m�dulo de pol�tica usar� <literal> SYSINIT </"
"literal> invocar uma fun��o de registro; quando um m�dulo de pol�tica � "
"descarregado, <literal> SYSINIT </literal> Da mesma forma, invocar� uma "
"fun��o de cancelamento de registro. O registro pode falhar se um m�dulo de "
"pol�tica for carregado mais de uma vez, se recursos insuficientes estiverem "
"dispon�veis para o registro (por exemplo, a pol�tica exigir rotulagem e "
"estado de rotulagem insuficiente estiver dispon�vel) ou se outros pr�-"
"requisitos de diretiva n�o forem atendidos s� pode ser carregado antes da "
"inicializa��o). Da mesma forma, o cancelamento de registro poder� falhar se "
"uma pol�tica for sinalizada como n�o descarreg�vel. "

#. (itstool) path: sect2/title
#: book.translate.xml:4678
#, fuzzy
msgid "Entry Points"
msgstr "Pontos de entrada"

#. (itstool) path: sect2/para
#: book.translate.xml:4680
#, fuzzy
msgid ""
"Kernel services interact with the MAC Framework in two ways: they invoke a "
"series of APIs to notify the framework of relevant events, and they provide "
"a policy-agnostic label structure pointer in security-relevant objects. The "
"label pointer is maintained by the MAC Framework via label management entry "
"points, and permits the Framework to offer a labeling service to policy "
"modules through relatively non-invasive changes to the kernel subsystem "
"maintaining the object. For example, label pointers have been added to "
"processes, process credentials, sockets, pipes, vnodes, Mbufs, network "
"interfaces, IP reassembly queues, and a variety of other security-relevant "
"structures. Kernel services also invoke the MAC Framework when they perform "
"important security decisions, permitting policy modules to augment those "
"decisions based on their own criteria (possibly including data stored in "
"security labels). Most of these security critical decisions will be explicit "
"access control checks; however, some affect more general decision functions "
"such as packet matching for sockets and label transition at program "
"execution."
msgstr ""
"Os servi�os do kernel interagem com o MAC Framework de duas maneiras: eles "
"invocam uma s�rie de APIs para notificar a estrutura de eventos relevantes e "
"fornecem um ponteiro de estrutura de r�tulos agn�sticos para pol�ticas em "
"objetos relevantes para a seguran�a. O ponteiro de r�tulo � mantido pelo MAC "
"Framework via pontos de entrada de gerenciamento de r�tulos e permite que o "
"Framework ofere�a um servi�o de rotulagem aos m�dulos de pol�tica atrav�s de "
"altera��es relativamente n�o invasivas ao subsistema do kernel mantendo os "
"objetos. Por exemplo, ponteiros de r�tulo foram adicionados a processos, "
"credenciais de processo, soquetes vnodes, Mbufs, interfaces de rede, filas "
"de reagrupamento IP e uma variedade de outras estruturas relevantes para "
"seguran�a.Os servi�os de kernel tamb�m invocam o MAC Framework quando "
"executam importantes decis�es de seguran�a, permitindo que os m�dulos de "
"pol�ticas aumentem essas decis�es com base em seus pr�prios crit�rios "
"(possivelmente incluindo os dados armazenados nos r�tulos de seguran�a.) A "
"maioria dessas decis�es cr�ticas de seguran�a ser�o verifica��es expl�citas "
"de controle de acesso; afetam fun��es de decis�o mais gerais, como "
"correspond�ncia de pacotes para soquetes e transi��o de r�tulo na execu��o "
"do programa. "

#. (itstool) path: sect2/title
#: book.translate.xml:4703
#, fuzzy
msgid "Policy Composition"
msgstr "Composi��o da Pol�tica"

#. (itstool) path: sect2/para
#: book.translate.xml:4705
#, fuzzy
msgid ""
"When more than one policy module is loaded into the kernel at a time, the "
"results of the policy modules will be composed by the framework using a "
"composition operator. This operator is currently hard-coded, and requires "
"that all active policies must approve a request for it to return success. As "
"policies may return a variety of error conditions (success, access denied, "
"object does not exist, ...), a precedence operator selects the resulting "
"error from the set of errors returned by policies. In general, errors "
"indicating that an object does not exist will be preferred to errors "
"indicating that access to an object is denied. While it is not guaranteed "
"that the resulting composition will be useful or secure, we have found that "
"it is for many useful selections of policies. For example, traditional "
"trusted systems often ship with two or more policies using a similar "
"composition."
msgstr ""
"Quando mais de um m�dulo de pol�tica � carregado no kernel de cada vez, os "
"resultados dos m�dulos de pol�tica ser�o compostos pela estrutura usando um "
"operador de composi��o. Esse operador est� atualmente embutido em c�digo e "
"requer que todas as pol�ticas ativas aprovem uma pedido para que ele retorne "
"sucesso.Como as pol�ticas podem retornar uma variedade de condi��es de erro "
"(sucesso, acesso negado, objeto n�o existe, ...), um operador de preced�ncia "
"seleciona o erro resultante do conjunto de erros retornados pelas "
"pol�ticas. , erros indicando que um objeto n�o existe ser�o preferidos a "
"erros indicando que o acesso a um objeto � negado.Enquanto n�o � garantido "
"que a composi��o resultante ser� �til ou segura, descobrimos que � para "
"muitas sele��es �teis de pol�ticas Por exemplo, sistemas confi�veis ​​"
"tradicionais geralmente v�m com duas ou mais pol�ticas usando uma composi��o "
"similar. "

#. (itstool) path: sect2/title
#: book.translate.xml:4723
#, fuzzy
msgid "Labeling Support"
msgstr "Suporte de rotulagem"

#. (itstool) path: sect2/para
#: book.translate.xml:4725
#, fuzzy
msgid ""
"As many interesting access control extensions rely on security labels on "
"objects, the MAC Framework provides a set of policy-agnostic label "
"management system calls covering a variety of user-exposed objects. Common "
"label types include partition identifiers, sensitivity labels, integrity "
"labels, compartments, domains, roles, and types. By policy agnostic, we mean "
"that policy modules are able to completely define the semantics of meta-data "
"associated with an object. Policy modules participate in the internalization "
"and externalization of string-based labels provides by user applications, "
"and can expose multiple label elements to applications if desired."
msgstr ""
"Como muitas extens�es de controle de acesso interessantes dependem de "
"r�tulos de seguran�a em objetos, o MAC Framework fornece um conjunto de "
"chamadas de sistema de gerenciamento de r�tulos agn�sticos que cobrem uma "
"variedade de objetos expostos pelo usu�rio. Os tipos de r�tulos comuns "
"incluem identificadores de parti��o, r�tulos de sensibilidade e r�tulos de "
"integridade. compartimentos, dom�nios, fun��es e tipos. Por pol�tica "
"agn�stica, queremos dizer que os m�dulos de pol�tica s�o capazes de definir "
"completamente a sem�ntica de metadados associados a um objeto. M�dulos de "
"pol�ticas participam da internaliza��o e externaliza��o de r�tulos baseados "
"em strings fornecidas pelo usu�rio aplicativos e pode expor v�rios elementos "
"de r�tulo para aplicativos, se desejado. "

#. (itstool) path: sect2/para
#: book.translate.xml:4738
#, fuzzy
msgid ""
"In-memory labels are stored in slab-allocated <varname remap=\"structname"
"\">struct label</varname>, which consists of a fixed-length array of unions, "
"each holding a <literal>void *</literal> pointer and a <literal>long</"
"literal>. Policies registering for label storage will be assigned a \"slot\" "
"identifier, which may be used to dereference the label storage. The "
"semantics of the storage are left entirely up to the policy module: modules "
"are provided with a variety of entry points associated with the kernel "
"object life cycle, including initialization, association/creation, and "
"destruction. Using these interfaces, it is possible to implement reference "
"counting and other storage models. Direct access to the object structure is "
"generally not required by policy modules to retrieve a label, as the MAC "
"Framework generally passes both a pointer to the object and a direct pointer "
"to the object's label into entry points. The primary exception to this rule "
"is the process credential, which must be manually dereferenced to access the "
"credential label. This may change in future revisions of the MAC Framework."
msgstr ""
"Etiquetas na mem�ria s�o armazenadas em aloca��o de placas <varname remap="
"\"structname\"> r�tulo struct </varname> , que consiste em uma matriz de "
"uni�es de comprimento fixo, cada uma segurando uma <literal> void * </"
"literal> ponteiro e um <literal> longo </literal> . As pol�ticas que se "
"registram para o armazenamento de r�tulo receber�o um identificador \\ "
"\"slot \", que pode ser usado para excluir a refer�ncia do armazenamento de "
"r�tulo. A sem�ntica do armazenamento � deixada inteiramente para o m�dulo de "
"pol�tica: os m�dulos s�o fornecidos com uma variedade de pontos de entrada "
"associados ao ciclo de vida do objeto do kernel, incluindo inicializa��o, "
"associa��o / cria��o e destrui��o. Usando essas interfaces, � poss�vel "
"implementar a contagem de refer�ncia e outros modelos de armazenamento. O "
"acesso direto � estrutura do objeto geralmente n�o � exigido pelos m�dulos "
"de pol�tica para recuperar um r�tulo, j� que o MAC Framework geralmente "
"passa um ponteiro para o objeto e um ponteiro direto para o r�tulo do objeto "
"nos pontos de entrada. A principal exce��o a essa regra � a credencial do "
"processo, que deve ser manualmente referenciada para acessar o r�tulo da "
"credencial. Isso pode mudar em futuras revis�es do MAC Framework. "

#. (itstool) path: sect2/para
#: book.translate.xml:4757
#, fuzzy
msgid ""
"Initialization entry points frequently include a sleeping disposition flag "
"indicating whether or not an initialization is permitted to sleep; if "
"sleeping is not permitted, a failure may be returned to cancel allocation of "
"the label (and hence object). This may occur, for example, in the network "
"stack during interrupt handling, where sleeping is not permitted, or while "
"the caller holds a mutex. Due to the performance cost of maintaining labels "
"on in-flight network packets (Mbufs), policies must specifically declare a "
"requirement that Mbuf labels be allocated. Dynamically loaded policies "
"making use of labels must be able to handle the case where their init "
"function has not been called on an object, as objects may already exist when "
"the policy is loaded. The MAC Framework guarantees that uninitialized label "
"slots will hold a 0 or NULL value, which policies may use to detect "
"uninitialized values. However, as allocation of Mbuf labels is conditional, "
"policies must also be able to handle a NULL label pointer for Mbufs if they "
"have been loaded dynamically."
msgstr ""
"Os pontos de entrada de inicializa��o freq�entemente incluem um sinalizador "
"de disposi��o de sono indicando se uma inicializa��o � permitida ou n�o; se "
"dormir n�o for permitido, uma falha pode ser retornada para cancelar a "
"aloca��o do r�tulo (e, portanto, objeto). Isso pode ocorrer, por exemplo , "
"na pilha de rede durante o manuseio de interrup��o, onde dormir n�o � "
"permitido ou enquanto o chamador possui um mutex.Devido ao custo de "
"desempenho de manuten��o de r�tulos em pacotes de rede em tr�nsito (Mbufs), "
"diretivas devem declarar especificamente um requisito que r�tulos Mbuf "
"Pol�ticas carregadas dinamicamente que usam r�tulos devem ser capazes de "
"lidar com o caso em que sua fun��o init n�o foi chamada em um objeto, j� que "
"objetos j� podem existir quando a pol�tica � carregada. O MAC Framework "
"garante que os slots de r�tulo n�o inicializados um valor 0 ou NULL, que as "
"pol�ticas podem usar para detectar valores n�o inicializados.No entanto, "
"como a aloca��o de r�tulos Mbuf � condicional, as pol�ticas tamb�m devem ser "
"capazes de manipular Ponteiro de r�tulo NULL para Mbufs se eles foram "
"carregados dinamicamente. "

#. (itstool) path: sect2/para
#: book.translate.xml:4776
#, fuzzy
msgid ""
"In the case of file system labels, special support is provided for the "
"persistent storage of security labels in extended attributes. Where "
"available, extended attribute transactions are used to permit consistent "
"compound updates of security labels on vnodes--currently this support is "
"present only in the UFS2 file system. Policy authors may choose to implement "
"multilabel file system object labels using one (or more) extended "
"attributes. For efficiency reasons, the vnode label (<literal>v_label</"
"literal>) is a cache of any on-disk label; policies are able to load values "
"into the cache when the vnode is instantiated, and update the cache as "
"needed. As a result, the extended attribute need not be directly accessed "
"with every access control check."
msgstr ""
"No caso de r�tulos de sistema de arquivos, � fornecido suporte especial para "
"o armazenamento persistente de r�tulos de seguran�a em atributos estendidos. "
"Quando dispon�veis, transa��es de atributos estendidas s�o usadas para "
"permitir atualiza��es consistentes de r�tulos de seguran�a em vnodes - "
"atualmente este suporte est� presente apenas No sistema de arquivos UFS2, os "
"autores de pol�ticas podem optar por implementar r�tulos de objeto de "
"sistema de arquivos multilabel usando um (ou mais) atributos estendidos.Por "
"raz�es de efici�ncia, o r�tulo vnode ( <literal> v_label </literal> ) � um "
"cache de qualquer r�tulo no disco; as pol�ticas podem carregar valores no "
"cache quando o vnode � instanciado e atualizar o cache conforme necess�rio. "
"Como resultado, o atributo estendido n�o precisa ser acessado diretamente "
"com todas as verifica��es de controle de acesso. "

#. (itstool) path: note/para
#: book.translate.xml:4791
#, fuzzy
msgid ""
"Currently, if a labeled policy permits dynamic unloading, its state slot "
"cannot be reclaimed, which places a strict (and relatively low) bound on the "
"number of unload-reload operations for labeled policies."
msgstr ""
"Atualmente, se uma pol�tica rotulada permite descarregamento din�mico, seu "
"slot de estado n�o pode ser recuperado, o que coloca um limite estrito (e "
"relativamente baixo) no n�mero de opera��es de descarregamento para "
"pol�ticas rotuladas."

#. (itstool) path: sect2/title
#: book.translate.xml:4799
#, fuzzy
msgid "System Calls"
msgstr "Chamadas do sistema"

#. (itstool) path: sect2/para
#: book.translate.xml:4801
#, fuzzy
msgid ""
"The MAC Framework implements a number of system calls: most of these calls "
"support the policy-agnostic label retrieval and manipulation APIs exposed to "
"user applications."
msgstr ""
"O MAC Framework implementa v�rias chamadas de sistema: a maioria dessas "
"chamadas suporta APIs de recupera��o e manipula��o de etiquetas agn�sticas "
"de pol�ticas expostas a aplicativos de usu�rios."

#. (itstool) path: sect2/para
#: book.translate.xml:4806
#, fuzzy
msgid ""
"The label management calls accept a label description structure, <varname "
"remap=\"structname\">struct mac</varname>, which contains a series of MAC "
"label elements. Each element contains a character string name, and character "
"string value. Each policy will be given the chance to claim a particular "
"element name, permitting policies to expose multiple independent elements if "
"desired. Policy modules perform the internalization and externalization "
"between kernel labels and user-provided labels via entry points, permitting "
"a variety of semantics. Label management system calls are generally wrapped "
"by user library functions to perform memory allocation and error handling, "
"simplifying user applications that must manage labels."
msgstr ""
"As chamadas de gerenciamento de etiquetas aceitam uma estrutura de descri��o "
"de r�tulo, <varname remap=\"structname\"> struct mac </varname> , que cont�m "
"uma s�rie de elementos de r�tulo MAC. Cada elemento cont�m um nome de cadeia "
"de caracteres e um valor de cadeia de caracteres. Cada pol�tica ter� a "
"chance de reivindicar um determinado nome de elemento, permitindo que as "
"pol�ticas exponham v�rios elementos independentes, se desejado. Os m�dulos "
"de pol�tica executam a internaliza��o e a externaliza��o entre os r�tulos do "
"kernel e os r�tulos fornecidos pelo usu�rio por meio de pontos de entrada, "
"permitindo uma variedade de sem�nticas. As chamadas do sistema de "
"gerenciamento de r�tulos geralmente s�o agrupadas por fun��es da biblioteca "
"do usu�rio para executar aloca��o de mem�ria e tratamento de erros, "
"simplificando os aplicativos do usu�rio que devem gerenciar r�tulos. "

#. (itstool) path: sect2/para
#: book.translate.xml:4820
#, fuzzy
msgid ""
"The following MAC-related system calls are present in the FreeBSD kernel:"
msgstr ""
"As seguintes chamadas do sistema relacionadas ao MAC est�o presentes no "
"kernel do FreeBSD:"

#. (itstool) path: listitem/para
#: book.translate.xml:4825
#, fuzzy
msgid ""
"<function>mac_get_proc()</function> may be used to retrieve the label of the "
"current process."
msgstr ""
" <function> mac_get_proc () </function> pode ser usado para recuperar o "
"r�tulo do processo atual. "

#. (itstool) path: listitem/para
#: book.translate.xml:4830
#, fuzzy
msgid ""
"<function>mac_set_proc()</function> may be used to request a change in the "
"label of the current process."
msgstr ""
" <function> mac_set_proc () </function> pode ser usado para solicitar uma "
"altera��o no r�tulo do processo atual. "

#. (itstool) path: listitem/para
#: book.translate.xml:4836
#, fuzzy
msgid ""
"<function>mac_get_fd()</function> may be used to retrieve the label of an "
"object (file, socket, pipe, ...) referenced by a file descriptor."
msgstr ""
" <function> mac_get_fd () </function> pode ser usado para recuperar o r�tulo "
"de um objeto (arquivo, socket, pipe, ...) referenciado por um descritor de "
"arquivo. "

#. (itstool) path: listitem/para
#: book.translate.xml:4842
#, fuzzy
msgid ""
"<function>mac_get_file()</function> may be used to retrieve the label of an "
"object referenced by a file system path."
msgstr ""
" <function> mac_get_file () </function> pode ser usado para recuperar o "
"r�tulo de um objeto referenciado por um caminho do sistema de arquivos. "

#. (itstool) path: listitem/para
#: book.translate.xml:4848
#, fuzzy
msgid ""
"<function>mac_set_fd()</function> may be used to request a change in the "
"label of an object (file, socket, pipe, ...) referenced by a file descriptor."
msgstr ""
" <function> mac_set_fd () </function> pode ser usado para solicitar uma "
"altera��o no r�tulo de um objeto (arquivo, socket, pipe, ...) referenciado "
"por um descritor de arquivo. "

#. (itstool) path: listitem/para
#: book.translate.xml:4854
#, fuzzy
msgid ""
"<function>mac_set_file()</function> may be used to request a change in the "
"label of an object referenced by a file system path."
msgstr ""
" <function> mac_set_file () </function> pode ser usado para solicitar uma "
"altera��o no r�tulo de um objeto referenciado por um caminho do sistema de "
"arquivos. "

#. (itstool) path: listitem/para
#: book.translate.xml:4860
#, fuzzy
msgid ""
"<function>mac_syscall()</function> permits policy modules to create new "
"system calls without modifying the system call table; it accepts a target "
"policy name, operation number, and opaque argument for use by the policy."
msgstr ""
" <function> mac_syscall () </function> permite que os m�dulos de pol�tica "
"criem novas chamadas do sistema sem modificar a tabela de chamadas do "
"sistema; aceita um nome de pol�tica de destino, n�mero de opera��o e "
"argumento opaco para uso pela pol�tica. "

#. (itstool) path: listitem/para
#: book.translate.xml:4868
#, fuzzy
msgid ""
"<function>mac_get_pid()</function> may be used to request the label of "
"another process by process id."
msgstr ""
" <function> mac_get_pid () </function> pode ser usado para solicitar o "
"r�tulo de outro processo pelo id do processo. "

#. (itstool) path: listitem/para
#: book.translate.xml:4873
#, fuzzy
msgid ""
"<function>mac_get_link()</function> is identical to "
"<function>mac_get_file()</function>, only it will not follow a symbolic link "
"if it is the final entry in the path, so may be used to retrieve the label "
"on a symlink."
msgstr ""
" <function> mac_get_link () </function> � id�ntico a <function> mac_get_file "
"() </function> , s� n�o seguir� um link simb�lico se for a entrada final no "
"caminho, ent�o pode ser usado para recuperar o r�tulo em um symlink. "

#. (itstool) path: listitem/para
#: book.translate.xml:4881
#, fuzzy
msgid ""
"<function>mac_set_link()</function> is identical to "
"<function>mac_set_file()</function>, only it will not follow a symbolic link "
"if it is the final entry in a path, so may be used to manipulate the label "
"on a symlink."
msgstr ""
" <function> mac_set_link () </function> � id�ntico a <function> mac_set_file "
"() </function> , s� n�o seguir� um link simb�lico se for a entrada final em "
"um caminho, ent�o pode ser usado para manipular o r�tulo em um symlink \""

#. (itstool) path: listitem/para
#: book.translate.xml:4889
#, fuzzy
msgid ""
"<function>mac_execve()</function> is identical to the <function>execve()</"
"function> system call, only it also accepts a requested label to set the "
"process label to when beginning execution of a new program. This change in "
"label on execution is referred to as a \"transition\"."
msgstr ""
" <function> mac_execve () </function> � id�ntico ao <function> execve () </"
"function> chamada de sistema, s� que tamb�m aceita um r�tulo solicitado para "
"definir o r�tulo do processo ao iniciar a execu��o de um novo programa. Esta "
"mudan�a na etiqueta na execu��o � referida como \\ \"transi��o \". "

#. (itstool) path: listitem/para
#: book.translate.xml:4898
#, fuzzy
msgid ""
"<function>mac_get_peer()</function>, actually implemented via a socket "
"option, retrieves the label of a remote peer on a socket, if available."
msgstr ""
" <function> mac_get_peer () </function> , na verdade, implementado por meio "
"de uma op��o de soquete, recupera o r�tulo de um ponto remoto em um soquete, "
"se dispon�vel. "

#. (itstool) path: sect2/para
#: book.translate.xml:4904
#, fuzzy
msgid ""
"In addition to these system calls, the <literal>SIOCSIGMAC</literal> and "
"<literal>SIOCSIFMAC</literal> network interface ioctls permit the labels on "
"network interfaces to be retrieved and set."
msgstr ""
"Al�m dessas chamadas de sistema, o <literal> SIOCSIGMAC </literal> e "
"<literal> SIOCSIFMAC </literal> Os ioctls da interface de rede permitem que "
"os r�tulos nas interfaces de rede sejam recuperados e definidos. "

#. (itstool) path: sect1/title
#: book.translate.xml:4913
#, fuzzy
msgid "MAC Policy Architecture"
msgstr "Arquitetura de pol�ticas MAC"

#. (itstool) path: sect1/para
#: book.translate.xml:4915
#, fuzzy
msgid ""
"Security policies are either linked directly into the kernel, or compiled "
"into loadable kernel modules that may be loaded at boot, or dynamically "
"using the module loading system calls at runtime. Policy modules interact "
"with the system through a set of declared entry points, providing access to "
"a stream of system events and permitting the policy to influence access "
"control decisions. Each policy contains a number of elements:"
msgstr ""
"As pol�ticas de seguran�a s�o ligadas diretamente ao kernel ou compiladas em "
"m�dulos do kernel carreg�veis ​​que podem ser carregados na inicializa��o ou "
"dinamicamente usando o m�dulo carregando chamadas do sistema em tempo de "
"execu��o. M�dulos de pol�ticas interagem com o sistema atrav�s de um "
"conjunto de pontos de entrada declarados, fornecendo acesso a um fluxo de "
"eventos do sistema e permitindo que a pol�tica influencie as decis�es de "
"controle de acesso. Cada pol�tica cont�m v�rios elementos: "

#. (itstool) path: listitem/para
#: book.translate.xml:4926
#, fuzzy
msgid "Optional configuration parameters for policy."
msgstr "Par�metros de configura��o opcionais para pol�tica."

#. (itstool) path: listitem/para
#: book.translate.xml:4930
#, fuzzy
msgid "Centralized implementation of the policy logic and parameters."
msgstr "Implementa��o centralizada da l�gica e par�metros da pol�tica."

#. (itstool) path: listitem/para
#: book.translate.xml:4934
#, fuzzy
msgid ""
"Optional implementation of policy life cycle events, such as initialization "
"and destruction."
msgstr ""
"Implementa��o opcional de eventos do ciclo de vida da pol�tica, como "
"inicializa��o e destrui��o."

#. (itstool) path: listitem/para
#: book.translate.xml:4938
#, fuzzy
msgid ""
"Optional support for initializing, maintaining, and destroying labels on "
"selected kernel objects."
msgstr ""
"Suporte opcional para inicializar, manter e destruir r�tulos em objetos de "
"kernel selecionados."

#. (itstool) path: listitem/para
#: book.translate.xml:4943
#, fuzzy
msgid ""
"Optional support for user process inspection and modification of labels on "
"selected objects."
msgstr ""
"Suporte opcional para inspe��o de processo do usu�rio e modifica��o de "
"r�tulos em objetos selecionados."

#. (itstool) path: listitem/para
#: book.translate.xml:4948
#, fuzzy
msgid ""
"Implementation of selected access control entry points that are of interest "
"to the policy."
msgstr ""
"Implementa��o de pontos de entrada de controle de acesso selecionados que "
"s�o de interesse para a pol�tica."

#. (itstool) path: listitem/para
#: book.translate.xml:4952
#, fuzzy
msgid ""
"Declaration of policy identity, module entry points, and policy properties."
msgstr ""
"Declara��o de identidade de pol�tica, pontos de entrada de m�dulo e "
"propriedades de pol�tica."

#. (itstool) path: sect2/title
#: book.translate.xml:4958
#, fuzzy
msgid "Policy Declaration"
msgstr "Declara��o de pol�tica"

#. (itstool) path: sect2/para
#: book.translate.xml:4960
#, fuzzy
msgid ""
"Modules may be declared using the <function>MAC_POLICY_SET()</function> "
"macro, which names the policy, provides a reference to the MAC entry point "
"vector, provides load-time flags determining how the policy framework should "
"handle the policy, and optionally requests the allocation of label state by "
"the framework."
msgstr ""
"Os m�dulos podem ser declarados usando o <function> MAC_POLICY_SET () </"
"function> macro, que nomeia a pol�tica, fornece uma refer�ncia ao vetor de "
"ponto de entrada MAC, fornece sinalizadores de tempo de carregamento "
"determinando como a estrutura de pol�tica deve manipular a pol�tica e, "
"opcionalmente, solicita a aloca��o do estado do r�tulo pela estrutura. "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:4967
#, no-wrap
msgid ""
"static struct mac_policy_ops mac_<replaceable>policy</replaceable>_ops =\n"
"{\n"
"        .mpo_destroy = mac_<replaceable>policy</replaceable>_destroy,\n"
"        .mpo_init = mac_<replaceable>policy</replaceable>_init,\n"
"        .mpo_init_bpfdesc_label = mac_<replaceable>policy</replaceable>_init_bpfdesc_label,\n"
"        .mpo_init_cred_label = mac_<replaceable>policy</replaceable>_init_label,\n"
"/* ... */\n"
"        .mpo_check_vnode_setutimes = mac_<replaceable>policy</replaceable>_check_vnode_setutimes,\n"
"        .mpo_check_vnode_stat = mac_<replaceable>policy</replaceable>_check_vnode_stat,\n"
"        .mpo_check_vnode_write = mac_<replaceable>policy</replaceable>_check_vnode_write,\n"
"};"
msgstr ""
"static struct mac_policy_ops mac_<replaceable>policy</replaceable>_ops =\n"
"{\n"
"        .mpo_destroy = mac_<replaceable>policy</replaceable>_destroy,\n"
"        .mpo_init = mac_<replaceable>policy</replaceable>_init,\n"
"        .mpo_init_bpfdesc_label = mac_<replaceable>policy</replaceable>_init_bpfdesc_label,\n"
"        .mpo_init_cred_label = mac_<replaceable>policy</replaceable>_init_label,\n"
"/* ... */\n"
"        .mpo_check_vnode_setutimes = mac_<replaceable>policy</replaceable>_check_vnode_setutimes,\n"
"        .mpo_check_vnode_stat = mac_<replaceable>policy</replaceable>_check_vnode_stat,\n"
"        .mpo_check_vnode_write = mac_<replaceable>policy</replaceable>_check_vnode_write,\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:4979
#, fuzzy
msgid ""
"The MAC policy entry point vector, <varname>mac_<replaceable>policy</"
"replaceable>_ops</varname> in this example, associates functions defined in "
"the module with specific entry points. A complete listing of available entry "
"points and their prototypes may be found in the MAC entry point reference "
"section. Of specific interest during module registration are the <symbol>."
"mpo_destroy</symbol> and <symbol>.mpo_init</symbol> entry points. <symbol>."
"mpo_init</symbol> will be invoked once a policy is successfully registered "
"with the module framework but prior to any other entry points becoming "
"active. This permits the policy to perform any policy-specific allocation "
"and initialization, such as initialization of any data or locks. <symbol>."
"mpo_destroy</symbol> will be invoked when a policy module is unloaded to "
"permit releasing of any allocated memory and destruction of locks. "
"Currently, these two entry points are invoked with the MAC policy list mutex "
"held to prevent any other entry points from being invoked: this will be "
"changed, but in the mean time, policies should be careful about what kernel "
"primitives they invoke so as to avoid lock ordering or sleeping problems."
msgstr ""
"O vetor do ponto de entrada da pol�tica MAC, <varname> Mac_ <replaceable> "
"pol�tica </replaceable> _ops </varname> neste exemplo, associa fun��es "
"definidas no m�dulo com pontos de entrada espec�ficos. Uma lista completa "
"dos pontos de entrada dispon�veis e seus prot�tipos podem ser encontrados na "
"se��o de refer�ncia do ponto de entrada MAC. De interesse espec�fico durante "
"o registro do m�dulo s�o os <symbol> .mpo_destroy </symbol> e <symbol> ."
"mpo_init </symbol> pontos de entrada. <symbol> .mpo_init </symbol> ser� "
"invocado assim que uma pol�tica for registrada com sucesso na estrutura do "
"m�dulo, mas antes de qualquer outro ponto de entrada se tornar ativo. Isso "
"permite que a pol�tica execute qualquer aloca��o e inicializa��o espec�ficas "
"da pol�tica, como a inicializa��o de quaisquer dados ou bloqueios. <symbol> ."
"mpo_destroy </symbol> ser� invocado quando um m�dulo de pol�tica for "
"descarregado para permitir a libera��o de qualquer mem�ria alocada e "
"destrui��o de bloqueios. Atualmente, esses dois pontos de entrada s�o "
"invocados com o mutex da lista de pol�ticas MAC mantido para evitar que "
"outros pontos de entrada sejam invocados: isso ser� alterado, mas nesse meio "
"tempo, as pol�ticas devem ter cuidado com as primitivas de kernel que "
"invocam para evitar bloquear pedidos ou problemas de sono. "

#. (itstool) path: sect2/para
#: book.translate.xml:5001
#, fuzzy
msgid ""
"The policy declaration's module name field exists so that the module may be "
"uniquely identified for the purposes of module dependencies. An appropriate "
"string should be selected. The full string name of the policy is displayed "
"to the user via the kernel log during load and unload events, and also "
"exported when providing status information to userland processes."
msgstr ""
"O campo de nome do m�dulo da declara��o de pol�tica existe para que o m�dulo "
"possa ser identificado exclusivamente para fins de depend�ncias do m�dulo. "
"Uma sequ�ncia apropriada deve ser selecionada. O nome completo da cadeia da "
"pol�tica � exibido ao usu�rio atrav�s do log do kernel durante o "
"carregamento e descarregamento eventos e tamb�m exportados ao fornecer "
"informa��es de status para os processos do usu�rio. "

#. (itstool) path: sect2/title
#: book.translate.xml:5011
#, fuzzy
msgid "Policy Flags"
msgstr "Bandeiras de Pol�ticas"

#. (itstool) path: sect2/para
#: book.translate.xml:5013
#, fuzzy
msgid ""
"The policy declaration flags field permits the module to provide the "
"framework with information about its capabilities at the time the module is "
"loaded. Currently, three flags are defined:"
msgstr ""
"O campo flags de declara��o de pol�tica permite que o m�dulo forne�a � "
"estrutura informa��es sobre suas capacidades no momento em que o m�dulo � "
"carregado. Atualmente, tr�s sinalizadores s�o definidos:"

#. (itstool) path: varlistentry/term
#: book.translate.xml:5020
#, fuzzy
msgid "MPC_LOADTIME_FLAG_UNLOADOK"
msgstr "MPC_LOADTIME_FLAG_UNLOADOK"

#. (itstool) path: listitem/para
#: book.translate.xml:5023
#, fuzzy
msgid ""
"This flag indicates that the policy module may be unloaded. If this flag is "
"not provided, then the policy framework will reject requests to unload the "
"module. This flag might be used by modules that allocate label state and are "
"unable to free that state at runtime."
msgstr ""
"Esse sinalizador indica que o m�dulo de pol�tica pode ser descarregado. Se "
"esse sinalizador n�o for fornecido, a estrutura de pol�tica rejeitar� "
"solicita��es para descarregar o m�dulo. Esse sinalizador pode ser usado por "
"m�dulos que alocam o estado de r�tulo e n�o conseguem liberar esse estado em "
"tempo de execu��o."

#. (itstool) path: varlistentry/term
#: book.translate.xml:5033
#, fuzzy
msgid "MPC_LOADTIME_FLAG_NOTLATE"
msgstr "MPC_LOADTIME_FLAG_NOTLATE"

#. (itstool) path: listitem/para
#: book.translate.xml:5036
#, fuzzy
msgid ""
"This flag indicates that the policy module must be loaded and initialized "
"early in the boot process. If the flag is specified, attempts to register "
"the module following boot will be rejected. The flag may be used by policies "
"that require pervasive labeling of all system objects, and cannot handle "
"objects that have not been properly initialized by the policy."
msgstr ""
"Este sinalizador indica que o m�dulo de pol�tica deve ser carregado e "
"inicializado no in�cio do processo de inicializa��o. Se o sinalizador for "
"especificado, tentativas de registrar o m�dulo ap�s a inicializa��o ser�o "
"rejeitadas. O sinalizador pode ser usado por pol�ticas que exigem rotulagem "
"abrangente de todo o sistema objetos e n�o podem manipular objetos que n�o "
"foram inicializados corretamente pela pol�tica. "

#. (itstool) path: varlistentry/term
#: book.translate.xml:5047
#, fuzzy
msgid "MPC_LOADTIME_FLAG_LABELMBUFS"
msgstr "MPC_LOADTIME_FLAG_LABELMBUFS"

#. (itstool) path: listitem/para
#: book.translate.xml:5050
#, fuzzy
msgid ""
"This flag indicates that the policy module requires labeling of Mbufs, and "
"that memory should always be allocated for the storage of Mbuf labels. By "
"default, the MAC Framework will not allocate label storage for Mbufs unless "
"at least one loaded policy has this flag set. This measurably improves "
"network performance when policies do not require Mbuf labeling. A kernel "
"option, <literal>MAC_ALWAYS_LABEL_MBUF</literal>, exists to force the MAC "
"Framework to allocate Mbuf label storage regardless of the setting of this "
"flag, and may be useful in some environments."
msgstr ""
"Este sinalizador indica que o m�dulo de pol�tica requer rotulagem de Mbufs, "
"e essa mem�ria sempre deve ser alocada para o armazenamento de r�tulos Mbuf. "
"Por padr�o, o MAC Framework n�o alocar� armazenamento de r�tulo para Mbufs a "
"menos que pelo menos uma diretiva carregada tenha este sinalizador definido "
"Isso aumenta consideravelmente o desempenho da rede quando as pol�ticas n�o "
"exigem rotulagem Mbuf. <literal> MAC_ALWAYS_LABEL_MBUF </literal> existe "
"para for�ar o MAC Framework a alocar o armazenamento de r�tulos Mbuf, "
"independentemente da configura��o desse sinalizador, e pode ser �til em "
"alguns ambientes. "

#. (itstool) path: note/para
#: book.translate.xml:5066
#, fuzzy
msgid ""
"Policies using the <literal>MPC_LOADTIME_FLAG_LABELMBUFS</literal> without "
"the <literal>MPC_LOADTIME_FLAG_NOTLATE</literal> flag set must be able to "
"correctly handle <literal>NULL</literal> Mbuf label pointers passed into "
"entry points. This is necessary as in-flight Mbufs without label storage may "
"persist after a policy enabling Mbuf labeling has been loaded. If a policy "
"is loaded before the network subsystem is active (i.e., the policy is not "
"being loaded late), then all Mbufs are guaranteed to have label storage."
msgstr ""
"Pol�ticas usando o <literal> MPC_LOADTIME_FLAG_LABELMBUFS </literal> sem o "
"<literal> MPC_LOADTIME_FLAG_NOTLATE </literal> conjunto de sinalizadores "
"deve ser capaz de manipular corretamente <literal> NULO </literal> Ponteiros "
"de r�tulos Mbuf passados ​​para pontos de entrada. Isso � necess�rio, pois o "
"Mbufs em andamento sem armazenamento de r�tulo pode persistir ap�s uma "
"pol�tica que permite que o r�tulo Mbuf seja carregado. Se uma pol�tica for "
"carregada antes que o subsistema de rede esteja ativo (ou seja, a pol�tica "
"n�o esteja sendo carregada com atraso), todos os Mbufs ter�o garantia de "
"armazenamento de r�tulo. "

#. (itstool) path: sect2/title
#: book.translate.xml:5080
#, fuzzy
msgid "Policy Entry Points"
msgstr "Pontos de Entrada de Pol�ticas"

#. (itstool) path: sect2/para
#: book.translate.xml:5082
#, fuzzy
msgid ""
"Four classes of entry points are offered to policies registered with the "
"framework: entry points associated with the registration and management of "
"policies, entry points denoting initialization, creation, destruction, and "
"other life cycle events for kernel objects, events associated with access "
"control decisions that the policy module may influence, and calls associated "
"with the management of labels on objects. In addition, a "
"<function>mac_syscall()</function> entry point is provided so that policies "
"may extend the kernel interface without registering new system calls."
msgstr ""
"Quatro classes de pontos de entrada s�o oferecidas a pol�ticas registradas "
"no framework: pontos de entrada associados ao registro e gerenciamento de "
"pol�ticas, pontos de entrada denotando inicializa��o, cria��o, destrui��o e "
"outros eventos de ciclo de vida para objetos do kernel, eventos associados a "
"decis�es de controle de acesso que o m�dulo de pol�tica pode influenciar e "
"as chamadas associadas ao gerenciamento de r�tulos em objetos. <function> "
"mac_syscall () </function> ponto de entrada � fornecido para que as "
"pol�ticas possam estender a interface do kernel sem registrar novas chamadas "
"do sistema. "

#. (itstool) path: sect2/para
#: book.translate.xml:5093
#, fuzzy
msgid ""
"Policy module writers should be aware of the kernel locking strategy, as "
"well as what object locks are available during which entry points. Writers "
"should attempt to avoid deadlock scenarios by avoiding grabbing non-leaf "
"locks inside of entry points, and also follow the locking protocol for "
"object access and modification. In particular, writers should be aware that "
"while necessary locks to access objects and their labels are generally held, "
"sufficient locks to modify an object or its label may not be present for all "
"entry points. Locking information for arguments is documented in the MAC "
"framework entry point document."
msgstr ""
"Os redatores de módulos de política devem estar cientes da estratégia de "
"bloqueio do kernel, bem como quais bloqueios de objeto estão disponíveis "
"durante os quais os pontos de entrada. Os escritores devem tentar evitar "
"cenários de impasse, evitando pegar bloqueios não-folha dentro de pontos de "
"entrada, e também seguir o protocolo de bloqueio para acesso e modificação "
"de objetos. Em particular, os escritores devem estar cientes de que, embora "
"bloqueios necessários para acessar objetos e seus rótulos sejam geralmente "
"mantidos, bloqueios suficientes para modificar um objeto ou seu rótulo podem "
"não estar presentes em todos os pontos de entrada. A informação de bloqueio "
"para argumentos é documentada no documento do ponto de entrada da estrutura "
"MAC."

#. (itstool) path: sect2/para
#: book.translate.xml:5105
#, fuzzy
msgid ""
"Policy entry points will pass a reference to the object label along with the "
"object itself. This permits labeled policies to be unaware of the internals "
"of the object yet still make decisions based on the label. The exception to "
"this is the process credential, which is assumed to be understood by "
"policies as a first class security object in the kernel."
msgstr ""
"Os pontos de entrada da pol�tica passar�o uma refer�ncia ao r�tulo do objeto "
"junto com o pr�prio objeto. Isso permite que as pol�ticas rotuladas n�o "
"estejam cientes dos componentes internos do objeto e ainda tomem decis�es "
"com base no r�tulo. A exce��o a isso � a credencial do processo, que � "
"assumido como sendo entendido pelas pol�ticas como um objeto de seguran�a de "
"primeira classe no kernel. "

#. (itstool) path: sect1/title
#: book.translate.xml:5116
#, fuzzy
msgid "MAC Policy Entry Point Reference"
msgstr "Refer�ncia do Ponto de Entrada da Pol�tica MAC"

#. (itstool) path: sect2/title
#: book.translate.xml:5119
#, fuzzy
msgid "General-Purpose Module Entry Points"
msgstr "Pontos de Entrada do M�dulo de Finalidade Geral"

#. (itstool) path: sect3/title
#: book.translate.xml:5122
#, fuzzy
msgid "<function>mpo_init</function>"
msgstr " <function> mpo_init </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5125
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init</function></funcdef> <paramdef>struct "
"mac_policy_conf *<parameter>conf</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init </function></funcdef><paramdef> struct "
"mac_policy_conf * <parameter> conf </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5143 book.translate.xml:5189 book.translate.xml:5232
#: book.translate.xml:5300 book.translate.xml:5364 book.translate.xml:5406
#: book.translate.xml:5448 book.translate.xml:5490 book.translate.xml:5533
#: book.translate.xml:5591 book.translate.xml:5651 book.translate.xml:5700
#: book.translate.xml:5742 book.translate.xml:5785 book.translate.xml:5836
#: book.translate.xml:5886 book.translate.xml:5929 book.translate.xml:5971
#: book.translate.xml:6015 book.translate.xml:6059 book.translate.xml:6103
#: book.translate.xml:6147 book.translate.xml:6191 book.translate.xml:6235
#: book.translate.xml:6281 book.translate.xml:6331 book.translate.xml:6375
#: book.translate.xml:6419 book.translate.xml:6462 book.translate.xml:6505
#: book.translate.xml:6551 book.translate.xml:6600 book.translate.xml:6649
#: book.translate.xml:6700 book.translate.xml:6777 book.translate.xml:6854
#: book.translate.xml:6931 book.translate.xml:7007 book.translate.xml:7084
#: book.translate.xml:7161 book.translate.xml:7236 book.translate.xml:7311
#: book.translate.xml:7386 book.translate.xml:7461 book.translate.xml:7617
#: book.translate.xml:7696 book.translate.xml:7766 book.translate.xml:7829
#: book.translate.xml:7891 book.translate.xml:7958 book.translate.xml:8041
#: book.translate.xml:8130 book.translate.xml:8196 book.translate.xml:8245
#: book.translate.xml:8311 book.translate.xml:8378 book.translate.xml:8455
#: book.translate.xml:8521 book.translate.xml:8579 book.translate.xml:8640
#: book.translate.xml:8706 book.translate.xml:8771 book.translate.xml:8837
#: book.translate.xml:8902 book.translate.xml:8972 book.translate.xml:9030
#: book.translate.xml:9087 book.translate.xml:9153 book.translate.xml:9219
#: book.translate.xml:9285 book.translate.xml:9353 book.translate.xml:9421
#: book.translate.xml:9488 book.translate.xml:9557 book.translate.xml:9637
#: book.translate.xml:9706 book.translate.xml:9783 book.translate.xml:9850
#: book.translate.xml:9917 book.translate.xml:9973 book.translate.xml:10050
#: book.translate.xml:10113 book.translate.xml:10155 book.translate.xml:10199
#: book.translate.xml:10314 book.translate.xml:10378 book.translate.xml:10421
#: book.translate.xml:10470 book.translate.xml:10518 book.translate.xml:10569
#: book.translate.xml:10622 book.translate.xml:10665 book.translate.xml:10714
#: book.translate.xml:10781 book.translate.xml:10838 book.translate.xml:10897
#: book.translate.xml:10960 book.translate.xml:11018 book.translate.xml:11077
#: book.translate.xml:11139 book.translate.xml:11208 book.translate.xml:11266
#: book.translate.xml:11322 book.translate.xml:11383 book.translate.xml:11439
#: book.translate.xml:11504 book.translate.xml:11565 book.translate.xml:11620
#: book.translate.xml:11685 book.translate.xml:11750 book.translate.xml:11811
#: book.translate.xml:11881 book.translate.xml:11943 book.translate.xml:12005
#: book.translate.xml:12087 book.translate.xml:12174 book.translate.xml:12243
#: book.translate.xml:12308 book.translate.xml:12381 book.translate.xml:12467
#: book.translate.xml:12543 book.translate.xml:12607 book.translate.xml:12667
#: book.translate.xml:12726 book.translate.xml:12795 book.translate.xml:12877
#: book.translate.xml:12960 book.translate.xml:13020 book.translate.xml:13088
#: book.translate.xml:13151 book.translate.xml:13213 book.translate.xml:13279
#: book.translate.xml:13345 book.translate.xml:13423 book.translate.xml:13509
#: book.translate.xml:13577 book.translate.xml:13646 book.translate.xml:13718
#: book.translate.xml:13788 book.translate.xml:13845 book.translate.xml:13906
#: book.translate.xml:13974 book.translate.xml:14050 book.translate.xml:14123
#: book.translate.xml:14188 book.translate.xml:14242 book.translate.xml:14285
#: book.translate.xml:14333 book.translate.xml:14379 book.translate.xml:14440
#, fuzzy
msgid "Parameter"
msgstr "Par�metro"

#. (itstool) path: row/entry
#: book.translate.xml:5144 book.translate.xml:5190 book.translate.xml:5233
#: book.translate.xml:5301 book.translate.xml:5365 book.translate.xml:5407
#: book.translate.xml:5449 book.translate.xml:5491 book.translate.xml:5534
#: book.translate.xml:5592 book.translate.xml:5652 book.translate.xml:5701
#: book.translate.xml:5743 book.translate.xml:5786 book.translate.xml:5837
#: book.translate.xml:5887 book.translate.xml:5930 book.translate.xml:5972
#: book.translate.xml:6016 book.translate.xml:6060 book.translate.xml:6104
#: book.translate.xml:6148 book.translate.xml:6192 book.translate.xml:6236
#: book.translate.xml:6282 book.translate.xml:6332 book.translate.xml:6376
#: book.translate.xml:6420 book.translate.xml:6463 book.translate.xml:6506
#: book.translate.xml:6552 book.translate.xml:6601 book.translate.xml:6650
#: book.translate.xml:6701 book.translate.xml:6778 book.translate.xml:6855
#: book.translate.xml:6932 book.translate.xml:7008 book.translate.xml:7085
#: book.translate.xml:7162 book.translate.xml:7237 book.translate.xml:7312
#: book.translate.xml:7387 book.translate.xml:7462 book.translate.xml:7618
#: book.translate.xml:7697 book.translate.xml:7767 book.translate.xml:7830
#: book.translate.xml:7892 book.translate.xml:7959 book.translate.xml:8042
#: book.translate.xml:8131 book.translate.xml:8197 book.translate.xml:8246
#: book.translate.xml:8312 book.translate.xml:8379 book.translate.xml:8456
#: book.translate.xml:8522 book.translate.xml:8580 book.translate.xml:8641
#: book.translate.xml:8707 book.translate.xml:8772 book.translate.xml:8838
#: book.translate.xml:8903 book.translate.xml:8973 book.translate.xml:9031
#: book.translate.xml:9088 book.translate.xml:9154 book.translate.xml:9220
#: book.translate.xml:9286 book.translate.xml:9354 book.translate.xml:9422
#: book.translate.xml:9489 book.translate.xml:9558 book.translate.xml:9638
#: book.translate.xml:9707 book.translate.xml:9784 book.translate.xml:9851
#: book.translate.xml:9918 book.translate.xml:9974 book.translate.xml:10051
#: book.translate.xml:10114 book.translate.xml:10156 book.translate.xml:10200
#: book.translate.xml:10315 book.translate.xml:10379 book.translate.xml:10422
#: book.translate.xml:10471 book.translate.xml:10519 book.translate.xml:10570
#: book.translate.xml:10623 book.translate.xml:10666 book.translate.xml:10715
#: book.translate.xml:10782 book.translate.xml:10839 book.translate.xml:10898
#: book.translate.xml:10961 book.translate.xml:11019 book.translate.xml:11078
#: book.translate.xml:11140 book.translate.xml:11209 book.translate.xml:11267
#: book.translate.xml:11323 book.translate.xml:11384 book.translate.xml:11440
#: book.translate.xml:11505 book.translate.xml:11566 book.translate.xml:11621
#: book.translate.xml:11686 book.translate.xml:11751 book.translate.xml:11812
#: book.translate.xml:11882 book.translate.xml:11944 book.translate.xml:12006
#: book.translate.xml:12088 book.translate.xml:12175 book.translate.xml:12244
#: book.translate.xml:12309 book.translate.xml:12382 book.translate.xml:12468
#: book.translate.xml:12544 book.translate.xml:12608 book.translate.xml:12668
#: book.translate.xml:12727 book.translate.xml:12796 book.translate.xml:12878
#: book.translate.xml:12961 book.translate.xml:13021 book.translate.xml:13089
#: book.translate.xml:13152 book.translate.xml:13214 book.translate.xml:13280
#: book.translate.xml:13346 book.translate.xml:13424 book.translate.xml:13510
#: book.translate.xml:13578 book.translate.xml:13647 book.translate.xml:13719
#: book.translate.xml:13789 book.translate.xml:13846 book.translate.xml:13907
#: book.translate.xml:13975 book.translate.xml:14051 book.translate.xml:14124
#: book.translate.xml:14189 book.translate.xml:14243 book.translate.xml:14286
#: book.translate.xml:14334 book.translate.xml:14380 book.translate.xml:14441
#, fuzzy
msgid "Description"
msgstr "Descri��o"

#. (itstool) path: row/entry
#: book.translate.xml:5145 book.translate.xml:5191 book.translate.xml:5234
#: book.translate.xml:5302 book.translate.xml:5366 book.translate.xml:5408
#: book.translate.xml:5450 book.translate.xml:5492 book.translate.xml:5535
#: book.translate.xml:5593 book.translate.xml:5653 book.translate.xml:5702
#: book.translate.xml:5744 book.translate.xml:5787 book.translate.xml:5838
#: book.translate.xml:5888 book.translate.xml:5931 book.translate.xml:5973
#: book.translate.xml:6017 book.translate.xml:6061 book.translate.xml:6105
#: book.translate.xml:6149 book.translate.xml:6193 book.translate.xml:6237
#: book.translate.xml:6283 book.translate.xml:6333 book.translate.xml:6377
#: book.translate.xml:6421 book.translate.xml:6464 book.translate.xml:6507
#: book.translate.xml:6553 book.translate.xml:6602 book.translate.xml:6651
#: book.translate.xml:6702 book.translate.xml:6779 book.translate.xml:6856
#: book.translate.xml:6933 book.translate.xml:7009 book.translate.xml:7086
#: book.translate.xml:7163 book.translate.xml:7238 book.translate.xml:7313
#: book.translate.xml:7388 book.translate.xml:7463 book.translate.xml:7619
#: book.translate.xml:7698 book.translate.xml:7768 book.translate.xml:7831
#: book.translate.xml:7893 book.translate.xml:7960 book.translate.xml:8043
#: book.translate.xml:8132 book.translate.xml:8198 book.translate.xml:8247
#: book.translate.xml:8313 book.translate.xml:8380 book.translate.xml:8457
#: book.translate.xml:8523 book.translate.xml:8581 book.translate.xml:8642
#: book.translate.xml:8708 book.translate.xml:8773 book.translate.xml:8839
#: book.translate.xml:8904 book.translate.xml:8974 book.translate.xml:9032
#: book.translate.xml:9089 book.translate.xml:9155 book.translate.xml:9221
#: book.translate.xml:9287 book.translate.xml:9355 book.translate.xml:9423
#: book.translate.xml:9490 book.translate.xml:9559 book.translate.xml:9639
#: book.translate.xml:9708 book.translate.xml:9785 book.translate.xml:9852
#: book.translate.xml:9919 book.translate.xml:9975 book.translate.xml:10052
#: book.translate.xml:10115 book.translate.xml:10157 book.translate.xml:10201
#: book.translate.xml:10316 book.translate.xml:10380 book.translate.xml:10423
#: book.translate.xml:10472 book.translate.xml:10520 book.translate.xml:10571
#: book.translate.xml:10624 book.translate.xml:10667 book.translate.xml:10716
#: book.translate.xml:10783 book.translate.xml:10840 book.translate.xml:10899
#: book.translate.xml:10962 book.translate.xml:11020 book.translate.xml:11079
#: book.translate.xml:11141 book.translate.xml:11210 book.translate.xml:11268
#: book.translate.xml:11324 book.translate.xml:11385 book.translate.xml:11441
#: book.translate.xml:11506 book.translate.xml:11567 book.translate.xml:11622
#: book.translate.xml:11687 book.translate.xml:11752 book.translate.xml:11813
#: book.translate.xml:11883 book.translate.xml:11945 book.translate.xml:12007
#: book.translate.xml:12089 book.translate.xml:12176 book.translate.xml:12245
#: book.translate.xml:12310 book.translate.xml:12383 book.translate.xml:12469
#: book.translate.xml:12545 book.translate.xml:12609 book.translate.xml:12669
#: book.translate.xml:12728 book.translate.xml:12797 book.translate.xml:12879
#: book.translate.xml:12962 book.translate.xml:13022 book.translate.xml:13090
#: book.translate.xml:13153 book.translate.xml:13215 book.translate.xml:13281
#: book.translate.xml:13347 book.translate.xml:13425 book.translate.xml:13511
#: book.translate.xml:13579 book.translate.xml:13648 book.translate.xml:13720
#: book.translate.xml:13790 book.translate.xml:13847 book.translate.xml:13908
#: book.translate.xml:13976 book.translate.xml:14052 book.translate.xml:14125
#: book.translate.xml:14190 book.translate.xml:14244 book.translate.xml:14287
#: book.translate.xml:14335 book.translate.xml:14381 book.translate.xml:14442
#, fuzzy
msgid "Locking"
msgstr "Bloqueio"

#. (itstool) path: row/entry
#: book.translate.xml:5152 book.translate.xml:5198
#, fuzzy
msgid "<parameter>conf</parameter>"
msgstr " <parameter> conf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:5153 book.translate.xml:5199
#, fuzzy
msgid "MAC policy definition"
msgstr "Defini��o de pol�tica MAC"

#. (itstool) path: sect3/para
#: book.translate.xml:5159
#, fuzzy
msgid ""
"Policy load event. The policy list mutex is held, so sleep operations cannot "
"be performed, and calls out to other kernel subsystems must be made with "
"caution. If potentially sleeping memory allocations are required during "
"policy initialization, they should be made using a separate module SYSINIT()."
msgstr ""
"Evento de carregamento da pol�tica. O mutex da lista de pol�ticas � retido, "
"portanto opera��es de suspens�o n�o podem ser executadas e chamadas para "
"outros subsistemas do kernel devem ser feitas com cautela. Se aloca��es de "
"mem�ria potencialmente suspensas forem necess�rias durante a inicializa��o "
"da pol�tica, elas devem ser feitas usando m�dulo SYSINIT (). "

#. (itstool) path: sect3/title
#: book.translate.xml:5168
#, fuzzy
msgid "<function>mpo_destroy</function>"
msgstr " <function> mpo_destroy </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5171
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy</function></funcdef> <paramdef>struct "
"mac_policy_conf *<parameter>conf</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy </function></funcdef><paramdef> "
"struct mac_policy_conf * <parameter> conf </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:5205
#, fuzzy
msgid ""
"Policy load event. The policy list mutex is held, so caution should be "
"applied."
msgstr ""
"Evento de carregamento da pol�tica. O mutex da lista de pol�ticas � mantido, "
"portanto, cuidado deve ser aplicado."

#. (itstool) path: sect3/title
#: book.translate.xml:5210
#, fuzzy
msgid "<function>mpo_syscall</function>"
msgstr " <function> mpo_syscall </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5213
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_syscall</function></funcdef> <paramdef>struct "
"thread *<parameter>td</parameter></paramdef> <paramdef>int <parameter>call</"
"parameter></paramdef> <paramdef>void *<parameter>arg</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_syscall </function></funcdef><paramdef> thread "
"de estrutura * <parameter> td </parameter></paramdef><paramdef> int "
"<parameter> ligar </parameter></paramdef><paramdef> void * <parameter> arg </"
"parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5241 book.translate.xml:5309
#, fuzzy
msgid "<parameter>td</parameter>"
msgstr " <parameter> por exemplo, </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:5242
#, fuzzy
msgid "Calling thread"
msgstr "Chamada de discuss�o"

#. (itstool) path: row/entry
#: book.translate.xml:5246
#, fuzzy
msgid "<parameter>call</parameter>"
msgstr " <parameter> ligar </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:5247
#, fuzzy
msgid "Policy-specific syscall number"
msgstr "N�mero de syscall espec�fico da pol�tica"

#. (itstool) path: row/entry
#: book.translate.xml:5251
#, fuzzy
msgid "<parameter>arg</parameter>"
msgstr " <parameter> arg </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:5252
#, fuzzy
msgid "Pointer to syscall arguments"
msgstr "Ponteiro para argumentos syscall"

#. (itstool) path: sect3/para
#: book.translate.xml:5258
#, fuzzy
msgid ""
"This entry point provides a policy-multiplexed system call so that policies "
"may provide additional services to user processes without registering "
"specific system calls. The policy name provided during registration is used "
"to demux calls from userland, and the arguments will be forwarded to this "
"entry point. When implementing new services, security modules should be sure "
"to invoke appropriate access control checks from the MAC framework as "
"needed. For example, if a policy implements an augmented signal "
"functionality, it should call the necessary signal access control checks to "
"invoke the MAC framework and other registered policies."
msgstr ""
"Esse ponto de entrada fornece uma chamada de sistema multiplexada por "
"pol�tica para que as pol�ticas possam fornecer servi�os adicionais aos "
"processos do usu�rio sem registrar chamadas espec�ficas do sistema. O nome "
"da pol�tica fornecido durante o registro � usado para desmobilizar chamadas "
"de usu�rios e os argumentos ser�o encaminhados para essa entrada. Ao "
"implementar novos servi�os, os m�dulos de seguran�a devem invocar as "
"verifica��es de controle de acesso apropriadas da estrutura do MAC, conforme "
"necess�rio.Por exemplo, se uma pol�tica implementa uma funcionalidade de "
"sinal aumentada, ela deve chamar as verifica��es de controle de acesso de "
"sinal necess�rias para invocar o MAC. estrutura e outras pol�ticas "
"registradas. "

#. (itstool) path: note/para
#: book.translate.xml:5272
#, fuzzy
msgid ""
"Modules must currently perform the <function>copyin()</function> of the "
"syscall data on their own."
msgstr ""
"Os m�dulos devem atualmente executar o <function> copyin () </function> dos "
"dados syscall por conta pr�pria. "

#. (itstool) path: sect3/title
#: book.translate.xml:5279
#, fuzzy
msgid "<function>mpo_thread_userret</function>"
msgstr " <function> mpo_thread_userret </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5282
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_thread_userret</function></funcdef> "
"<paramdef>struct thread *<parameter>td</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_thread_userret </function></"
"funcdef><paramdef> thread de estrutura * <parameter> td </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5310
#, fuzzy
msgid "Returning thread"
msgstr "T�pico de retorno"

#. (itstool) path: sect3/para
#: book.translate.xml:5317
#, fuzzy
msgid ""
"This entry point permits policy modules to perform MAC-related events when a "
"thread returns to user space, via a system call return, trap return, or "
"otherwise. This is required for policies that have floating process labels, "
"as it is not always possible to acquire the process lock at arbitrary points "
"in the stack during system call processing; process labels might represent "
"traditional authentication data, process history information, or other data. "
"To employ this mechanism, intended changes to the process credential label "
"may be stored in the <literal>p_label</literal> protected by a per-policy "
"spin lock, and then set the per-thread <literal>TDF_ASTPENDING</literal> "
"flag and per-process <literal>PS_MACPENDM</literal> flag to schedule a call "
"to the userret entry point. From this entry point, the policy may create a "
"replacement credential with less concern about the locking context. Policy "
"writers are cautioned that event ordering relating to scheduling an AST and "
"the AST being performed may be complex and interlaced in multithreaded "
"applications."
msgstr ""
"Esse ponto de entrada permite que os m�dulos de pol�tica executem eventos "
"relacionados ao MAC quando um encadeamento retorna ao espa�o do usu�rio, por "
"meio de um retorno de chamada do sistema, retorno de intercepta��o ou outro. "
"Isso � necess�rio para pol�ticas que possuem r�tulos de processo flutuantes, "
"pois nem sempre � poss�vel para adquirir o bloqueio de processo em pontos "
"arbitr�rios na pilha durante o processamento da chamada do sistema, os "
"r�tulos de processo podem representar dados de autentica��o tradicionais, "
"informa��es do hist�rico de processos ou outros dados. <literal> p_label </"
"literal> protegido por um bloqueio por rota��o por pol�tica e, em seguida, "
"defina o <literal> TDF_ASTPENDING </literal> bandeira e por processo "
"<literal> PS_MACPENDM </literal> flag para agendar uma chamada para o ponto "
"de entrada userret. A partir desse ponto de entrada, a pol�tica pode criar "
"uma credencial de substitui��o com menos preocupa��o sobre o contexto de "
"bloqueio. Escritores de pol�ticas s�o alertados que a ordena��o de eventos "
"relacionados ao planejamento de um AST e do AST sendo executado pode ser "
"complexa e entrela�ada em aplicativos multithread. "

#. (itstool) path: sect2/title
#: book.translate.xml:5340
#, fuzzy
msgid "Label Operations"
msgstr "Opera��es de etiqueta"

#. (itstool) path: sect3/title
#: book.translate.xml:5343
#, fuzzy
msgid "<function>mpo_init_bpfdesc_label</function>"
msgstr " <function> mpo_init_bpfdesc_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5346
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_bpfdesc_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_bpfdesc_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5373 book.translate.xml:5415 book.translate.xml:5457
#: book.translate.xml:5499 book.translate.xml:5542 book.translate.xml:5606
#: book.translate.xml:5709 book.translate.xml:5751 book.translate.xml:5794
#: book.translate.xml:5845 book.translate.xml:5895 book.translate.xml:5938
#: book.translate.xml:5980 book.translate.xml:6024 book.translate.xml:6068
#: book.translate.xml:6112 book.translate.xml:6156 book.translate.xml:6200
#: book.translate.xml:6244 book.translate.xml:6340 book.translate.xml:6428
#: book.translate.xml:6471 book.translate.xml:6514 book.translate.xml:6710
#: book.translate.xml:6787 book.translate.xml:6864 book.translate.xml:6941
#: book.translate.xml:7017 book.translate.xml:7094 book.translate.xml:7171
#: book.translate.xml:7246 book.translate.xml:7321 book.translate.xml:7396
#: book.translate.xml:7471 book.translate.xml:7849 book.translate.xml:8060
#: book.translate.xml:11830 book.translate.xml:12117 book.translate.xml:12195
#: book.translate.xml:12262 book.translate.xml:12327 book.translate.xml:12400
#: book.translate.xml:12497 book.translate.xml:12562 book.translate.xml:12625
#: book.translate.xml:12751 book.translate.xml:12825 book.translate.xml:12907
#: book.translate.xml:13107 book.translate.xml:13232 book.translate.xml:13298
#: book.translate.xml:13364 book.translate.xml:13442 book.translate.xml:13528
#: book.translate.xml:13596 book.translate.xml:13665 book.translate.xml:13737
#: book.translate.xml:13925
#, fuzzy
msgid "<parameter>label</parameter>"
msgstr " <parameter> r�tulo </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:5374 book.translate.xml:5458 book.translate.xml:5500
#: book.translate.xml:5543
#, fuzzy
msgid "New label to apply"
msgstr "Novo r�tulo para aplicar"

#. (itstool) path: sect3/para
#: book.translate.xml:5380
#, fuzzy
msgid ""
"Initialize the label on a newly instantiated bpfdesc (BPF descriptor). "
"Sleeping is permitted."
msgstr ""
"Inicialize o r�tulo em um bpfdesc rec�m-instanciado (descritor BPF). Dormir "
"� permitido."

#. (itstool) path: sect3/title
#: book.translate.xml:5385
#, fuzzy
msgid "<function>mpo_init_cred_label</function>"
msgstr " <function> mpo_init_cred_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5388
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_cred_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5416 book.translate.xml:5795 book.translate.xml:5846
#: book.translate.xml:5896 book.translate.xml:5939
#, fuzzy
msgid "New label to initialize"
msgstr "Novo r�tulo para inicializar"

#. (itstool) path: sect3/para
#: book.translate.xml:5422
#, fuzzy
msgid ""
"Initialize the label for a newly instantiated user credential. Sleeping is "
"permitted."
msgstr ""
"Inicialize o r�tulo para uma credencial de usu�rio rec�m-instanciada. A "
"suspens�o � permitida."

#. (itstool) path: sect3/title
#: book.translate.xml:5427
#, fuzzy
msgid "<function>mpo_init_devfsdirent_label</function>"
msgstr " <function> mpo_init_devfsdirent_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5430
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_devfsdirent_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_devfsdirent_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:5464
#, fuzzy
msgid ""
"Initialize the label on a newly instantiated devfs entry. Sleeping is "
"permitted."
msgstr ""
"Inicialize o r�tulo em uma entrada recentemente instanciada devfs. Dormir � "
"permitido."

#. (itstool) path: sect3/title
#: book.translate.xml:5469
#, fuzzy
msgid "<function>mpo_init_ifnet_label</function>"
msgstr " <function> mpo_init_ifnet_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5472
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_ifnet_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:5506
#, fuzzy
msgid ""
"Initialize the label on a newly instantiated network interface. Sleeping is "
"permitted."
msgstr ""
"Inicialize o r�tulo em uma interface de rede rec�m-instanciada. � permitido "
"dormir."

#. (itstool) path: sect3/title
#: book.translate.xml:5511
#, fuzzy
msgid "<function>mpo_init_ipq_label</function>"
msgstr " <function> mpo_init_ipq_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5514
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_ipq_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>flag</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_ipq_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> bandeira </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5547 book.translate.xml:5600 book.translate.xml:5799
#: book.translate.xml:5850
#, fuzzy
msgid "<parameter>flag</parameter>"
msgstr " <parameter> bandeira </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:5548 book.translate.xml:5601
#, fuzzy
msgid ""
"Sleeping/non-sleeping <citerefentry><refentrytitle>malloc</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>; see below"
msgstr ""
"Dormir / n�o dormir <citerefentry><refentrytitle> malloc </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> ; ver abaixo"

#. (itstool) path: sect3/para
#: book.translate.xml:5555
#, fuzzy
msgid ""
"Initialize the label on a newly instantiated IP fragment reassembly queue. "
"The <parameter>flag</parameter> field may be one of <symbol>M_WAITOK</"
"symbol> and <symbol>M_NOWAIT</symbol>, and should be employed to avoid "
"performing a sleeping <citerefentry><refentrytitle>malloc</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> during this "
"initialization call. IP fragment reassembly queue allocation frequently "
"occurs in performance sensitive environments, and the implementation should "
"be careful to avoid sleeping or long-lived operations. This entry point is "
"permitted to fail resulting in the failure to allocate the IP fragment "
"reassembly queue."
msgstr ""
"Inicialize o r�tulo em uma fila de remontagem de fragmento IP rec�m-"
"instanciada. <parameter> bandeira </parameter> campo pode ser um dos "
"<symbol> M_WAITOK </symbol> e <symbol> M_NOWAIT </symbol> , e deve ser "
"empregado para evitar a realiza��o de um sono <citerefentry><refentrytitle> "
"malloc </refentrytitle><manvolnum> 9 </manvolnum></citerefentry> durante "
"esta chamada de inicializa��o. A aloca��o de fila de remontagem de fragmento "
"de IP ocorre com frequ�ncia em ambientes sens�veis ao desempenho, e a "
"implementa��o deve ter cuidado para evitar opera��es de longa dura��o ou de "
"suspens�o. Este ponto de entrada tem permiss�o para falhar, resultando na "
"falha de alocar a fila de remontagem de fragmento de IP. "

#. (itstool) path: sect3/title
#: book.translate.xml:5569
#, fuzzy
msgid "<function>mpo_init_mbuf_label</function>"
msgstr " <function> mpo_init_mbuf_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5572
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_mbuf_label</function></funcdef> "
"<paramdef>int <parameter>flag</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_mbuf_label </function></"
"funcdef><paramdef> int <parameter> bandeira </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5607
#, fuzzy
msgid "Policy label to initialize"
msgstr "R�tulo de Pol�tica para Inicializar"

#. (itstool) path: sect3/para
#: book.translate.xml:5613
#, fuzzy
msgid ""
"Initialize the label on a newly instantiated mbuf packet header "
"(<parameter>mbuf</parameter>). The <parameter>flag</parameter> field may be "
"one of <symbol>M_WAITOK</symbol> and <symbol>M_NOWAIT</symbol>, and should "
"be employed to avoid performing a sleeping "
"<citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> during this initialization call. Mbuf allocation frequently "
"occurs in performance sensitive environments, and the implementation should "
"be careful to avoid sleeping or long-lived operations. This entry point is "
"permitted to fail resulting in the failure to allocate the mbuf header."
msgstr ""
"Inicialize o r�tulo em um cabe�alho de pacote mbuf rec�m-instanciado "
"( <parameter> mbuf </parameter> ). o <parameter> bandeira </parameter> campo "
"pode ser um dos <symbol> M_WAITOK </symbol> e <symbol> M_NOWAIT </symbol> , "
"e deve ser empregado para evitar a realiza��o de um sono "
"<citerefentry><refentrytitle> malloc </refentrytitle><manvolnum> 9 </"
"manvolnum></citerefentry> durante esta chamada de inicializa��o. A aloca��o "
"de Mbuf ocorre com freq��ncia em ambientes sens�veis ao desempenho, e a "
"implementa��o deve ser cuidadosa para evitar opera��es de longa dura��o ou "
"suspensas. Este ponto de entrada tem permiss�o para falhar, resultando na "
"falha de alocar o cabe�alho mbuf. "

#. (itstool) path: sect3/title
#: book.translate.xml:5627
#, fuzzy
msgid "<function>mpo_init_mount_label</function>"
msgstr " <function> mpo_init_mount_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5630
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_mount_label</function></funcdef> "
"<paramdef>struct label *<parameter>mntlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_mount_label </function></"
"funcdef><paramdef> label struct * <parameter> mntlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5660 book.translate.xml:6290 book.translate.xml:8149
#, fuzzy
msgid "<parameter>mntlabel</parameter>"
msgstr " <parameter> mntlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:5661
#, fuzzy
msgid "Policy label to be initialized for the mount itself"
msgstr "Etiqueta de pol�tica a ser inicializada para a montagem em si"

#. (itstool) path: row/entry
#: book.translate.xml:5666 book.translate.xml:6295 book.translate.xml:7631
#: book.translate.xml:7710 book.translate.xml:7780 book.translate.xml:8155
#, fuzzy
msgid "<parameter>fslabel</parameter>"
msgstr " <parameter> fslabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:5667
#, fuzzy
msgid "Policy label to be initialized for the file system"
msgstr "R�tulo de Pol�tica a Ser Inicializado para o Sistema de Arquivos"

#. (itstool) path: sect3/para
#: book.translate.xml:5674
#, fuzzy
msgid ""
"Initialize the labels on a newly instantiated mount point. Sleeping is "
"permitted."
msgstr ""
"Inicialize os r�tulos em um ponto de montagem rec�m-instanciado. � permitido "
"dormir."

#. (itstool) path: sect3/title
#: book.translate.xml:5679
#, fuzzy
msgid "<function>mpo_init_mount_fs_label</function>"
msgstr " <function> mpo_init_mount_fs_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5682
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_mount_fs_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_mount_fs_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5710
#, fuzzy
msgid "Label to be initialized"
msgstr "R�tulo a ser inicializado"

#. (itstool) path: sect3/para
#: book.translate.xml:5716
#, fuzzy
msgid ""
"Initialize the label on a newly mounted file system. Sleeping is permitted"
msgstr ""
"Inicialize o r�tulo em um sistema de arquivos rec�m montado. � permitido "
"dormir"

#. (itstool) path: sect3/title
#: book.translate.xml:5721
#, fuzzy
msgid "<function>mpo_init_pipe_label</function>"
msgstr " <function> mpo_init_pipe_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5724
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_pipe_label</function></funcdef> "
"<paramdef>struct label*<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_pipe_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5752 book.translate.xml:7172 book.translate.xml:7247
#: book.translate.xml:7322 book.translate.xml:7397 book.translate.xml:7472
#, fuzzy
msgid "Label to be filled in"
msgstr "Etiqueta a ser preenchida"

#. (itstool) path: sect3/para
#: book.translate.xml:5758
#, fuzzy
msgid ""
"Initialize a label for a newly instantiated pipe. Sleeping is permitted."
msgstr ""
"Inicialize um r�tulo para um pipe rec�m-instanciado. � permitido dormir."

#. (itstool) path: sect3/title
#: book.translate.xml:5763
#, fuzzy
msgid "<function>mpo_init_socket_label</function>"
msgstr " <function> mpo_init_socket_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5766
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>flag</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_socket_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> bandeira </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5800 book.translate.xml:5851
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> flags"
msgstr ""
" <citerefentry><refentrytitle> malloc </refentrytitle><manvolnum> 9 </"
"manvolnum></citerefentry> bandeiras"

#. (itstool) path: sect3/para
#: book.translate.xml:5806
#, fuzzy
msgid ""
"Initialize a label for a newly instantiated socket. The <parameter>flag</"
"parameter> field may be one of <symbol>M_WAITOK</symbol> and "
"<symbol>M_NOWAIT</symbol>, and should be employed to avoid performing a "
"sleeping <citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> during this initialization call."
msgstr ""
"Inicialize um r�tulo para um soquete rec�m-instanciado. <parameter> bandeira "
"</parameter> campo pode ser um dos <symbol> M_WAITOK </symbol> e <symbol> "
"M_NOWAIT </symbol> , e deve ser empregado para evitar a realiza��o de um "
"sono <citerefentry><refentrytitle> malloc </refentrytitle><manvolnum> 9 </"
"manvolnum></citerefentry> durante esta chamada de inicializa��o. "

#. (itstool) path: sect3/title
#: book.translate.xml:5814
#, fuzzy
msgid "<function>mpo_init_socket_peer_label</function>"
msgstr " <function> mpo_init_socket_peer_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5817
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_socket_peer_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>flag</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_socket_peer_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> bandeira </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:5857
#, fuzzy
msgid ""
"Initialize the peer label for a newly instantiated socket. The "
"<parameter>flag</parameter> field may be one of <symbol>M_WAITOK</symbol> "
"and <symbol>M_NOWAIT</symbol>, and should be employed to avoid performing a "
"sleeping <citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> during this initialization call."
msgstr ""
"Inicialize o r�tulo peer para um soquete rec�m-instanciado. <parameter> "
"bandeira </parameter> campo pode ser um dos <symbol> M_WAITOK </symbol> e "
"<symbol> M_NOWAIT </symbol> , e deve ser empregado para evitar a realiza��o "
"de um sono <citerefentry><refentrytitle> malloc </refentrytitle><manvolnum> "
"9 </manvolnum></citerefentry> durante esta chamada de inicializa��o. "

#. (itstool) path: sect3/title
#: book.translate.xml:5865
#, fuzzy
msgid "<function>mpo_init_proc_label</function>"
msgstr " <function> mpo_init_proc_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5868
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_proc_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_proc_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:5902
#, fuzzy
msgid ""
"Initialize the label for a newly instantiated process. Sleeping is permitted."
msgstr ""
"Inicialize o r�tulo para um processo rec�m-instanciado. � permitido dormir."

#. (itstool) path: sect3/title
#: book.translate.xml:5908
#, fuzzy
msgid "<function>mpo_init_vnode_label</function>"
msgstr " <function> mpo_init_vnode_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5911
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_vnode_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:5945
#, fuzzy
msgid ""
"Initialize the label on a newly instantiated vnode. Sleeping is permitted."
msgstr "Inicialize o r�tulo em um vnode rec�m-instanciado. Dormir � permitido."

#. (itstool) path: sect3/title
#: book.translate.xml:5950
#, fuzzy
msgid "<function>mpo_destroy_bpfdesc_label</function>"
msgstr " <function> mpo_destroy_bpfdesc_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5953
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_bpfdesc_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_bpfdesc_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5981
#, fuzzy
msgid "bpfdesc label"
msgstr "r�tulo bpfdesc"

#. (itstool) path: sect3/para
#: book.translate.xml:5987
#, fuzzy
msgid ""
"Destroy the label on a BPF descriptor. In this entry point a policy should "
"free any internal storage associated with <parameter>label</parameter> so "
"that it may be destroyed."
msgstr ""
"Destrua o r�tulo em um descritor BPF. Neste ponto de entrada, uma pol�tica "
"deve liberar qualquer armazenamento interno associado a <parameter> r�tulo </"
"parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:5994
#, fuzzy
msgid "<function>mpo_destroy_cred_label</function>"
msgstr " <function> mpo_destroy_cred_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5997
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_cred_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:6025 book.translate.xml:6069 book.translate.xml:6113
#: book.translate.xml:6157 book.translate.xml:6201
#, fuzzy
msgid "Label being destroyed"
msgstr "Etiqueta sendo destru�da"

#. (itstool) path: sect3/para
#: book.translate.xml:6031
#, fuzzy
msgid ""
"Destroy the label on a credential. In this entry point, a policy module "
"should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"Destrua o r�tulo em uma credencial. Nesse ponto de entrada, um m�dulo de "
"pol�tica deve liberar qualquer armazenamento interno associado a <parameter> "
"r�tulo </parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6038
#, fuzzy
msgid "<function>mpo_destroy_devfsdirent_label</function>"
msgstr " <function> mpo_destroy_devfsdirent_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6041
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_devfsdirent_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_devfsdirent_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:6075
#, fuzzy
msgid ""
"Destroy the label on a devfs entry. In this entry point, a policy module "
"should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"Destrua o r�tulo em uma entrada devfs. Nesse ponto de entrada, um m�dulo de "
"pol�tica deve liberar qualquer armazenamento interno associado <parameter> "
"r�tulo </parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6082
#, fuzzy
msgid "<function>mpo_destroy_ifnet_label</function>"
msgstr " <function> mpo_destroy_ifnet_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6085
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_ifnet_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:6119
#, fuzzy
msgid ""
"Destroy the label on a removed interface. In this entry point, a policy "
"module should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"Destrua o r�tulo em uma interface removida. Nesse ponto de entrada, um "
"m�dulo de pol�tica deve liberar qualquer armazenamento interno associado a "
"<parameter> r�tulo </parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6126
#, fuzzy
msgid "<function>mpo_destroy_ipq_label</function>"
msgstr " <function> mpo_destroy_ipq_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6129
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_ipq_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_ipq_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:6163
#, fuzzy
msgid ""
"Destroy the label on an IP fragment queue. In this entry point, a policy "
"module should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"Destrua o r�tulo em uma fila de fragmentos de IP. Nesse ponto de entrada, um "
"m�dulo de pol�tica deve liberar qualquer armazenamento interno associado a "
"<parameter> r�tulo </parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6170
#, fuzzy
msgid "<function>mpo_destroy_mbuf_label</function>"
msgstr " <function> mpo_destroy_mbuf_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6173
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_mbuf_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_mbuf_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:6207
#, fuzzy
msgid ""
"Destroy the label on an mbuf header. In this entry point, a policy module "
"should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"Destrua o r�tulo em um cabe�alho mbuf. Nesse ponto de entrada, um m�dulo de "
"pol�tica deve liberar qualquer armazenamento interno associado a <parameter> "
"r�tulo </parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6214 book.translate.xml:6258
#, fuzzy
msgid "<function>mpo_destroy_mount_label</function>"
msgstr " <function> mpo_destroy_mount_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6217
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_mount_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_mount_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:6245 book.translate.xml:6291
#, fuzzy
msgid "Mount point label being destroyed"
msgstr "Etiqueta de ponto de montagem sendo destru�da"

#. (itstool) path: sect3/para
#: book.translate.xml:6251
#, fuzzy
msgid ""
"Destroy the labels on a mount point. In this entry point, a policy module "
"should free the internal storage associated with <parameter>mntlabel</"
"parameter> so that they may be destroyed."
msgstr ""
"Destrua os r�tulos em um ponto de montagem. Nesse ponto de entrada, um "
"m�dulo de pol�tica deve liberar o armazenamento interno associado "
"<parameter> mntlabel </parameter> para que eles sejam destru�dos \""

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6261
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_mount_label</function></funcdef> "
"<paramdef>struct label *<parameter>mntlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_mount_label </function></"
"funcdef><paramdef> label struct * <parameter> mntlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:6296
#, fuzzy
msgid "File system label being destroyed&gt;"
msgstr "R�tulo do sistema de arquivos sendo destru�do&gt;"

#. (itstool) path: sect3/para
#: book.translate.xml:6302
#, fuzzy
msgid ""
"Destroy the labels on a mount point. In this entry point, a policy module "
"should free the internal storage associated with <parameter>mntlabel</"
"parameter> and <parameter>fslabel</parameter> so that they may be destroyed."
msgstr ""
"Destrua os r�tulos em um ponto de montagem. Nesse ponto de entrada, um "
"m�dulo de pol�tica deve liberar o armazenamento interno associado "
"<parameter> mntlabel </parameter> e <parameter> fslabel </parameter> para "
"que eles sejam destru�dos \""

#. (itstool) path: sect3/title
#: book.translate.xml:6310
#, fuzzy
msgid "<function>mpo_destroy_socket_label</function>"
msgstr " <function> mpo_destroy_socket_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6313
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_socket_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:6341
#, fuzzy
msgid "Socket label being destroyed"
msgstr "Etiqueta de soquete sendo destru�da"

#. (itstool) path: sect3/para
#: book.translate.xml:6347
#, fuzzy
msgid ""
"Destroy the label on a socket. In this entry point, a policy module should "
"free any internal storage associated with <parameter>label</parameter> so "
"that it may be destroyed."
msgstr ""
"Destrua o r�tulo em um soquete. Nesse ponto de entrada, um m�dulo de "
"pol�tica deve liberar qualquer armazenamento interno associado <parameter> "
"r�tulo </parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6354
#, fuzzy
msgid "<function>mpo_destroy_socket_peer_label</function>"
msgstr " <function> mpo_destroy_socket_peer_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6357
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_socket_peer_label</function></funcdef> "
"<paramdef>struct label *<parameter>peerlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_socket_peer_label </function></"
"funcdef><paramdef> label struct * <parameter> peerlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:6384
#, fuzzy
msgid "<parameter>peerlabel</parameter>"
msgstr " <parameter> peerlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:6385
#, fuzzy
msgid "Socket peer label being destroyed"
msgstr "R�tulo do par de soquetes sendo destru�do"

#. (itstool) path: sect3/para
#: book.translate.xml:6391
#, fuzzy
msgid ""
"Destroy the peer label on a socket. In this entry point, a policy module "
"should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"Destrua o r�tulo peer em um soquete. Neste ponto de entrada, um m�dulo de "
"pol�tica deve liberar qualquer armazenamento interno associado <parameter> "
"r�tulo </parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6398
#, fuzzy
msgid "<function>mpo_destroy_pipe_label</function>"
msgstr " <function> mpo_destroy_pipe_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6401
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_pipe_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:6429
#, fuzzy
msgid "Pipe label"
msgstr "R�tulo de tubo"

#. (itstool) path: sect3/para
#: book.translate.xml:6435
#, fuzzy
msgid ""
"Destroy the label on a pipe. In this entry point, a policy module should "
"free any internal storage associated with <parameter>label</parameter> so "
"that it may be destroyed."
msgstr ""
"Destrua o r�tulo em um pipe. Nesse ponto de entrada, um m�dulo de pol�tica "
"deve liberar qualquer armazenamento interno associado <parameter> r�tulo </"
"parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6442
#, fuzzy
msgid "<function>mpo_destroy_proc_label</function>"
msgstr " <function> mpo_destroy_proc_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6445
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_proc_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_proc_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:6472 book.translate.xml:6515
#, fuzzy
msgid "Process label"
msgstr "R�tulo do processo"

#. (itstool) path: sect3/para
#: book.translate.xml:6478
#, fuzzy
msgid ""
"Destroy the label on a process. In this entry point, a policy module should "
"free any internal storage associated with <parameter>label</parameter> so "
"that it may be destroyed."
msgstr ""
"Destrua o r�tulo em um processo. Nesse ponto de entrada, um m�dulo de "
"pol�tica deve liberar qualquer armazenamento interno associado <parameter> "
"r�tulo </parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6485
#, fuzzy
msgid "<function>mpo_destroy_vnode_label</function>"
msgstr " <function> mpo_destroy_vnode_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6488
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_vnode_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:6521
#, fuzzy
msgid ""
"Destroy the label on a vnode. In this entry point, a policy module should "
"free any internal storage associated with <parameter>label</parameter> so "
"that it may be destroyed."
msgstr ""
"Destrua o r�tulo em um vnode. Nesse ponto de entrada, um m�dulo de pol�tica "
"deve liberar qualquer armazenamento interno associado <parameter> r�tulo </"
"parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6528
#, fuzzy
msgid "<function>mpo_copy_mbuf_label</function>"
msgstr " <function> mpo_copy_mbuf_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6531
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_copy_mbuf_label</function></funcdef> "
"<paramdef>struct label *<parameter>src</parameter></paramdef> "
"<paramdef>struct label *<parameter>dest</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_copy_mbuf_label </function></"
"funcdef><paramdef> label struct * <parameter> src </parameter></"
"paramdef><paramdef> label struct * <parameter> dest </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:6560 book.translate.xml:6609 book.translate.xml:6658
#, fuzzy
msgid "<parameter>src</parameter>"
msgstr " <parameter> src </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:6561 book.translate.xml:6610 book.translate.xml:6659
#, fuzzy
msgid "Source label"
msgstr "R�tulo da fonte"

#. (itstool) path: row/entry
#: book.translate.xml:6565 book.translate.xml:6614 book.translate.xml:6663
#, fuzzy
msgid "<parameter>dest</parameter>"
msgstr " <parameter> come�ou </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:6566 book.translate.xml:6615 book.translate.xml:6664
#, fuzzy
msgid "Destination label"
msgstr "Etiqueta de destino"

#. (itstool) path: sect3/para
#: book.translate.xml:6572 book.translate.xml:6621 book.translate.xml:6670
#, fuzzy
msgid ""
"Copy the label information in <parameter>src</parameter> into "
"<parameter>dest</parameter>."
msgstr ""
"Copie as informa��es da etiqueta em <parameter> src </parameter> para dentro "
"<parameter> dest </parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:6577
#, fuzzy
msgid "<function>mpo_copy_pipe_label</function>"
msgstr " <function> mpo_copy_pipe_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6580
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_copy_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>src</parameter></paramdef> "
"<paramdef>struct label *<parameter>dest</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_copy_pipe_label </function></"
"funcdef><paramdef> label struct * <parameter> src </parameter></"
"paramdef><paramdef> label struct * <parameter> come�ou </parameter></"
"paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:6626
#, fuzzy
msgid "<function>mpo_copy_vnode_label</function>"
msgstr " <function> mpo_copy_vnode_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6629
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_copy_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>src</parameter></paramdef> "
"<paramdef>struct label *<parameter>dest</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_copy_vnode_label </function></"
"funcdef><paramdef> label struct * <parameter> src </parameter></"
"paramdef><paramdef> label struct * <parameter> dest </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:6675
#, fuzzy
msgid "<function>mpo_externalize_cred_label</function>"
msgstr " <function> mpo_externalize_cred_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6678
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_cred_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> struct sbuf * <parameter> sb </parameter></"
"paramdef><paramdef> int <parameter> * reivindicado </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:6711 book.translate.xml:6788 book.translate.xml:6865
#: book.translate.xml:6942 book.translate.xml:7018 book.translate.xml:7095
#, fuzzy
msgid "Label to be externalized"
msgstr "Etiqueta a ser externalizada"

#. (itstool) path: row/entry
#: book.translate.xml:6715 book.translate.xml:6792 book.translate.xml:6869
#: book.translate.xml:6946 book.translate.xml:7022 book.translate.xml:7099
#: book.translate.xml:7176 book.translate.xml:7251 book.translate.xml:7326
#: book.translate.xml:7401 book.translate.xml:7476
#, fuzzy
msgid "<parameter>element_name</parameter>"
msgstr " <parameter> element_name </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:6716 book.translate.xml:6793 book.translate.xml:6870
#: book.translate.xml:6947 book.translate.xml:7023 book.translate.xml:7100
#, fuzzy
msgid "Name of the policy whose label should be externalized"
msgstr "Nome da pol�tica cujo r�tulo deve ser externalizado"

#. (itstool) path: row/entry
#: book.translate.xml:6720 book.translate.xml:6797 book.translate.xml:6874
#: book.translate.xml:6951 book.translate.xml:7027 book.translate.xml:7104
#, fuzzy
msgid "<parameter>sb</parameter>"
msgstr " <parameter> sb </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:6721 book.translate.xml:6798 book.translate.xml:6875
#: book.translate.xml:6952 book.translate.xml:7028 book.translate.xml:7105
#, fuzzy
msgid "String buffer to be filled with a text representation of label"
msgstr ""
"Buffer de cadeia a ser preenchido com uma representa��o de texto de r�tulo"

#. (itstool) path: row/entry
#: book.translate.xml:6726 book.translate.xml:6803 book.translate.xml:6880
#: book.translate.xml:6957 book.translate.xml:7033 book.translate.xml:7110
#: book.translate.xml:7186 book.translate.xml:7261 book.translate.xml:7336
#: book.translate.xml:7411 book.translate.xml:7486
#, fuzzy
msgid "<parameter>claimed</parameter>"
msgstr " <parameter> reivindicado </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:6727 book.translate.xml:6804 book.translate.xml:6881
#: book.translate.xml:6958 book.translate.xml:7034 book.translate.xml:7111
#, fuzzy
msgid ""
"Should be incremented when <parameter>element_data</parameter> can be filled "
"in."
msgstr ""
"Deve ser incrementado quando <parameter> element_data </parameter> pode ser "
"preenchido. "

#. (itstool) path: sect3/para
#: book.translate.xml:6736 book.translate.xml:6813 book.translate.xml:6890
#: book.translate.xml:6967 book.translate.xml:7043 book.translate.xml:7120
#, fuzzy
msgid ""
"Produce an externalized label based on the label structure passed. An "
"externalized label consists of a text representation of the label contents "
"that can be used with userland applications and read by the user. Currently, "
"all policies' <function>externalize</function> entry points will be called, "
"so the implementation should check the contents of <parameter>element_name</"
"parameter> before attempting to fill in <parameter>sb</parameter>. If "
"<parameter>element_name</parameter> does not match the name of your policy, "
"simply return <returnvalue>0</returnvalue>. Only return nonzero if an error "
"occurs while externalizing the label data. Once the policy fills in "
"<parameter>element_data</parameter>, <varname>*claimed</varname> should be "
"incremented."
msgstr ""
"Produza um r�tulo externalizado com base na estrutura de r�tulo passada. Um "
"r�tulo externalizado consiste em uma representa��o de texto do conte�do do "
"r�tulo que pode ser usado com aplicativos de usu�rio final e lido pelo "
"usu�rio. Atualmente, todas as pol�ticas '; <function> externalizar </"
"function> pontos de entrada ser�o chamados, ent�o a implementa��o deve "
"verificar o conte�do de <parameter> element_name </parameter> antes de "
"tentar preencher <parameter> sb </parameter> . E se <parameter> element_name "
"</parameter> n�o corresponde ao nome da sua pol�tica, basta retornar "
"<returnvalue> 0 </returnvalue> . S� retornar� diferente de zero se ocorrer "
"um erro ao externalizar os dados da etiqueta. Quando a pol�tica preencher "
"<parameter> element_data </parameter> , <varname> * reivindicado </varname> "
"deve ser incrementado \""

#. (itstool) path: sect3/title
#: book.translate.xml:6752
#, fuzzy
msgid "<function>mpo_externalize_ifnet_label</function>"
msgstr " <function> mpo_externalize_ifnet_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6755
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_ifnet_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> struct sbuf * <parameter> sb </parameter></"
"paramdef><paramdef> int <parameter> * reivindicado </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:6829
#, fuzzy
msgid "<function>mpo_externalize_pipe_label</function>"
msgstr " <function> mpo_externalize_pipe_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6832
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_pipe_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> struct sbuf * <parameter> sb </parameter></"
"paramdef><paramdef> int <parameter> * reivindicado </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:6906
#, fuzzy
msgid "<function>mpo_externalize_socket_label</function>"
msgstr " <function> mpo_externalize_socket_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6909
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_socket_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> struct sbuf * <parameter> sb </parameter></"
"paramdef><paramdef> int <parameter> * reivindicado </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:6983
#, fuzzy
msgid "<function>mpo_externalize_socket_peer_label</function>"
msgstr " <function> mpo_externalize_socket_peer_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6986
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_socket_peer_label</function></"
"funcdef> <paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_socket_peer_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> struct sbuf * <parameter> sb </parameter></"
"paramdef><paramdef> int <parameter> * reivindicado </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:7059
#, fuzzy
msgid "<function>mpo_externalize_vnode_label</function>"
msgstr " <function> mpo_externalize_vnode_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7062
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_vnode_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> struct sbuf * <parameter> sb </parameter></"
"paramdef><paramdef> int <parameter> * reivindicado </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:7136
#, fuzzy
msgid "<function>mpo_internalize_cred_label</function>"
msgstr " <function> mpo_internalize_cred_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7139
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_internalize_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_internalize_cred_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_data </parameter></"
"paramdef><paramdef> int * <parameter> reivindicado </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:7177 book.translate.xml:7252 book.translate.xml:7327
#: book.translate.xml:7402 book.translate.xml:7477
#, fuzzy
msgid "Name of the policy whose label should be internalized"
msgstr "Nome da pol�tica cujo r�tulo deve ser internalizado"

#. (itstool) path: row/entry
#: book.translate.xml:7181 book.translate.xml:7256 book.translate.xml:7331
#: book.translate.xml:7406 book.translate.xml:7481
#, fuzzy
msgid "<parameter>element_data</parameter>"
msgstr " <parameter> element_data </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7182 book.translate.xml:7257 book.translate.xml:7332
#: book.translate.xml:7407 book.translate.xml:7482
#, fuzzy
msgid "Text data to be internalized"
msgstr "Dados de texto a serem internalizados"

#. (itstool) path: row/entry
#: book.translate.xml:7187 book.translate.xml:7262 book.translate.xml:7337
#: book.translate.xml:7412 book.translate.xml:7487
#, fuzzy
msgid "Should be incremented when data can be successfully internalized."
msgstr ""
"Deve ser incrementado quando os dados podem ser internalizados com sucesso."

#. (itstool) path: sect3/para
#: book.translate.xml:7196 book.translate.xml:7271 book.translate.xml:7346
#: book.translate.xml:7421 book.translate.xml:7496
#, fuzzy
msgid ""
"Produce an internal label structure based on externalized label data in text "
"format. Currently, all policies' <function>internalize</function> entry "
"points are called when internalization is requested, so the implementation "
"should compare the contents of <parameter>element_name</parameter> to its "
"own name in order to be sure it should be internalizing the data in "
"<parameter>element_data</parameter>. Just as in the <function>externalize</"
"function> entry points, the entry point should return <returnvalue>0</"
"returnvalue> if <parameter>element_name</parameter> does not match its own "
"name, or when data can successfully be internalized, in which case "
"<varname>*claimed</varname> should be incremented."
msgstr ""
"Produzir uma estrutura de r�tulo interno com base em dados de r�tulo "
"externalizados em formato de texto. Atualmente, todas as pol�ticas '; "
"<function> internalizar </function> os pontos de entrada s�o chamados quando "
"a internaliza��o � solicitada, ent�o a implementa��o deve comparar o "
"conte�do de <parameter> element_name </parameter> para o seu pr�prio nome, a "
"fim de ter certeza de que deveria estar internalizando os dados em "
"<parameter> element_data </parameter> . Assim como no <function> "
"externalizar </function> pontos de entrada, o ponto de entrada deve retornar "
"<returnvalue> 0 </returnvalue> E se <parameter> element_name </parameter> "
"n�o corresponde ao seu pr�prio nome, ou quando os dados podem ser "
"internalizados com �xito, em cujo caso <varname> * reivindicado </varname> "
"deve ser incrementado \""

#. (itstool) path: sect3/title
#: book.translate.xml:7211
#, fuzzy
msgid "<function>mpo_internalize_ifnet_label</function>"
msgstr " <function> mpo_internalize_ifnet_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7214
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_internalize_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_internalize_ifnet_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_data </parameter></"
"paramdef><paramdef> int * <parameter> reivindicado </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:7286
#, fuzzy
msgid "<function>mpo_internalize_pipe_label</function>"
msgstr " <function> mpo_internalize_pipe_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7289
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_internalize_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_internalize_pipe_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_data </parameter></"
"paramdef><paramdef> int * <parameter> reivindicado </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:7361
#, fuzzy
msgid "<function>mpo_internalize_socket_label</function>"
msgstr " <function> mpo_internalize_socket_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7364
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_internalize_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_internalize_socket_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_data </parameter></"
"paramdef><paramdef> int * <parameter> reivindicado </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:7436
#, fuzzy
msgid "<function>mpo_internalize_vnode_label</function>"
msgstr " <function> mpo_internalize_vnode_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7439
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_internalize_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_internalize_vnode_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_data </parameter></"
"paramdef><paramdef> int * <parameter> reivindicado </parameter></paramdef> "

#. (itstool) path: sect2/title
#: book.translate.xml:7512
#, fuzzy
msgid "Label Events"
msgstr "Eventos de etiqueta"

#. (itstool) path: sect2/para
#: book.translate.xml:7514
#, fuzzy
msgid ""
"This class of entry points is used by the MAC framework to permit policies "
"to maintain label information on kernel objects. For each labeled kernel "
"object of interest to a MAC policy, entry points may be registered for "
"relevant life cycle events. All objects implement initialization, creation, "
"and destruction hooks. Some objects will also implement relabeling, allowing "
"user processes to change the labels on objects. Some objects will also "
"implement object-specific events, such as label events associated with IP "
"reassembly. A typical labeled object will have the following life cycle of "
"entry points:"
msgstr ""
"Essa classe de pontos de entrada � usada pela estrutura MAC para permitir "
"que as pol�ticas mantenham informa��es de r�tulos nos objetos do kernel. "
"Para cada objeto rotulado do kernel de interesse de uma pol�tica MAC, os "
"pontos de entrada podem ser registrados para eventos de ciclo de vida "
"relevantes. Al�m disso, alguns objetos tamb�m implementar�o a remarca��o, "
"permitindo que os processos do usu�rio alterem os r�tulos dos objetos.Alguns "
"objetos tamb�m implementar�o eventos espec�ficos do objeto, como eventos de "
"r�tulo associados � remontagem do IP.Um objeto rotulado t�pico seguinte "
"ciclo de vida dos pontos de entrada: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:7526
#, no-wrap
msgid ""
"Label initialization          o\n"
"(object-specific wait)         \\\n"
"Label creation                  o\n"
"                                 \\\n"
"Relabel events,                   o--&lt;--.\n"
"Various object-specific,          |     |\n"
"Access control events             ~--&gt;--o\n"
"                                         \\\n"
"Label destruction                         o"
msgstr ""
"Label initialization          o\n"
"(object-specific wait)         \\\n"
"Label creation                  o\n"
"                                 \\\n"
"Relabel events,                   o--&lt;--.\n"
"Various object-specific,          |     |\n"
"Access control events             ~--&gt;--o\n"
"                                         \\\n"
"Label destruction                         o"

#. (itstool) path: sect2/para
#: book.translate.xml:7536
#, fuzzy
msgid ""
"Label initialization permits policies to allocate memory and set initial "
"values for labels without context for the use of the object. The label slot "
"allocated to a policy will be zeroed by default, so some policies may not "
"need to perform initialization."
msgstr ""
"A inicializa��o do r�tulo permite que pol�ticas aloquem mem�ria e definam "
"valores iniciais para r�tulos sem contexto para o uso do objeto. O slot de "
"r�tulo alocado a uma pol�tica ser� zerado por padr�o, portanto, algumas "
"pol�ticas podem n�o precisar executar a inicializa��o."

#. (itstool) path: sect2/para
#: book.translate.xml:7542
#, fuzzy
msgid ""
"Label creation occurs when the kernel structure is associated with an actual "
"kernel object. For example, Mbufs may be allocated and remain unused in a "
"pool until they are required. mbuf allocation causes label initialization on "
"the mbuf to take place, but mbuf creation occurs when the mbuf is associated "
"with a datagram. Typically, context will be provided for a creation event, "
"including the circumstances of the creation, and labels of other relevant "
"objects in the creation process. For example, when an mbuf is created from a "
"socket, the socket and its label will be presented to registered policies in "
"addition to the new mbuf and its label. Memory allocation in creation events "
"is discouraged, as it may occur in performance sensitive ports of the "
"kernel; in addition, creation calls are not permitted to fail so a failure "
"to allocate memory cannot be reported."
msgstr ""
"A cria��o de r�tulos ocorre quando a estrutura do kernel � associada a um "
"objeto de kernel real. Por exemplo, Mbufs podem ser alocados e permanecer "
"sem uso em um conjunto at� que sejam necess�rios. A aloca��o de mbuf faz com "
"que a inicializa��o de r�tulo ocorra, mas a cria��o de mbuf ocorre Quando o "
"mbuf � associado a um datagrama.Normalmente, o contexto ser� fornecido para "
"um evento de cria��o, incluindo as circunst�ncias da cria��o, e r�tulos de "
"outros objetos relevantes no processo de cria��o.Por exemplo, quando um mbuf "
"� criado a partir de um soquete, o soquete e seu r�tulo ser�o apresentados a "
"pol�ticas registradas, al�m do novo mbuf e seu r�tulo.A aloca��o de mem�ria "
"em eventos de cria��o � desencorajada, pois pode ocorrer em portas sens�veis "
"ao desempenho do kernel, al�m disso, as chamadas de cria��o n�o t�m "
"permiss�o para falhar, portanto, uma falha na aloca��o de mem�ria n�o pode "
"ser reportada. "

#. (itstool) path: sect2/para
#: book.translate.xml:7558
#, fuzzy
msgid ""
"Object specific events do not generally fall into the other broad classes of "
"label events, but will generally provide an opportunity to modify or update "
"the label on an object based on additional context. For example, the label "
"on an IP fragment reassembly queue may be updated during the "
"<symbol>MAC_UPDATE_IPQ</symbol> entry point as a result of the acceptance of "
"an additional mbuf to that queue."
msgstr ""
"Eventos espec�ficos de objeto geralmente n�o se enquadram em outras classes "
"de eventos de r�tulo, mas geralmente fornecem uma oportunidade para "
"modificar ou atualizar o r�tulo em um objeto com base em contexto adicional. "
"Por exemplo, o r�tulo em uma fila de reagrupamento de fragmento IP pode ser "
"atualizado durante o <symbol> MAC_UPDATE_IPQ </symbol> ponto de entrada como "
"resultado da aceita��o de um mbuf adicional para essa fila. "

#. (itstool) path: sect2/para
#: book.translate.xml:7566
#, fuzzy
msgid "Access control events are discussed in detail in the following section."
msgstr ""
"Os eventos de controle de acesso s�o discutidos em detalhes na se��o a "
"seguir."

#. (itstool) path: sect2/para
#: book.translate.xml:7569
#, fuzzy
msgid ""
"Label destruction permits policies to release storage or state associated "
"with a label during its association with an object so that the kernel data "
"structures supporting the object may be reused or released."
msgstr ""
"A destrui��o de etiqueta permite que pol�ticas liberem armazenamento ou "
"estado associado a um r�tulo durante sua associa��o com um objeto, de forma "
"que as estruturas de dados do kernel que suportam o objeto possam ser "
"reutilizadas ou liberadas."

#. (itstool) path: sect2/para
#: book.translate.xml:7574
#, fuzzy
msgid ""
"In addition to labels associated with specific kernel objects, an additional "
"class of labels exists: temporary labels. These labels are used to store "
"update information submitted by user processes. These labels are initialized "
"and destroyed as with other label types, but the creation event is "
"<symbol>MAC_INTERNALIZE</symbol>, which accepts a user label to be converted "
"to an in-kernel representation."
msgstr ""
"Al�m de r�tulos associados a objetos de kernel espec�ficos, existe uma "
"classe adicional de r�tulos: r�tulos tempor�rios. Esses r�tulos s�o usados ​​"
"para armazenar informa��es de atualiza��o enviadas pelos processos do "
"usu�rio. Esses r�tulos s�o inicializados e destru�dos como com outros tipos "
"de r�tulo, mas o evento de cria��o � <symbol> MAC_INTERNALIZE </symbol> , "
"que aceita um r�tulo de usu�rio para ser convertido em uma representa��o no "
"kernel. "

#. (itstool) path: sect3/title
#: book.translate.xml:7583
#, fuzzy
msgid "File System Object Labeling Event Operations"
msgstr "Opera��es de eventos de rotulagem de objeto de sistema de arquivos"

#. (itstool) path: sect4/title
#: book.translate.xml:7586
#, fuzzy
msgid "<function>mpo_associate_vnode_devfs</function>"
msgstr " <function> mpo_associate_vnode_devfs </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7589
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_associate_vnode_devfs</function></funcdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef> "
"<paramdef>struct devfs_dirent *<parameter>de</parameter></paramdef> "
"<paramdef>struct label *<parameter>delabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_associate_vnode_devfs </function></"
"funcdef><paramdef> montagem struct * <parameter> mp </parameter></"
"paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef><paramdef> struct devfs_dirent * <parameter> de </parameter></"
"paramdef><paramdef> label struct * <parameter> delabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:7626 book.translate.xml:7705 book.translate.xml:7775
#: book.translate.xml:7972 book.translate.xml:8144 book.translate.xml:11699
#, fuzzy
msgid "<parameter>mp</parameter>"
msgstr " <parameter> pf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7627 book.translate.xml:7973
#, fuzzy
msgid "Devfs mount point"
msgstr "Devfs mount point"

#. (itstool) path: row/entry
#: book.translate.xml:7632
#, fuzzy
msgid "Devfs file system label (<varname>mp-&gt;mnt_fslabel</varname>)"
msgstr ""
"R�tulo do sistema de arquivos Devfs ( <varname> mp-&gt; mnt_fslabel </"
"varname> ) "

#. (itstool) path: row/entry
#: book.translate.xml:7637 book.translate.xml:7988
#, fuzzy
msgid "<parameter>de</parameter>"
msgstr " <parameter> de </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7638
#, fuzzy
msgid "Devfs directory entry"
msgstr "Entrada do diret�rio Devfs"

#. (itstool) path: row/entry
#: book.translate.xml:7642 book.translate.xml:7993
#, fuzzy
msgid "<parameter>delabel</parameter>"
msgstr " <parameter> delabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7643
#, fuzzy
msgid "Policy label associated with <parameter>de</parameter>"
msgstr "Etiqueta de pol�tica associada a <parameter> de </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7648 book.translate.xml:7715 book.translate.xml:7785
#: book.translate.xml:8076 book.translate.xml:8259 book.translate.xml:8325
#: book.translate.xml:8399 book.translate.xml:9993 book.translate.xml:10066
#: book.translate.xml:10583 book.translate.xml:11635 book.translate.xml:11825
#: book.translate.xml:12112 book.translate.xml:12189 book.translate.xml:12257
#: book.translate.xml:12322 book.translate.xml:12395 book.translate.xml:12492
#: book.translate.xml:12557 book.translate.xml:12621 book.translate.xml:12681
#: book.translate.xml:12746 book.translate.xml:12820 book.translate.xml:12902
#: book.translate.xml:13102 book.translate.xml:13227 book.translate.xml:13293
#: book.translate.xml:13359 book.translate.xml:13437 book.translate.xml:13523
#: book.translate.xml:13591 book.translate.xml:13660 book.translate.xml:13732
#: book.translate.xml:13920 book.translate.xml:14202 book.translate.xml:14393
#, fuzzy
msgid "<parameter>vp</parameter>"
msgstr " <parameter> vp </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7649
#, fuzzy
msgid "vnode associated with <parameter>de</parameter>"
msgstr "vnode associado com <parameter> de </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7654 book.translate.xml:7720 book.translate.xml:7790
#: book.translate.xml:8081 book.translate.xml:8331 book.translate.xml:10588
#: book.translate.xml:14207 book.translate.xml:14398
#, fuzzy
msgid "<parameter>vlabel</parameter>"
msgstr " <parameter> vlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7655 book.translate.xml:7721 book.translate.xml:7791
#: book.translate.xml:8082 book.translate.xml:8332 book.translate.xml:12498
#: book.translate.xml:12563 book.translate.xml:12752 book.translate.xml:12826
#: book.translate.xml:12908
#, fuzzy
msgid "Policy label associated with <parameter>vp</parameter>"
msgstr "Etiqueta de pol�tica associada a <parameter> vp </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:7662
#, fuzzy
msgid ""
"Fill in the label (<parameter>vlabel</parameter>) for a newly created devfs "
"vnode based on the devfs directory entry passed in <parameter>de</parameter> "
"and its label."
msgstr ""
"Preencha o r�tulo ( <parameter> vlabel </parameter> ) para um vnode devfs "
"rec�m-criado com base na entrada de diret�rio devfs passada <parameter> de </"
"parameter> e seu r�tulo \""

#. (itstool) path: sect4/title
#: book.translate.xml:7669
#, fuzzy
msgid "<function>mpo_associate_vnode_extattr</function>"
msgstr " <function> mpo_associate_vnode_extattr </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7672
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_associate_vnode_extattr</function></funcdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_associate_vnode_extattr </function></"
"funcdef><paramdef> montagem struct * <parameter> mp </parameter></"
"paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:7706 book.translate.xml:7776 book.translate.xml:8056
#, fuzzy
msgid "File system mount point"
msgstr "Ponto de montagem do sistema de arquivos"

#. (itstool) path: row/entry
#: book.translate.xml:7711 book.translate.xml:7781 book.translate.xml:8061
#, fuzzy
msgid "File system label"
msgstr "R�tulo do sistema de arquivos"

#. (itstool) path: row/entry
#: book.translate.xml:7716 book.translate.xml:7786
#, fuzzy
msgid "Vnode to label"
msgstr "Vnode para rotular"

#. (itstool) path: sect4/para
#: book.translate.xml:7728
#, fuzzy
msgid ""
"Attempt to retrieve the label for <parameter>vp</parameter> from the file "
"system extended attributes. Upon success, the value <literal>0</literal> is "
"returned. Should extended attribute retrieval not be supported, an accepted "
"fallback is to copy <parameter>fslabel</parameter> into <parameter>vlabel</"
"parameter>. In the event of an error, an appropriate value for "
"<varname>errno</varname> should be returned."
msgstr ""
"Tentativa de recuperar o r�tulo para <parameter> vp </parameter> dos "
"atributos estendidos do sistema de arquivos. Ap�s o sucesso, o valor "
"<literal> 0 </literal> � retornado. Caso a recupera��o de atributos "
"estendidos n�o seja suportada, um substituto aceito � copiar <parameter> "
"fslabel </parameter> para dentro <parameter> vlabel </parameter> . Em caso "
"de erro, um valor apropriado para <varname> errno </varname> deve ser "
"devolvido \""

#. (itstool) path: sect4/title
#: book.translate.xml:7740
#, fuzzy
msgid "<function>mpo_associate_vnode_singlelabel</function>"
msgstr " <function> mpo_associate_vnode_singlelabel </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7743
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_associate_vnode_singlelabel</function></funcdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
"<funcdef> vazio <function> mpo_associate_vnode_singlelabel </function></"
"funcdef><paramdef> montagem struct * <parameter> mp </parameter></"
"paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vlabel </parameter></paramdef>"

#. (itstool) path: sect4/para
#: book.translate.xml:7798
#, fuzzy
msgid ""
"On non-multilabel file systems, this entry point is called to set the policy "
"label for <parameter>vp</parameter> based on the file system label, "
"<parameter>fslabel</parameter>."
msgstr ""
"Em sistemas de arquivos n�o multilabel, este ponto de entrada � chamado para "
"definir o r�tulo de pol�tica para <parameter> vp </parameter> com base no "
"r�tulo do sistema de arquivos, <parameter> fslabel </parameter> "

#. (itstool) path: sect4/title
#: book.translate.xml:7805
#, fuzzy
msgid "<function>mpo_create_devfs_device</function>"
msgstr " <function> mpo_create_devfs_device </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7808
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_devfs_device</function></funcdef> "
"<paramdef>dev_t <parameter>dev</parameter></paramdef> <paramdef>struct "
"devfs_dirent *<parameter>devfs_dirent</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_devfs_device </function></"
"funcdef><paramdef> dev_t <parameter> dev </parameter></paramdef><paramdef> "
"struct devfs_dirent * <parameter> devfs_dirent </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:7838
#, fuzzy
msgid "<parameter>dev</parameter>"
msgstr " <parameter> dev </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7839
#, fuzzy
msgid "Device corresponding with <parameter>devfs_dirent</parameter>"
msgstr "Dispositivo correspondente com <parameter> devfs_dirent </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7844 book.translate.xml:7911 book.translate.xml:8387
#, fuzzy
msgid "<parameter>devfs_dirent</parameter>"
msgstr " <parameter> devfs_dirent </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7845
#, fuzzy
msgid "Devfs directory entry to be labeled."
msgstr "Devfs entrada do diret�rio a ser rotulado."

#. (itstool) path: row/entry
#: book.translate.xml:7850
#, fuzzy
msgid "Label for <parameter>devfs_dirent</parameter> to be filled in."
msgstr ""
"R�tulo para <parameter> devfs_dirent </parameter> para ser preenchido. "

#. (itstool) path: sect4/para
#: book.translate.xml:7857
#, fuzzy
msgid ""
"Fill out the label on a devfs_dirent being created for the passed device. "
"This call will be made when the device file system is mounted, regenerated, "
"or a new device is made available."
msgstr ""
"Preencha o r�tulo em um devfs_dirent sendo criado para o dispositivo "
"passado. Essa chamada ser� feita quando o sistema de arquivos do dispositivo "
"for montado, regenerado ou um novo dispositivo for disponibilizado."

#. (itstool) path: sect4/title
#: book.translate.xml:7864
#, fuzzy
msgid "<function>mpo_create_devfs_directory</function>"
msgstr " <function> mpo_create_devfs_directory </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7867
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_devfs_directory</function></funcdef> "
"<paramdef>char *<parameter>dirname</parameter></paramdef> <paramdef>int "
"<parameter>dirnamelen</parameter></paramdef> <paramdef>struct devfs_dirent "
"*<parameter>devfs_dirent</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_devfs_directory </function></"
"funcdef><paramdef> Caracteres * <parameter> dirname </parameter></"
"paramdef><paramdef> int <parameter> dirnamelen </parameter></"
"paramdef><paramdef> struct devfs_dirent * <parameter> devfs_dirent </"
"parameter></paramdef><paramdef> label struct * <parameter> r�tulo </"
"parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:7900
#, fuzzy
msgid "<parameter>dirname</parameter>"
msgstr " <parameter> dirname </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7901
#, fuzzy
msgid "Name of directory being created"
msgstr "Nome do diret�rio sendo criado"

#. (itstool) path: row/entry
#: book.translate.xml:7905 book.translate.xml:14459
#, fuzzy
msgid "<parameter>namelen</parameter>"
msgstr " <parameter> namelen </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7906
#, fuzzy
msgid "Length of string <parameter>dirname</parameter>"
msgstr "Comprimento da corda <parameter> dirname </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7912
#, fuzzy
msgid "Devfs directory entry for directory being created."
msgstr "Entrada do diret�rio Devfs para o diret�rio que est� sendo criado."

#. (itstool) path: sect4/para
#: book.translate.xml:7919
#, fuzzy
msgid ""
"Fill out the label on a devfs_dirent being created for the passed directory. "
"This call will be made when the device file system is mounted, regenerated, "
"or a new device requiring a specific directory hierarchy is made available."
msgstr ""
"Preencha o r�tulo em um devfs_dirent que est� sendo criado para o diret�rio "
"passado. Essa chamada ser� feita quando o sistema de arquivos do dispositivo "
"for montado, regenerado ou um novo dispositivo que exija uma hierarquia de "
"diret�rio espec�fica seja disponibilizado."

#. (itstool) path: sect4/title
#: book.translate.xml:7927
#, fuzzy
msgid "<function>mpo_create_devfs_symlink</function>"
msgstr " <function> mpo_create_devfs_symlink </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7930
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_devfs_symlink</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct devfs_dirent *<parameter>dd</parameter></paramdef> "
"<paramdef>struct label *<parameter>ddlabel</parameter></paramdef> "
"<paramdef>struct devfs_dirent *<parameter>de</parameter></paramdef> "
"<paramdef>struct label *<parameter>delabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_devfs_symlink </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> montagem struct * <parameter> mp </parameter></"
"paramdef><paramdef> struct devfs_dirent * <parameter> dd </parameter></"
"paramdef><paramdef> label struct * <parameter> ddlabel </parameter></"
"paramdef><paramdef> struct devfs_dirent * <parameter> de </parameter></"
"paramdef><paramdef> label struct * <parameter> delabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:7967 book.translate.xml:8050 book.translate.xml:8139
#: book.translate.xml:8254 book.translate.xml:8320 book.translate.xml:8530
#: book.translate.xml:8588 book.translate.xml:8715 book.translate.xml:8780
#: book.translate.xml:8981 book.translate.xml:9792 book.translate.xml:10122
#: book.translate.xml:10164 book.translate.xml:10208 book.translate.xml:10387
#: book.translate.xml:10430 book.translate.xml:10479 book.translate.xml:10527
#: book.translate.xml:10578 book.translate.xml:10631 book.translate.xml:10674
#: book.translate.xml:10723 book.translate.xml:10790 book.translate.xml:10847
#: book.translate.xml:10906 book.translate.xml:10969 book.translate.xml:11027
#: book.translate.xml:11086 book.translate.xml:11148 book.translate.xml:11217
#: book.translate.xml:11275 book.translate.xml:11392 book.translate.xml:11448
#: book.translate.xml:11513 book.translate.xml:11574 book.translate.xml:11629
#: book.translate.xml:11694 book.translate.xml:11759 book.translate.xml:11820
#: book.translate.xml:11890 book.translate.xml:11952 book.translate.xml:12014
#: book.translate.xml:12096 book.translate.xml:12183 book.translate.xml:12252
#: book.translate.xml:12317 book.translate.xml:12390 book.translate.xml:12476
#: book.translate.xml:12552 book.translate.xml:12616 book.translate.xml:12676
#: book.translate.xml:12804 book.translate.xml:12886 book.translate.xml:12969
#: book.translate.xml:13029 book.translate.xml:13097 book.translate.xml:13160
#: book.translate.xml:13222 book.translate.xml:13288 book.translate.xml:13354
#: book.translate.xml:13432 book.translate.xml:13518 book.translate.xml:13586
#: book.translate.xml:13655 book.translate.xml:13727 book.translate.xml:13797
#: book.translate.xml:13854 book.translate.xml:13915 book.translate.xml:13983
#: book.translate.xml:14059 book.translate.xml:14132 book.translate.xml:14251
#: book.translate.xml:14294 book.translate.xml:14342 book.translate.xml:14388
#: book.translate.xml:14449
#, fuzzy
msgid "<parameter>cred</parameter>"
msgstr " <parameter> Eu </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7968 book.translate.xml:8051 book.translate.xml:8140
#: book.translate.xml:8255 book.translate.xml:8321 book.translate.xml:8531
#: book.translate.xml:8589 book.translate.xml:8716 book.translate.xml:8781
#: book.translate.xml:8982 book.translate.xml:9793 book.translate.xml:10209
#: book.translate.xml:10388 book.translate.xml:10431 book.translate.xml:10480
#: book.translate.xml:10528 book.translate.xml:10579 book.translate.xml:10632
#: book.translate.xml:10675 book.translate.xml:10724 book.translate.xml:10791
#: book.translate.xml:10848 book.translate.xml:10907 book.translate.xml:10970
#: book.translate.xml:11028 book.translate.xml:11087 book.translate.xml:11149
#: book.translate.xml:11218 book.translate.xml:11276 book.translate.xml:11332
#: book.translate.xml:11393 book.translate.xml:11449 book.translate.xml:11514
#: book.translate.xml:11575 book.translate.xml:11630 book.translate.xml:11695
#: book.translate.xml:11760 book.translate.xml:11821 book.translate.xml:11891
#: book.translate.xml:11953 book.translate.xml:12015 book.translate.xml:12097
#: book.translate.xml:12184 book.translate.xml:12253 book.translate.xml:12318
#: book.translate.xml:12391 book.translate.xml:12477 book.translate.xml:12553
#: book.translate.xml:12677 book.translate.xml:12736 book.translate.xml:12805
#: book.translate.xml:12887 book.translate.xml:12970 book.translate.xml:13030
#: book.translate.xml:13098 book.translate.xml:13161 book.translate.xml:13223
#: book.translate.xml:13289 book.translate.xml:13355 book.translate.xml:13433
#: book.translate.xml:13519 book.translate.xml:13587 book.translate.xml:13656
#: book.translate.xml:13728 book.translate.xml:13798 book.translate.xml:13855
#: book.translate.xml:13916 book.translate.xml:13984 book.translate.xml:14060
#: book.translate.xml:14133 book.translate.xml:14198 book.translate.xml:14252
#: book.translate.xml:14295 book.translate.xml:14343 book.translate.xml:14389
#: book.translate.xml:14450
#, fuzzy
msgid "Subject credential"
msgstr "Sujeito credencial"

#. (itstool) path: row/entry
#: book.translate.xml:7977
#, fuzzy
msgid "<parameter>dd</parameter>"
msgstr " <parameter> dd </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7978
#, fuzzy
msgid "Link destination"
msgstr "Destino do link"

#. (itstool) path: row/entry
#: book.translate.xml:7982
#, fuzzy
msgid "<parameter>ddlabel</parameter>"
msgstr " <parameter> ddlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7983
#, fuzzy
msgid "Label associated with <parameter>dd</parameter>"
msgstr "Etiqueta associada a <parameter> dd </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7989
#, fuzzy
msgid "Symlink entry"
msgstr "Entrada no Symlink"

#. (itstool) path: row/entry
#: book.translate.xml:7994
#, fuzzy
msgid "Label associated with <parameter>de</parameter>"
msgstr "Etiqueta associada a <parameter> de </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8001
#, fuzzy
msgid ""
"Fill in the label (<parameter>delabel</parameter>) for a newly created "
"<citerefentry vendor=\"current\"><refentrytitle>devfs</"
"refentrytitle><manvolnum>5</manvolnum></citerefentry> symbolic link entry."
msgstr ""
"Preencha o r�tulo ( <parameter> delabel </parameter> ) para um rec�m criado "
"<citerefentry vendor=\"current\"><refentrytitle> devfs </"
"refentrytitle><manvolnum> 5 </manvolnum></citerefentry> entrada de link "
"simb�lico \""

#. (itstool) path: sect4/title
#: book.translate.xml:8006
#, fuzzy
msgid "<function>mpo_create_vnode_extattr</function>"
msgstr " <function> mpo_create_vnode_extattr </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8009
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_create_vnode_extattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef> "
"<paramdef>struct componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_create_vnode_extattr </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> montagem struct * <parameter> mp </parameter></"
"paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> dvp </parameter></"
"paramdef><paramdef> label struct * <parameter> dlabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vlabel </parameter></"
"paramdef><paramdef> struct componentname * <parameter> cnp </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8055
#, fuzzy
msgid "<parameter>mount</parameter>"
msgstr " <parameter> montar </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8065 book.translate.xml:11895 book.translate.xml:11957
#: book.translate.xml:12019 book.translate.xml:12101 book.translate.xml:12481
#: book.translate.xml:12809 book.translate.xml:12891 book.translate.xml:13034
#: book.translate.xml:13165
#, fuzzy
msgid "<parameter>dvp</parameter>"
msgstr " <parameter> dvp </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8066 book.translate.xml:12102
#, fuzzy
msgid "Parent directory vnode"
msgstr "Diret�rio pai vnode"

#. (itstool) path: row/entry
#: book.translate.xml:8070 book.translate.xml:11900 book.translate.xml:11962
#: book.translate.xml:12024 book.translate.xml:12106 book.translate.xml:12486
#: book.translate.xml:12814 book.translate.xml:12896 book.translate.xml:13039
#: book.translate.xml:13170
#, fuzzy
msgid "<parameter>dlabel</parameter>"
msgstr " <parameter> dlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8071
#, fuzzy
msgid "Label associated with <parameter>dvp</parameter>"
msgstr "Etiqueta associada a <parameter> dvp </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8077
#, fuzzy
msgid "Newly created vnode"
msgstr "Vnode recentemente criado"

#. (itstool) path: row/entry
#: book.translate.xml:8087 book.translate.xml:12030 book.translate.xml:12123
#: book.translate.xml:12503 book.translate.xml:12831 book.translate.xml:12919
#: book.translate.xml:13045
#, fuzzy
msgid "<parameter>cnp</parameter>"
msgstr " <parameter> CNP </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8088 book.translate.xml:12124 book.translate.xml:12832
#, fuzzy
msgid "Component name for <parameter>vp</parameter>"
msgstr "Nome do componente para <parameter> vp </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8095
#, fuzzy
msgid ""
"Write out the label for <parameter>vp</parameter> to the appropriate "
"extended attribute. If the write succeeds, fill in <parameter>vlabel</"
"parameter> with the label, and return <returnvalue>0</returnvalue>. "
"Otherwise, return an appropriate error."
msgstr ""
"Escreva o r�tulo para <parameter> vp </parameter> para o atributo estendido "
"apropriado. Se a grava��o for bem-sucedida, preencha <parameter> vlabel </"
"parameter> com o r�tulo e retornar <returnvalue> 0 </returnvalue> . Caso "
"contr�rio, retorne um erro apropriado. "

#. (itstool) path: sect4/title
#: book.translate.xml:8103
#, fuzzy
msgid "<function>mpo_create_mount</function>"
msgstr " <function> mpo_create_mount </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8106
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mount</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>mnt</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mount </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> montagem "
"struct * <parameter> mp </parameter></paramdef><paramdef> label struct * "
"<parameter> mnt </parameter></paramdef><paramdef> label struct * <parameter> "
"fslabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8145
#, fuzzy
msgid "Object; file system being mounted"
msgstr "Objeto; sistema de arquivos sendo montado"

#. (itstool) path: row/entry
#: book.translate.xml:8150
#, fuzzy
msgid "Policy label to be filled in for <parameter>mp</parameter>"
msgstr ""
"Etiqueta de pol�tica a ser preenchida para <parameter> mp </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8156
#, fuzzy
msgid "Policy label for the file system <parameter>mp</parameter> mounts."
msgstr ""
"R�tulo de Pol�tica para o Sistema de Arquivos <parameter> mp </parameter> "
"montagens. "

#. (itstool) path: sect4/para
#: book.translate.xml:8163
#, fuzzy
msgid ""
"Fill out the labels on the mount point being created by the passed subject "
"credential. This call will be made when a new file system is mounted."
msgstr ""
"Preencha os r�tulos no ponto de montagem que est� sendo criado pela "
"credencial de assunto passada. Essa chamada ser� feita quando um novo "
"sistema de arquivos for montado."

#. (itstool) path: sect4/title
#: book.translate.xml:8169
#, fuzzy
msgid "<function>mpo_create_root_mount</function>"
msgstr " <function> mpo_create_root_mount </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8172
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_root_mount</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>mntlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_root_mount </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> montagem struct * <parameter> mp </parameter></"
"paramdef><paramdef> label struct * <parameter> mntlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8205
#, fuzzy
msgid "See <xref linkend=\"mac-mpo-create-mount\"/>."
msgstr "Vejo <xref linkend=\"mac-mpo-create-mount\"/> "

#. (itstool) path: sect4/para
#: book.translate.xml:8211
#, fuzzy
msgid ""
"Fill out the labels on the mount point being created by the passed subject "
"credential. This call will be made when the root file system is mounted, "
"after mpo_create_mount;."
msgstr ""
"Preencha os r�tulos no ponto de montagem que est� sendo criado pela "
"credencial de assunto passada. Essa chamada ser� feita quando o sistema de "
"arquivos raiz for montado, ap�s mpo_create_mount ;."

#. (itstool) path: sect4/title
#: book.translate.xml:8218
#, fuzzy
msgid "<function>mpo_relabel_vnode</function>"
msgstr " <function> mpo_relabel_vnode </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8221
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_relabel_vnode</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_relabel_vnode </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vnodelabel </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8260
#, fuzzy
msgid "vnode to relabel"
msgstr "vnode para reclassificar"

#. (itstool) path: row/entry
#: book.translate.xml:8264 book.translate.xml:8405 book.translate.xml:9998
#: book.translate.xml:10071 book.translate.xml:11641
#, fuzzy
msgid "<parameter>vnodelabel</parameter>"
msgstr " <parameter> vnodelabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8265 book.translate.xml:11642
#, fuzzy
msgid "Existing policy label for <parameter>vp</parameter>"
msgstr "Etiqueta de pol�tica existente para <parameter> vp </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8270 book.translate.xml:8731 book.translate.xml:8797
#: book.translate.xml:8861 book.translate.xml:9808 book.translate.xml:10213
#: book.translate.xml:10922 book.translate.xml:11464 book.translate.xml:11529
#: book.translate.xml:11579 book.translate.xml:11647
#, fuzzy
msgid "<parameter>newlabel</parameter>"
msgstr " <parameter> newlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8271
#, fuzzy
msgid ""
"New, possibly partial label to replace <parameter>vnodelabel</parameter>"
msgstr ""
"Etiqueta nova, possivelmente parcial, para substituir <parameter> vnodelabel "
"</parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8278
#, fuzzy
msgid ""
"Update the label on the passed vnode given the passed update vnode label and "
"the passed subject credential."
msgstr ""
"Atualize o r�tulo no vnode passado, dado o r�tulo vnode da atualiza��o "
"passada e a credencial de assunto passada."

#. (itstool) path: sect4/title
#: book.translate.xml:8284
#, fuzzy
msgid "<function>mpo_setlabel_vnode_extattr</function>"
msgstr " <function> mpo_setlabel_vnode_extattr </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8287
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_setlabel_vnode_extattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>intlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_setlabel_vnode_extattr </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> intlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8326
#, fuzzy
msgid "Vnode for which the label is being written"
msgstr "Vnode para o qual o r�tulo est� sendo gravado"

#. (itstool) path: row/entry
#: book.translate.xml:8337
#, fuzzy
msgid "<parameter>intlabel</parameter>"
msgstr " <parameter> louco </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8338
#, fuzzy
msgid "Label to write out"
msgstr "Etiqueta para escrever"

#. (itstool) path: sect4/para
#: book.translate.xml:8344
#, fuzzy
msgid ""
"Write out the policy from <parameter>intlabel</parameter> to an extended "
"attribute. This is called from <function>vop_stdcreatevnode_ea</function>."
msgstr ""
"Escreva a pol�tica de <parameter> intlabel </parameter> para um atributo "
"estendido. Isso � chamado de <function> vop_stdcreatevnode_ea </function> "

#. (itstool) path: sect4/title
#: book.translate.xml:8351
#, fuzzy
msgid "<function>mpo_update_devfsdirent</function>"
msgstr " <function> mpo_update_devfsdirent </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8354
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_update_devfsdirent</function></funcdef> "
"<paramdef>struct devfs_dirent *<parameter>devfs_dirent</parameter></"
"paramdef> <paramdef>struct label *<parameter>direntlabel</parameter></"
"paramdef> <paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_update_devfsdirent </function></"
"funcdef><paramdef> struct devfs_dirent * <parameter> devfs_dirent </"
"parameter></paramdef><paramdef> label struct * <parameter> direntlabel </"
"parameter></paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vnodelabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8388
#, fuzzy
msgid "Object; devfs directory entry"
msgstr "Objeto; entrada do diret�rio devfs"

#. (itstool) path: row/entry
#: book.translate.xml:8392
#, fuzzy
msgid "<parameter>direntlabel</parameter>"
msgstr " <parameter> direntlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8393
#, fuzzy
msgid "Policy label for <parameter>devfs_dirent</parameter> to be updated."
msgstr ""
"Etiqueta de pol�tica para <parameter> devfs_dirent </parameter> ser "
"atualizado."

#. (itstool) path: row/entry
#: book.translate.xml:8400
#, fuzzy
msgid "Parent vnode"
msgstr "Parent vnode"

#. (itstool) path: row/entry
#: book.translate.xml:8401 book.translate.xml:9994 book.translate.xml:11637
#: book.translate.xml:12191
#, fuzzy
msgid "Locked"
msgstr "Bloqueado"

#. (itstool) path: row/entry
#: book.translate.xml:8406 book.translate.xml:9999 book.translate.xml:10072
#: book.translate.xml:11831 book.translate.xml:12118 book.translate.xml:12196
#: book.translate.xml:12263 book.translate.xml:12328 book.translate.xml:12401
#: book.translate.xml:13108 book.translate.xml:13233 book.translate.xml:13299
#: book.translate.xml:13365 book.translate.xml:13443 book.translate.xml:13529
#: book.translate.xml:13597 book.translate.xml:13666 book.translate.xml:13738
#: book.translate.xml:13926
#, fuzzy
msgid "Policy label for <parameter>vp</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> vp </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8413
#, fuzzy
msgid ""
"Update the <parameter>devfs_dirent</parameter> label from the passed devfs "
"vnode label. This call will be made when a devfs vnode has been successfully "
"relabeled to commit the label change such that it lasts even if the vnode is "
"recycled. It will also be made when a symlink is created in devfs, following "
"a call to <function>mac_vnode_create_from_vnode</function> to initialize the "
"vnode label."
msgstr ""
"Atualizar o <parameter> devfs_dirent </parameter> label do r�tulo vnode "
"devfs passado. Essa chamada ser� feita quando um devfs vnode tiver sido "
"renomeado com sucesso para confirmar a mudan�a de r�tulo, de modo que ele "
"dure mesmo que o vnode seja reciclado. Tamb�m ser� feito quando um link "
"simb�lico � criado no devfs, ap�s uma chamada para <function> "
"mac_vnode_create_from_vnode </function> para inicializar o r�tulo vnode. "

#. (itstool) path: sect3/title
#: book.translate.xml:8425
#, fuzzy
msgid "IPC Object Labeling Event Operations"
msgstr "Opera��es de evento de rotulagem de objeto IPC"

#. (itstool) path: sect4/title
#: book.translate.xml:8428
#, fuzzy
msgid "<function>mpo_create_mbuf_from_socket</function>"
msgstr " <function> mpo_create_mbuf_from_socket </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8431
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_from_socket</function></funcdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>m</parameter></paramdef> <paramdef>struct "
"label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_from_socket </function></"
"funcdef><paramdef> soquete de estrutura * <parameter> assim </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> m </parameter></"
"paramdef><paramdef> label struct * <parameter> mbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8464 book.translate.xml:11091 book.translate.xml:11153
#: book.translate.xml:11397 book.translate.xml:11518 book.translate.xml:12974
#, fuzzy
msgid "<parameter>socket</parameter>"
msgstr " <parameter> soquete </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8465 book.translate.xml:11223 book.translate.xml:11281
#, fuzzy
msgid "Socket"
msgstr "Soquete"

#. (itstool) path: row/entry
#: book.translate.xml:8466
#, fuzzy
msgid "Socket locking WIP"
msgstr "Socket locking WIP"

#. (itstool) path: row/entry
#: book.translate.xml:8470 book.translate.xml:8599 book.translate.xml:11096
#: book.translate.xml:11158 book.translate.xml:11227 book.translate.xml:11285
#: book.translate.xml:11402 book.translate.xml:11523 book.translate.xml:12979
#: book.translate.xml:14143
#, fuzzy
msgid "<parameter>socketlabel</parameter>"
msgstr " <parameter> socketlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8471 book.translate.xml:11097 book.translate.xml:11159
#: book.translate.xml:11403 book.translate.xml:12980
#, fuzzy
msgid "Policy label for <parameter>socket</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> soquete </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8476
#, fuzzy
msgid "<parameter>m</parameter>"
msgstr " <parameter> m </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8477
#, fuzzy
msgid "Object; mbuf"
msgstr "Objeto; mbuf"

#. (itstool) path: row/entry
#: book.translate.xml:8481 book.translate.xml:8851 book.translate.xml:9378
#: book.translate.xml:9446 book.translate.xml:9513 book.translate.xml:9864
#: book.translate.xml:14004 book.translate.xml:14080
#, fuzzy
msgid "<parameter>mbuflabel</parameter>"
msgstr " <parameter> mbuflabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8482
#, fuzzy
msgid "Policy label to fill in for <parameter>m</parameter>"
msgstr "Etiqueta de pol�tica a preencher para <parameter> m </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8489
#, fuzzy
msgid ""
"Set the label on a newly created mbuf header from the passed socket label. "
"This call is made when a new datagram or message is generated by the socket "
"and stored in the passed mbuf."
msgstr ""
"Configure o r�tulo em um cabe�alho mbuf rec�m-criado a partir do r�tulo do "
"soquete passado. Essa chamada � feita quando um novo datagrama ou mensagem � "
"gerado pelo soquete e armazenado no mbuf passado."

#. (itstool) path: sect4/title
#: book.translate.xml:8496
#, fuzzy
msgid "<function>mpo_create_pipe</function>"
msgstr " <function> mpo_create_pipe </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8499
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_pipe</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_pipe </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> pipe de "
"estrutura * <parameter> tubo </parameter></paramdef><paramdef> label struct "
"* <parameter> pipelabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8535 book.translate.xml:8720 book.translate.xml:10728
#: book.translate.xml:10795 book.translate.xml:10852 book.translate.xml:10911
#: book.translate.xml:10974 book.translate.xml:11032
#, fuzzy
msgid "<parameter>pipe</parameter>"
msgstr " <parameter> tubo </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8536 book.translate.xml:8721 book.translate.xml:10729
#: book.translate.xml:10796 book.translate.xml:10853 book.translate.xml:10912
#: book.translate.xml:10975 book.translate.xml:11033
#, fuzzy
msgid "Pipe"
msgstr "Tubo"

#. (itstool) path: row/entry
#: book.translate.xml:8540 book.translate.xml:10733 book.translate.xml:10800
#: book.translate.xml:10857 book.translate.xml:10916 book.translate.xml:10979
#: book.translate.xml:11037
#, fuzzy
msgid "<parameter>pipelabel</parameter>"
msgstr " <parameter> pipelabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8541 book.translate.xml:10734 book.translate.xml:10801
#: book.translate.xml:10858 book.translate.xml:10980 book.translate.xml:11038
#, fuzzy
msgid "Policy label associated with <parameter>pipe</parameter>"
msgstr "Etiqueta de pol�tica associada a <parameter> tubo </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8548
#, fuzzy
msgid ""
"Set the label on a newly created pipe from the passed subject credential. "
"This call is made when a new pipe is created."
msgstr ""
"Configure o r�tulo em um pipe rec�m-criado a partir da credencial de assunto "
"passada. Essa chamada � feita quando um novo canal � criado."

#. (itstool) path: sect4/title
#: book.translate.xml:8554
#, fuzzy
msgid "<function>mpo_create_socket</function>"
msgstr " <function> mpo_create_socket </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8557
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_socket</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_socket </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> assim </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8590 book.translate.xml:8782 book.translate.xml:8983
#: book.translate.xml:9984 book.translate.xml:10062 book.translate.xml:11631
#: book.translate.xml:11761 book.translate.xml:12185 book.translate.xml:14134
#, fuzzy
msgid "Immutable"
msgstr "Imut�vel"

#. (itstool) path: row/entry
#: book.translate.xml:8594 book.translate.xml:8786 book.translate.xml:11222
#: book.translate.xml:11280 book.translate.xml:14138
#, fuzzy
msgid "<parameter>so</parameter>"
msgstr " <parameter> assim </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8595
#, fuzzy
msgid "Object; socket to label"
msgstr "Objeto; soquete para rotular"

#. (itstool) path: row/entry
#: book.translate.xml:8600
#, fuzzy
msgid "Label to fill in for <parameter>so</parameter>"
msgstr "R�tulo para preencher para <parameter> assim </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8607
#, fuzzy
msgid ""
"Set the label on a newly created socket from the passed subject credential. "
"This call is made when a socket is created."
msgstr ""
"Configure o r�tulo em um soquete rec�m-criado a partir da credencial de "
"assunto passada. Essa chamada � feita quando um soquete � criado."

#. (itstool) path: sect4/title
#: book.translate.xml:8613
#, fuzzy
msgid "<function>mpo_create_socket_from_socket</function>"
msgstr " <function> mpo_create_socket_from_socket </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8616
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_socket_from_socket</function></funcdef> "
"<paramdef>struct socket *<parameter>oldsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldsocketlabel</parameter></paramdef> "
"<paramdef>struct socket *<parameter>newsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>newsocketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_socket_from_socket </function></"
"funcdef><paramdef> soquete de estrutura * <parameter> oldsocket </"
"parameter></paramdef><paramdef> label struct * <parameter> oldsocketlabel </"
"parameter></paramdef><paramdef> soquete de estrutura * <parameter> boletim "
"de not�cias </parameter></paramdef><paramdef> label struct * <parameter> "
"newsocketlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8649 book.translate.xml:8911
#, fuzzy
msgid "<parameter>oldsocket</parameter>"
msgstr " <parameter> oldsocket </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8650
#, fuzzy
msgid "Listening socket"
msgstr "Tomada de escuta"

#. (itstool) path: row/entry
#: book.translate.xml:8654 book.translate.xml:8916
#, fuzzy
msgid "<parameter>oldsocketlabel</parameter>"
msgstr " <parameter> oldsocketlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8655
#, fuzzy
msgid "Policy label associated with <parameter>oldsocket</parameter>"
msgstr "Etiqueta de pol�tica associada a <parameter> oldsocket </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8660 book.translate.xml:8922
#, fuzzy
msgid "<parameter>newsocket</parameter>"
msgstr " <parameter> newsocket </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8661
#, fuzzy
msgid "New socket"
msgstr "Novo soquete"

#. (itstool) path: row/entry
#: book.translate.xml:8665
#, fuzzy
msgid "<parameter>newsocketlabel</parameter>"
msgstr " <parameter> newsocketlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8666
#, fuzzy
msgid "Policy label associated with <parameter>newsocketlabel</parameter>"
msgstr ""
"Etiqueta de pol�tica associada a <parameter> newsocketlabel </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8673
#, fuzzy
msgid ""
"Label a socket, <parameter>newsocket</parameter>, newly "
"<citerefentry><refentrytitle>accept</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>ed, based on the <citerefentry><refentrytitle>listen</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> socket, "
"<parameter>oldsocket</parameter>."
msgstr ""
"Etiquetar um soquete, <parameter> boletim de not�cias </parameter> "
"recentemente <citerefentry><refentrytitle> aceitar </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> ed, com base no "
"<citerefentry><refentrytitle> ou�o </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> soquete <parameter> oldsocket </parameter> "

#. (itstool) path: sect4/title
#: book.translate.xml:8679
#, fuzzy
msgid "<function>mpo_relabel_pipe</function>"
msgstr " <function> mpo_relabel_pipe </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8682
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_relabel_pipe</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_relabel_pipe </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> pipe de "
"estrutura * <parameter> tubo </parameter></paramdef><paramdef> label struct "
"* <parameter> oldlabel </parameter></paramdef><paramdef> label struct * "
"<parameter> newlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8725 book.translate.xml:8791 book.translate.xml:8856
#, fuzzy
msgid "<parameter>oldlabel</parameter>"
msgstr " <parameter> oldlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8726 book.translate.xml:10917
#, fuzzy
msgid "Current policy label associated with <parameter>pipe</parameter>"
msgstr "Etiqueta de pol�tica atual associada a <parameter> tubo </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8732
#, fuzzy
msgid "Policy label update to apply to <parameter>pipe</parameter>"
msgstr ""
"Atualiza��o de r�tulo de pol�tica a ser aplicada a <parameter> tubo </"
"parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8739
#, fuzzy
msgid ""
"Apply a new label, <parameter>newlabel</parameter>, to <parameter>pipe</"
"parameter>."
msgstr ""
"Aplique um novo r�tulo, <parameter> newlabel </parameter> , para <parameter> "
"tubo </parameter> "

#. (itstool) path: sect4/title
#: book.translate.xml:8744
#, fuzzy
msgid "<function>mpo_relabel_socket</function>"
msgstr " <function> mpo_relabel_socket </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8747
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_relabel_socket</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_relabel_socket </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> assim </parameter></"
"paramdef><paramdef> label struct * <parameter> oldlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8787 book.translate.xml:11398 book.translate.xml:11519
#: book.translate.xml:12975 book.translate.xml:14139
#, fuzzy
msgid "Object; socket"
msgstr "Objeto; soquete"

#. (itstool) path: row/entry
#: book.translate.xml:8792
#, fuzzy
msgid "Current label for <parameter>so</parameter>"
msgstr "Etiqueta atual para <parameter> assim </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8798
#, fuzzy
msgid "Label update for <parameter>so</parameter>"
msgstr "Atualiza��o de etiqueta para <parameter> assim </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8805
#, fuzzy
msgid "Update the label on a socket from the passed socket label update."
msgstr ""
"Atualize o r�tulo em um soquete da atualiza��o do r�tulo do soquete passado."

#. (itstool) path: sect4/title
#: book.translate.xml:8810
#, fuzzy
msgid "<function>mpo_set_socket_peer_from_mbuf</function>"
msgstr " <function> mpo_set_socket_peer_from_mbuf </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8813
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_set_socket_peer_from_mbuf</function></funcdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_set_socket_peer_from_mbuf </function></"
"funcdef><paramdef> struct mbuf * <parameter> mbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> mbuflabel </parameter></"
"paramdef><paramdef> label struct * <parameter> oldlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8846 book.translate.xml:9373 book.translate.xml:9441
#: book.translate.xml:9508 book.translate.xml:9859 book.translate.xml:13999
#: book.translate.xml:14075
#, fuzzy
msgid "<parameter>mbuf</parameter>"
msgstr " <parameter> mbuf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8847
#, fuzzy
msgid "First datagram received over socket"
msgstr "Primeiro datagrama recebido por soquete"

#. (itstool) path: row/entry
#: book.translate.xml:8852
#, fuzzy
msgid "Label for <parameter>mbuf</parameter>"
msgstr "R�tulo para <parameter> mbuf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8857
#, fuzzy
msgid "Current label for the socket"
msgstr "Etiqueta atual para o soquete"

#. (itstool) path: row/entry
#: book.translate.xml:8862
#, fuzzy
msgid "Policy label to be filled out for the socket"
msgstr "Etiqueta de pol�tica a ser preenchida para o socket"

#. (itstool) path: sect4/para
#: book.translate.xml:8869
#, fuzzy
msgid ""
"Set the peer label on a stream socket from the passed mbuf label. This call "
"will be made when the first datagram is received by the stream socket, with "
"the exception of Unix domain sockets."
msgstr ""
"Configure o r�tulo peer em um soquete de fluxo a partir do r�tulo mbuf "
"passado. Essa chamada ser� feita quando o primeiro datagrama for recebido "
"pelo soquete de fluxo, com a exce��o dos soquetes de dom�nio Unix."

#. (itstool) path: sect4/title
#: book.translate.xml:8876
#, fuzzy
msgid "<function>mpo_set_socket_peer_from_socket</function>"
msgstr " <function> mpo_set_socket_peer_from_socket </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8879
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_set_socket_peer_from_socket</function></funcdef> "
"<paramdef>struct socket *<parameter>oldsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldsocketlabel</parameter></paramdef> "
"<paramdef>struct socket *<parameter>newsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>newsocketpeerlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_set_socket_peer_from_socket </function></"
"funcdef><paramdef> soquete de estrutura * <parameter> oldsocket </"
"parameter></paramdef><paramdef> label struct * <parameter> oldsocketlabel </"
"parameter></paramdef><paramdef> soquete de estrutura * <parameter> boletim "
"de not�cias </parameter></paramdef><paramdef> label struct * <parameter> "
"newsocketpeerlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8912
#, fuzzy
msgid "Local socket"
msgstr "Soquete local"

#. (itstool) path: row/entry
#: book.translate.xml:8917
#, fuzzy
msgid "Policy label for <parameter>oldsocket</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> oldsocket </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8923
#, fuzzy
msgid "Peer socket"
msgstr "Soquete do par"

#. (itstool) path: row/entry
#: book.translate.xml:8927
#, fuzzy
msgid "<parameter>newsocketpeerlabel</parameter>"
msgstr " <parameter> newsocketpeerlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8928
#, fuzzy
msgid "Policy label to fill in for <parameter>newsocket</parameter>"
msgstr ""
"Etiqueta de pol�tica a preencher para <parameter> boletim de not�cias </"
"parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8936
#, fuzzy
msgid ""
"Set the peer label on a stream UNIX domain socket from the passed remote "
"socket endpoint. This call will be made when the socket pair is connected, "
"and will be made for both endpoints."
msgstr ""
"Configure o r�tulo peer em um soquete de dom�nio UNIX de fluxo a partir do "
"terminal de soquete remoto passado. Essa chamada ser� feita quando o par de "
"soquetes estiver conectado e ser� feita para os dois terminais."

#. (itstool) path: sect3/title
#: book.translate.xml:8944
#, fuzzy
msgid "Network Object Labeling Event Operations"
msgstr "Opera��es de evento de rotulagem de objeto de rede"

#. (itstool) path: sect4/title
#: book.translate.xml:8947
#, fuzzy
msgid "<function>mpo_create_bpfdesc</function>"
msgstr " <function> mpo_create_bpfdesc </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8950
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_bpfdesc</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct bpf_d *<parameter>bpf_d</parameter></paramdef> "
"<paramdef>struct label *<parameter>bpflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_bpfdesc </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct bpf_d * <parameter> bpf_d </parameter></"
"paramdef><paramdef> label struct * <parameter> bpflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8987 book.translate.xml:9430 book.translate.xml:10323
#, fuzzy
msgid "<parameter>bpf_d</parameter>"
msgstr " <parameter> bpf_d </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8988
#, fuzzy
msgid "Object; bpf descriptor"
msgstr "Objeto; descritor bpf"

#. (itstool) path: row/entry
#: book.translate.xml:8992
#, fuzzy
msgid "<parameter>bpf</parameter>"
msgstr " <parameter> bpf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8993
#, fuzzy
msgid "Policy label to be filled in for <parameter>bpf_d</parameter>"
msgstr ""
"Etiqueta de pol�tica a ser preenchida para <parameter> bpf_d </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9000
#, fuzzy
msgid ""
"Set the label on a newly created BPF descriptor from the passed subject "
"credential. This call will be made when a BPF device node is opened by a "
"process with the passed subject credential."
msgstr ""
"Configure o r�tulo em um descritor BPF rec�m-criado a partir da credencial "
"de assunto passada. Essa chamada ser� feita quando um n� de dispositivo BPF "
"for aberto por um processo com a credencial de assunto passada."

#. (itstool) path: sect4/title
#: book.translate.xml:9007
#, fuzzy
msgid "<function>mpo_create_ifnet</function>"
msgstr " <function> mpo_create_ifnet </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9010
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_ifnet</function></funcdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_ifnet </function></funcdef><paramdef> "
"struct ifnet * <parameter> ifnet </parameter></paramdef><paramdef> label "
"struct * <parameter> ifnetlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9039 book.translate.xml:9362 book.translate.xml:9497
#: book.translate.xml:9577 book.translate.xml:9797 book.translate.xml:10334
#: book.translate.xml:11453 book.translate.xml:13988 book.translate.xml:14064
#, fuzzy
msgid "<parameter>ifnet</parameter>"
msgstr " <parameter> ifnet </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9040 book.translate.xml:9363 book.translate.xml:9498
#: book.translate.xml:9578 book.translate.xml:13989 book.translate.xml:14065
#, fuzzy
msgid "Network interface"
msgstr "Interface de rede"

#. (itstool) path: row/entry
#: book.translate.xml:9044 book.translate.xml:9367 book.translate.xml:9502
#: book.translate.xml:9582 book.translate.xml:9802 book.translate.xml:10339
#: book.translate.xml:11458 book.translate.xml:13993 book.translate.xml:14069
#, fuzzy
msgid "<parameter>ifnetlabel</parameter>"
msgstr " <parameter> ifnetlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9045
#, fuzzy
msgid "Policy label to fill in for <parameter>ifnet</parameter>"
msgstr "Etiqueta de pol�tica a preencher para <parameter> ifnet </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9052
#, fuzzy
msgid ""
"Set the label on a newly created interface. This call may be made when a new "
"physical interface becomes available to the system, or when a pseudo-"
"interface is instantiated during the boot or as a result of a user action."
msgstr ""
"Configure o r�tulo em uma interface rec�m-criada. Essa chamada pode ser "
"feita quando uma nova interface f�sica se torna dispon�vel para o sistema ou "
"quando uma pseudo-interface � instanciada durante a inicializa��o ou como "
"resultado de uma a��o do usu�rio."

#. (itstool) path: sect4/title
#: book.translate.xml:9060
#, fuzzy
msgid "<function>mpo_create_ipq</function>"
msgstr " <function> mpo_create_ipq </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9063
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_ipq</function></funcdef> <paramdef>struct "
"mbuf *<parameter>fragment</parameter></paramdef> <paramdef>struct label "
"*<parameter>fragmentlabel</parameter></paramdef> <paramdef>struct ipq "
"*<parameter>ipq</parameter></paramdef> <paramdef>struct label "
"*<parameter>ipqlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_ipq </function></funcdef><paramdef> "
"struct mbuf * <parameter> fragmento </parameter></paramdef><paramdef> label "
"struct * <parameter> fragmento </parameter></paramdef><paramdef> struct ipq "
"* <parameter> ipq </parameter></paramdef><paramdef> label struct * "
"<parameter> ipqlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9096 book.translate.xml:9239 book.translate.xml:9715
#, fuzzy
msgid "<parameter>fragment</parameter>"
msgstr " <parameter> fragmento </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9097
#, fuzzy
msgid "First received IP fragment"
msgstr "Primeiro fragmento IP recebido"

#. (itstool) path: row/entry
#: book.translate.xml:9101 book.translate.xml:9244 book.translate.xml:9720
#, fuzzy
msgid "<parameter>fragmentlabel</parameter>"
msgstr " <parameter> fragmento </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9102 book.translate.xml:9721
#, fuzzy
msgid "Policy label for <parameter>fragment</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> fragmento </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9107 book.translate.xml:9162 book.translate.xml:9726
#: book.translate.xml:9870
#, fuzzy
msgid "<parameter>ipq</parameter>"
msgstr " <parameter> ipq </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9108
#, fuzzy
msgid "IP reassembly queue to be labeled"
msgstr "Fila de remontagem de IP a ser rotulada"

#. (itstool) path: row/entry
#: book.translate.xml:9112 book.translate.xml:9167 book.translate.xml:9731
#: book.translate.xml:9875
#, fuzzy
msgid "<parameter>ipqlabel</parameter>"
msgstr " <parameter> ipglabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9113
#, fuzzy
msgid "Policy label to be filled in for <parameter>ipq</parameter>"
msgstr ""
"Etiqueta de pol�tica a ser preenchida para <parameter> ipq </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9120
#, fuzzy
msgid ""
"Set the label on a newly created IP fragment reassembly queue from the mbuf "
"header of the first received fragment."
msgstr ""
"Configure o r�tulo em uma fila de remontagem de fragmento IP rec�m-criada a "
"partir do cabe�alho mbuf do primeiro fragmento recebido."

#. (itstool) path: sect4/title
#: book.translate.xml:9126
#, fuzzy
msgid "<function>mpo_create_datagram_from_ipq</function>"
msgstr " <function> mpo_create_datagram_from_ipq </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9129
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_create_datagram_from_ipq</function></"
"funcdef> <paramdef>struct ipq *<parameter>ipq</parameter></paramdef> "
"<paramdef>struct label *<parameter>ipqlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>datagram</parameter></paramdef> "
"<paramdef>struct label *<parameter>datagramlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_create_datagram_from_ipq </function></"
"funcdef><paramdef> struct ipq * <parameter> ipq </parameter></"
"paramdef><paramdef> label struct * <parameter> ipqlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> datagrama </parameter></"
"paramdef><paramdef> label struct * <parameter> datagramlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9163
#, fuzzy
msgid "IP reassembly queue"
msgstr "Fila de remontagem de IP"

#. (itstool) path: row/entry
#: book.translate.xml:9168 book.translate.xml:9732
#, fuzzy
msgid "Policy label for <parameter>ipq</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> ipq </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9173 book.translate.xml:9228
#, fuzzy
msgid "<parameter>datagram</parameter>"
msgstr " <parameter> datagrama </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9174
#, fuzzy
msgid "Datagram to be labeled"
msgstr "Datagrama a ser rotulado"

#. (itstool) path: row/entry
#: book.translate.xml:9178 book.translate.xml:9233
#, fuzzy
msgid "<parameter>datagramlabel</parameter>"
msgstr " <parameter> etiqueta datagrama </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9179
#, fuzzy
msgid "Policy label to be filled in for <parameter>datagramlabel</parameter>"
msgstr ""
"Etiqueta de pol�tica a ser preenchida para <parameter> datagramlabel </"
"parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9186
#, fuzzy
msgid ""
"Set the label on a newly reassembled IP datagram from the IP fragment "
"reassembly queue from which it was generated."
msgstr ""
"Configure o r�tulo em um datagrama IP rec�m remontado da fila de remontagem "
"de fragmento IP a partir da qual ele foi gerado."

#. (itstool) path: sect4/title
#: book.translate.xml:9192
#, fuzzy
msgid "<function>mpo_create_fragment</function>"
msgstr " <function> mpo_create_fragment </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9195
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_fragment</function></funcdef> "
"<paramdef>struct mbuf *<parameter>datagram</parameter></paramdef> "
"<paramdef>struct label *<parameter>datagramlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>fragment</parameter></paramdef> "
"<paramdef>struct label *<parameter>fragmentlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_fragment </function></"
"funcdef><paramdef> struct mbuf * <parameter> datagrama </parameter></"
"paramdef><paramdef> label struct * <parameter> datagramlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> fragmento </parameter></"
"paramdef><paramdef> label struct * <parameter> fragmento </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9229
#, fuzzy
msgid "Datagram"
msgstr "Datagrama"

#. (itstool) path: row/entry
#: book.translate.xml:9234
#, fuzzy
msgid "Policy label for <parameter>datagram</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> datagrama </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9240
#, fuzzy
msgid "Fragment to be labeled"
msgstr "Fragmento a ser rotulado"

#. (itstool) path: row/entry
#: book.translate.xml:9245
#, fuzzy
msgid "Policy label to be filled in for <parameter>datagram</parameter>"
msgstr ""
"Etiqueta de pol�tica a ser preenchida para <parameter> datagrama </"
"parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9252
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created IP fragment from the "
"label on the mbuf header of the datagram it was generate from."
msgstr ""
"Configure o r�tulo no cabe�alho mbuf de um fragmento IP rec�m-criado a "
"partir do r�tulo no cabe�alho mbuf do datagrama do qual ele foi gerado."

#. (itstool) path: sect4/title
#: book.translate.xml:9258
#, fuzzy
msgid "<function>mpo_create_mbuf_from_mbuf</function>"
msgstr " <function> mpo_create_mbuf_from_mbuf </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9261
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_from_mbuf</function></funcdef> "
"<paramdef>struct mbuf *<parameter>oldmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldmbuflabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>newmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>newmbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_from_mbuf </function></"
"funcdef><paramdef> struct mbuf * <parameter> oldmbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> oldmbuflabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> newmbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> newmbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9294 book.translate.xml:9566 book.translate.xml:9646
#, fuzzy
msgid "<parameter>oldmbuf</parameter>"
msgstr " <parameter> oldmbuf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9295
#, fuzzy
msgid "Existing (source) mbuf"
msgstr "Existente (fonte) mbuf"

#. (itstool) path: row/entry
#: book.translate.xml:9299 book.translate.xml:9571 book.translate.xml:9651
#, fuzzy
msgid "<parameter>oldmbuflabel</parameter>"
msgstr " <parameter> oldmbuflabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9300 book.translate.xml:9572 book.translate.xml:9652
#, fuzzy
msgid "Policy label for <parameter>oldmbuf</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> oldmbuf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9305 book.translate.xml:9588 book.translate.xml:9657
#, fuzzy
msgid "<parameter>newmbuf</parameter>"
msgstr " <parameter> newmbuf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9306 book.translate.xml:9442
#, fuzzy
msgid "New mbuf to be labeled"
msgstr "Novo mbuf a ser rotulado"

#. (itstool) path: row/entry
#: book.translate.xml:9310 book.translate.xml:9594 book.translate.xml:9662
#, fuzzy
msgid "<parameter>newmbuflabel</parameter>"
msgstr " <parameter> newmbuflabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9311 book.translate.xml:9595
#, fuzzy
msgid "Policy label to be filled in for <parameter>newmbuf</parameter>"
msgstr ""
"Etiqueta de pol�tica a ser preenchida para <parameter> newmbuf </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9318
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram from the mbuf "
"header of an existing datagram. This call may be made in a number of "
"situations, including when an mbuf is re-allocated for alignment purposes."
msgstr ""
"Configure o r�tulo no cabe�alho mbuf de um datagrama rec�m-criado a partir "
"do cabe�alho mbuf de um datagrama existente. Essa chamada pode ser feita em "
"v�rias situa��es, inclusive quando um mbuf � realocado para fins de "
"alinhamento."

#. (itstool) path: sect4/title
#: book.translate.xml:9326
#, fuzzy
msgid "<function>mpo_create_mbuf_linklayer</function>"
msgstr " <function> mpo_create_mbuf_linklayer </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9329
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_linklayer</function></funcdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_linklayer </function></"
"funcdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> mbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> mbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9368 book.translate.xml:9583 book.translate.xml:9803
#: book.translate.xml:10340 book.translate.xml:13994 book.translate.xml:14070
#, fuzzy
msgid "Policy label for <parameter>ifnet</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> ifnet </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9374 book.translate.xml:9509
#, fuzzy
msgid "mbuf header for new datagram"
msgstr "cabe�alho mbuf para novo datagrama"

#. (itstool) path: row/entry
#: book.translate.xml:9379 book.translate.xml:9514
#, fuzzy
msgid "Policy label to be filled in for <parameter>mbuf</parameter>"
msgstr ""
"Etiqueta de pol�tica a ser preenchida para <parameter> mbuf </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9386
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram generated for "
"the purposes of a link layer response for the passed interface. This call "
"may be made in a number of situations, including for ARP or ND6 responses in "
"the IPv4 and IPv6 stacks."
msgstr ""
"Defina o r�tulo no cabe�alho mbuf de um datagrama rec�m-criado gerado para "
"fins de uma resposta de camada de link para a interface passada. Essa "
"chamada pode ser feita em v�rias situa��es, incluindo respostas ARP ou ND6 "
"nas pilhas IPv4 e IPv6 "

#. (itstool) path: sect4/title
#: book.translate.xml:9394
#, fuzzy
msgid "<function>mpo_create_mbuf_from_bpfdesc</function>"
msgstr " <function> mpo_create_mbuf_from_bpfdesc </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9397
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_from_bpfdesc</function></funcdef> "
"<paramdef>struct bpf_d *<parameter>bpf_d</parameter></paramdef> "
"<paramdef>struct label *<parameter>bpflabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_from_bpfdesc </function></"
"funcdef><paramdef> struct bpf_d * <parameter> bpf_d </parameter></"
"paramdef><paramdef> label struct * <parameter> bpflabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> mbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> mbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9431
#, fuzzy
msgid "BPF descriptor"
msgstr "Descritor BPF"

#. (itstool) path: row/entry
#: book.translate.xml:9435 book.translate.xml:10328
#, fuzzy
msgid "<parameter>bpflabel</parameter>"
msgstr " <parameter> bpflabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9436
#, fuzzy
msgid "Policy label for <parameter>bpflabel</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> bpflabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9447
#, fuzzy
msgid "Policy label to fill in for <parameter>mbuf</parameter>"
msgstr "Etiqueta de pol�tica a preencher para <parameter> mbuf </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9454
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram generated using "
"the passed BPF descriptor. This call is made when a write is performed to "
"the BPF device associated with the passed BPF descriptor."
msgstr ""
"Definir o r�tulo no cabe�alho mbuf de um datagrama rec�m-criado gerado "
"usando o descritor BPF passado. Essa chamada � feita quando uma grava��o � "
"executada para o dispositivo BPF associado ao descritor BPF passado."

#. (itstool) path: sect4/title
#: book.translate.xml:9461
#, fuzzy
msgid "<function>mpo_create_mbuf_from_ifnet</function>"
msgstr " <function> mpo_create_mbuf_from_ifnet </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9464
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_from_ifnet</function></funcdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_from_ifnet </function></"
"funcdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> mbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> mbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9503
#, fuzzy
msgid "Policy label for <parameter>ifnetlabel</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> ifnetlabel </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9521
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram generated from "
"the passed network interface."
msgstr ""
"Configure o r�tulo no cabe�alho mbuf de um datagrama rec�m-criado gerado a "
"partir da interface de rede passada."

#. (itstool) path: sect4/title
#: book.translate.xml:9527
#, fuzzy
msgid "<function>mpo_create_mbuf_multicast_encap</function>"
msgstr " <function> mpo_create_mbuf_multicast_encap </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9530
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_multicast_encap</function></funcdef> "
"<paramdef>struct mbuf *<parameter>oldmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldmbuflabel</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>newmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>newmbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_multicast_encap </function></"
"funcdef><paramdef> struct mbuf * <parameter> oldmbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> oldmbuflabel </parameter></"
"paramdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> newmbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> newmbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9567
#, fuzzy
msgid "mbuf header for existing datagram"
msgstr "cabe�alho mbuf para datagrama existente"

#. (itstool) path: row/entry
#: book.translate.xml:9589
#, fuzzy
msgid "mbuf header to be labeled for new datagram"
msgstr "cabe�alho mbuf a ser rotulado para novo datagrama"

#. (itstool) path: sect4/para
#: book.translate.xml:9602
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram generated from "
"the existing passed datagram when it is processed by the passed multicast "
"encapsulation interface. This call is made when an mbuf is to be delivered "
"using the virtual interface."
msgstr ""
"Configure o r�tulo no cabe�alho mbuf de um datagrama rec�m-criado gerado a "
"partir do datagrama passado existente quando ele � processado pela interface "
"de encapsulamento de difus�o m�ltipla passada. Essa chamada � feita quando "
"um mbuf deve ser entregue usando a interface virtual."

#. (itstool) path: sect4/title
#: book.translate.xml:9610
#, fuzzy
msgid "<function>mpo_create_mbuf_netlayer</function>"
msgstr " <function> mpo_create_mbuf_netlayer </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9613
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_netlayer</function></funcdef> "
"<paramdef>struct mbuf *<parameter>oldmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldmbuflabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>newmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>newmbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_netlayer </function></"
"funcdef><paramdef> struct mbuf * <parameter> oldmbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> oldmbuflabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> newmbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> newmbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9647
#, fuzzy
msgid "Received datagram"
msgstr "Recebido datagrama"

#. (itstool) path: row/entry
#: book.translate.xml:9658
#, fuzzy
msgid "Newly created datagram"
msgstr "Datagrama rec�m-criado"

#. (itstool) path: row/entry
#: book.translate.xml:9663
#, fuzzy
msgid "Policy label for <parameter>newmbuf</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> newmbuf </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9670
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram generated by "
"the IP stack in response to an existing received datagram "
"(<parameter>oldmbuf</parameter>). This call may be made in a number of "
"situations, including when responding to ICMP request datagrams."
msgstr ""
"Definir o r�tulo no cabe�alho mbuf de um datagrama rec�m-criado gerado pela "
"pilha IP em resposta a um datagrama recebido existente ( <parameter> oldmbuf "
"</parameter> ). Essa chamada pode ser feita em v�rias situa��es, inclusive "
"ao responder datagramas de solicita��o do ICMP. "

#. (itstool) path: sect4/title
#: book.translate.xml:9679
#, fuzzy
msgid "<function>mpo_fragment_match</function>"
msgstr " <function> mpo_fragment_match </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9682
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_fragment_match</function></funcdef> "
"<paramdef>struct mbuf *<parameter>fragment</parameter></paramdef> "
"<paramdef>struct label *<parameter>fragmentlabel</parameter></paramdef> "
"<paramdef>struct ipq *<parameter>ipq</parameter></paramdef> <paramdef>struct "
"label *<parameter>ipqlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_fragment_match </function></funcdef><paramdef> "
"struct mbuf * <parameter> fragmento </parameter></paramdef><paramdef> label "
"struct * <parameter> fragmento </parameter></paramdef><paramdef> struct ipq "
"* <parameter> ipq </parameter></paramdef><paramdef> label struct * "
"<parameter> ipqlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9716
#, fuzzy
msgid "IP datagram fragment"
msgstr "Fragmento de datagrama IP"

#. (itstool) path: row/entry
#: book.translate.xml:9727 book.translate.xml:9871
#, fuzzy
msgid "IP fragment reassembly queue"
msgstr "Fila de remontagem de fragmento de IP"

#. (itstool) path: sect4/para
#: book.translate.xml:9739
#, fuzzy
msgid ""
"Determine whether an mbuf header containing an IP datagram "
"(<parameter>fragment</parameter>) fragment matches the label of the passed "
"IP fragment reassembly queue (<parameter>ipq</parameter>). Return "
"(<returnvalue>1</returnvalue>) for a successful match, or (<returnvalue>0</"
"returnvalue>) for no match. This call is made when the IP stack attempts to "
"find an existing fragment reassembly queue for a newly received fragment; if "
"this fails, a new fragment reassembly queue may be instantiated for the "
"fragment. Policies may use this entry point to prevent the reassembly of "
"otherwise matching IP fragments if policy does not permit them to be "
"reassembled based on the label or other information."
msgstr ""
"Determina se um cabe�alho mbuf contendo um datagrama IP ( <parameter> "
"fragmento </parameter> ) fragment corresponde ao r�tulo da fila de "
"remontagem de fragmentos IP passada ( <parameter> ipq </parameter> ). "
"Retorna ( <returnvalue> 1 </returnvalue> ) para um jogo bem sucedido, ou "
"( <returnvalue> 0 </returnvalue> ) sem correspond�ncia. Essa chamada � feita "
"quando a pilha de IP tenta localizar uma fila de remontagem de fragmento "
"existente para um fragmento rec�m-recebido; se isso falhar, uma nova fila de "
"remontagem de fragmento pode ser instanciada para o fragmento. As pol�ticas "
"podem usar este ponto de entrada para impedir a remontagem de fragmentos IP "
"correspondentes, caso a pol�tica n�o permita que eles sejam remontados com "
"base no r�tulo ou em outras informa��es. "

#. (itstool) path: sect4/title
#: book.translate.xml:9756
#, fuzzy
msgid "<function>mpo_relabel_ifnet</function>"
msgstr " <function> mpo_relabel_ifnet </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9759
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_relabel_ifnet</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_relabel_ifnet </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9798
#, fuzzy
msgid "Object; Network interface"
msgstr "Objeto; interface de rede"

#. (itstool) path: row/entry
#: book.translate.xml:9809
#, fuzzy
msgid "Label update to apply to <parameter>ifnet</parameter>"
msgstr "Atualiza��o de etiqueta para aplicar a <parameter> ifnet </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9816
#, fuzzy
msgid ""
"Update the label of network interface, <parameter>ifnet</parameter>, based "
"on the passed update label, <parameter>newlabel</parameter>, and the passed "
"subject credential, <parameter>cred</parameter>."
msgstr ""
"Atualizar o r�tulo da interface de rede, <parameter> ifnet </parameter> , "
"com base na etiqueta de atualiza��o aprovada, <parameter> newlabel </"
"parameter> e a credencial de assunto passada <parameter> cred </parameter> "

#. (itstool) path: sect4/title
#: book.translate.xml:9823
#, fuzzy
msgid "<function>mpo_update_ipq</function>"
msgstr " <function> mpo_update_ipq </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9826
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_update_ipq</function></funcdef> <paramdef>struct "
"mbuf *<parameter>fragment</parameter></paramdef> <paramdef>struct label "
"*<parameter>fragmentlabel</parameter></paramdef> <paramdef>struct ipq "
"*<parameter>ipq</parameter></paramdef> <paramdef>struct label "
"*<parameter>ipqlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_update_ipq </function></funcdef><paramdef> "
"struct mbuf * <parameter> fragmento </parameter></paramdef><paramdef> label "
"struct * <parameter> fragmento </parameter></paramdef><paramdef> struct ipq "
"* <parameter> ipq </parameter></paramdef><paramdef> label struct * "
"<parameter> ipqlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9860
#, fuzzy
msgid "IP fragment"
msgstr "Fragmento de IP"

#. (itstool) path: row/entry
#: book.translate.xml:9865 book.translate.xml:14005 book.translate.xml:14081
#, fuzzy
msgid "Policy label for <parameter>mbuf</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> mbuf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9876
#, fuzzy
msgid "Policy label to be updated for <parameter>ipq</parameter>"
msgstr ""
"Etiqueta de pol�tica a ser atualizada para <parameter> ipq </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9883
#, fuzzy
msgid ""
"Update the label on an IP fragment reassembly queue (<parameter>ipq</"
"parameter>) based on the acceptance of the passed IP fragment mbuf header "
"(<parameter>mbuf</parameter>)."
msgstr ""
"Atualize o r�tulo em uma fila de remontagem de fragmento IP ( <parameter> "
"ipq </parameter> ) com base na aceita��o do cabe�alho mbuf do fragmento IP "
"transmitido ( <parameter> mbuf </parameter> ) "

#. (itstool) path: sect3/title
#: book.translate.xml:9891
#, fuzzy
msgid "Process Labeling Event Operations"
msgstr "Opera��es de eventos de rotulagem de processos"

#. (itstool) path: sect4/title
#: book.translate.xml:9894
#, fuzzy
msgid "<function>mpo_create_cred</function>"
msgstr " <function> mpo_create_cred </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9897
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_cred</function></funcdef> "
"<paramdef>struct ucred *<parameter>parent_cred</parameter></paramdef> "
"<paramdef>struct ucred *<parameter>child_cred</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_cred </function></funcdef><paramdef> "
"struct ucred * <parameter> parent_cred </parameter></paramdef><paramdef> "
"struct ucred * <parameter> child_cred </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9926
#, fuzzy
msgid "<parameter>parent_cred</parameter>"
msgstr " <parameter> parent_cred </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9927
#, fuzzy
msgid "Parent subject credential"
msgstr "Parent subject credential"

#. (itstool) path: row/entry
#: book.translate.xml:9931
#, fuzzy
msgid "<parameter>child_cred</parameter>"
msgstr " <parameter> child_cred </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9932
#, fuzzy
msgid "Child subject credential"
msgstr "Credencial do sujeito da crian�a"

#. (itstool) path: sect4/para
#: book.translate.xml:9938
#, fuzzy
msgid ""
"Set the label of a newly created subject credential from the passed subject "
"credential. This call will be made when <citerefentry><refentrytitle>crcopy</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> is invoked on a newly "
"created <type>struct ucred</type>. This call should not be confused with a "
"process forking or creation event."
msgstr ""
"Definir o r�tulo de uma credencial de assunto rec�m-criada a partir da "
"credencial de assunto passada. Essa chamada ser� feita quando "
"<citerefentry><refentrytitle> crcopy </refentrytitle><manvolnum> 9 </"
"manvolnum></citerefentry> � invocado em um rec�m-criado <type> structurred </"
"type> . Esta chamada n�o deve ser confundida com um processo de bifurca��o "
"ou evento de cria��o. "

#. (itstool) path: sect4/title
#: book.translate.xml:9946
#, fuzzy
msgid "<function>mpo_execve_transition</function>"
msgstr " <function> mpo_execve_transition </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9949
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_execve_transition</function></funcdef> "
"<paramdef>struct ucred *<parameter>old</parameter></paramdef> "
"<paramdef>struct ucred *<parameter>new</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_execve_transition </function></"
"funcdef><paramdef> struct ucred * <parameter> velho </parameter></"
"paramdef><paramdef> struct ucred * <parameter> Novo </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vnodelabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9982 book.translate.xml:10059 book.translate.xml:14463
#, fuzzy
msgid "<parameter>old</parameter>"
msgstr " <parameter> velho </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9983
#, fuzzy
msgid "Existing subject credential"
msgstr "Credencial de assunto existente"

#. (itstool) path: row/entry
#: book.translate.xml:9988 book.translate.xml:14477
#, fuzzy
msgid "<parameter>new</parameter>"
msgstr " <parameter> Novo </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9989
#, fuzzy
msgid "New subject credential to be labeled"
msgstr "Nova credencial de sujeito a ser rotulada"

#. (itstool) path: row/entry
#: book.translate.xml:9994 book.translate.xml:10067
#, fuzzy
msgid "File to execute"
msgstr "Arquivo para executar"

#. (itstool) path: sect4/para
#: book.translate.xml:10006
#, fuzzy
msgid ""
"Update the label of a newly created subject credential (<parameter>new</"
"parameter>) from the passed existing subject credential (<parameter>old</"
"parameter>) based on a label transition caused by executing the passed vnode "
"(<parameter>vp</parameter>). This call occurs when a process executes the "
"passed vnode and one of the policies returns a success from the "
"<function>mpo_execve_will_transition</function> entry point. Policies may "
"choose to implement this call simply by invoking <function>mpo_create_cred</"
"function> and passing the two subject credentials so as not to implement a "
"transitioning event. Policies should not leave this entry point "
"unimplemented if they implement <function>mpo_create_cred</function>, even "
"if they do not implement <function>mpo_execve_will_transition</function>."
msgstr ""
"Atualizar o r�tulo de uma credencial de assunto rec�m-criada ( <parameter> "
"Novo </parameter> ) da credencial de sujeito j� existente ( <parameter> "
"velho </parameter> ) baseado em uma transi��o de r�tulo causada pela "
"execu��o do vnode passado ( <parameter> vp </parameter> ). Essa chamada "
"ocorre quando um processo executa o vnode passado e uma das pol�ticas "
"retorna um sucesso do <function> mpo_execve_will_transition </function> "
"ponto de entrada. As pol�ticas podem optar por implementar essa chamada "
"simplesmente invocando <function> mpo_create_cred </function> e passando as "
"duas credenciais de assunto para n�o implementar um evento de transi��o. As "
"pol�ticas n�o devem deixar este ponto de entrada n�o implementado se "
"implementarem <function> mpo_create_cred </function> , mesmo que eles n�o "
"implementem <function> mpo_execve_will_transition </function> "

#. (itstool) path: sect4/title
#: book.translate.xml:10025
#, fuzzy
msgid "<function>mpo_execve_will_transition</function>"
msgstr " <function> mpo_execve_will_transition </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10028
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_execve_will_transition</function></funcdef> "
"<paramdef>struct ucred *<parameter>old</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_execve_will_transition </function></"
"funcdef><paramdef> struct ucred * <parameter> velho </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vnodelabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:10060
#, fuzzy
msgid ""
"Subject credential prior to <citerefentry><refentrytitle>execve</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
"Credencial do sujeito antes de <citerefentry><refentrytitle> execve </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#. (itstool) path: sect4/para
#: book.translate.xml:10079
#, fuzzy
msgid ""
"Determine whether the policy will want to perform a transition event as a "
"result of the execution of the passed vnode by the passed subject "
"credential. Return <returnvalue>1</returnvalue> if a transition is required, "
"<returnvalue>0</returnvalue> if not. Even if a policy returns "
"<returnvalue>0</returnvalue>, it should behave correctly in the presence of "
"an unexpected invocation of <function>mpo_execve_transition</function>, as "
"that call may happen as a result of another policy requesting a transition."
msgstr ""
"Determine se a pol�tica desejar� executar um evento de transi��o como "
"resultado da execu��o do vnode transmitido pela credencial de assunto "
"passada. <returnvalue> 1 </returnvalue> se uma transi��o for necess�ria, "
"<returnvalue> 0 </returnvalue> se n�o. Mesmo que uma pol�tica retorne "
"<returnvalue> 0 </returnvalue> , deve comportar-se corretamente na presen�a "
"de uma invoca��o inesperada de <function> mpo_execve_transition </"
"function> , como essa chamada pode acontecer como resultado de outra "
"pol�tica solicitando uma transi��o \""

#. (itstool) path: sect4/title
#: book.translate.xml:10092
#, fuzzy
msgid "<function>mpo_create_proc0</function>"
msgstr " <function> mpo_create_proc0 </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10095
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_proc0</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_proc0 </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:10123 book.translate.xml:10165
#, fuzzy
msgid "Subject credential to be filled in"
msgstr "Assunto credencial a ser preenchido"

#. (itstool) path: sect4/para
#: book.translate.xml:10129
#, fuzzy
msgid ""
"Create the subject credential of process 0, the parent of all kernel "
"processes."
msgstr ""
"Crie a credencial do assunto do processo 0, o pai de todos os processos do "
"kernel."

#. (itstool) path: sect4/title
#: book.translate.xml:10134
#, fuzzy
msgid "<function>mpo_create_proc1</function>"
msgstr " <function> mpo_create_proc1 </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10137
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_proc1</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_proc1 </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef> "

#. (itstool) path: sect4/para
#: book.translate.xml:10171
#, fuzzy
msgid ""
"Create the subject credential of process 1, the parent of all user processes."
msgstr ""
"Crie a credencial do assunto do processo 1, o pai de todos os processos do "
"usu�rio."

#. (itstool) path: sect4/title
#: book.translate.xml:10176
#, fuzzy
msgid "<function>mpo_relabel_cred</function>"
msgstr " <function> mpo_relabel_cred </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10179
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_relabel_cred</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_relabel_cred </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> label "
"struct * <parameter> newlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:10214
#, fuzzy
msgid "Label update to apply to <parameter>cred</parameter>"
msgstr "Atualiza��o de etiqueta para aplicar a <parameter> cred </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:10221
#, fuzzy
msgid "Update the label on a subject credential from the passed update label."
msgstr ""
"Atualize o r�tulo de uma credencial de assunto da etiqueta de atualiza��o "
"passada."

#. (itstool) path: sect2/title
#: book.translate.xml:10229
#, fuzzy
msgid "Access Control Checks"
msgstr "Verifica��es de controle de acesso"

#. (itstool) path: sect2/para
#: book.translate.xml:10231
#, fuzzy
msgid ""
"Access control entry points permit policy modules to influence access "
"control decisions made by the kernel. Generally, although not always, "
"arguments to an access control entry point will include one or more "
"authorizing credentials, information (possibly including a label) for any "
"other objects involved in the operation. An access control entry point may "
"return 0 to permit the operation, or an <citerefentry><refentrytitle>errno</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> error value. The "
"results of invoking the entry point across various registered policy modules "
"will be composed as follows: if all modules permit the operation to succeed, "
"success will be returned. If one or modules returns a failure, a failure "
"will be returned. If more than one module returns a failure, the errno value "
"to return to the user will be selected using the following precedence, "
"implemented by the <function>error_select()</function> function in "
"<filename>kern_mac.c</filename>:"
msgstr ""
"Pontos de entrada de controle de acesso permitem que m�dulos de pol�tica "
"influenciem decis�es de controle de acesso feitas pelo kernel. Geralmente, "
"embora nem sempre, argumentos para um ponto de entrada de controle de acesso "
"incluir�o uma ou mais credenciais de autoriza��o, informa��es (possivelmente "
"incluindo um r�tulo) para quaisquer outros objetos O ponto de entrada de "
"controle de acesso pode retornar 0 para permitir a opera��o ou "
"<citerefentry><refentrytitle> errno </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> valor de erro. Os resultados de invocar o ponto de "
"entrada em v�rios m�dulos de pol�tica registrados ser�o compostos da "
"seguinte maneira: se todos os m�dulos permitirem que a opera��o seja bem-"
"sucedida, o sucesso ser� retornado. Se um ou os m�dulos retornarem uma "
"falha, uma falha ser� retornada. Se mais de um m�dulo retornar uma falha, o "
"valor de errno a ser retornado ao usu�rio ser� selecionado usando a seguinte "
"preced�ncia, implementada pelo <function> error_select () </function> fun��o "
"em <filename> kern_mac.c </filename> : "

#. (itstool) path: row/entry
#: book.translate.xml:10252
#, fuzzy
msgid "Most precedence"
msgstr "Maior preced�ncia"

#. (itstool) path: row/entry
#: book.translate.xml:10253
#, fuzzy
msgid "<errorcode>EDEADLK</errorcode>"
msgstr " <errorcode> EDEADLK </errorcode> "

#. (itstool) path: row/entry
#: book.translate.xml:10258
#, fuzzy
msgid "<errorcode>EINVAL</errorcode>"
msgstr " <errorcode> escolhido </errorcode> "

#. (itstool) path: row/entry
#: book.translate.xml:10263
#, fuzzy
msgid "<errorcode>ESRCH</errorcode>"
msgstr " <errorcode> ESRCH </errorcode> "

#. (itstool) path: row/entry
#: book.translate.xml:10268
#, fuzzy
msgid "EACCES"
msgstr "EACCES"

#. (itstool) path: row/entry
#: book.translate.xml:10272
#, fuzzy
msgid "Least precedence"
msgstr "Menos preced�ncia"

#. (itstool) path: row/entry
#: book.translate.xml:10273
#, fuzzy
msgid "EPERM"
msgstr "EPERM"

#. (itstool) path: sect2/para
#: book.translate.xml:10279
#, fuzzy
msgid ""
"If none of the error values returned by all modules are listed in the "
"precedence chart then an arbitrarily selected value from the set will be "
"returned. In general, the rules provide precedence to errors in the "
"following order: kernel failures, invalid arguments, object not present, "
"access not permitted, other."
msgstr ""
"Se nenhum dos valores de erro retornados por todos os m�dulos estiverem "
"listados no gr�fico de preced�ncia, um valor selecionado arbitrariamente do "
"conjunto ser� retornado. Em geral, as regras fornecem preced�ncia a erros na "
"seguinte ordem: falhas de kernel, argumentos inv�lidos, objeto n�o presente, "
"acesso n�o permitido, outro \""

#. (itstool) path: sect3/title
#: book.translate.xml:10287
#, fuzzy
msgid "<function>mpo_check_bpfdesc_receive</function>"
msgstr " <function> mpo_check_bpfdesc_receive </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10290
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_bpfdesc_receive</function></funcdef> "
"<paramdef>struct bpf_d *<parameter>bpf_d</parameter></paramdef> "
"<paramdef>struct label *<parameter>bpflabel</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_bpfdesc_receive </function></"
"funcdef><paramdef> struct bpf_d * <parameter> bpf_d </parameter></"
"paramdef><paramdef> label struct * <parameter> bpflabel </parameter></"
"paramdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:10324
#, fuzzy
msgid "Subject; BPF descriptor"
msgstr "Assunto; descritor BPF"

#. (itstool) path: row/entry
#: book.translate.xml:10329
#, fuzzy
msgid "Policy label for <parameter>bpf_d</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> bpf_d </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:10335 book.translate.xml:11454
#, fuzzy
msgid "Object; network interface"
msgstr "Objeto; interface de rede"

#. (itstool) path: sect3/para
#: book.translate.xml:10347
#, fuzzy
msgid ""
"Determine whether the MAC framework should permit datagrams from the passed "
"interface to be delivered to the buffers of the passed BPF descriptor. "
"Return (<returnvalue>0</returnvalue>) for success, or an <varname>errno</"
"varname> value for failure Suggested failure: <errorcode>EACCES</errorcode> "
"for label mismatches, <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se o framework MAC deve permitir que os datagramas da interface "
"passada sejam entregues aos buffers do descritor BPF passado. Return "
"( <returnvalue> 0 </returnvalue> ) para o sucesso, ou um <varname> errno </"
"varname> valor para falha Falha sugerida: <errorcode> EACCES </errorcode> "
"para incompatibilidades de r�tulo, <errorcode> EPERM </errorcode> por falta "
"de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:10357
#, fuzzy
msgid "<function>mpo_check_kenv_dump</function>"
msgstr " <function> mpo_check_kenv_dump </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10360
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kenv_dump</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kenv_dump </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:10394
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to retrieve the kernel "
"environment (see <citerefentry><refentrytitle>kenv</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>)."
msgstr ""
"Determine se o assunto deve ter permiss�o para recuperar o ambiente do "
"kernel (veja <citerefentry><refentrytitle> kenv </refentrytitle><manvolnum> "
"2 </manvolnum></citerefentry> ) "

#. (itstool) path: sect3/title
#: book.translate.xml:10399
#, fuzzy
msgid "<function>mpo_check_kenv_get</function>"
msgstr " <function> mpo_check_kenv_get </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10402
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kenv_get</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>char *<parameter>name</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kenv_get </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> Caracteres "
"* <parameter> nome </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:10435 book.translate.xml:10484 book.translate.xml:10532
#: book.translate.xml:12411 book.translate.xml:13453 book.translate.xml:14454
#, fuzzy
msgid "<parameter>name</parameter>"
msgstr " <parameter> nome </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:10436 book.translate.xml:10485 book.translate.xml:10533
#, fuzzy
msgid "Kernel environment variable name"
msgstr "Nome da vari�vel de ambiente do kernel"

#. (itstool) path: sect3/para
#: book.translate.xml:10442
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to retrieve the value of the "
"specified kernel environment variable."
msgstr ""
"Determine se o assunto deve ter permiss�o para recuperar o valor da vari�vel "
"de ambiente do kernel especificada."

#. (itstool) path: sect3/title
#: book.translate.xml:10448
#, fuzzy
msgid "<function>mpo_check_kenv_set</function>"
msgstr " <function> mpo_check_kenv_set </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10451
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kenv_set</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>char *<parameter>name</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kenv_set </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> Caracteres "
"* <parameter> nome </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:10491
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to set the specified kernel "
"environment variable."
msgstr ""
"Determine se o assunto deve ter permiss�o para definir a vari�vel de "
"ambiente do kernel especificada."

#. (itstool) path: sect3/title
#: book.translate.xml:10496
#, fuzzy
msgid "<function>mpo_check_kenv_unset</function>"
msgstr " <function> mpo_check_kenv_unset </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10499
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kenv_unset</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>char *<parameter>name</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kenv_unset </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> Caracteres * <parameter> nome </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:10539
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to unset the specified "
"kernel environment variable."
msgstr ""
"Determine se o assunto deve ter permiss�o para desfazer a vari�vel de "
"ambiente do kernel especificada."

#. (itstool) path: sect3/title
#: book.translate.xml:10544
#, fuzzy
msgid "<function>mpo_check_kld_load</function>"
msgstr " <function> mpo_check_kld_load </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10547
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kld_load</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kld_load </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct "
"vnode * <parameter> vp </parameter></paramdef><paramdef> label struct * "
"<parameter> vlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:10584
#, fuzzy
msgid "Kernel module vnode"
msgstr "M�dulo do kernel vnode"

#. (itstool) path: row/entry
#: book.translate.xml:10589 book.translate.xml:14208 book.translate.xml:14399
#, fuzzy
msgid "Label associated with <parameter>vp</parameter>"
msgstr "Etiqueta associada a <parameter> vp </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:10596
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to load the specified module "
"file."
msgstr ""
"Determine se o assunto deve ter permiss�o para carregar o arquivo do m�dulo "
"especificado."

#. (itstool) path: sect3/title
#: book.translate.xml:10601
#, fuzzy
msgid "<function>mpo_check_kld_stat</function>"
msgstr " <function> mpo_check_kld_stat </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10604
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kld_stat</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kld_stat </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:10638
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to retrieve a list of loaded "
"kernel module files and associated statistics."
msgstr ""
"Determine se o assunto deve ter permiss�o para recuperar uma lista de "
"arquivos do m�dulo do kernel carregados e estat�sticas associadas."

#. (itstool) path: sect3/title
#: book.translate.xml:10644
#, fuzzy
msgid "<function>mpo_check_kld_unload</function>"
msgstr " <function> mpo_check_kld_unload </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10647
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kld_unload</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kld_unload </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:10681
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to unload a kernel module."
msgstr ""
"Determine se o assunto deve ter permiss�o para descarregar um m�dulo do "
"kernel."

#. (itstool) path: sect3/title
#: book.translate.xml:10686
#, fuzzy
msgid "<function>mpo_check_pipe_ioctl</function>"
msgstr " <function> mpo_check_pipe_ioctl </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10689
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_ioctl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef> "
"<paramdef>unsigned long <parameter>cmd</parameter></paramdef> <paramdef>void "
"*<parameter>data</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_ioctl </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> pipe de estrutura * <parameter> tubo </parameter></"
"paramdef><paramdef> label struct * <parameter> pipelabel </parameter></"
"paramdef><paramdef> sem assinatura longa <parameter> cmd </parameter></"
"paramdef><paramdef> void * <parameter> dados </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:10739
#, fuzzy
msgid "<parameter>cmd</parameter>"
msgstr " <parameter> cmd </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:10740
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> command"
msgstr ""
" <citerefentry><refentrytitle> ioctl </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> comando"

#. (itstool) path: row/entry
#: book.translate.xml:10744
#, fuzzy
msgid "<parameter>data</parameter>"
msgstr " <parameter> dados </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:10745
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> data"
msgstr ""
" <citerefentry><refentrytitle> ioctl </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> dados"

#. (itstool) path: sect3/para
#: book.translate.xml:10751
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to make the specified "
"<citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> call."
msgstr ""
"Determinar se o assunto deve ter permiss�o para fazer o especificado "
"<citerefentry><refentrytitle> ioctl </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> ligar."

#. (itstool) path: sect3/title
#: book.translate.xml:10756
#, fuzzy
msgid "<function>mpo_check_pipe_poll</function>"
msgstr " <function> mpo_check_pipe_poll </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10759
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_poll</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_poll </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> pipe de estrutura * <parameter> tubo </parameter></"
"paramdef><paramdef> label struct * <parameter> pipelabel </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:10808
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to poll <parameter>pipe</"
"parameter>."
msgstr ""
"Determine se o assunto deve ter permiss�o para pesquisar <parameter> tubo </"
"parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:10813
#, fuzzy
msgid "<function>mpo_check_pipe_read</function>"
msgstr " <function> mpo_check_pipe_read </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10816
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_read</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_read </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> pipe de estrutura * <parameter> tubo </parameter></"
"paramdef><paramdef> label struct * <parameter> pipelabel </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:10865
#, fuzzy
msgid ""
"Determine whether the subject should be allowed read access to "
"<parameter>pipe</parameter>."
msgstr ""
"Determine se o assunto deve ter permiss�o de acesso de leitura a <parameter> "
"tubo </parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:10870
#, fuzzy
msgid "<function>mpo_check_pipe_relabel</function>"
msgstr " <function> mpo_check_pipe_relabel </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10873
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_relabel </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> pipe de estrutura * <parameter> tubo </parameter></"
"paramdef><paramdef> label struct * <parameter> pipelabel </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:10923
#, fuzzy
msgid "Label update to <parameter>pipelabel</parameter>"
msgstr "Atualiza��o de etiqueta para <parameter> pipelabel </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:10930
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to relabel <parameter>pipe</"
"parameter>."
msgstr ""
"Determine se o assunto deve ser autorizado a reclassificar <parameter> tubo "
"</parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:10935
#, fuzzy
msgid "<function>mpo_check_pipe_stat</function>"
msgstr " <function> mpo_check_pipe_stat </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10938
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_stat</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_stat </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> pipe de estrutura * <parameter> tubo </parameter></"
"paramdef><paramdef> label struct * <parameter> pipelabel </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:10987
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to retrieve statistics "
"related to <parameter>pipe</parameter>."
msgstr ""
"Determine se o assunto deve ter permiss�o para recuperar estat�sticas "
"relacionadas a <parameter> tubo </parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:10993
#, fuzzy
msgid "<function>mpo_check_pipe_write</function>"
msgstr " <function> mpo_check_pipe_write </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10996
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_write</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_write </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> pipe de estrutura * <parameter> tubo </parameter></"
"paramdef><paramdef> label struct * <parameter> pipelabel </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:11045
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to write to <parameter>pipe</"
"parameter>."
msgstr ""
"Determine se o assunto deve ter permiss�o para escrever <parameter> tubo </"
"parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:11050
#, fuzzy
msgid "<function>mpo_check_socket_bind</function>"
msgstr " <function> mpo_check_socket_bind </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11053
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_bind</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef> "
"<paramdef>struct sockaddr *<parameter>sockaddr</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_bind </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> soquete </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef><paramdef> struct sockaddr * <parameter> sockaddr </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11092
#, fuzzy
msgid "Socket to be bound"
msgstr "Soquete a ser ligado"

#. (itstool) path: row/entry
#: book.translate.xml:11102 book.translate.xml:11164
#, fuzzy
msgid "<parameter>sockaddr</parameter>"
msgstr " <parameter> sockaddr </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:11103 book.translate.xml:11165
#, fuzzy
msgid "Address of <parameter>socket</parameter>"
msgstr "Endere�o de <parameter> soquete </parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:11112
#, fuzzy
msgid "<function>mpo_check_socket_connect</function>"
msgstr " <function> mpo_check_socket_connect </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11115
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_connect</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef> "
"<paramdef>struct sockaddr *<parameter>sockaddr</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_connect </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> soquete </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef><paramdef> struct sockaddr * <parameter> sockaddr </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11154
#, fuzzy
msgid "Socket to be connected"
msgstr "Soquete para ser conectado"

#. (itstool) path: sect3/para
#: book.translate.xml:11172
#, fuzzy
msgid ""
"Determine whether the subject credential (<parameter>cred</parameter>) can "
"connect the passed socket (<parameter>socket</parameter>) to the passed "
"socket address (<parameter>sockaddr</parameter>). Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatches, "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do sujeito ( <parameter> cred </parameter> ) pode "
"conectar o soquete passado ( <parameter> soquete </parameter> ) para o "
"endere�o de socket passado ( <parameter> sockaddr </parameter> ). Retorna "
"<returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> errno </"
"varname> valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> "
"para incompatibilidades de r�tulo, <errorcode> EPERM </errorcode> por falta "
"de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:11183
#, fuzzy
msgid "<function>mpo_check_socket_receive</function>"
msgstr " <function> mpo_check_socket_receive </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11186
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_receive</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_receive </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> assim </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11228 book.translate.xml:11286
#, fuzzy
msgid "Policy label associated with <parameter>so</parameter>"
msgstr "Etiqueta de pol�tica associada a <parameter> assim </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:11235
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to receive information from "
"the socket <parameter>so</parameter>."
msgstr ""
"Determinar se o assunto deve receber permiss�o de receber informa��es do "
"soquete <parameter> assim </parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:11241
#, fuzzy
msgid "<function>mpo_check_socket_send</function>"
msgstr " <function> mpo_check_socket_send </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11244
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_send</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_send </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> assim </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:11293
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to send information across "
"the socket <parameter>so</parameter>."
msgstr ""
"Determinar se o assunto deve ter permiss�o para enviar informa��es atrav�s "
"do soquete <parameter> assim </parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:11299
#, fuzzy
msgid "<function>mpo_check_cred_visible</function>"
msgstr " <function> mpo_check_cred_visible </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11302
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_cred_visible</function></funcdef> "
"<paramdef>struct ucred *<parameter>u1</parameter></paramdef> "
"<paramdef>struct ucred *<parameter>u2</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_cred_visible </function></"
"funcdef><paramdef> struct ucred * <parameter> u1 </parameter></"
"paramdef><paramdef> struct ucred * <parameter> u2 </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11331
#, fuzzy
msgid "<parameter>u1</parameter>"
msgstr " <parameter> u1 </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:11336
#, fuzzy
msgid "<parameter>u2</parameter>"
msgstr " <parameter> u2 </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:11337
#, fuzzy
msgid "Object credential"
msgstr "Credencial do objeto"

#. (itstool) path: sect3/para
#: book.translate.xml:11343
#, fuzzy
msgid ""
"Determine whether the subject credential <parameter>u1</parameter> can "
"<quote>see</quote> other subjects with the passed subject credential "
"<parameter>u2</parameter>. Return <returnvalue>0</returnvalue> for success, "
"or an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatches, <errorcode>EPERM</"
"errorcode> for lack of privilege, or <errorcode>ESRCH</errorcode> to hide "
"visibility. This call may be made in a number of situations, including inter-"
"process status sysctl's used by <command>ps</command>, and in procfs lookups."
msgstr ""
"Determinar se a credencial do sujeito <parameter> u1 </parameter> posso "
"<quote> Vejo </quote> outros assuntos com a credencial do sujeito passado "
"<parameter> u2 </parameter> . Retorna <returnvalue> 0 </returnvalue> para o "
"sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidades de r�tulo, "
"<errorcode> EPERM </errorcode> por falta de privil�gio, ou <errorcode> ESRCH "
"</errorcode> para esconder a visibilidade. Essa chamada pode ser feita em "
"v�rias situa��es, incluindo sysctl de status entre processos usado por "
"<command> ps </command> e em pesquisas procfs \""

#. (itstool) path: sect3/title
#: book.translate.xml:11358 book.translate.xml:14098
#, fuzzy
msgid "<function>mpo_check_socket_visible</function>"
msgstr " <function> mpo_check_socket_visible </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11361
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_visible</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_visible </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> soquete </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:11412
#, fuzzy
msgid "<function>mpo_check_ifnet_relabel</function>"
msgstr " <function> mpo_check_ifnet_relabel </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11415
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_ifnet_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_ifnet_relabel </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11459
#, fuzzy
msgid "Existing policy label for <parameter>ifnet</parameter>"
msgstr "Etiqueta de pol�tica existente para <parameter> ifnet </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:11465
#, fuzzy
msgid "Policy label update to later be applied to <parameter>ifnet</parameter>"
msgstr ""
"Atualiza��o de r�tulo de pol�tica para depois ser aplicada a <parameter> "
"ifnet </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:11472
#, fuzzy
msgid ""
"Determine whether the subject credential can relabel the passed network "
"interface to the passed label update."
msgstr ""
"Determine se a credencial do assunto pode reclassificar a interface de rede "
"passada para a atualiza��o de r�tulo passada."

#. (itstool) path: sect3/title
#: book.translate.xml:11477
#, fuzzy
msgid "<function>mpo_check_socket_relabel</function>"
msgstr " <function> mpo_check_socket_relabel </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11480
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_relabel </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> soquete </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11524
#, fuzzy
msgid "Existing policy label for <parameter>socket</parameter>"
msgstr "Etiqueta de pol�tica existente para <parameter> soquete </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:11530
#, fuzzy
msgid "Label update to later be applied to <parameter>socketlabel</parameter>"
msgstr ""
"Atualiza��o de etiqueta para depois ser aplicada a <parameter> socketlabel </"
"parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:11537
#, fuzzy
msgid ""
"Determine whether the subject credential can relabel the passed socket to "
"the passed label update."
msgstr ""
"Determine se a credencial do assunto pode reclassificar o soquete "
"transmitido para a atualiza��o de r�tulo transmitida."

#. (itstool) path: sect3/title
#: book.translate.xml:11542
#, fuzzy
msgid "<function>mpo_check_cred_relabel</function>"
msgstr " <function> mpo_check_cred_relabel </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11545
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_cred_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_cred_relabel </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11580
#, fuzzy
msgid "Label update to later be applied to <parameter>cred</parameter>"
msgstr ""
"Atualiza��o de etiqueta para depois ser aplicada a <parameter> cred </"
"parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:11587
#, fuzzy
msgid ""
"Determine whether the subject credential can relabel itself to the passed "
"label update."
msgstr ""
"Determine se a credencial do assunto pode se renomear para a atualiza��o de "
"r�tulo passada."

#. (itstool) path: sect3/title
#: book.translate.xml:11593
#, fuzzy
msgid "<function>mpo_check_vnode_relabel</function>"
msgstr " <function> mpo_check_vnode_relabel </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11596
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_relabel </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vnodelabel </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11636 book.translate.xml:11826 book.translate.xml:12020
#: book.translate.xml:12190 book.translate.xml:12323 book.translate.xml:12396
#: book.translate.xml:13035 book.translate.xml:13103 book.translate.xml:13228
#: book.translate.xml:13294 book.translate.xml:13360 book.translate.xml:13438
#: book.translate.xml:13524 book.translate.xml:13592 book.translate.xml:13661
#: book.translate.xml:13921
#, fuzzy
msgid "Object; vnode"
msgstr "Objeto; vnode"

#. (itstool) path: row/entry
#: book.translate.xml:11648
#, fuzzy
msgid "Policy label update to later be applied to <parameter>vp</parameter>"
msgstr ""
"Atualiza��o de r�tulo de pol�tica para depois ser aplicada a <parameter> vp "
"</parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:11655
#, fuzzy
msgid ""
"Determine whether the subject credential can relabel the passed vnode to the "
"passed label update."
msgstr ""
"Determine se a credencial do assunto pode reclassificar o vnode transmitido "
"para a atualiza��o de r�tulo transmitida."

#. (itstool) path: sect3/title
#: book.translate.xml:11660
#, fuzzy
msgid "<function>mpo_check_mount_stat</function>"
msgstr " <function> mpo_check_mount_stat </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11663
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_mount_stat</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>mountlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_mount_stat </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> montagem struct * <parameter> mp </parameter></"
"paramdef><paramdef> label struct * <parameter> mountlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11700
#, fuzzy
msgid "Object; file system mount"
msgstr "Objeto; montagem do sistema de arquivos"

#. (itstool) path: row/entry
#: book.translate.xml:11704
#, fuzzy
msgid "<parameter>mountlabel</parameter>"
msgstr " <parameter> mountlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:11705
#, fuzzy
msgid "Policy label for <parameter>mp</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> mp </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:11713
#, fuzzy
msgid ""
"Determine whether the subject credential can see the results of a statfs "
"performed on the file system. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested "
"failure: <errorcode>EACCES</errorcode> for label mismatches or "
"<errorcode>EPERM</errorcode> for lack of privilege. This call may be made in "
"a number of situations, including during invocations of "
"<citerefentry><refentrytitle>statfs</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> and related calls, as well as to determine what file systems "
"to exclude from listings of file systems, such as when "
"<citerefentry><refentrytitle>getfsstat</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> is invoked."
msgstr ""
"Determine se a credencial do assunto pode ver os resultados de um statfs "
"executado no sistema de arquivos. <returnvalue> 0 </returnvalue> para o "
"sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidades de r�tulo ou "
"<errorcode> EPERM </errorcode> por falta de privil�gio. Essa chamada pode "
"ser feita em v�rias situa��es, inclusive durante invoca��es de "
"<citerefentry><refentrytitle> statfs </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> e chamadas relacionadas, bem como para determinar "
"quais sistemas de arquivos devem ser exclu�dos das listagens de sistemas de "
"arquivos, como quando <citerefentry><refentrytitle> getfsstat </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> � invocado. "

#. (itstool) path: sect3/title
#: book.translate.xml:11727
#, fuzzy
msgid "<function>mpo_check_proc_debug</function>"
msgstr " <function> mpo_check_proc_debug </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11730
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_proc_debug</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct proc *<parameter>proc</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_proc_debug </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct proc * <parameter> proc </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11765 book.translate.xml:13802 book.translate.xml:13859
#, fuzzy
msgid "<parameter>proc</parameter>"
msgstr " <parameter> por cento </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:11766 book.translate.xml:13803 book.translate.xml:13860
#, fuzzy
msgid "Object; process"
msgstr "Objeto; processo"

#. (itstool) path: sect3/para
#: book.translate.xml:11772
#, fuzzy
msgid ""
"Determine whether the subject credential can debug the passed process. "
"Return <returnvalue>0</returnvalue> for success, or an <varname>errno</"
"varname> value for failure. Suggested failure: <errorcode>EACCES</errorcode> "
"for label mismatch, <errorcode>EPERM</errorcode> for lack of privilege, or "
"<errorcode>ESRCH</errorcode> to hide visibility of the target. This call may "
"be made in a number of situations, including use of the "
"<citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> and <citerefentry><refentrytitle>ktrace</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> APIs, as well as for "
"some types of procfs operations."
msgstr ""
"Determine se a credencial do assunto pode depurar o processo passado. "
"Retornar <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> "
"errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </"
"errorcode> para incompatibilidade de etiqueta, <errorcode> EPERM </"
"errorcode> por falta de privil�gio, ou <errorcode> ESRCH </errorcode> para "
"ocultar a visibilidade do alvo. Esta chamada pode ser feita em v�rias "
"situa��es, incluindo o uso do <citerefentry><refentrytitle> ptrace </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> e "
"<citerefentry><refentrytitle> ktrace </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> APIs, bem como para alguns tipos de opera��es "
"procfs \""

#. (itstool) path: sect3/title
#: book.translate.xml:11785
#, fuzzy
msgid "<function>mpo_check_vnode_access</function>"
msgstr " <function> mpo_check_vnode_access </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11788
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_access</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>flags</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_access </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> bandeiras </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11836 book.translate.xml:13534
#, fuzzy
msgid "<parameter>flags</parameter>"
msgstr " <parameter> bandeiras </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:11837
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>access</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> flags"
msgstr ""
" <citerefentry><refentrytitle> Acesso </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> bandeiras"

#. (itstool) path: sect3/para
#: book.translate.xml:11843
#, fuzzy
msgid ""
"Determine how invocations of <citerefentry><refentrytitle>access</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> and related calls by "
"the subject credential should return when performed on the passed vnode "
"using the passed access flags. This should generally be implemented using "
"the same semantics used in <function>mpo_check_vnode_open</function>. Return "
"<returnvalue>0</returnvalue> for success, or an <varname>errno</varname> "
"value for failure. Suggested failure: <errorcode>EACCES</errorcode> for "
"label mismatches or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determinar como invoca��es de <citerefentry><refentrytitle> Acesso </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> e chamadas "
"relacionadas pela credencial de assunto devem retornar quando executadas no "
"vnode passado usando os sinalizadores de acesso passado. Isso geralmente "
"deve ser implementado usando a mesma sem�ntica usada <function> "
"mpo_check_vnode_open </function> . Retorna <returnvalue> 0 </returnvalue> "
"para o sucesso, ou um <varname> errno </varname> valor para falha. Falha "
"sugerida: <errorcode> EACCES </errorcode> para incompatibilidades de r�tulo "
"ou <errorcode> EPERM </errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:11856
#, fuzzy
msgid "<function>mpo_check_vnode_chdir</function>"
msgstr " <function> mpo_check_vnode_chdir </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11859
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_chdir</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_chdir </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> dvp </parameter></"
"paramdef><paramdef> label struct * <parameter> dlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11896
#, fuzzy
msgid ""
"Object; vnode to <citerefentry><refentrytitle>chdir</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> into"
msgstr ""
"Objeto; vnode para <citerefentry><refentrytitle> chdir </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> para dentro"

#. (itstool) path: row/entry
#: book.translate.xml:11901 book.translate.xml:12025 book.translate.xml:12107
#: book.translate.xml:13040 book.translate.xml:13171
#, fuzzy
msgid "Policy label for <parameter>dvp</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> dvp </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:11908
#, fuzzy
msgid ""
"Determine whether the subject credential can change the process working "
"directory to the passed vnode. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested "
"failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode alterar o diret�rio de trabalho do "
"processo para o vnode passado. <returnvalue> 0 </returnvalue> para o "
"sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidade de etiqueta, ou "
"<errorcode> EPERM </errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:11918
#, fuzzy
msgid "<function>mpo_check_vnode_chroot</function>"
msgstr " <function> mpo_check_vnode_chroot </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11921
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_chroot</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_chroot </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> dvp </parameter></"
"paramdef><paramdef> label struct * <parameter> dlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11958 book.translate.xml:12482 book.translate.xml:12810
#: book.translate.xml:12892
#, fuzzy
msgid "Directory vnode"
msgstr "Diret�rio vnode"

#. (itstool) path: row/entry
#: book.translate.xml:11963 book.translate.xml:12487 book.translate.xml:12815
#: book.translate.xml:12897
#, fuzzy
msgid "Policy label associated with <parameter>dvp</parameter>"
msgstr "Etiqueta de pol�tica associada a <parameter> dvp </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:11970
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to "
"<citerefentry><refentrytitle>chroot</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> into the specified directory (<parameter>dvp</parameter>)."
msgstr ""
"Determinar se o assunto deve ser permitido <citerefentry><refentrytitle> "
"chroot </refentrytitle><manvolnum> 2 </manvolnum></citerefentry> no "
"diret�rio especificado ( <parameter> dvp </parameter> ) "

#. (itstool) path: sect3/title
#: book.translate.xml:11976
#, fuzzy
msgid "<function>mpo_check_vnode_create</function>"
msgstr " <function> mpo_check_vnode_create </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11979
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_create</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct componentname *<parameter>cnp</parameter></paramdef> "
"<paramdef>struct vattr *<parameter>vap</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_create </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> dvp </parameter></"
"paramdef><paramdef> label struct * <parameter> dlabel </parameter></"
"paramdef><paramdef> struct componentname * <parameter> cnp </parameter></"
"paramdef><paramdef> struct vattr * <parameter> vap </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12031
#, fuzzy
msgid "Component name for <parameter>dvp</parameter>"
msgstr "Nome do componente para <parameter> dvp </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12036
#, fuzzy
msgid "<parameter>vap</parameter>"
msgstr " <parameter> vap </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12037
#, fuzzy
msgid "vnode attributes for <parameter>vap</parameter>"
msgstr "atributos vnode para <parameter> vap </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:12044
#, fuzzy
msgid ""
"Determine whether the subject credential can create a vnode with the passed "
"parent directory, passed name information, and passed attribute information. "
"Return <returnvalue>0</returnvalue> for success, or an <varname>errno</"
"varname> value for failure. Suggested failure: <errorcode>EACCES</errorcode> "
"for label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege. "
"This call may be made in a number of situations, including as a result of "
"calls to <citerefentry><refentrytitle>open</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> with <symbol>O_CREAT</symbol>, "
"<citerefentry><refentrytitle>mkfifo</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>, and others."
msgstr ""
"Determine se a credencial de assunto pode criar um vnode com o diret�rio pai "
"passado, informa��es de nome passadas e informa��es de atributo "
"transmitidas. <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> "
"errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </"
"errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM </"
"errorcode> por falta de privil�gio. Esta chamada pode ser feita em v�rias "
"situa��es, inclusive como resultado de chamadas para "
"<citerefentry><refentrytitle> aberto </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> com <symbol> O_CREAT </symbol> , "
"<citerefentry><refentrytitle> mkfifo </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> , e outros."

#. (itstool) path: sect3/title
#: book.translate.xml:12057
#, fuzzy
msgid "<function>mpo_check_vnode_delete</function>"
msgstr " <function> mpo_check_vnode_delete </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12060
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_delete</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> <paramdef>void "
"*<parameter>label</parameter></paramdef> <paramdef>struct componentname "
"*<parameter>cnp</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_delete </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> dvp </parameter></"
"paramdef><paramdef> label struct * <parameter> dlabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> void * <parameter> r�tulo </parameter></"
"paramdef><paramdef> struct componentname * <parameter> cnp </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12113
#, fuzzy
msgid "Object; vnode to delete"
msgstr "Objeto; vnode para excluir"

#. (itstool) path: sect3/para
#: book.translate.xml:12131
#, fuzzy
msgid ""
"Determine whether the subject credential can delete a vnode from the passed "
"parent directory and passed name information. Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege. This call may be made in "
"a number of situations, including as a result of calls to "
"<citerefentry><refentrytitle>unlink</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> and <citerefentry><refentrytitle>rmdir</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>. Policies implementing "
"this entry point should also implement <function>mpo_check_rename_to</"
"function> to authorize deletion of objects as a result of being the target "
"of a rename."
msgstr ""
"Determine se a credencial do assunto pode excluir um vnode do diret�rio pai "
"passado e passou as informa��es de nome. <returnvalue> 0 </returnvalue> para "
"o sucesso, ou um <varname> errno </varname> valor para falha. Falha "
"sugerida: <errorcode> EACCES </errorcode> para incompatibilidade de "
"etiqueta, ou <errorcode> EPERM </errorcode> por falta de privil�gio. Esta "
"chamada pode ser feita em v�rias situa��es, inclusive como resultado de "
"chamadas para <citerefentry><refentrytitle> desvincular </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> e "
"<citerefentry><refentrytitle> rmdir </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> . Pol�ticas que implementam este ponto de entrada "
"tamb�m devem implementar <function> mpo_check_rename_to </function> para "
"autorizar a exclus�o de objetos como resultado de ser o alvo de uma "
"renomea��o. "

#. (itstool) path: sect3/title
#: book.translate.xml:12147
#, fuzzy
msgid "<function>mpo_check_vnode_deleteacl</function>"
msgstr " <function> mpo_check_vnode_deleteacl </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12150
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_deleteacl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>acl_type_t <parameter>type</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_deleteacl </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> acl_type_t <parameter> tipo </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12201 book.translate.xml:12333 book.translate.xml:13370
#, fuzzy
msgid "<parameter>type</parameter>"
msgstr " <parameter> tipo </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12202 book.translate.xml:12334 book.translate.xml:13371
#, fuzzy
msgid "ACL type"
msgstr "Tipo de ACL"

#. (itstool) path: sect3/para
#: book.translate.xml:12208
#, fuzzy
msgid ""
"Determine whether the subject credential can delete the ACL of passed type "
"from the passed vnode. Return <returnvalue>0</returnvalue> for success, or "
"an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode excluir a ACL do tipo passado do "
"vnode passado. Retornar <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM "
"</errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:12218
#, fuzzy
msgid "<function>mpo_check_vnode_exec</function>"
msgstr " <function> mpo_check_vnode_exec </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12221
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_exec</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_exec </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12258
#, fuzzy
msgid "Object; vnode to execute"
msgstr "Objeto; vnode para executar"

#. (itstool) path: sect3/para
#: book.translate.xml:12270
#, fuzzy
msgid ""
"Determine whether the subject credential can execute the passed vnode. "
"Determination of execute privilege is made separately from decisions about "
"any transitioning event. Return <returnvalue>0</returnvalue> for success, or "
"an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode executar o vnode passado. A "
"determina��o do privil�gio de execu��o � feita separadamente das decis�es "
"sobre qualquer evento de transi��o. <returnvalue> 0 </returnvalue> para o "
"sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidade de etiqueta, ou "
"<errorcode> EPERM </errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:12281
#, fuzzy
msgid "<function>mpo_check_vnode_getacl</function>"
msgstr " <function> mpo_check_vnode_getacl </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12284
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_getacl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>acl_type_t <parameter>type</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_getacl </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> acl_type_t <parameter> tipo </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:12340
#, fuzzy
msgid ""
"Determine whether the subject credential can retrieve the ACL of passed type "
"from the passed vnode. Return <returnvalue>0</returnvalue> for success, or "
"an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial de assunto pode recuperar a ACL do tipo passado do "
"vnode passado. <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM "
"</errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:12350
#, fuzzy
msgid "<function>mpo_check_vnode_getextattr</function>"
msgstr " <function> mpo_check_vnode_getextattr </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12353
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_getextattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>attrnamespace</parameter></paramdef> "
"<paramdef>const char *<parameter>name</parameter></paramdef> "
"<paramdef>struct uio *<parameter>uio</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_getextattr </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> attrnamespace </parameter></"
"paramdef><paramdef> const char * <parameter> nome </parameter></"
"paramdef><paramdef> struct uio * <parameter> uio </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12406 book.translate.xml:13448
#, fuzzy
msgid "<parameter>attrnamespace</parameter>"
msgstr " <parameter> attrnamespace </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12407 book.translate.xml:13449
#, fuzzy
msgid "Extended attribute namespace"
msgstr "Namespace de atributo estendido"

#. (itstool) path: row/entry
#: book.translate.xml:12412 book.translate.xml:13454
#, fuzzy
msgid "Extended attribute name"
msgstr "Nome do atributo estendido"

#. (itstool) path: row/entry
#: book.translate.xml:12416 book.translate.xml:13458
#, fuzzy
msgid "<parameter>uio</parameter>"
msgstr " <parameter> uio </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12417 book.translate.xml:13459
#, fuzzy
msgid ""
"I/O structure pointer; see <citerefentry><refentrytitle>uio</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""
"Ponteiro de estrutura de E / S; consulte <citerefentry><refentrytitle> uio </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> "

#. (itstool) path: sect3/para
#: book.translate.xml:12423
#, fuzzy
msgid ""
"Determine whether the subject credential can retrieve the extended attribute "
"with the passed namespace and name from the passed vnode. Policies "
"implementing labeling using extended attributes may be interested in special "
"handling of operations on those extended attributes. Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial de assunto pode recuperar o atributo estendido com "
"o namespace passado e o nome do vnode transmitido. As pol�ticas que "
"implementam a rotulagem usando atributos estendidos podem estar interessadas "
"no tratamento especial de opera��es nesses atributos estendidos. Voltar para "
"o in�cio <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> "
"errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </"
"errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM </"
"errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:12436
#, fuzzy
msgid "<function>mpo_check_vnode_link</function>"
msgstr " <function> mpo_check_vnode_link </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12439
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_link</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>struct componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_link </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> dvp </parameter></"
"paramdef><paramdef> label struct * <parameter> dlabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> struct componentname * <parameter> cnp </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12493
#, fuzzy
msgid "Link destination vnode"
msgstr "Link destino vnode"

#. (itstool) path: row/entry
#: book.translate.xml:12504
#, fuzzy
msgid "Component name for the link being created"
msgstr "Nome do componente para o link que est� sendo criado"

#. (itstool) path: sect3/para
#: book.translate.xml:12511
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to create a link to the "
"vnode <parameter>vp</parameter> with the name specified by <parameter>cnp</"
"parameter>."
msgstr ""
"Determine se o assunto deve ter permiss�o para criar um link para o vnode "
"<parameter> vp </parameter> com o nome especificado por <parameter> cnp </"
"parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:12517
#, fuzzy
msgid "<function>mpo_check_vnode_mmap</function>"
msgstr " <function> mpo_check_vnode_mmap </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12520
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_mmap</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>prot</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_mmap </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> prot </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12558
#, fuzzy
msgid "Vnode to map"
msgstr "Vnode para mapear"

#. (itstool) path: row/entry
#: book.translate.xml:12568 book.translate.xml:12629 book.translate.xml:12686
#, fuzzy
msgid "<parameter>prot</parameter>"
msgstr " <parameter> prot </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12569
#, fuzzy
msgid ""
"Mmap protections (see <citerefentry><refentrytitle>mmap</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>)"
msgstr ""
"Prote��es Mmap (veja <citerefentry><refentrytitle> mmap </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> ) "

#. (itstool) path: sect3/para
#: book.translate.xml:12575
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to map the vnode "
"<parameter>vp</parameter> with the protections specified in <parameter>prot</"
"parameter>."
msgstr ""
"Determine se o assunto deve ter permiss�o para mapear o vnode <parameter> vp "
"</parameter> com as prote��es especificadas em <parameter> prot </parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:12581
#, fuzzy
msgid "<function>mpo_check_vnode_mmap_downgrade</function>"
msgstr " <function> mpo_check_vnode_mmap_downgrade </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12584
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_check_vnode_mmap_downgrade</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int *<parameter>prot</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_check_vnode_mmap_downgrade </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int * <parameter> prot </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12617
#, fuzzy
msgid "See <xref linkend=\"mac-mpo-check-vnode-mmap\"/>."
msgstr "Vejo <xref linkend=\"mac-mpo-check-vnode-mmap\"/> "

#. (itstool) path: row/entry
#: book.translate.xml:12630
#, fuzzy
msgid "Mmap protections to be downgraded"
msgstr "Prote��es Mmap a serem desatualizadas"

#. (itstool) path: sect3/para
#: book.translate.xml:12636
#, fuzzy
msgid "Downgrade the mmap protections based on the subject and object labels."
msgstr ""
"Fa�a o downgrade das prote��es mmap com base nos r�tulos de assunto e objeto."

#. (itstool) path: sect3/title
#: book.translate.xml:12641
#, fuzzy
msgid "<function>mpo_check_vnode_mprotect</function>"
msgstr " <function> mpo_check_vnode_mprotect </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12644
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_mprotect</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>prot</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_mprotect </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> prot </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12682
#, fuzzy
msgid "Mapped vnode"
msgstr "Vnode mapeado"

#. (itstool) path: row/entry
#: book.translate.xml:12687
#, fuzzy
msgid "Memory protections"
msgstr "Prote��es de mem�ria"

#. (itstool) path: sect3/para
#: book.translate.xml:12693
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to set the specified memory "
"protections on memory mapped from the vnode <parameter>vp</parameter>."
msgstr ""
"Determine se o assunto deve ter permiss�o para definir as prote��es de "
"mem�ria especificadas na mem�ria mapeada a partir do vnode <parameter> vp </"
"parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:12699
#, fuzzy
msgid "<function>mpo_check_vnode_poll</function>"
msgstr " <function> mpo_check_vnode_poll </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12702
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_poll</function></funcdef> "
"<paramdef>struct ucred *<parameter>active_cred</parameter></paramdef> "
"<paramdef>struct ucred *<parameter>file_cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_poll </function></"
"funcdef><paramdef> struct ucred * <parameter> active_cred </parameter></"
"paramdef><paramdef> struct ucred * <parameter> file_cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12735
#, fuzzy
msgid "<parameter>active_cred</parameter>"
msgstr " <parameter> active_cred </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12740
#, fuzzy
msgid "<parameter>file_cred</parameter>"
msgstr " <parameter> file_cred </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12741
#, fuzzy
msgid "Credential associated with the <type>struct file</type>"
msgstr "Credencial associado ao <type> arquivo struct </type> "

#. (itstool) path: row/entry
#: book.translate.xml:12747
#, fuzzy
msgid "Polled vnode"
msgstr "Polled vnode"

#. (itstool) path: sect3/para
#: book.translate.xml:12759
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to poll the vnode "
"<parameter>vp</parameter>."
msgstr ""
"Determine se o assunto deve ter permiss�o para pesquisar o vnode <parameter> "
"vp </parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:12764
#, fuzzy
msgid "<function>mpo_check_vnode_rename_from</function>"
msgstr " <function> mpo_check_vnode_rename_from </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12767
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_vnode_rename_from</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>struct componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_vnode_rename_from </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> dvp </parameter></"
"paramdef><paramdef> label struct * <parameter> dlabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> struct componentname * <parameter> cnp </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12821
#, fuzzy
msgid "Vnode to be renamed"
msgstr "Vnode a ser renomeado"

#. (itstool) path: sect3/para
#: book.translate.xml:12839
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to rename the vnode "
"<parameter>vp</parameter> to something else."
msgstr ""
"Determinar se o assunto deve ter permiss�o para renomear o vnode <parameter> "
"vp </parameter> para outra coisa \""

#. (itstool) path: sect3/title
#: book.translate.xml:12845
#, fuzzy
msgid "<function>mpo_check_vnode_rename_to</function>"
msgstr " <function> mpo_check_vnode_rename_to </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12848
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_rename_to</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>samedir</parameter></paramdef> <paramdef>struct "
"componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_rename_to </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> dvp </parameter></"
"paramdef><paramdef> label struct * <parameter> dlabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> samedir </parameter></"
"paramdef><paramdef> struct componentname * <parameter> cnp </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12903
#, fuzzy
msgid "Overwritten vnode"
msgstr "Vnode sobrescrito"

#. (itstool) path: row/entry
#: book.translate.xml:12913
#, fuzzy
msgid "<parameter>samedir</parameter>"
msgstr " <parameter> samedir </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12914
#, fuzzy
msgid ""
"Boolean; <literal>1</literal> if the source and destination directories are "
"the same"
msgstr ""
"Boleano; <literal> 1 </literal> se os diret�rios de origem e destino forem "
"os mesmos "

#. (itstool) path: row/entry
#: book.translate.xml:12920
#, fuzzy
msgid "Destination component name"
msgstr "Nome do componente de destino"

#. (itstool) path: sect3/para
#: book.translate.xml:12926
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to rename to the vnode "
"<parameter>vp</parameter>, into the directory <parameter>dvp</parameter>, or "
"to the name represented by <parameter>cnp</parameter>. If there is no "
"existing file to overwrite, <parameter>vp</parameter> and <parameter>label</"
"parameter> will be NULL."
msgstr ""
"Determinar se o assunto deve ter permiss�o para renomear para o vnode "
"<parameter> vp </parameter> , no diret�rio <parameter> dvp </parameter> , ou "
"para o nome representado por <parameter> cnp </parameter> . Se n�o houver "
"nenhum arquivo existente para substituir, <parameter> vp </parameter> e "
"<parameter> r�tulo </parameter> ser� NULL. "

#. (itstool) path: sect3/title
#: book.translate.xml:12935
#, fuzzy
msgid "<function>mpo_check_socket_listen</function>"
msgstr " <function> mpo_check_socket_listen </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12938
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_listen</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_listen </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> soquete </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:12987
#, fuzzy
msgid ""
"Determine whether the subject credential can listen on the passed socket. "
"Return <returnvalue>0</returnvalue> for success, or an <varname>errno</"
"varname> value for failure. Suggested failure: <errorcode>EACCES</errorcode> "
"for label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode escutar no soquete passado. "
"Retornar <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> "
"errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </"
"errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM </"
"errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:12996
#, fuzzy
msgid "<function>mpo_check_vnode_lookup</function>"
msgstr " <function> mpo_check_vnode_lookup </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12999
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_lookup</function></funcdef> "
"<paramdef>struct ucred *<parameter/>cred</paramdef> <paramdef>struct vnode "
"*<parameter/>dvp</paramdef> <paramdef>struct label *<parameter/>dlabel</"
"paramdef> <paramdef>struct componentname *<parameter>cnp</parameter></"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_lookup </function></"
"funcdef><paramdef> struct ucred * <parameter/> cred </paramdef><paramdef> "
"struct vnode * <parameter/> dvp </paramdef><paramdef> label struct * "
"<parameter/> dlabel </paramdef><paramdef> struct componentname * <parameter> "
"cnp </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13046
#, fuzzy
msgid "Component name being looked up"
msgstr "Nome do componente sendo pesquisado"

#. (itstool) path: sect3/para
#: book.translate.xml:13052
#, fuzzy
msgid ""
"Determine whether the subject credential can perform a lookup in the passed "
"directory vnode for the passed name. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested "
"failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode executar uma pesquisa no diret�rio "
"passado vnode para o nome passado. <returnvalue> 0 </returnvalue> para o "
"sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidade de etiqueta, ou "
"<errorcode> EPERM </errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13062
#, fuzzy
msgid "<function>mpo_check_vnode_open</function>"
msgstr " <function> mpo_check_vnode_open </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13065
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_open</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>acc_mode</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_open </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> acc_mode </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13113
#, fuzzy
msgid "<parameter>acc_mode</parameter>"
msgstr " <parameter> acc_mode </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:13114
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>open</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> access mode"
msgstr ""
" <citerefentry><refentrytitle> aberto </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> modo de acesso"

#. (itstool) path: sect3/para
#: book.translate.xml:13120
#, fuzzy
msgid ""
"Determine whether the subject credential can perform an open operation on "
"the passed vnode with the passed access mode. Return <returnvalue>0</"
"returnvalue> for success, or an errno value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode executar uma opera��o aberta no "
"vnode passado com o modo de acesso passado. <returnvalue> 0 </returnvalue> "
"para o sucesso, ou um valor errno para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM "
"</errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13129
#, fuzzy
msgid "<function>mpo_check_vnode_readdir</function>"
msgstr " <function> mpo_check_vnode_readdir </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13132
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_readdir</function></funcdef> "
"<paramdef>struct ucred *<parameter/>cred</paramdef> <paramdef>struct vnode "
"*<parameter/>dvp</paramdef> <paramdef>struct label *<parameter/>dlabel</"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_readdir </function></"
"funcdef><paramdef> struct ucred * <parameter/> cred </paramdef><paramdef> "
"struct vnode * <parameter/> dvp </paramdef><paramdef> label struct * "
"<parameter/> dlabel </paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13166
#, fuzzy
msgid "Object; directory vnode"
msgstr "Objeto; diret�rio vnode"

#. (itstool) path: sect3/para
#: book.translate.xml:13178
#, fuzzy
msgid ""
"Determine whether the subject credential can perform a <function>readdir</"
"function> operation on the passed directory vnode. Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode executar uma <function> readdir </"
"function> opera��o no diret�rio passado vnode. Retorna <returnvalue> 0 </"
"returnvalue> para o sucesso, ou um <varname> errno </varname> valor para "
"falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta "
"de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13188
#, fuzzy
msgid "<function>mpo_check_vnode_readlink</function>"
msgstr " <function> mpo_check_vnode_readlink </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13191
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_readlink</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_readlink </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:13240
#, fuzzy
msgid ""
"Determine whether the subject credential can perform a <function>readlink</"
"function> operation on the passed symlink vnode. Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege. This call may be made in "
"a number of situations, including an explicit <function>readlink</function> "
"call by the user process, or as a result of an implicit <function>readlink</"
"function> during a name lookup by the process."
msgstr ""
"Determine se a credencial do assunto pode executar uma <function> readlink </"
"function> opera��o no vnode symlink passado. Retorna <returnvalue> 0 </"
"returnvalue> para o sucesso, ou um <varname> errno </varname> valor para "
"falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta "
"de privil�gio. Esta chamada pode ser feita em v�rias situa��es, incluindo "
"uma <function> readlink </function> chamada pelo processo do usu�rio ou como "
"resultado de um <function> readlink </function> durante uma pesquisa de nome "
"pelo processo \""

#. (itstool) path: sect3/title
#: book.translate.xml:13254
#, fuzzy
msgid "<function>mpo_check_vnode_revoke</function>"
msgstr " <function> mpo_check_vnode_revoke </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13257
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_revoke</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_revoke </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:13306
#, fuzzy
msgid ""
"Determine whether the subject credential can revoke access to the passed "
"vnode. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode revogar o acesso ao vnode passado. "
"Retornar <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> "
"errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </"
"errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM </"
"errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13316
#, fuzzy
msgid "<function>mpo_check_vnode_setacl</function>"
msgstr " <function> mpo_check_vnode_setacl </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13319
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setacl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>acl_type_t <parameter>type</parameter></paramdef> <paramdef>struct "
"acl *<parameter>acl</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setacl </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> acl_type_t <parameter> tipo </parameter></"
"paramdef><paramdef> struct acl * <parameter> acl </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13375
#, fuzzy
msgid "<parameter>acl</parameter>"
msgstr " <parameter> acl </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:13376
#, fuzzy
msgid "ACL"
msgstr "ACL"

#. (itstool) path: sect3/para
#: book.translate.xml:13382
#, fuzzy
msgid ""
"Determine whether the subject credential can set the passed ACL of passed "
"type on the passed vnode. Return <returnvalue>0</returnvalue> for success, "
"or an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial de assunto pode definir a ACL transmitida do tipo "
"passado no vnode passado. <returnvalue> 0 </returnvalue> para o sucesso, ou "
"um <varname> errno </varname> valor para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM "
"</errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13392
#, fuzzy
msgid "<function>mpo_check_vnode_setextattr</function>"
msgstr " <function> mpo_check_vnode_setextattr </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13395
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setextattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>attrnamespace</parameter></paramdef> "
"<paramdef>const char *<parameter>name</parameter></paramdef> "
"<paramdef>struct uio *<parameter>uio</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setextattr </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> attrnamespace </parameter></"
"paramdef><paramdef> const char * <parameter> nome </parameter></"
"paramdef><paramdef> struct uio * <parameter> uio </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:13465
#, fuzzy
msgid ""
"Determine whether the subject credential can set the extended attribute of "
"passed name and passed namespace on the passed vnode. Policies implementing "
"security labels backed into extended attributes may want to provide "
"additional protections for those attributes. Additionally, policies should "
"avoid making decisions based on the data referenced from <parameter>uio</"
"parameter>, as there is a potential race condition between this check and "
"the actual operation. The <parameter>uio</parameter> may also be "
"<literal>NULL</literal> if a delete operation is being performed. Return "
"<returnvalue>0</returnvalue> for success, or an <varname>errno</varname> "
"value for failure. Suggested failure: <errorcode>EACCES</errorcode> for "
"label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determinar se a credencial de assunto pode definir o atributo estendido do "
"nome passado e o espa�o de nomes passado no vnode passado. As pol�ticas que "
"implementam r�tulos de seguran�a com backup em atributos estendidos podem "
"fornecer prote��es adicionais para esses atributos. Al�m disso, as pol�ticas "
"devem evitar tomar decis�es com base no dados referenciados de <parameter> "
"uio </parameter> , como h� uma condi��o de corrida em potencial entre essa "
"verifica��o e a opera��o real. o <parameter> uio </parameter> Tamb�m pode "
"ser <literal> NULO </literal> se uma opera��o de exclus�o estiver sendo "
"executada. Retorna <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM "
"</errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13483
#, fuzzy
msgid "<function>mpo_check_vnode_setflags</function>"
msgstr " <function> mpo_check_vnode_setflags </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13486
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setflags</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>u_long <parameter>flags</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setflags </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> u_long <parameter> bandeiras </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13535
#, fuzzy
msgid ""
"File flags; see <citerefentry><refentrytitle>chflags</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
"Sinalizadores de arquivo; consulte <citerefentry><refentrytitle> chflags </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#. (itstool) path: sect3/para
#: book.translate.xml:13541
#, fuzzy
msgid ""
"Determine whether the subject credential can set the passed flags on the "
"passed vnode. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode definir os sinalizadores passados ​​"
"no vnode passado. Retornar <returnvalue> 0 </returnvalue> para o sucesso, ou "
"um <varname> errno </varname> valor para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM "
"</errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13551
#, fuzzy
msgid "<function>mpo_check_vnode_setmode</function>"
msgstr " <function> mpo_check_vnode_setmode </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13554
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setmode</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>mode_t <parameter>mode</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setmode </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> mode_t <parameter> modo </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13602
#, fuzzy
msgid "<parameter>mode</parameter>"
msgstr " <parameter> modo </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:13603
#, fuzzy
msgid ""
"File mode; see <citerefentry><refentrytitle>chmod</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
"Modo de arquivo; consulte <citerefentry><refentrytitle> chmod </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#. (itstool) path: sect3/para
#: book.translate.xml:13609
#, fuzzy
msgid ""
"Determine whether the subject credential can set the passed mode on the "
"passed vnode. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode definir o modo passado no vnode "
"passado. Retornar <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM "
"</errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13619
#, fuzzy
msgid "<function>mpo_check_vnode_setowner</function>"
msgstr " <function> mpo_check_vnode_setowner </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13622
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setowner</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>uid_t <parameter>uid</parameter></paramdef> <paramdef>gid_t "
"<parameter>gid</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setowner </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> uid_t <parameter> uido </parameter></paramdef><paramdef> "
"gid_t <parameter> gid </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13671
#, fuzzy
msgid "<parameter>uid</parameter>"
msgstr " <parameter> uido </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:13672
#, fuzzy
msgid "User ID"
msgstr "ID do usu�rio"

#. (itstool) path: row/entry
#: book.translate.xml:13676
#, fuzzy
msgid "<parameter>gid</parameter>"
msgstr " <parameter> guia </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:13677
#, fuzzy
msgid "Group ID"
msgstr "ID do grupo"

#. (itstool) path: sect3/para
#: book.translate.xml:13683
#, fuzzy
msgid ""
"Determine whether the subject credential can set the passed uid and passed "
"gid as file uid and file gid on the passed vnode. The IDs may be set to "
"(<literal>-1</literal>) to request no update. Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode definir o uid passado e o gid "
"passado como arquivo uid e gid do arquivo no vnode transmitido. Os IDs podem "
"ser definidos como ( <literal> -1 </literal> ) para solicitar nenhuma "
"atualiza��o. Retorna <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM "
"</errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13694
#, fuzzy
msgid "<function>mpo_check_vnode_setutimes</function>"
msgstr " <function> mpo_check_vnode_setutimes </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13697
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setutimes</function></funcdef> "
"<paramdef>struct ucred *<parameter/>cred</paramdef> <paramdef>struct vnode "
"*<parameter/>vp</paramdef> <paramdef>struct label *<parameter/>label</"
"paramdef> <paramdef>struct timespec <parameter/>atime</paramdef> "
"<paramdef>struct timespec <parameter/>mtime</paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setutimes </function></"
"funcdef><paramdef> struct ucred * <parameter/> cred </paramdef><paramdef> "
"struct vnode * <parameter/> vp </paramdef><paramdef> label struct * "
"<parameter/> r�tulo </paramdef><paramdef> struct timespec <parameter/> um "
"tempo </paramdef><paramdef> struct timespec <parameter/> mtime </paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13733
#, fuzzy
msgid "Object; vp"
msgstr "Objeto; vp"

#. (itstool) path: row/entry
#: book.translate.xml:13743
#, fuzzy
msgid "<parameter>atime</parameter>"
msgstr " <parameter> um tempo </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:13744
#, fuzzy
msgid ""
"Access time; see <citerefentry><refentrytitle>utimes</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
"Tempo de acesso; consulte <citerefentry><refentrytitle> utimes </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#. (itstool) path: row/entry
#: book.translate.xml:13748
#, fuzzy
msgid "<parameter>mtime</parameter>"
msgstr " <parameter> mtime </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:13749
#, fuzzy
msgid ""
"Modification time; see <citerefentry><refentrytitle>utimes</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
"Tempo de modifica��o; ver <citerefentry><refentrytitle> utimes </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#. (itstool) path: sect3/para
#: book.translate.xml:13755
#, fuzzy
msgid ""
"Determine whether the subject credential can set the passed access "
"timestamps on the passed vnode. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested "
"failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial de assunto pode definir os registros de data e "
"hora de acesso transmitidos no vnode transmitido. <returnvalue> 0 </"
"returnvalue> para o sucesso, ou um <varname> errno </varname> valor para "
"falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta "
"de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13765
#, fuzzy
msgid "<function>mpo_check_proc_sched</function>"
msgstr " <function> mpo_check_proc_sched </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13768
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_proc_sched</function></funcdef> "
"<paramdef>struct ucred *<parameter>ucred</parameter></paramdef> "
"<paramdef>struct proc *<parameter>proc</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_proc_sched </function></"
"funcdef><paramdef> struct ucred * <parameter> ucred </parameter></"
"paramdef><paramdef> struct proc * <parameter> proc </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:13809
#, fuzzy
msgid ""
"Determine whether the subject credential can change the scheduling "
"parameters of the passed process. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested "
"failure: <errorcode>EACCES</errorcode> for label mismatch, <errorcode>EPERM</"
"errorcode> for lack of privilege, or <errorcode>ESRCH</errorcode> to limit "
"visibility."
msgstr ""
"Determine se a credencial do assunto pode alterar os par�metros de "
"agendamento do processo passado. <returnvalue> 0 </returnvalue> para o "
"sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidade de etiqueta, "
"<errorcode> EPERM </errorcode> por falta de privil�gio, ou <errorcode> ESRCH "
"</errorcode> para limitar a visibilidade \""

#. (itstool) path: sect3/para
#: book.translate.xml:13817
#, fuzzy
msgid ""
"See <citerefentry><refentrytitle>setpriority</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> for more information."
msgstr ""
"Vejo <citerefentry><refentrytitle> definir prioridades </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> Para maiores "
"informa��es."

#. (itstool) path: sect3/title
#: book.translate.xml:13821
#, fuzzy
msgid "<function>mpo_check_proc_signal</function>"
msgstr " <function> mpo_check_proc_signal </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13824
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_proc_signal</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct proc *<parameter>proc</parameter></paramdef> <paramdef>int "
"<parameter>signal</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_proc_signal </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct proc * <parameter> proc </parameter></"
"paramdef><paramdef> int <parameter> sinal </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13864
#, fuzzy
msgid "<parameter>signal</parameter>"
msgstr " <parameter> sinal </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:13865
#, fuzzy
msgid ""
"Signal; see <citerefentry><refentrytitle>kill</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>"
msgstr ""
"Signal; ver <citerefentry><refentrytitle> matar </refentrytitle><manvolnum> "
"2 </manvolnum></citerefentry> "

#. (itstool) path: sect3/para
#: book.translate.xml:13871
#, fuzzy
msgid ""
"Determine whether the subject credential can deliver the passed signal to "
"the passed process. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, <errorcode>EPERM</"
"errorcode> for lack of privilege, or <errorcode>ESRCH</errorcode> to limit "
"visibility."
msgstr ""
"Determine se a credencial do participante pode entregar o sinal passado ao "
"processo passado. <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, <errorcode> EPERM </"
"errorcode> por falta de privil�gio, ou <errorcode> ESRCH </errorcode> para "
"limitar a visibilidade \""

#. (itstool) path: sect3/title
#: book.translate.xml:13881
#, fuzzy
msgid "<function>mpo_check_vnode_stat</function>"
msgstr " <function> mpo_check_vnode_stat </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13884
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_stat</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_stat </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:13933
#, fuzzy
msgid ""
"Determine whether the subject credential can <function>stat</function> the "
"passed vnode. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do sujeito pode <function> stat </function> o "
"vnode passado. Retorna <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM "
"</errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/para
#: book.translate.xml:13941
#, fuzzy
msgid ""
"See <citerefentry><refentrytitle>stat</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> for more information."
msgstr ""
"Vejo <citerefentry><refentrytitle> stat </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> Para maiores informa��es."

#. (itstool) path: sect3/title
#: book.translate.xml:13945
#, fuzzy
msgid "<function>mpo_check_ifnet_transmit</function>"
msgstr " <function> mpo_check_ifnet_transmit </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13948
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_ifnet_transmit</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_ifnet_transmit </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> mbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> mbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:14000
#, fuzzy
msgid "Object; mbuf to be sent"
msgstr "Objeto; mbuf a ser enviado"

#. (itstool) path: sect3/para
#: book.translate.xml:14012
#, fuzzy
msgid ""
"Determine whether the network interface can transmit the passed mbuf. Return "
"<returnvalue>0</returnvalue> for success, or an <varname>errno</varname> "
"value for failure. Suggested failure: <errorcode>EACCES</errorcode> for "
"label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a interface de rede pode transmitir o mbuf passado. "
"<returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> errno </"
"varname> valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> "
"para incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por "
"falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:14021
#, fuzzy
msgid "<function>mpo_check_socket_deliver</function>"
msgstr " <function> mpo_check_socket_deliver </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14024
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_deliver</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_deliver </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> mbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> mbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:14076
#, fuzzy
msgid "Object; mbuf to be delivered"
msgstr "Objeto; mbuf a ser entregue"

#. (itstool) path: sect3/para
#: book.translate.xml:14088
#, fuzzy
msgid ""
"Determine whether the socket may receive the datagram stored in the passed "
"mbuf header. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failures: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determina se o socket pode receber o datagrama armazenado no cabe�alho mbuf "
"passado. <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> "
"errno </varname> valor para falha. Falhas sugeridas: <errorcode> EACCES </"
"errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM </"
"errorcode> por falta de privil�gio \""

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14101
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_visible</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_visible </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> assim </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:14144
#, fuzzy
msgid "Policy label for <parameter>so</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> assim </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:14151
#, fuzzy
msgid ""
"Determine whether the subject credential cred can \"see\" the passed socket "
"(<parameter>socket</parameter>) using system monitoring functions, such as "
"those employed by <citerefentry><refentrytitle>netstat</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry> and "
"<citerefentry><refentrytitle>sockstat</refentrytitle><manvolnum>1</"
"manvolnum></citerefentry>. Return <returnvalue>0</returnvalue> for success, "
"or an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatches, <errorcode>EPERM</"
"errorcode> for lack of privilege, or <errorcode>ESRCH</errorcode> to hide "
"visibility."
msgstr ""
"Determine se o credencial da pessoa em quest�o pode\" ver \"o soquete "
"passado ( <parameter> soquete </parameter> ) usando fun��es de monitoramento "
"do sistema, como aquelas empregadas <citerefentry><refentrytitle> netstat </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> e "
"<citerefentry><refentrytitle> sockstat </refentrytitle><manvolnum> 1 </"
"manvolnum></citerefentry> . Retorna <returnvalue> 0 </returnvalue> para o "
"sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidades de r�tulo, "
"<errorcode> EPERM </errorcode> por falta de privil�gio, ou <errorcode> ESRCH "
"</errorcode> para esconder visibilidade \""

#. (itstool) path: sect3/title
#: book.translate.xml:14163
#, fuzzy
msgid "<function>mpo_check_system_acct</function>"
msgstr " <function> mpo_check_system_acct </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14166
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_acct</function></funcdef> "
"<paramdef>struct ucred *<parameter>ucred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_acct </function></"
"funcdef><paramdef> struct ucred * <parameter> ucred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:14197
#, fuzzy
msgid "<parameter>ucred</parameter>"
msgstr " <parameter> ucred </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:14203
#, fuzzy
msgid ""
"Accounting file; <citerefentry><refentrytitle>acct</"
"refentrytitle><manvolnum>5</manvolnum></citerefentry>"
msgstr ""
"Arquivo cont�bil; <citerefentry><refentrytitle> acct </"
"refentrytitle><manvolnum> 5 </manvolnum></citerefentry> "

#. (itstool) path: sect3/para
#: book.translate.xml:14215
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to enable accounting, based "
"on its label and the label of the accounting log file."
msgstr ""
"Determine se o assunto deve ter permiss�o para ativar a contabilidade, com "
"base em seu r�tulo e no r�tulo do arquivo de registro cont�bil."

#. (itstool) path: sect3/title
#: book.translate.xml:14221
#, fuzzy
msgid "<function>mpo_check_system_nfsd</function>"
msgstr " <function> mpo_check_system_nfsd </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14224
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_nfsd</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_nfsd </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:14258
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to call "
"<citerefentry><refentrytitle>nfssvc</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>."
msgstr ""
"Determinar se o assunto deve ter permiss�o para ligar "
"<citerefentry><refentrytitle> nfssvc </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> "

#. (itstool) path: sect3/title
#: book.translate.xml:14263
#, fuzzy
msgid "<function>mpo_check_system_reboot</function>"
msgstr " <function> mpo_check_system_reboot </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14266
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_reboot</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>int "
"<parameter>howto</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_reboot </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> int <parameter> como </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:14299
#, fuzzy
msgid "<parameter>howto</parameter>"
msgstr " <parameter> como </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:14300
#, fuzzy
msgid ""
"<parameter>howto</parameter> parameter from "
"<citerefentry><refentrytitle>reboot</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>"
msgstr ""
" <parameter> como </parameter> par�metro de <citerefentry><refentrytitle> "
"reiniciar </refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#. (itstool) path: sect3/para
#: book.translate.xml:14307
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to reboot the system in the "
"specified manner."
msgstr ""
"Determine se o assunto deve ter permiss�o para reinicializar o sistema da "
"maneira especificada."

#. (itstool) path: sect3/title
#: book.translate.xml:14312
#, fuzzy
msgid "<function>mpo_check_system_settime</function>"
msgstr " <function> mpo_check_system_settime </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14315
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_settime</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_settime </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:14349
#, fuzzy
msgid "Determine whether the user should be allowed to set the system clock."
msgstr ""
"Determine se o usu�rio deve ter permiss�o para definir o rel�gio do sistema."

#. (itstool) path: sect3/title
#: book.translate.xml:14354
#, fuzzy
msgid "<function>mpo_check_system_swapon</function>"
msgstr " <function> mpo_check_system_swapon </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14357
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_swapon</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_swapon </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:14394
#, fuzzy
msgid "Swap device"
msgstr "Dispositivo de troca"

#. (itstool) path: sect3/para
#: book.translate.xml:14406
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to add <parameter>vp</"
"parameter> as a swap device."
msgstr ""
"Determine se o assunto deve ter permiss�o para adicionar <parameter> vp </"
"parameter> como um dispositivo de troca \""

#. (itstool) path: sect3/title
#: book.translate.xml:14411
#, fuzzy
msgid "<function>mpo_check_system_sysctl</function>"
msgstr " <function> mpo_check_system_sysctl </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14414
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_sysctl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>int "
"*<parameter>name</parameter></paramdef> <paramdef>u_int *<parameter>namelen</"
"parameter></paramdef> <paramdef>void *<parameter>old</parameter></paramdef> "
"<paramdef>size_t *<parameter>oldlenp</parameter></paramdef> <paramdef>int "
"<parameter>inkernel</parameter></paramdef> <paramdef>void *<parameter>new</"
"parameter></paramdef> <paramdef>size_t <parameter>newlen</parameter></"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_sysctl </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> int * <parameter> nome </parameter></paramdef><paramdef> "
"u_int * <parameter> namelen </parameter></paramdef><paramdef> void * "
"<parameter> velho </parameter></paramdef><paramdef> size_t * <parameter> "
"oldlenp </parameter></paramdef><paramdef> int <parameter> t�nica </"
"parameter></paramdef><paramdef> void * <parameter> Novo </parameter></"
"paramdef><paramdef> size_t <parameter> Newlen </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:14455 book.translate.xml:14478
#, fuzzy
msgid ""
"See <citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry>"
msgstr ""
"Vejo <citerefentry><refentrytitle> sysctl </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> "

#. (itstool) path: row/entry
#: book.translate.xml:14467
#, fuzzy
msgid "<parameter>oldlenp</parameter>"
msgstr " <parameter> oldlenp </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:14471
#, fuzzy
msgid "<parameter>inkernel</parameter>"
msgstr " <parameter> inkernel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:14472
#, fuzzy
msgid "Boolean; <literal>1</literal> if called from kernel"
msgstr "Boleano; <literal> 1 </literal> se chamado do kernel "

#. (itstool) path: row/entry
#: book.translate.xml:14482
#, fuzzy
msgid "<parameter>newlen</parameter>"
msgstr " <parameter> newlen </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:14488
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to make the specified "
"<citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry> transaction."
msgstr ""
"Determinar se o assunto deve ter permiss�o para fazer o especificado "
"<citerefentry><refentrytitle> sysctl </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> transa��o."

#. (itstool) path: sect2/title
#: book.translate.xml:14494
#, fuzzy
msgid "Label Management Calls"
msgstr "Chamadas de Gerenciamento de Etiqueta"

#. (itstool) path: sect2/para
#: book.translate.xml:14496
#, fuzzy
msgid ""
"Relabel events occur when a user process has requested that the label on an "
"object be modified. A two-phase update occurs: first, an access control "
"check will be performed to determine if the update is both valid and "
"permitted, and then the update itself is performed via a separate entry "
"point. Relabel entry points typically accept the object, object label "
"reference, and an update label submitted by the process. Memory allocation "
"during relabel is discouraged, as relabel calls are not permitted to fail "
"(failure should be reported earlier in the relabel check)."
msgstr ""
"Os eventos de reclassifica��o ocorrem quando um processo do usu�rio solicita "
"que o r�tulo de um objeto seja modificado. Uma atualiza��o de duas fases "
"ocorre: primeiro, uma verifica��o de controle de acesso ser� executada para "
"determinar se a atualiza��o � v�lida e permitida e, em seguida, a "
"atualiza��o O ponto de entrada de reclassifica��o normalmente aceita o "
"objeto, a refer�ncia de r�tulo de objeto e um r�tulo de atualiza��o enviado "
"pelo processo.A aloca��o de mem�ria durante a reclassifica��o n�o � "
"recomendada, pois as chamadas de reclassifica��o n�o t�m permiss�o para "
"falhar mais cedo na verifica��o de reclassifica��o). "

#. (itstool) path: sect1/title
#: book.translate.xml:14510
#, fuzzy
msgid "Userland Architecture"
msgstr "Arquitetura Userland"

#. (itstool) path: sect1/para
#: book.translate.xml:14512
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework includes a number of policy-agnostic elements, "
"including MAC library interfaces for abstractly managing labels, "
"modifications to the system credential management and login libraries to "
"support the assignment of MAC labels to users, and a set of tools to monitor "
"and modify labels on processes, files, and network interfaces. More details "
"on the user architecture will be added to this section in the near future."
msgstr ""
"O TrustedBSD MAC Framework inclui v�rios elementos agn�sticos de pol�ticas, "
"incluindo interfaces de biblioteca MAC para gerenciar r�tulos, modifica��es "
"no gerenciamento de credenciais do sistema e bibliotecas de login para "
"suportar a atribui��o de r�tulos MAC aos usu�rios e um conjunto de "
"ferramentas para monitorar e modificar r�tulos em processos, arquivos e "
"interfaces de rede. Mais detalhes sobre a arquitetura do usu�rio ser�o "
"adicionados a esta se��o em um futuro pr�ximo. "

#. (itstool) path: sect2/title
#: book.translate.xml:14522
#, fuzzy
msgid "APIs for Policy-Agnostic Label Management"
msgstr "APIs para gerenciamento de r�tulos agn�sticos em pol�ticas"

#. (itstool) path: sect2/para
#: book.translate.xml:14524
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework provides a number of library and system calls "
"permitting applications to manage MAC labels on objects using a policy-"
"agnostic interface. This permits applications to manipulate labels for a "
"variety of policies without being written to support specific policies. "
"These interfaces are used by general-purpose tools such as "
"<citerefentry><refentrytitle>ifconfig</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>, <citerefentry><refentrytitle>ls</"
"refentrytitle><manvolnum>1</manvolnum></citerefentry> and "
"<citerefentry><refentrytitle>ps</refentrytitle><manvolnum>1</manvolnum></"
"citerefentry> to view labels on network interfaces, files, and processes. "
"The APIs also support MAC management tools including "
"<citerefentry><refentrytitle>getfmac</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>, <citerefentry><refentrytitle>getpmac</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>setfmac</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>, <citerefentry><refentrytitle>setfsmac</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>, and "
"<citerefentry><refentrytitle>setpmac</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>. The MAC APIs are documented in "
"<citerefentry><refentrytitle>mac</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>."
msgstr ""
"O TrustedBSD MAC Framework fornece v�rias chamadas de biblioteca e de "
"sistema, permitindo que aplicativos gerenciem r�tulos MAC em objetos usando "
"uma interface independente de pol�ticas. Isso permite que os aplicativos "
"manipulem r�tulos para uma variedade de pol�ticas sem serem escritos para "
"suportar pol�ticas espec�ficas. Essas interfaces s�o usado por ferramentas "
"de uso geral, como <citerefentry><refentrytitle> ifconfig </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> , "
"<citerefentry><refentrytitle> ls </refentrytitle><manvolnum> 1 </manvolnum></"
"citerefentry> e <citerefentry><refentrytitle> ps </refentrytitle><manvolnum> "
"1 </manvolnum></citerefentry> para exibir r�tulos em interfaces de rede, "
"arquivos e processos. As APIs tamb�m suportam ferramentas de gerenciamento "
"MAC, incluindo <citerefentry><refentrytitle> getfmac </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> , "
"<citerefentry><refentrytitle> getpmac </refentrytitle><manvolnum> 8 </"
"manvolnum></citerefentry> , <citerefentry><refentrytitle> setfmac </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> , "
"<citerefentry><refentrytitle> setfsmac </refentrytitle><manvolnum> 8 </"
"manvolnum></citerefentry> e <citerefentry><refentrytitle> setpmac </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> . As APIs do MAC "
"est�o documentadas em <citerefentry><refentrytitle> Mac </"
"refentrytitle><manvolnum> 3 </manvolnum></citerefentry> "

#. (itstool) path: sect2/para
#: book.translate.xml:14538
#, fuzzy
msgid ""
"Applications handle MAC labels in two forms: an internalized form used to "
"return and set labels on processes and objects (<literal>mac_t</literal>), "
"and externalized form based on C strings appropriate for storage in "
"configuration files, display to the user, or input from the user. Each MAC "
"label contains a number of elements, each consisting of a name and value "
"pair. Policy modules in the kernel bind to specific names and interpret the "
"values in policy-specific ways. In the externalized string form, labels are "
"represented by a comma-delimited list of name and value pairs separated by "
"the <literal>/</literal> character. Labels may be directly converted to and "
"from text using provided APIs; when retrieving labels from the kernel, "
"internalized label storage must first be prepared for the desired label "
"element set. Typically, this is done in one of two ways: using "
"<citerefentry><refentrytitle>mac_prepare</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry> and an arbitrary list of desired label elements, "
"or one of the variants of the call that loads a default element set from the "
"<citerefentry><refentrytitle>mac.conf</refentrytitle><manvolnum>5</"
"manvolnum></citerefentry> configuration file. Per-object defaults permit "
"application writers to usefully display labels associated with objects "
"without being aware of the policies present in the system."
msgstr ""
"Os aplicativos manipulam r�tulos MAC de duas formas: um formul�rio "
"internalizado usado para retornar e definir r�tulos em processos e objetos "
"( <literal> mac_t </literal> ) e formul�rio externalizado baseado em "
"sequ�ncias C apropriadas para armazenamento em arquivos de configura��o, "
"exibi��o para o usu�rio ou entrada do usu�rio. Cada r�tulo MAC cont�m v�rios "
"elementos, cada um consistindo em um par de nome e valor. Os m�dulos de "
"pol�tica no kernel s�o vinculados a nomes espec�ficos e interpretam os "
"valores de maneiras espec�ficas da pol�tica. No formul�rio de string "
"exteriorizado, os r�tulos s�o representados por uma lista delimitada por "
"v�rgulas de pares de nome e valor separados por <literal> / </literal> "
"personagem. Os r�tulos podem ser convertidos diretamente para e a partir do "
"texto usando as APIs fornecidas; Ao recuperar r�tulos do kernel, o "
"armazenamento de r�tulos internalizado deve primeiro ser preparado para o "
"conjunto de elementos de r�tulo desejado. Normalmente, isso � feito de duas "
"maneiras: usando <citerefentry><refentrytitle> mac_prepare </"
"refentrytitle><manvolnum> 3 </manvolnum></citerefentry> e uma lista "
"arbitr�ria de elementos de r�tulo desejados, ou uma das variantes da chamada "
"que carrega um conjunto de elementos padr�o do <citerefentry><refentrytitle> "
"mac.conf </refentrytitle><manvolnum> 5 </manvolnum></citerefentry> arquivo "
"de configura��o. Padr�es por objeto permitem que escritores de aplicativos "
"exibam r�tulos associados a objetos sem estarem cientes das pol�ticas "
"presentes no sistema. "

#. (itstool) path: note/para
#: book.translate.xml:14563
#, fuzzy
msgid ""
"Currently, direct manipulation of label elements other than by conversion to "
"a text string, string editing, and conversion back to an internalized label "
"is not supported by the MAC library. Such interfaces may be added in the "
"future if they prove necessary for application writers."
msgstr ""
"Atualmente, a manipula��o direta de elementos de r�tulo diferentes da "
"convers�o para uma string de texto, edi��o de string e convers�o de volta "
"para um r�tulo internalizado n�o � suportada pela biblioteca MAC. Tais "
"interfaces podem ser adicionadas no futuro se forem necess�rias para "
"escritores de aplicativos "

#. (itstool) path: sect2/title
#: book.translate.xml:14573
#, fuzzy
msgid "Binding of Labels to Users"
msgstr "Liga��o de etiquetas aos usu�rios"

#. (itstool) path: sect2/para
#: book.translate.xml:14575
#, fuzzy
msgid ""
"The standard user context management interface, "
"<citerefentry><refentrytitle>setusercontext</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry>, has been modified to retrieve MAC labels "
"associated with a user's class from <citerefentry><refentrytitle>login.conf</"
"refentrytitle><manvolnum>5</manvolnum></citerefentry>. These labels are then "
"set along with other user context when either <literal>LOGIN_SETALL</"
"literal> is specified, or when <literal>LOGIN_SETMAC</literal> is explicitly "
"specified."
msgstr ""
"A interface padr�o de gerenciamento de contexto do usu�rio, "
"<citerefentry><refentrytitle> setusercontext </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> , foi modificado para recuperar r�tulos MAC "
"associados a uma classe de usu�rio de <citerefentry><refentrytitle> login."
"conf </refentrytitle><manvolnum> 5 </manvolnum></citerefentry> . Esses "
"r�tulos s�o ent�o definidos junto com outro contexto de usu�rio quando "
"<literal> LOGIN_SETALL </literal> � especificado, ou quando <literal> "
"LOGIN_SETMAC </literal> � explicitamente especificado. "

#. (itstool) path: note/para
#: book.translate.xml:14584
#, fuzzy
msgid ""
"It is expected that, in a future version of FreeBSD, the MAC label database "
"will be separated from the <filename>login.conf</filename> user class "
"abstraction, and be maintained in a separate database. However, the "
"<citerefentry><refentrytitle>setusercontext</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry> API should remain the same following such a change."
msgstr ""
"Espera-se que, em uma vers�o futura do FreeBSD, o banco de dados de r�tulos "
"MAC seja separado do <filename> login.conf </filename> abstra��o de classe "
"de usu�rio, e ser mantido em um banco de dados separado. No entanto, o "
"<citerefentry><refentrytitle> setusercontext </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> A API deve permanecer a mesma ap�s essa mudan�a. "

#. (itstool) path: sect1/title
#: book.translate.xml:14594
#, fuzzy
msgid "Conclusion"
msgstr "Conclus�o"

#. (itstool) path: sect1/para
#: book.translate.xml:14596
#, fuzzy
msgid ""
"The TrustedBSD MAC framework permits kernel modules to augment the system "
"security policy in a highly integrated manner. They may do this based on "
"existing object properties, or based on label data that is maintained with "
"the assistance of the MAC framework. The framework is sufficiently flexible "
"to implement a variety of policy types, including information flow security "
"policies such as MLS and Biba, as well as policies based on existing BSD "
"credentials or file protections. Policy authors may wish to consult this "
"documentation as well as existing security modules when implementing a new "
"security service."
msgstr ""
"A estrutura do TrustedBSD MAC permite que os m�dulos do kernel aumentem a "
"pol�tica de seguran�a do sistema de uma maneira altamente integrada. Eles "
"podem fazer isso com base nas propriedades de objetos existentes ou com base "
"nos dados de r�tulo que s�o mantidos com a assist�ncia da estrutura MAC. "
"flex�veis para implementar uma variedade de tipos de pol�ticas, incluindo "
"pol�ticas de seguran�a de fluxo de informa��es como MLS e Biba, bem como "
"pol�ticas baseadas em credenciais BSD existentes ou prote��es de arquivos."
"Autoriais de pol�ticas podem desejar consultar esta documenta��o assim como "
"m�dulos de seguran�a existentes ao implementar novo servi�o de seguran�a. "

#. (itstool) path: info/title
#: book.translate.xml:14619
#, fuzzy
msgid "Virtual Memory System"
msgstr "Sistema de Mem�ria Virtual"

#. (itstool) path: authorgroup/author
#: book.translate.xml:14622
#, fuzzy
msgid ""
"<personname> <firstname>Matthew</firstname> <surname>Dillon</surname> </"
"personname> <contrib>Contributed by </contrib>"
msgstr ""
" <personname><firstname> Mateus </firstname><surname> Dillon </surname></"
"personname><contrib> Contribu�ram por </contrib> "

#. (itstool) path: sect1/title
#: book.translate.xml:14633
#, fuzzy
msgid "Management of Physical Memory—<literal>vm_page_t</literal>"
msgstr "Gerenciamento de mem�ria f�sica— <literal> vm_page_t </literal> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14636
#, fuzzy
msgid "<primary>virtual memory</primary>"
msgstr " <primary> mem�ria virtual </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14637
#, fuzzy
msgid "<primary>physical memory</primary>"
msgstr " <primary> mem�ria f�sica </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14638
#, fuzzy
msgid "<primary><literal>vm_page_t</literal> structure</primary>"
msgstr " <primary><literal> vm_page_t </literal> estrutura </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:14642
#, fuzzy
msgid ""
"Physical memory is managed on a page-by-page basis through the "
"<literal>vm_page_t</literal> structure. Pages of physical memory are "
"categorized through the placement of their respective <literal>vm_page_t</"
"literal> structures on one of several paging queues."
msgstr ""
"A mem�ria f�sica � gerenciada p�gina por p�gina atrav�s do <literal> "
"vm_page_t </literal> estrutura. As p�ginas da mem�ria f�sica s�o "
"categorizadas atrav�s da coloca��o de seus respectivos <literal> vm_page_t </"
"literal> estruturas em uma das v�rias filas de pagina��o. "

#. (itstool) path: sect1/para
#: book.translate.xml:14648
#, fuzzy
msgid ""
"A page can be in a wired, active, inactive, cache, or free state. Except for "
"the wired state, the page is typically placed in a doubly link list queue "
"representing the state that it is in. Wired pages are not placed on any "
"queue."
msgstr ""
"Uma p�gina pode estar em um estado com fio, ativo, inativo, em cache ou "
"livre. Exceto pelo estado com fio, a p�gina normalmente � colocada em uma "
"fila de lista de links duplamente representando o estado em que est�. As "
"p�ginas com fio n�o s�o colocadas em qualquer fila. "

#. (itstool) path: sect1/para
#: book.translate.xml:14653
#, fuzzy
msgid ""
"FreeBSD implements a more involved paging queue for cached and free pages in "
"order to implement page coloring. Each of these states involves multiple "
"queues arranged according to the size of the processor's L1 and L2 caches. "
"When a new page needs to be allocated, FreeBSD attempts to obtain one that "
"is reasonably well aligned from the point of view of the L1 and L2 caches "
"relative to the VM object the page is being allocated for."
msgstr ""
"O FreeBSD implementa uma fila de pagina��o mais envolvida para p�ginas em "
"cache e livres, a fim de implementar colora��o de p�gina. Cada um desses "
"estados envolve v�rias filas organizadas de acordo com o tamanho dos caches "
"L1 e L2 do processador. Quando uma nova p�gina precisa ser alocada, o "
"FreeBSD tenta obter um que esteja razoavelmente bem alinhado do ponto de "
"vista dos caches L1 e L2 em rela��o ao objeto de VM para o qual a p�gina "
"est� sendo alocada. "

#. (itstool) path: sect1/para
#: book.translate.xml:14662
#, fuzzy
msgid ""
"Additionally, a page may be held with a reference count or locked with a "
"busy count. The VM system also implements an <quote>ultimate locked</quote> "
"state for a page using the PG_BUSY bit in the page's flags."
msgstr ""
"Al�m disso, uma p�gina pode ser mantida com uma contagem de refer�ncia ou "
"bloqueada com uma contagem ocupada. O sistema VM tamb�m implementa uma "
"<quote> ultimate bloqueado </quote> estado para uma p�gina usando o bit "
"PG_BUSY nos flags da p�gina. "

#. (itstool) path: sect1/para
#: book.translate.xml:14667
#, fuzzy
msgid ""
"In general terms, each of the paging queues operates in a LRU fashion. A "
"page is typically placed in a wired or active state initially. When wired, "
"the page is usually associated with a page table somewhere. The VM system "
"ages the page by scanning pages in a more active paging queue (LRU) in order "
"to move them to a less-active paging queue. Pages that get moved into the "
"cache are still associated with a VM object but are candidates for immediate "
"reuse. Pages in the free queue are truly free. FreeBSD attempts to minimize "
"the number of pages in the free queue, but a certain minimum number of truly "
"free pages must be maintained in order to accommodate page allocation at "
"interrupt time."
msgstr ""
"Em termos gerais, cada uma das filas de pagina��o opera de forma LRU. Uma "
"p�gina � normalmente colocada em um estado com fio ou ativo inicialmente. "
"Quando ligada, a p�gina � geralmente associada a uma tabela de p�ginas em "
"algum lugar. O sistema VM envelhece a p�gina por varrendo p�ginas em uma "
"fila de pagina��o mais ativa (LRU) para mov�-las para uma fila de pagina��o "
"menos ativa As p�ginas que s�o movidas para o cache ainda s�o associadas a "
"um objeto VM, mas s�o candidatas a reutiliza��o imediata. O FreeBSD tenta "
"minimizar o n�mero de p�ginas na fila livre, mas um certo n�mero m�nimo de "
"p�ginas realmente livres deve ser mantido para acomodar a aloca��o de "
"p�ginas no momento da interrup��o. "

#. (itstool) path: sect1/para
#: book.translate.xml:14680
#, fuzzy
msgid ""
"If a process attempts to access a page that does not exist in its page table "
"but does exist in one of the paging queues (such as the inactive or cache "
"queues), a relatively inexpensive page reactivation fault occurs which "
"causes the page to be reactivated. If the page does not exist in system "
"memory at all, the process must block while the page is brought in from disk."
msgstr ""
"Se um processo tentar acessar uma p�gina que n�o existe em sua tabela de "
"p�ginas mas existir em uma das filas de pagina��o (como as filas inativas ou "
"de cache), ocorrer� uma falha de reativa��o de p�gina relativamente barata "
"que faz com que a p�gina seja reativada Se a p�gina n�o existir na mem�ria "
"do sistema, o processo deve ser bloqueado enquanto a p�gina � trazida do "
"disco. "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14688
#, fuzzy
msgid "<primary>paging queues</primary>"
msgstr " <primary> filas de pagina��o </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:14690
#, fuzzy
msgid ""
"FreeBSD dynamically tunes its paging queues and attempts to maintain "
"reasonable ratios of pages in the various queues as well as attempts to "
"maintain a reasonable breakdown of clean versus dirty pages. The amount of "
"rebalancing that occurs depends on the system's memory load. This "
"rebalancing is implemented by the pageout daemon and involves laundering "
"dirty pages (syncing them with their backing store), noticing when pages are "
"activity referenced (resetting their position in the LRU queues or moving "
"them between queues), migrating pages between queues when the queues are out "
"of balance, and so forth. FreeBSD's VM system is willing to take a "
"reasonable number of reactivation page faults to determine how active or how "
"idle a page actually is. This leads to better decisions being made as to "
"when to launder or swap-out a page."
msgstr ""
"O FreeBSD ajusta dinamicamente suas filas de pagina��o e tenta manter "
"�ndices razo�veis ​​de p�ginas nas v�rias filas, bem como tentativas de manter "
"um detalhamento razo�vel de p�ginas limpas versus p�ginas sujas. A "
"quantidade de rebalanceamento que ocorre depende da carga de mem�ria do "
"sistema. implementado pelo daemon de pageout e envolve a lavagem de p�ginas "
"sujas (sincronizando-as com seu armazenamento de backup), observando quando "
"as p�ginas s�o referenciadas � atividade (redefinindo sua posi��o nas filas "
"de LRU ou movendo-as entre filas), migrando p�ginas entre filas quando as "
"filas est�o fora O sistema VM do FreeBSD est� disposto a aceitar um n�mero "
"razo�vel de falhas de p�gina de reativa��o para determinar o qu�o ativo ou "
"ocioso � uma p�gina. Isso leva a melhores decis�es sobre quando lavar ou "
"trocar uma p�gina. "

#. (itstool) path: sect1/title
#: book.translate.xml:14707
#, fuzzy
msgid "The Unified Buffer Cache—<literal>vm_object_t</literal>"
msgstr "O Unified Buffer Cache— <literal> vm_object_t </literal> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14710
#, fuzzy
msgid "<primary>unified buffer cache</primary>"
msgstr " <primary> cache de buffer unificado </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14711
#, fuzzy
msgid "<primary><literal>vm_object_t</literal> structure</primary>"
msgstr " <primary><literal> vm_object_t </literal> estrutura </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:14715
#, fuzzy
msgid ""
"FreeBSD implements the idea of a generic <quote>VM object</quote>. VM "
"objects can be associated with backing store of various types—unbacked, swap-"
"backed, physical device-backed, or file-backed storage. Since the filesystem "
"uses the same VM objects to manage in-core data relating to files, the "
"result is a unified buffer cache."
msgstr ""
"O FreeBSD implementa a id�ia de um gen�rico <quote> Objeto da VM </quote> . "
"Os objetos da VM podem ser associados ao armazenamento de suporte de v�rios "
"tipos - armazenamento n�o suportado, com suporte a permuta, com suporte para "
"dispositivos f�sicos ou com suporte a arquivos. Como o sistema de arquivos "
"usa os mesmos objetos de VM para gerenciar dados internos relacionados aos "
"arquivos, o resultado � um cache de buffer unificado. "

#. (itstool) path: sect1/para
#: book.translate.xml:14722
#, fuzzy
msgid ""
"VM objects can be <emphasis>shadowed</emphasis>. That is, they can be "
"stacked on top of each other. For example, you might have a swap-backed VM "
"object stacked on top of a file-backed VM object in order to implement a "
"MAP_PRIVATE mmap()ing. This stacking is also used to implement various "
"sharing properties, including copy-on-write, for forked address spaces."
msgstr ""
"Objetos VM podem ser <emphasis> sombreado </emphasis> . Ou seja, eles podem "
"ser empilhados uns sobre os outros. Por exemplo, voc� pode ter um objeto de "
"VM com suporte a permuta empilhado sobre um objeto de VM com backup de "
"arquivo para implementar um MAP_PRIVATE mmap (). Esse empilhamento tamb�m � "
"usado para implementar v�rias propriedades de compartilhamento, incluindo "
"copy-on-write, para espa�os de endere�amento bifurcados. "

#. (itstool) path: sect1/para
#: book.translate.xml:14730
#, fuzzy
msgid ""
"It should be noted that a <literal>vm_page_t</literal> can only be "
"associated with one VM object at a time. The VM object shadowing implements "
"the perceived sharing of the same page across multiple instances."
msgstr ""
"Deve-se notar que um <literal> vm_page_t </literal> s� pode ser associado a "
"um objeto de VM por vez. O sombreamento de objeto da VM implementa o "
"compartilhamento percebido da mesma p�gina em v�rias inst�ncias. "

#. (itstool) path: sect1/title
#: book.translate.xml:14737
#, fuzzy
msgid "Filesystem I/O—<literal>struct buf</literal>"
msgstr "Sistema de arquivos I / O— <literal> struct buf </literal> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14739
#, fuzzy
msgid "<primary>vnode</primary>"
msgstr " <primary> vnode </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:14740
#, fuzzy
msgid ""
"vnode-backed VM objects, such as file-backed objects, generally need to "
"maintain their own clean/dirty info independent from the VM system's idea of "
"clean/dirty. For example, when the VM system decides to synchronize a "
"physical page to its backing store, the VM system needs to mark the page "
"clean before the page is actually written to its backing store. "
"Additionally, filesystems need to be able to map portions of a file or file "
"metadata into KVM in order to operate on it."
msgstr ""
"Objetos VM com backup de vnode, como objetos com backup de arquivos, "
"geralmente precisam manter suas pr�prias informa��es limpas / sujas "
"independentemente da id�ia de limpeza / sujeira do sistema VM. Por exemplo, "
"quando o sistema VM decide sincronizar uma p�gina f�sica com No backing "
"store, o sistema VM precisa marcar a p�gina limpa antes que a p�gina seja "
"realmente gravada em seu armazenamento de backup. Al�m disso, os sistemas de "
"arquivos precisam poder mapear partes de um arquivo ou metadados de arquivo "
"para o KVM para oper�-lo. "

#. (itstool) path: sect1/para
#: book.translate.xml:14749
#, fuzzy
msgid ""
"The entities used to manage this are known as filesystem buffers, "
"<literal>struct buf</literal>'s, or <literal>bp</literal>'s. When a "
"filesystem needs to operate on a portion of a VM object, it typically maps "
"part of the object into a struct buf and then maps the pages in the struct "
"buf into KVM. In the same manner, disk I/O is typically issued by mapping "
"portions of objects into buffer structures and then issuing the I/O on the "
"buffer structures. The underlying vm_page_t's are typically busied for the "
"duration of the I/O. Filesystem buffers also have their own notion of being "
"busy, which is useful to filesystem driver code which would rather operate "
"on filesystem buffers instead of hard VM pages."
msgstr ""
"As entidades usadas para gerenciar isso s�o conhecidas como buffers de "
"sistema de arquivos, <literal> struct buf </literal> � ou <literal> pb </"
"literal> . Quando um sistema de arquivos precisa operar em uma parte de um "
"objeto VM, ele normalmente mapeia parte do objeto em um struct buf e, em "
"seguida, mapeia as p�ginas no struct buf para o KVM. Da mesma maneira, a E / "
"S de disco normalmente � emitida por partes de mapeamento de objetos em "
"estruturas de buffer e, em seguida, emitindo a E / S nas estruturas de "
"buffer. As vm_page_t subjacentes geralmente s�o ocupadas pela dura��o da E / "
"S. Os buffers do sistema de arquivos tamb�m t�m sua pr�pria no��o de estar "
"ocupado, o que � �til para o c�digo do driver do sistema de arquivos, que "
"preferia operar em buffers do sistema de arquivos em vez de p�ginas da VM. "

#. (itstool) path: sect1/para
#: book.translate.xml:14762
#, fuzzy
msgid ""
"FreeBSD reserves a limited amount of KVM to hold mappings from struct bufs, "
"but it should be made clear that this KVM is used solely to hold mappings "
"and does not limit the ability to cache data. Physical data caching is "
"strictly a function of <literal>vm_page_t</literal>'s, not filesystem "
"buffers. However, since filesystem buffers are used to placehold I/O, they "
"do inherently limit the amount of concurrent I/O possible. However, as there "
"are usually a few thousand filesystem buffers available, this is not usually "
"a problem."
msgstr ""
"O FreeBSD reserva uma quantidade limitada de KVM para conter os mapeamentos "
"de struct bufs, mas deve ficar claro que este KVM � usado apenas para manter "
"mapeamentos e n�o limita a capacidade de armazenar dados em cache. O cache "
"de dados f�sicos � estritamente uma fun��o de <literal> vm_page_t </literal> "
"n�o s�o buffers de sistema de arquivos. No entanto, como os buffers do "
"sistema de arquivos s�o usados ​​para posicionar E / S, eles limitam "
"inerentemente a quantidade de E / S simult�nea poss�vel. No entanto, como "
"geralmente h� alguns milhares de buffers de sistema de arquivos dispon�veis, "
"isso geralmente n�o � um problema. "

#. (itstool) path: sect1/title
#: book.translate.xml:14774
#, fuzzy
msgid "Mapping Page Tables—<literal>vm_map_t, vm_entry_t</literal>"
msgstr "Mapping Page Tables— <literal> vm_map_t, vm_entry_t </literal> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14777
#, fuzzy
msgid "<primary>page tables</primary>"
msgstr " <primary> tabelas de p�ginas </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:14778
#, fuzzy
msgid ""
"FreeBSD separates the physical page table topology from the VM system. All "
"hard per-process page tables can be reconstructed on the fly and are usually "
"considered throwaway. Special page tables such as those managing KVM are "
"typically permanently preallocated. These page tables are not throwaway."
msgstr ""
"O FreeBSD separa a topologia da tabela de p�ginas f�sicas do sistema VM. "
"Todas as tabelas de p�ginas dif�ceis por processo podem ser reconstru�das "
"rapidamente e s�o geralmente consideradas descart�veis. Tabelas de p�ginas "
"especiais como aquelas que gerenciam KVM s�o tipicamente pr�-alocadas "
"permanentemente. jogar fora."

#. (itstool) path: sect1/para
#: book.translate.xml:14785
#, fuzzy
msgid ""
"FreeBSD associates portions of vm_objects with address ranges in virtual "
"memory through <literal>vm_map_t</literal> and <literal>vm_entry_t</literal> "
"structures. Page tables are directly synthesized from the <literal>vm_map_t</"
"literal>/<literal>vm_entry_t</literal>/ <literal>vm_object_t</literal> "
"hierarchy. Recall that I mentioned that physical pages are only directly "
"associated with a <literal>vm_object</literal>; that is not quite true. "
"<literal>vm_page_t</literal>'s are also linked into page tables that they "
"are actively associated with. One <literal>vm_page_t</literal> can be linked "
"into several <emphasis>pmaps</emphasis>, as page tables are called. However, "
"the hierarchical association holds, so all references to the same page in "
"the same object reference the same <literal>vm_page_t</literal> and thus "
"give us buffer cache unification across the board."
msgstr ""
"O FreeBSD associa por��es de vm_objects com intervalos de endere�o na "
"mem�ria virtual atrav�s de <literal> vm_map_t </literal> e <literal> "
"vm_entry_t </literal> estruturas. Tabelas de p�gina s�o diretamente "
"sintetizadas a partir do <literal> vm_map_t </literal> / <literal> "
"vm_entry_t </literal> / <literal> vm_object_t </literal> hierarquia. Lembre-"
"se de que mencionei que as p�ginas f�sicas s�o associadas diretamente a "
"<literal> vm_object </literal> ; isso n�o � bem verdade. <literal> vm_page_t "
"</literal> tamb�m est�o ligados a tabelas de p�ginas com as quais est�o "
"ativamente associados. 1 <literal> vm_page_t </literal> pode ser ligado em "
"v�rios <emphasis> pmaps </emphasis> , como as tabelas de p�ginas s�o "
"chamadas. No entanto, a associa��o hier�rquica � v�lida, portanto, todas as "
"refer�ncias � mesma p�gina no mesmo objeto fazem refer�ncia ao mesmo "
"<literal> vm_page_t </literal> e assim nos dar a unifica��o do cache de "
"buffer atrav�s da placa. "

#. (itstool) path: sect1/title
#: book.translate.xml:14804
#, fuzzy
msgid "KVM Memory Mapping"
msgstr "Mapeamento de mem�ria KVM"

#. (itstool) path: sect1/para
#: book.translate.xml:14806
#, fuzzy
msgid ""
"FreeBSD uses KVM to hold various kernel structures. The single largest "
"entity held in KVM is the filesystem buffer cache. That is, mappings "
"relating to <literal>struct buf</literal> entities."
msgstr ""
"O FreeBSD usa o KVM para armazenar v�rias estruturas de kernel. A maior "
"entidade individual mantida no KVM � o cache de buffer do sistema de "
"arquivos. Ou seja, mapeamentos relacionados a <literal> struct buf </"
"literal> entidades."

#. (itstool) path: sect1/para
#: book.translate.xml:14811
#, fuzzy
msgid ""
"Unlike Linux, FreeBSD does <emphasis>not</emphasis> map all of physical "
"memory into KVM. This means that FreeBSD can handle memory configurations up "
"to 4G on 32 bit platforms. In fact, if the mmu were capable of it, FreeBSD "
"could theoretically handle memory configurations up to 8TB on a 32 bit "
"platform. However, since most 32 bit platforms are only capable of mapping "
"4GB of ram, this is a moot point."
msgstr ""
"Ao contr�rio do Linux, o FreeBSD faz <emphasis> n�o </emphasis> mapear toda "
"a mem�ria f�sica para o KVM. Isso significa que o FreeBSD pode manipular "
"configura��es de mem�ria de at� 4G em plataformas de 32 bits. De fato, se o "
"mmu fosse capaz disso, o FreeBSD teoricamente poderia manipular "
"configura��es de mem�ria de at� 8 TB em uma plataforma de 32 bits. No "
"entanto, como a maioria das plataformas de 32 bits s� � capaz de mapear 4 GB "
"de RAM, isso � um ponto discut�vel. "

#. (itstool) path: sect1/para
#: book.translate.xml:14819
#, fuzzy
msgid ""
"KVM is managed through several mechanisms. The main mechanism used to manage "
"KVM is the <emphasis>zone allocator</emphasis>. The zone allocator takes a "
"chunk of KVM and splits it up into constant-sized blocks of memory in order "
"to allocate a specific type of structure. You can use <command>vmstat -m</"
"command> to get an overview of current KVM utilization broken down by zone."
msgstr ""
"O KVM � gerenciado atrav�s de v�rios mecanismos. O principal mecanismo usado "
"para gerenciar o KVM � o <emphasis> alocador de zona </emphasis> . O "
"alocador de zona pega um peda�o do KVM e o divide em blocos de mem�ria de "
"tamanho constante para alocar um tipo espec�fico de estrutura. Voc� pode "
"usar <command> vmstat -m </command> para obter uma vis�o geral da utiliza��o "
"atual da KVM dividida por zona. "

#. (itstool) path: sect1/title
#: book.translate.xml:14829
#, fuzzy
msgid "Tuning the FreeBSD VM System"
msgstr "Ajustando o sistema VM do FreeBSD"

#. (itstool) path: sect1/para
#: book.translate.xml:14831
#, fuzzy
msgid ""
"A concerted effort has been made to make the FreeBSD kernel dynamically tune "
"itself. Typically you do not need to mess with anything beyond the "
"<option>maxusers</option> and <option>NMBCLUSTERS</option> kernel config "
"options. That is, kernel compilation options specified in (typically) "
"<filename>/usr/src/sys/i386/conf/<replaceable>CONFIG_FILE</replaceable></"
"filename>. A description of all available kernel configuration options can "
"be found in <filename>/usr/src/sys/i386/conf/LINT</filename>."
msgstr ""
"Um esfor�o concentrado foi feito para fazer o kernel do FreeBSD se ajustar "
"dinamicamente. Normalmente voc� n�o precisa mexer com nada al�m do <option "
"value=maxusers> maxusers </option> e <option value=NMBCLUSTERS> NMBCLUSTERS "
"</option> op��es de configura��o do kernel. Isto �, op��es de compila��o do "
"kernel especificadas em (tipicamente) <filename> / usr / src / sys / i386 / "
"conf / <replaceable> CONFIG_FILE </replaceable></filename> . Uma descri��o "
"de todas as op��es de configura��o do kernel dispon�veis pode ser encontrada "
"em <filename> / usr / src / sys / i386 / conf / LINT </filename> "

#. (itstool) path: sect1/para
#: book.translate.xml:14841
#, fuzzy
msgid ""
"In a large system configuration you may wish to increase <option>maxusers</"
"option>. Values typically range from 10 to 128. Note that raising "
"<option>maxusers</option> too high can cause the system to overflow "
"available KVM resulting in unpredictable operation. It is better to leave "
"<option>maxusers</option> at some reasonable number and add other options, "
"such as <option>NMBCLUSTERS</option>, to increase specific resources."
msgstr ""
"Em uma grande configura��o do sistema, voc� pode querer aumentar <option "
"value=maxusers> maxusers </option> . Os valores geralmente variam de 10 a "
"128. Observe que aumentar <option value=maxusers> maxusers </option> muito "
"alto pode fazer com que o sistema transborde KVM dispon�vel, resultando em "
"opera��o imprevis�vel. � melhor deixar <option value=maxusers> maxusers </"
"option> em algum n�mero razo�vel e adicionar outras op��es, como <option "
"value=NMBCLUSTERS> NMBCLUSTERS </option> , para aumentar recursos "
"espec�ficos \""

#. (itstool) path: sect1/para
#: book.translate.xml:14850
#, fuzzy
msgid ""
"If your system is going to use the network heavily, you may want to increase "
"<option>NMBCLUSTERS</option>. Typical values range from 1024 to 4096."
msgstr ""
"Se o seu sistema vai usar a rede pesadamente, voc� pode querer aumentar "
"<option value=NMBCLUSTERS> NMBCLUSTERS </option> . Valores t�picos variam de "
"1024 a 4096. "

#. (itstool) path: sect1/para
#: book.translate.xml:14854
#, fuzzy
msgid ""
"The <literal>NBUF</literal> parameter is also traditionally used to scale "
"the system. This parameter determines the amount of KVA the system can use "
"to map filesystem buffers for I/O. Note that this parameter has nothing "
"whatsoever to do with the unified buffer cache! This parameter is "
"dynamically tuned in 3.0-CURRENT and later kernels and should generally not "
"be adjusted manually. We recommend that you <emphasis>not</emphasis> try to "
"specify an <literal>NBUF</literal> parameter. Let the system pick it. Too "
"small a value can result in extremely inefficient filesystem operation while "
"too large a value can starve the page queues by causing too many pages to "
"become wired down."
msgstr ""
"O <literal> NBUF </literal> par�metro tamb�m � tradicionalmente usado para "
"dimensionar o sistema. Esse par�metro determina a quantidade de KVA que o "
"sistema pode usar para mapear buffers de sistema de arquivos para E / S. "
"Note que este par��metro n�o tem nada a ver com o cache de buffer unificado! "
"Este par�metro � dinamicamente ajustado nos kernels 3.0-CURRENT e "
"posteriores e geralmente n�o deve ser ajustado manualmente. Recomendamos que "
"voc� <emphasis> n�o </emphasis> tente especificar um <literal> NBUF </"
"literal> par�metro. Deixe o sistema selecion�-lo. Um valor muito pequeno "
"pode resultar em opera��o do sistema de arquivos extremamente ineficiente, "
"enquanto um valor muito grande pode prejudicar as filas de p�ginas, fazendo "
"com que muitas p�ginas fiquem inativas. "

#. (itstool) path: sect1/para
#: book.translate.xml:14867
#, fuzzy
msgid ""
"By default, FreeBSD kernels are not optimized. You can set debugging and "
"optimization flags with the <literal>makeoptions</literal> directive in the "
"kernel configuration. Note that you should not use <option>-g</option> "
"unless you can accommodate the large (typically 7 MB+) kernels that result."
msgstr ""
"Por padr�o, os kernels do FreeBSD n�o s�o otimizados. Voc� pode definir "
"sinalizadores de depura��o e otimiza��o com o <literal> makeoptions </"
"literal> diretiva na configura��o do kernel. Note que voc� n�o deve usar "
"<option value=-g> -g </option> a menos que voc� possa acomodar os kernels "
"grandes (normalmente de 7 MB +) resultantes. "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:14874
#, no-wrap
msgid ""
"makeoptions      DEBUG=\"-g\"\n"
"makeoptions      COPTFLAGS=\"-O -pipe\""
msgstr ""
"makeoptions      DEBUG=\"-g\"\n"
"makeoptions      COPTFLAGS=\"-O -pipe\""

#. (itstool) path: sect1/para
#: book.translate.xml:14877
#, fuzzy
msgid ""
"Sysctl provides a way to tune kernel parameters at run-time. You typically "
"do not need to mess with any of the sysctl variables, especially the VM "
"related ones."
msgstr ""
"O Sysctl fornece uma maneira de ajustar os par�metros do kernel em tempo de "
"execu��o. Voc� normalmente n�o precisa mexer em nenhuma das vari�veis ​​do "
"sysctl, especialmente aquelas relacionadas � VM."

#. (itstool) path: sect1/para
#: book.translate.xml:14881
#, fuzzy
msgid ""
"Run time VM and system tuning is relatively straightforward. First, use Soft "
"Updates on your UFS/FFS filesystems whenever possible. <filename>/usr/src/"
"sys/ufs/ffs/README.softupdates</filename> contains instructions (and "
"restrictions) on how to configure it."
msgstr ""
"A VM de tempo de execu��o e o ajuste do sistema s�o relativamente diretos. "
"Primeiro, use as Soft Updates nos seus sistemas de arquivos UFS / FFS sempre "
"que poss�vel. <filename> /usr/src/sys/ufs/ffs/README.softupdates </filename> "
"cont�m instru��es (e restri��es) sobre como configur�-lo. "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14888
#, fuzzy
msgid "<primary>swap partition</primary>"
msgstr " <primary> parti��o swap </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:14889
#, fuzzy
msgid ""
"Second, configure sufficient swap. You should have a swap partition "
"configured on each physical disk, up to four, even on your <quote>work</"
"quote> disks. You should have at least 2x the swap space as you have main "
"memory, and possibly even more if you do not have a lot of memory. You "
"should also size your swap partition based on the maximum memory "
"configuration you ever intend to put on the machine so you do not have to "
"repartition your disks later on. If you want to be able to accommodate a "
"crash dump, your first swap partition must be at least as large as main "
"memory and <filename>/var/crash</filename> must have sufficient free space "
"to hold the dump."
msgstr ""
"Segundo, configure uma troca suficiente. Voc� deve ter uma parti��o swap "
"configurada em cada disco f�sico, at� quatro, mesmo no seu <quote> trabalhos "
"</quote> discos. Voc� deve ter pelo menos 2x o espa�o de troca como voc� tem "
"mem�ria principal, e possivelmente ainda mais se voc� n�o tiver muita "
"mem�ria. Voc� tamb�m deve dimensionar sua parti��o de troca com base na "
"configura��o m�xima de mem�ria que voc� pretende colocar na m�quina para que "
"n�o seja necess�rio reparticionar seus discos posteriormente. Se voc� quiser "
"ser capaz de acomodar um despejo de mem�ria, sua primeira parti��o de troca "
"deve ser pelo menos t�o grande quanto a mem�ria principal e <filename> / "
"var / crash </filename> deve ter espa�o livre suficiente para guardar o "
"lixo. "

#. (itstool) path: sect1/para
#: book.translate.xml:14901
#, fuzzy
msgid ""
"NFS-based swap is perfectly acceptable on 4.X or later systems, but you must "
"be aware that the NFS server will take the brunt of the paging load."
msgstr ""
"A troca baseada em NFS � perfeitamente aceit�vel em sistemas 4.X ou "
"posteriores, mas voc� deve estar ciente de que o servidor NFS ir� receber o "
"peso da carga de pagina��o."

#. (itstool) path: info/title
#: book.translate.xml:14915
#, fuzzy
msgid "SMPng Design Document"
msgstr "Documento de Projeto SMPng"

#. (itstool) path: authorgroup/author
#: book.translate.xml:14917
#, fuzzy
msgid ""
"<personname><firstname>John</firstname><surname>Baldwin</surname></"
"personname><contrib>Written by </contrib>"
msgstr ""
" <personname><firstname> John </firstname><surname> Baldwin </surname></"
"personname><contrib> Escrito por </contrib> "

#. (itstool) path: authorgroup/author
#: book.translate.xml:14918
#, fuzzy
msgid ""
"<personname><firstname>Robert</firstname><surname>Watson</surname></"
"personname>"
msgstr ""
" <personname><firstname> Robert </firstname><surname> Watson </surname></"
"personname> "

#. (itstool) path: info/copyright
#: book.translate.xml:14921
#, fuzzy
msgid ""
"<year>2002</year> <year>2004</year> <year>2005</year> <holder>John Baldwin</"
"holder> <holder>Robert Watson</holder>"
msgstr ""
" <year> 2002 </year><year> 2004 </year><year> 2005 </year><holder> John "
"Baldwin </holder><holder> Robert Watson </holder> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14935
#, fuzzy
msgid "<primary>SMP Next Generation</primary>"
msgstr " <primary> SMP Next Generation </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14936
#, fuzzy
msgid "<primary>kernel synchronization</primary>"
msgstr " <primary> sincroniza��o do kernel </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:14938
#, fuzzy
msgid ""
"This document presents the current design and implementation of the SMPng "
"Architecture. First, the basic primitives and tools are introduced. Next, a "
"general architecture for the FreeBSD kernel's synchronization and execution "
"model is laid out. Then, locking strategies for specific subsystems are "
"discussed, documenting the approaches taken to introduce fine-grained "
"synchronization and parallelism for each subsystem. Finally, detailed "
"implementation notes are provided to motivate design choices, and make the "
"reader aware of important implications involving the use of specific "
"primitives."
msgstr ""
"Este documento apresenta o projeto atual e a implementa��o da Arquitetura "
"SMPng. Primeiro, as primitivas e ferramentas b�sicas s�o apresentadas. Em "
"seguida, � apresentada uma arquitetura geral para o modelo de execu��o e "
"sincroniza��o do kernel do FreeBSD. Ent�o, estrat�gias de bloqueio para "
"subsistemas espec�ficos s�o discutidas. , documentando as abordagens "
"adotadas para introduzir sincroniza��o e paralelismo de alta granularidade "
"para cada subsistema. Finalmente, notas de implementa��o detalhadas s�o "
"fornecidas para motivar as escolhas de design e tornar o leitor ciente de "
"implica��es importantes envolvendo o uso de primitivos espec�ficos. "

#. (itstool) path: sect1/para
#: book.translate.xml:14949
#, fuzzy
msgid ""
"This document is a work-in-progress, and will be updated to reflect on-going "
"design and implementation activities associated with the SMPng Project. Many "
"sections currently exist only in outline form, but will be fleshed out as "
"work proceeds. Updates or suggestions regarding the document may be directed "
"to the document editors."
msgstr ""
"Este documento � um trabalho em andamento e ser� atualizado para refletir as "
"atividades de projeto e implementa��o associadas ao Projeto SMPng. Muitas "
"se��es existem atualmente apenas em forma de t�picos, mas ser�o "
"desenvolvidas � medida que o trabalho prossegue. Atualiza��es ou sugest�es "
"relativas ao documento podem ser direcionadas aos editores de documentos. "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14956
#, fuzzy
msgid "<primary>concurrency</primary>"
msgstr " <primary> simultaneidade </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:14957
#, fuzzy
msgid ""
"The goal of SMPng is to allow concurrency in the kernel. The kernel is "
"basically one rather large and complex program. To make the kernel multi-"
"threaded we use some of the same tools used to make other programs multi-"
"threaded. These include mutexes, shared/exclusive locks, semaphores, and "
"condition variables. For the definitions of these and other SMP-related "
"terms, please see the <xref linkend=\"smp-glossary\"/> section of this "
"article."
msgstr ""
"O objetivo do SMPng � permitir a simultaneidade no kernel. O kernel � "
"basicamente um programa bastante grande e complexo. Para fazer o kernel "
"multi-threaded usamos algumas das mesmas ferramentas usadas para fazer "
"outros programas multi-threaded. Estes incluem mutexes , bloqueios "
"compartilhados / exclusivos, sem�foros e vari�veis ​​de condi��o. Para as "
"defini��es desses e de outros termos relacionados a PMS, consulte <xref "
"linkend=\"smp-glossary\"/> se��o deste artigo. "

#. (itstool) path: sect1/title
#: book.translate.xml:14967
#, fuzzy
msgid "Basic Tools and Locking Fundamentals"
msgstr "Ferramentas B�sicas e Fundamentos de Bloqueio"

#. (itstool) path: sect2/title
#: book.translate.xml:14970
#, fuzzy
msgid "Atomic Instructions and Memory Barriers"
msgstr "Instru��es at�micas e barreiras de mem�ria"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:14972
#, fuzzy
msgid "<primary>atomic instructions</primary>"
msgstr " <primary> instru��es at�micas </primary> "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:14973
#, fuzzy
msgid "<primary>memory barriers</primary>"
msgstr " <primary> barreiras de mem�ria </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:14975
#, fuzzy
msgid ""
"There are several existing treatments of memory barriers and atomic "
"instructions, so this section will not include a lot of detail. To put it "
"simply, one can not go around reading variables without a lock if a lock is "
"used to protect writes to that variable. This becomes obvious when you "
"consider that memory barriers simply determine relative order of memory "
"operations; they do not make any guarantee about timing of memory "
"operations. That is, a memory barrier does not force the contents of a CPU's "
"local cache or store buffer to flush. Instead, the memory barrier at lock "
"release simply ensures that all writes to the protected data will be visible "
"to other CPU's or devices if the write to release the lock is visible. The "
"CPU is free to keep that data in its cache or store buffer as long as it "
"wants. However, if another CPU performs an atomic instruction on the same "
"datum, the first CPU must guarantee that the updated value is made visible "
"to the second CPU along with any other operations that memory barriers may "
"require."
msgstr ""
"H� v�rios tratamentos existentes de barreiras de mem�ria e instru��es "
"at�micas, portanto esta se��o n�o incluir� muitos detalhes. Para "
"simplificar, n�o � poss�vel ler vari�veis ​​sem um bloqueio se um bloqueio for "
"usado para proteger as grava��es nessa vari�vel Isso fica �bvio quando voc� "
"considera que as barreiras de mem�ria simplesmente determinam a ordem "
"relativa das opera��es de mem�ria, elas n�o garantem o tempo das opera��es "
"de mem�ria, ou seja, uma barreira de mem�ria n�o for�a o conte�do do cache "
"local Em vez disso, a barreira de mem�ria na libera��o de bloqueio "
"simplesmente garante que todas as grava��es nos dados protegidos ficar�o "
"vis�veis para outras CPUs ou dispositivos, se a grava��o para liberar o "
"bloqueio estiver vis�vel.A CPU est� livre para manter esses dados em seu "
"cache ou armazenar Entretanto, se outra CPU executar uma instru��o at�mica "
"no mesmo datum, a primeira CPU deve garantir que o valor atualizado fique "
"vis�vel para a segunda CPU junto com qualquer outra opera��o. ns que as "
"barreiras de mem�ria podem exigir. "

#. (itstool) path: sect2/para
#: book.translate.xml:14994
#, fuzzy
msgid ""
"For example, assuming a simple model where data is considered visible when "
"it is in main memory (or a global cache), when an atomic instruction is "
"triggered on one CPU, other CPU's store buffers and caches must flush any "
"writes to that same cache line along with any pending operations behind a "
"memory barrier."
msgstr ""
"Por exemplo, supondo um modelo simples em que os dados s�o considerados "
"vis�veis quando est�o na mem�ria principal (ou em um cache global), quando "
"uma instru��o at��mica � acionada em uma CPU, os buffers e caches de "
"armazenamento de outra CPU precisam liberar as grava��es para o mesmo cache "
"linha junto com quaisquer opera��es pendentes por tr�s de uma barreira de "
"mem�ria. "

#. (itstool) path: sect2/para
#: book.translate.xml:15001
#, fuzzy
msgid ""
"This requires one to take special care when using an item protected by "
"atomic instructions. For example, in the sleep mutex implementation, we have "
"to use an <function>atomic_cmpset</function> rather than an "
"<function>atomic_set</function> to turn on the <constant>MTX_CONTESTED</"
"constant> bit. The reason is that we read the value of <varname remap="
"\"structfield\">mtx_lock</varname> into a variable and then make a decision "
"based on that read. However, the value we read may be stale, or it may "
"change while we are making our decision. Thus, when the "
"<function>atomic_set</function> executed, it may end up setting the bit on "
"another value than the one we made the decision on. Thus, we have to use an "
"<function>atomic_cmpset</function> to set the value only if the value we "
"made the decision on is up-to-date and valid."
msgstr ""
"Isso requer um cuidado especial ao usar um item protegido por instru��es "
"at�micas. Por exemplo, na implementa��o do mutex de suspens�o, temos que "
"usar um <function> atomic_cmpset </function> em vez de um <function> "
"atomic_set </function> para ligar o <constant> MTX_CONTESTED </constant> "
"pouco. A raz�o � que lemos o valor de <varname remap=\"structfield\"> "
"mtx_lock </varname> em uma vari�vel e, em seguida, tomar uma decis�o com "
"base nessa leitura. No entanto, o valor que lemos pode estar obsoleto ou "
"pode mudar enquanto tomamos nossa decis�o. Assim, quando o <function> "
"atomic_set </function> executado, pode acabar definindo o bit em outro valor "
"diferente daquele em que tomamos a decis�o. Assim, temos que usar um "
"<function> atomic_cmpset </function> para definir o valor apenas se o valor "
"em que tomamos a decis�o estiver atualizado e v�lido. "

#. (itstool) path: sect2/para
#: book.translate.xml:15018
#, fuzzy
msgid ""
"Finally, atomic instructions only allow one item to be updated or read. If "
"one needs to atomically update several items, then a lock must be used "
"instead. For example, if two counters must be read and have values that are "
"consistent relative to each other, then those counters must be protected by "
"a lock rather than by separate atomic instructions."
msgstr ""
"Finalmente, as instru��es at�micas permitem apenas que um item seja "
"atualizado ou lido. Se for necess�rio atualizar atomicamente v�rios itens, "
"um bloqueio deve ser usado. Por exemplo, se dois contadores precisarem ser "
"lidos e ter valores consistentes em rela��o a cada item outros, ent�o esses "
"contadores devem ser protegidos por um bloqueio, e n�o por instru��es "
"at�micas separadas. "

#. (itstool) path: sect2/title
#: book.translate.xml:15027
#, fuzzy
msgid "Read Locks Versus Write Locks"
msgstr "Ler bloqueios versus bloqueios de grava��o"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15029
#, fuzzy
msgid "<primary>read locks</primary>"
msgstr " <primary> leia bloqueios </primary> "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15030
#, fuzzy
msgid "<primary>write locks</primary>"
msgstr " <primary> escrever bloqueios </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15031
#, fuzzy
msgid ""
"Read locks do not need to be as strong as write locks. Both types of locks "
"need to ensure that the data they are accessing is not stale. However, only "
"write access requires exclusive access. Multiple threads can safely read a "
"value. Using different types of locks for reads and writes can be "
"implemented in a number of ways."
msgstr ""
"Os bloqueios de leitura n�o precisam ser t�o fortes quanto os bloqueios de "
"grava��o. Os dois tipos de bloqueios precisam garantir que os dados que "
"est�o acessando n�o sejam obsoletos. No entanto, somente o acesso de "
"grava��o requer acesso exclusivo. V�rios segmentos podem ler um valor com "
"seguran�a. tipos de bloqueios para leituras e grava��es podem ser "
"implementados de v�rias maneiras. "

#. (itstool) path: sect2/para
#: book.translate.xml:15038
#, fuzzy
msgid ""
"First, sx locks can be used in this manner by using an exclusive lock when "
"writing and a shared lock when reading. This method is quite straightforward."
msgstr ""
"Primeiro, os bloqueios sx podem ser usados ​​dessa maneira usando um bloqueio "
"exclusivo ao escrever e um bloqueio compartilhado durante a leitura. Esse "
"m�todo � bastante simples."

#. (itstool) path: sect2/para
#: book.translate.xml:15042
#, fuzzy
msgid ""
"A second method is a bit more obscure. You can protect a datum with multiple "
"locks. Then for reading that data you simply need to have a read lock of one "
"of the locks. However, to write to the data, you need to have a write lock "
"of all of the locks. This can make writing rather expensive but can be "
"useful when data is accessed in various ways. For example, the parent "
"process pointer is protected by both the <varname>proctree_lock</varname> sx "
"lock and the per-process mutex. Sometimes the proc lock is easier as we are "
"just checking to see who a parent of a process is that we already have "
"locked. However, other places such as <function>inferior</function> need to "
"walk the tree of processes via parent pointers and locking each process "
"would be prohibitive as well as a pain to guarantee that the condition you "
"are checking remains valid for both the check and the actions taken as a "
"result of the check."
msgstr ""
"Um segundo m�todo � um pouco mais obscuro. Voc� pode proteger um datum com "
"v�rios bloqueios. Em seguida, para ler esses dados, basta ter um bloqueio de "
"leitura de um dos bloqueios. No entanto, para gravar os dados, voc� precisa "
"ter um bloqueio de grava��o de todos os bloqueios. Isso pode tornar a "
"escrita bastante cara, mas pode ser �til quando os dados s�o acessados ​​de "
"v�rias maneiras. Por exemplo, o ponteiro de processo pai � protegido por "
"ambos <varname> proctree_lock </varname> sx lock e o mutex por processo. �s "
"vezes, o proc lock � mais f�cil, pois estamos apenas verificando quem � pai "
"de um processo e j� estamos bloqueados. Por�m, outros lugares como "
"<function> inferior </function> precisa percorrer a �rvore de processos "
"atrav�s de ponteiros pai e bloquear cada processo seria proibitivo, assim "
"como uma dor para garantir que a condi��o que voc� est� verificando "
"permane�a v�lida tanto para a verifica��o quanto para as a��es tomadas como "
"resultado da verifica��o. "

#. (itstool) path: sect2/title
#: book.translate.xml:15061
#, fuzzy
msgid "Locking Conditions and Results"
msgstr "Condi��es de bloqueio e resultados"

#. (itstool) path: sect2/para
#: book.translate.xml:15063
#, fuzzy
msgid ""
"If you need a lock to check the state of a variable so that you can take an "
"action based on the state you read, you can not just hold the lock while "
"reading the variable and then drop the lock before you act on the value you "
"read. Once you drop the lock, the variable can change rendering your "
"decision invalid. Thus, you must hold the lock both while reading the "
"variable and while performing the action as a result of the test."
msgstr ""
"Se voc� precisa de um bloqueio para verificar o estado de uma vari�vel para "
"que possa realizar uma a��o com base no estado que voc� leu, n�o � poss�vel "
"manter o bloqueio enquanto l� a vari�vel e soltar o bloqueio antes de agir "
"no valor que voc� Uma vez que voc� soltar o bloqueio, a vari�vel pode mudar "
"tornando sua decis�o inv�lida. Assim, voc� deve manter o bloqueio tanto "
"durante a leitura da vari�vel e durante a execu��o da a��o como resultado do "
"teste. "

#. (itstool) path: sect1/title
#: book.translate.xml:15075
#, fuzzy
msgid "General Architecture and Design"
msgstr "Arquitetura Geral e Design"

#. (itstool) path: sect2/title
#: book.translate.xml:15078
#, fuzzy
msgid "Interrupt Handling"
msgstr "Interrupt Handling"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15080
#, fuzzy
msgid "<primary>interrupt handling</primary>"
msgstr " <primary> manuseio de interrup��es </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15082
#, fuzzy
msgid ""
"Following the pattern of several other multi-threaded <trademark class="
"\"registered\">UNIX</trademark> kernels, FreeBSD deals with interrupt "
"handlers by giving them their own thread context. Providing a context for "
"interrupt handlers allows them to block on locks. To help avoid latency, "
"however, interrupt threads run at real-time kernel priority. Thus, interrupt "
"handlers should not execute for very long to avoid starving other kernel "
"threads. In addition, since multiple handlers may share an interrupt thread, "
"interrupt handlers should not sleep or use a sleepable lock to avoid "
"starving another interrupt handler."
msgstr ""
"Seguindo o padr�o de v�rios outros multi-threaded <trademark class="
"\"registered\"> UNIX </trademark> kernels, o FreeBSD lida com manipuladores "
"de interrup��o, dando-lhes seu pr�prio contexto de encadeamento. Fornecer um "
"contexto para os manipuladores de interrup��o permite bloquear bloqueios. "
"Para ajudar a evitar a lat�ncia, no entanto, os threads de interrup��o s�o "
"executados na prioridade do kernel em tempo real. Assim, os manipuladores de "
"interrup��o n�o devem ser executados por muito tempo para evitar que outros "
"segmentos do kernel fiquem com fome. Al�m disso, como v�rios manipuladores "
"podem compartilhar um encadeamento de interrup��o, os manipuladores de "
"interrup��o n�o devem dormir ou usar um bloqueio adormecido para evitar "
"passar fome a outro manipulador de interrup��o. "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15093
#, fuzzy
msgid "<primary>interrupt threads</primary>"
msgstr " <primary> interromper t�picos </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15095
#, fuzzy
msgid ""
"The interrupt threads currently in FreeBSD are referred to as heavyweight "
"interrupt threads. They are called this because switching to an interrupt "
"thread involves a full context switch. In the initial implementation, the "
"kernel was not preemptive and thus interrupts that interrupted a kernel "
"thread would have to wait until the kernel thread blocked or returned to "
"userland before they would have an opportunity to run."
msgstr ""
"Os threads de interrup��o atualmente no FreeBSD s�o chamados de threads de "
"interrup��o de peso. Eles s�o chamados porque mudar para um thread de "
"interrup��o envolve um switch de contexto completo. Na implementa��o "
"inicial, o kernel n�o era preemptivo e assim interrup��es que interrompiam "
"um thread do kernel tem que esperar at� que o thread do kernel seja "
"bloqueado ou retornado ao userland antes que eles tenham a oportunidade de "
"executar. "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15104
#, fuzzy
msgid "<primary>latency</primary>"
msgstr " <primary> lat�ncia </primary> "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15105
#, fuzzy
msgid "<primary>preemption</primary>"
msgstr " <primary> preemp��o </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15107
#, fuzzy
msgid ""
"To deal with the latency problems, the kernel in FreeBSD has been made "
"preemptive. Currently, we only preempt a kernel thread when we release a "
"sleep mutex or when an interrupt comes in. However, the plan is to make the "
"FreeBSD kernel fully preemptive as described below."
msgstr ""
"Para lidar com os problemas de lat�ncia, o kernel do FreeBSD tornou-se "
"preemptivo. Atualmente, n�s apenas preemptamos um thread do kernel quando "
"lan�amos um mutex de suspens�o ou quando uma interrup��o entra. No entanto, "
"o plano � fazer com que o kernel do FreeBSD seja totalmente preventivo. como "
"descrito abaixo."

#. (itstool) path: sect2/para
#: book.translate.xml:15113
#, fuzzy
msgid ""
"Not all interrupt handlers execute in a thread context. Instead, some "
"handlers execute directly in primary interrupt context. These interrupt "
"handlers are currently misnamed <quote>fast</quote> interrupt handlers since "
"the <constant>INTR_FAST</constant> flag used in earlier versions of the "
"kernel is used to mark these handlers. The only interrupts which currently "
"use these types of interrupt handlers are clock interrupts and serial I/O "
"device interrupts. Since these handlers do not have their own context, they "
"may not acquire blocking locks and thus may only use spin mutexes."
msgstr ""
"Nem todos os manipuladores de interrup��o executam em um contexto de "
"encadeamento. Em vez disso, alguns manipuladores executam diretamente no "
"contexto de interrup��o principal. Esses manipuladores de interrup��o s�o "
"atualmente atribu�dos incorretamente <quote> velozes </quote> interromper "
"manipuladores desde o <constant> INTR_FAST </constant> flag usado em vers�es "
"anteriores do kernel � usado para marcar esses manipuladores. As �nicas "
"interrup��es que atualmente usam esses tipos de interrup��o s�o interrup��es "
"de clock e interrup��es de dispositivos de E / S serial. Como esses "
"manipuladores n�o t�m seu pr�prio contexto, eles podem n�o adquirir "
"bloqueios de bloqueio e, portanto, s� podem usar mutexes de rota��o. "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15125
#, fuzzy
msgid "<primary>context switches</primary>"
msgstr " <primary> comutadores de contexto </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15127
#, fuzzy
msgid ""
"Finally, there is one optional optimization that can be added in MD code "
"called lightweight context switches. Since an interrupt thread executes in a "
"kernel context, it can borrow the vmspace of any process. Thus, in a "
"lightweight context switch, the switch to the interrupt thread does not "
"switch vmspaces but borrows the vmspace of the interrupted thread. In order "
"to ensure that the vmspace of the interrupted thread does not disappear out "
"from under us, the interrupted thread is not allowed to execute until the "
"interrupt thread is no longer borrowing its vmspace. This can happen when "
"the interrupt thread either blocks or finishes. If an interrupt thread "
"blocks, then it will use its own context when it is made runnable again. "
"Thus, it can release the interrupted thread."
msgstr ""
"Finalmente, h� uma otimiza��o opcional que pode ser adicionada no c�digo MD, "
"chamada de comutadores de contexto leves. Como um thread de interrup��o � "
"executado em um contexto de kernel, ele pode emprestar o vmspace de qualquer "
"processo. Assim, em um switch de contexto leve, o thread de interrup��o n�o "
"troca vmspaces, mas toma emprestado o vmspace do thread interrompido.A fim "
"de garantir que o vmspace do thread interrompido n�o desapare�a de debaixo "
"de n�s, o thread interrompido n�o tem permiss�o para executar at� que o "
"thread de interrup��o n�o seja mais emprestando seu vmspace. Isso pode "
"acontecer quando o thread de interrup��o bloqueia ou finaliza. Se um thread "
"de interrup��o bloquear, ele usar� seu pr�prio contexto quando for tornado "
"execut�vel novamente. Assim, ele pode liberar o thread interrompido. "

#. (itstool) path: sect2/para
#: book.translate.xml:15142
#, fuzzy
msgid ""
"The cons of this optimization are that they are very machine specific and "
"complex and thus only worth the effort if their is a large performance "
"improvement. At this point it is probably too early to tell, and in fact, "
"will probably hurt performance as almost all interrupt handlers will "
"immediately block on Giant and require a thread fix-up when they block. "
"Also, an alternative method of interrupt handling has been proposed by Mike "
"Smith that works like so:"
msgstr ""
"Os contras desta otimiza��o s�o que eles s�o muito espec�ficos da m�quina e "
"complexos e, portanto, s� valem o esfor�o se a sua for uma grande melhoria "
"de desempenho. Neste momento, � provavelmente cedo demais para dizer e, de "
"fato, provavelmente prejudicar� o desempenho como quase todos os "
"manipuladores de interrup��es bloquear�o imediatamente o Giant e exigir�o "
"uma corre��o de thread quando eles bloquearem. Al�m disso, um m�todo "
"alternativo de manipula��o de interrup��es foi proposto por Mike Smith que "
"funciona assim: "

#. (itstool) path: listitem/para
#: book.translate.xml:15153
#, fuzzy
msgid ""
"Each interrupt handler has two parts: a predicate which runs in primary "
"interrupt context and a handler which runs in its own thread context."
msgstr ""
"Cada manipulador de interrup��o tem duas partes: um predicado que � "
"executado no contexto de interrup��o prim�rio e um manipulador que � "
"executado em seu pr�prio contexto de encadeamento."

#. (itstool) path: listitem/para
#: book.translate.xml:15159
#, fuzzy
msgid ""
"If an interrupt handler has a predicate, then when an interrupt is "
"triggered, the predicate is run. If the predicate returns true then the "
"interrupt is assumed to be fully handled and the kernel returns from the "
"interrupt. If the predicate returns false or there is no predicate, then the "
"threaded handler is scheduled to run."
msgstr ""
"Se um manipulador de interrup��o tiver um predicado, quando uma interrup��o "
"for disparada, o predicado ser� executado. Se o predicado retornar "
"verdadeiro, presume-se que a interrup��o seja totalmente tratada e o kernel "
"retorna da interrup��o. Se o predicado retornar falso ou n�o � um predicado, "
"ent�o o manipulador encadeado est� programado para ser executado. "

#. (itstool) path: sect2/para
#: book.translate.xml:15168
#, fuzzy
msgid ""
"Fitting light weight context switches into this scheme might prove rather "
"complicated. Since we may want to change to this scheme at some point in the "
"future, it is probably best to defer work on light weight context switches "
"until we have settled on the final interrupt handling architecture and "
"determined how light weight context switches might or might not fit into it."
msgstr ""
"Ajustar contextos de peso leve a esse esquema pode ser um pouco complicado. "
"Como podemos querer mudar para esse esquema em algum momento no futuro, "
"provavelmente � melhor adiar o trabalho em interruptores de contexto de peso "
"leve at� termos resolvido a interrup��o final. lidando com a arquitetura e "
"determinando como as chaves de contexto leves podem ou n�o se encaixar nela. "

#. (itstool) path: sect2/title
#: book.translate.xml:15178
#, fuzzy
msgid "Kernel Preemption and Critical Sections"
msgstr "Preemp��o do kernel e se��es cr�ticas"

#. (itstool) path: sect3/title
#: book.translate.xml:15181
#, fuzzy
msgid "Kernel Preemption in a Nutshell"
msgstr "Preemp��o do kernel em poucas palavras"

#. (itstool) path: sect3/para
#: book.translate.xml:15183
#, fuzzy
msgid ""
"Kernel preemption is fairly simple. The basic idea is that a CPU should "
"always be doing the highest priority work available. Well, that is the ideal "
"at least. There are a couple of cases where the expense of achieving the "
"ideal is not worth being perfect."
msgstr ""
"Preemp��o do kernel � bastante simples. A id�ia b�sica � que uma CPU deve "
"sempre estar fazendo o trabalho de maior prioridade dispon�vel. Bem, isso � "
"o ideal, pelo menos. H� alguns casos em que a despesa de alcan�ar o ideal "
"n�o vale a pena ser perfeito."

#. (itstool) path: sect3/para
#: book.translate.xml:15189
#, fuzzy
msgid ""
"Implementing full kernel preemption is very straightforward: when you "
"schedule a thread to be executed by putting it on a run queue, you check to "
"see if its priority is higher than the currently executing thread. If so, "
"you initiate a context switch to that thread."
msgstr ""
"Implementar preemp��o completa do kernel � muito simples: quando voc� "
"programa um encadeamento para ser executado colocando-o em uma fila de "
"execu��o, voc� verifica se sua prioridade � maior do que o encadeamento "
"atualmente em execu��o. Nesse caso, voc� inicia uma altern�ncia de contexto "
"fio."

#. (itstool) path: sect3/para
#: book.translate.xml:15195
#, fuzzy
msgid ""
"While locks can protect most data in the case of a preemption, not all of "
"the kernel is preemption safe. For example, if a thread holding a spin mutex "
"preempted and the new thread attempts to grab the same spin mutex, the new "
"thread may spin forever as the interrupted thread may never get a chance to "
"execute. Also, some code such as the code to assign an address space number "
"for a process during <function>exec</function> on the Alpha needs to not be "
"preempted as it supports the actual context switch code. Preemption is "
"disabled for these code sections by using a critical section."
msgstr ""
"Embora os bloqueios possam proteger a maioria dos dados no caso de uma "
"preemp��o, nem todo o kernel � protegido por preemp��o. Por exemplo, se um "
"segmento que det�m um mutex de rota��o for antecipado e o novo thread tentar "
"obter o mesmo mutex de rota��o, o novo thread pode giram para sempre, pois o "
"thread interrompido pode nunca ter a chance de executar.Tamb�m, algum c�digo "
"como o c�digo para atribuir um n�mero de espa�o de endere�o para um processo "
"durante <function> exec </function> no Alpha n�o precisa ser preterido, pois "
"suporta o c�digo de mudan�a de contexto real. A preemp��o est� desativada "
"para essas se��es de c�digo usando uma se��o cr�tica. "

#. (itstool) path: sect3/title
#: book.translate.xml:15209
#, fuzzy
msgid "Critical Sections"
msgstr "Sec��es Cr�ticas"

#. (itstool) path: sect3/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:15211 book.translate.xml:15333
#, fuzzy
msgid "<primary>critical sections</primary>"
msgstr " <primary> se��es cr�ticas </primary> "

#. (itstool) path: sect3/para
#: book.translate.xml:15213
#, fuzzy
msgid ""
"The responsibility of the critical section API is to prevent context "
"switches inside of a critical section. With a fully preemptive kernel, every "
"<function>setrunqueue</function> of a thread other than the current thread "
"is a preemption point. One implementation is for <function>critical_enter</"
"function> to set a per-thread flag that is cleared by its counterpart. If "
"<function>setrunqueue</function> is called with this flag set, it does not "
"preempt regardless of the priority of the new thread relative to the current "
"thread. However, since critical sections are used in spin mutexes to prevent "
"context switches and multiple spin mutexes can be acquired, the critical "
"section API must support nesting. For this reason the current implementation "
"uses a nesting count instead of a single per-thread flag."
msgstr ""
"A responsabilidade da API da se��o cr�tica � evitar interruptores de "
"contexto dentro de uma se��o cr�tica. Com um kernel totalmente preemptivo, "
"cada <function> setrunqueue </function> de um segmento diferente do segmento "
"atual � um ponto de preemp��o. Uma implementa��o � para <function> "
"critical_enter </function> para definir um sinalizador por thread que � "
"limpo por sua contraparte. E se <function> setrunqueue </function> � chamado "
"com este conjunto de sinalizadores, ele n�o se antecipa independentemente da "
"prioridade do novo encadeamento relativo ao encadeamento atual. No entanto, "
"como as se��es cr�ticas s�o usadas em mutexes de rota��o para evitar "
"comutadores de contexto e v�rios mutexes de rota��o podem ser adquiridos, a "
"API de se��o cr�tica deve oferecer suporte ao aninhamento. Por esse motivo, "
"a implementa��o atual usa uma contagem de aninhamento em vez de um �nico "
"sinalizador por thread. "

#. (itstool) path: sect3/para
#: book.translate.xml:15229
#, fuzzy
msgid ""
"In order to minimize latency, preemptions inside of a critical section are "
"deferred rather than dropped. If a thread that would normally be preempted "
"to is made runnable while the current thread is in a critical section, then "
"a per-thread flag is set to indicate that there is a pending preemption. "
"When the outermost critical section is exited, the flag is checked. If the "
"flag is set, then the current thread is preempted to allow the higher "
"priority thread to run."
msgstr ""
"Para minimizar a lat�ncia, as preemp��es dentro de uma se��o cr�tica s�o "
"adiadas em vez de descartadas. Se um encadeamento que normalmente seria "
"precedido for tornado execut�vel enquanto o encadeamento atual estiver em "
"uma se��o cr�tica, um sinalizador por encadeamento ser� definido como indica "
"que h� uma preemp��o pendente. Quando a se��o cr�tica mais externa � "
"encerrada, o sinalizador � verificado. Se o sinalizador estiver configurado, "
"o encadeamento atual ser� precedido para permitir que o encadeamento de "
"maior prioridade seja executado. "

#. (itstool) path: sect3/indexterm
#: book.translate.xml:15239
#, fuzzy
msgid "<primary>spin mutexes</primary>"
msgstr " <primary> mutexes de spin </primary> "

#. (itstool) path: sect3/indexterm
#: book.translate.xml:15240
#, fuzzy
msgid "<primary>mutexes</primary><secondary>spin</secondary>"
msgstr " <primary> mutexes </primary><secondary> girar </secondary> "

#. (itstool) path: sect3/para
#: book.translate.xml:15241
#, fuzzy
msgid ""
"Interrupts pose a problem with regards to spin mutexes. If a low-level "
"interrupt handler needs a lock, it needs to not interrupt any code needing "
"that lock to avoid possible data structure corruption. Currently, providing "
"this mechanism is piggybacked onto critical section API by means of the "
"<function>cpu_critical_enter</function> and <function>cpu_critical_exit</"
"function> functions. Currently this API disables and re-enables interrupts "
"on all of FreeBSD's current platforms. This approach may not be purely "
"optimal, but it is simple to understand and simple to get right. "
"Theoretically, this second API need only be used for spin mutexes that are "
"used in primary interrupt context. However, to make the code simpler, it is "
"used for all spin mutexes and even all critical sections. It may be "
"desirable to split out the MD API from the MI API and only use it in "
"conjunction with the MI API in the spin mutex implementation. If this "
"approach is taken, then the MD API likely would need a rename to show that "
"it is a separate API."
msgstr ""
"Interrup��es representam um problema com rela��o a mutexes de rota��o. Se um "
"manipulador de interrup��o de baixo n�vel precisar de um bloqueio, ele n�o "
"precisar� interromper nenhum c�digo que precise desse bloqueio para evitar "
"poss�vel corrup��o da estrutura de dados. Atualmente, fornecer esse "
"mecanismo � inserido na se��o cr�tica API por meio do <function> "
"cpu_critical_enter </function> e <function> cpu_critical_exit </function> "
"fun��es. Atualmente esta API desativa e reativa interrup��es em todas as "
"plataformas atuais do FreeBSD. Essa abordagem pode n�o ser puramente ideal, "
"mas � simples de entender e simples de acertar. Teoricamente, esta segunda "
"API s� precisa ser usada para mutexes de spin que s�o usados ​​no contexto de "
"interrup��o prim�ria. No entanto, para tornar o c�digo mais simples, ele � "
"usado para todos os mutexes de spin e at� mesmo para todas as se��es "
"cr�ticas. Pode ser desej�vel dividir a API do MD da API do MI e us�-la "
"somente em conjunto com a API do MI na implementa��o do mutex de rota��o. Se "
"essa abordagem for adotada, a API do MD provavelmente precisaria de uma "
"renomea��o para mostrar que � uma API separada. "

#. (itstool) path: sect3/title
#: book.translate.xml:15263
#, fuzzy
msgid "Design Tradeoffs"
msgstr "Tradeoffs de design"

#. (itstool) path: sect3/para
#: book.translate.xml:15265
#, fuzzy
msgid ""
"As mentioned earlier, a couple of trade-offs have been made to sacrifice "
"cases where perfect preemption may not always provide the best performance."
msgstr ""
"Como mencionado anteriormente, algumas compensa��es foram feitas para "
"sacrificar casos em que a preemp��o perfeita nem sempre fornece o melhor "
"desempenho."

#. (itstool) path: sect3/para
#: book.translate.xml:15269
#, fuzzy
msgid ""
"The first trade-off is that the preemption code does not take other CPUs "
"into account. Suppose we have a two CPU's A and B with the priority of A's "
"thread as 4 and the priority of B's thread as 2. If CPU B makes a thread "
"with priority 1 runnable, then in theory, we want CPU A to switch to the new "
"thread so that we will be running the two highest priority runnable threads. "
"However, the cost of determining which CPU to enforce a preemption on as "
"well as actually signaling that CPU via an IPI along with the "
"synchronization that would be required would be enormous. Thus, the current "
"code would instead force CPU B to switch to the higher priority thread. Note "
"that this still puts the system in a better position as CPU B is executing a "
"thread of priority 1 rather than a thread of priority 2."
msgstr ""
"O primeiro trade-off � que o c�digo de preemp��o n�o leva em conta outras "
"CPUs. Suponha que tenhamos dois A e B de um processador com a prioridade do "
"encadeamento de A como 4 e a prioridade do encadeamento de B como 2. Se a "
"CPU B fizer uma thread com prioridade 1 execut�vel, ent�o, em teoria, "
"queremos que a CPU A mude para o novo thread, para que possamos executar os "
"dois threads execut�veis ​​de maior prioridade, mas o custo de determinar para "
"qual CPU aplicar uma preemp��o, bem como sinalizar que a CPU atrav�s de um "
"IPI, juntamente com a sincroniza��o que seria necess�ria seria enorme.Assim, "
"o c�digo atual, em vez for�ar CPU B para mudar para o segmento de maior "
"prioridade.Note que isso ainda coloca o sistema em uma posi��o melhor como "
"CPU B est� executando um encadeamento de prioridade 1 em vez de um "
"encadeamento de prioridade 2. "

#. (itstool) path: sect3/para
#: book.translate.xml:15284
#, fuzzy
msgid ""
"The second trade-off limits immediate kernel preemption to real-time "
"priority kernel threads. In the simple case of preemption defined above, a "
"thread is always preempted immediately (or as soon as a critical section is "
"exited) if a higher priority thread is made runnable. However, many threads "
"executing in the kernel only execute in a kernel context for a short time "
"before either blocking or returning to userland. Thus, if the kernel "
"preempts these threads to run another non-realtime kernel thread, the kernel "
"may switch out the executing thread just before it is about to sleep or "
"execute. The cache on the CPU must then adjust to the new thread. When the "
"kernel returns to the preempted thread, it must refill all the cache "
"information that was lost. In addition, two extra context switches are "
"performed that could be avoided if the kernel deferred the preemption until "
"the first thread blocked or returned to userland. Thus, by default, the "
"preemption code will only preempt immediately if the higher priority thread "
"is a real-time priority thread."
msgstr ""
"O segundo trade-off limita a preemp��o imediata do kernel a threads de "
"kernel de prioridade em tempo real. No caso simples de preemp��o definido "
"acima, um thread � sempre preempted imediatamente (ou assim que uma se��o "
"cr�tica � encerrada) se um thread de prioridade mais alta for No entanto, "
"muitos threads executados no kernel s� executam em um contexto de kernel por "
"um curto per�odo de tempo antes de bloquear ou retornar a userland. O thread "
"na CPU deve ent�o se ajustar ao novo thread.Quando o kernel retorna para o "
"thread preempted, ele deve preencher todas as informa��es do cache que foram "
"perdidas.Al�m disso, o thread em execu��o antes da hora de dormir ou "
"executar. duas op��es de contexto extras s�o executadas, o que poderia ser "
"evitado se o kernel adiasse a preemp��o at� que o primeiro thread fosse "
"bloqueado ou retornado � userland. Assim, por padr�o, o c�digo de preemp��o "
"s� se antecipar� imediatamente se o thread de prioridade mais alta � um "
"thread de prioridade em tempo real. "

#. (itstool) path: sect3/para
#: book.translate.xml:15304
#, fuzzy
msgid ""
"Turning on full kernel preemption for all kernel threads has value as a "
"debugging aid since it exposes more race conditions. It is especially useful "
"on UP systems were many races are hard to simulate otherwise. Thus, there is "
"a kernel option <literal>FULL_PREEMPTION</literal> to enable preemption for "
"all kernel threads that can be used for debugging purposes."
msgstr ""
"Ativar a preemp��o total do kernel para todos os encadeamentos do kernel tem "
"valor como um aux�lio de depura��o, pois exp�e mais condi��es de corrida. � "
"especialmente �til em sistemas UP, pois muitas corridas s�o dif�ceis de "
"serem simuladas. Assim, h� uma op��o de kernel <literal> FULL_PREEMPTION </"
"literal> para ativar a preemp��o para todos os encadeamentos do kernel que "
"podem ser usados ​​para prop�sitos de depura��o. "

#. (itstool) path: sect2/title
#: book.translate.xml:15315
#, fuzzy
msgid "Thread Migration"
msgstr "Thread Migration"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15317
#, fuzzy
msgid "<primary>thread migration</primary>"
msgstr " <primary> migra��o de thread </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15319
#, fuzzy
msgid ""
"Simply put, a thread migrates when it moves from one CPU to another. In a "
"non-preemptive kernel this can only happen at well-defined points such as "
"when calling <function>msleep</function> or returning to userland. However, "
"in the preemptive kernel, an interrupt can force a preemption and possible "
"migration at any time. This can have negative affects on per-CPU data since "
"with the exception of <varname>curthread</varname> and <varname>curpcb</"
"varname> the data can change whenever you migrate. Since you can potentially "
"migrate at any time this renders unprotected per-CPU data access rather "
"useless. Thus it is desirable to be able to disable migration for sections "
"of code that need per-CPU data to be stable."
msgstr ""
"Simplificando, um thread migra quando se move de um CPU para outro. Em um "
"kernel n�o preemptiva, isso s� pode acontecer em pontos bem definidos, como "
"quando se chama <function> msleep </function> ou retornando ao userland. No "
"entanto, no kernel preemptivo, uma interrup��o pode for�ar uma preemp��o e "
"uma poss�vel migra��o a qualquer momento. Isso pode ter efeitos negativos "
"nos dados por CPU, pois, com a exce��o de <varname> encurtar </varname> e "
"<varname> curpcb </varname> os dados podem mudar sempre que voc� migrar. "
"Como voc� pode migrar a qualquer momento, isso torna o acesso aos dados "
"desprotegidos por CPU um pouco in�til. Assim, � desej�vel poder desabilitar "
"a migra��o para se��es de c�digo que precisam de dados por CPU para serem "
"est�veis. "

#. (itstool) path: sect2/para
#: book.translate.xml:15335
#, fuzzy
msgid ""
"Critical sections currently prevent migration since they do not allow "
"context switches. However, this may be too strong of a requirement to "
"enforce in some cases since a critical section also effectively blocks "
"interrupt threads on the current processor. As a result, another API has "
"been provided to allow the current thread to indicate that if it preempted "
"it should not migrate to another CPU."
msgstr ""
"As se��es cr�ticas atualmente impedem a migra��o, pois n�o permitem "
"comutadores de contexto. No entanto, isso pode ser um requisito muito forte "
"para ser aplicado em alguns casos, pois uma se��o cr�tica tamb�m bloqueia "
"efetivamente os threads de interrup��o no processador atual. Como resultado, "
"outra API foi fornecido para permitir que o segmento atual indique que, se "
"ele se precisasse, ele n�o deveria migrar para outra CPU. "

#. (itstool) path: sect2/para
#: book.translate.xml:15343
#, fuzzy
msgid ""
"This API is known as thread pinning and is provided by the scheduler. The "
"API consists of two functions: <function>sched_pin</function> and "
"<function>sched_unpin</function>. These functions manage a per-thread "
"nesting count <varname>td_pinned</varname>. A thread is pinned when its "
"nesting count is greater than zero and a thread starts off unpinned with a "
"nesting count of zero. Each scheduler implementation is required to ensure "
"that pinned threads are only executed on the CPU that they were executing on "
"when the <function>sched_pin</function> was first called. Since the nesting "
"count is only written to by the thread itself and is only read by other "
"threads when the pinned thread is not executing but while "
"<varname>sched_lock</varname> is held, then <varname>td_pinned</varname> "
"does not need any locking. The <function>sched_pin</function> function "
"increments the nesting count and <function>sched_unpin</function> decrements "
"the nesting count. Note that these functions only operate on the current "
"thread and bind the current thread to the CPU it is executing on at the "
"time. To bind an arbitrary thread to a specific CPU, the "
"<function>sched_bind</function> and <function>sched_unbind</function> "
"functions should be used instead."
msgstr ""
"Essa API � conhecida como fixa��o de threads e � fornecida pelo agendador. A "
"API consiste em duas fun��es: <function> sched_pin </function> e <function> "
"sched_unpin </function> . Essas fun��es gerenciam uma contagem de "
"aninhamento por thread <varname> td_pinned </varname> . Um encadeamento � "
"fixado quando sua contagem de aninhamento � maior que zero e um encadeamento "
"� iniciado desmarcado com uma contagem de aninhamento igual a zero. Cada "
"implementa��o do planejador � necess�ria para garantir que os encadeamentos "
"fixados sejam executados somente na CPU em que estavam sendo executados "
"quando o encadeamento <function> sched_pin </function> foi chamado pela "
"primeira vez. Como a contagem de aninhamento � gravada apenas pelo pr�prio "
"thread e � lida apenas por outros threads quando o thread fixo n�o est� em "
"execu��o, mas enquanto <varname> sched_lock </varname> � realizada, ent�o "
"<varname> td_pinned </varname> n�o precisa de nenhum bloqueio. o <function> "
"sched_pin </function> fun��o incrementa a contagem de aninhamento e "
"<function> sched_unpin </function> decrementa a contagem de aninhamento. "
"Observe que essas fun��es s� operam no encadeamento atual e ligam o "
"encadeamento atual � CPU que est� sendo executada no momento. Para ligar um "
"encadeamento arbitr�rio a uma CPU espec�fica, o <function> sched_bind </"
"function> e <function> sched_unbind </function> fun��es devem ser usadas em "
"vez disso. "

#. (itstool) path: sect2/title
#: book.translate.xml:15369
#, fuzzy
msgid "Callouts"
msgstr "Chamadas"

#. (itstool) path: sect2/para
#: book.translate.xml:15371
#, fuzzy
msgid ""
"The <function>timeout</function> kernel facility permits kernel services to "
"register functions for execution as part of the <function>softclock</"
"function> software interrupt. Events are scheduled based on a desired number "
"of clock ticks, and callbacks to the consumer-provided function will occur "
"at approximately the right time."
msgstr ""
"O <function> tempo esgotado </function> O recurso kernel permite que os "
"servi�os do kernel registrem fun��es para execu��o como parte do <function> "
"softclock </function> interrup��o de software. Os eventos s�o programados "
"com base em um n�mero desejado de pulsos de clock, e os retornos de chamada "
"para a fun��o fornecida pelo consumidor ocorrer�o aproximadamente no momento "
"certo. "

#. (itstool) path: sect2/para
#: book.translate.xml:15378
#, fuzzy
msgid ""
"The global list of pending timeout events is protected by a global spin "
"mutex, <varname>callout_lock</varname>; all access to the timeout list must "
"be performed with this mutex held. When <function>softclock</function> is "
"woken up, it scans the list of pending timeouts for those that should fire. "
"In order to avoid lock order reversal, the <function>softclock</function> "
"thread will release the <varname>callout_lock</varname> mutex when invoking "
"the provided <function>timeout</function> callback function. If the "
"<constant>CALLOUT_MPSAFE</constant> flag was not set during registration, "
"then Giant will be grabbed before invoking the callout, and then released "
"afterwards. The <varname>callout_lock</varname> mutex will be re-grabbed "
"before proceeding. The <function>softclock</function> code is careful to "
"leave the list in a consistent state while releasing the mutex. If "
"<constant>DIAGNOSTIC</constant> is enabled, then the time taken to execute "
"each function is measured, and a warning is generated if it exceeds a "
"threshold."
msgstr ""
"A lista global de eventos de timeout pendentes � protegida por um mutex de "
"rota��o global, <varname> callout_lock </varname> ; todo acesso � lista de "
"tempo limite deve ser executado com esse mutex mantido. Quando <function> "
"softclock </function> � acordado, varre a lista de tempos limite pendentes "
"para aqueles que devem disparar. Para evitar a revers�o da ordem de "
"bloqueio, o <function> softclock </function> fio vai liberar o <varname> "
"callout_lock </varname> mutex ao invocar o fornecido <function> tempo "
"esgotado </function> fun��o de retorno de chamada. Se o <constant> "
"CALLOUT_MPSAFE </constant> flag n�o foi definido durante o registro, ent�o o "
"Giant ser� agarrado antes de invocar o texto explicativo e, em seguida, "
"liberado posteriormente. o <varname> callout_lock </varname> mutex ser� re-"
"agarrado antes de prosseguir. o <function> softclock </function> c�digo tem "
"o cuidado de deixar a lista em um estado consistente ao liberar o mutex. E "
"se <constant> DIAGN�STICO </constant> est� habilitado, o tempo gasto para "
"executar cada fun��o � medido e um aviso � gerado se exceder um limite. "

#. (itstool) path: sect1/title
#: book.translate.xml:15401
#, fuzzy
msgid "Specific Locking Strategies"
msgstr "Estrat�gias Espec�ficas de Bloqueio"

#. (itstool) path: sect2/title
#: book.translate.xml:15404
#, fuzzy
msgid "Credentials"
msgstr "Credenciais"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15406
#, fuzzy
msgid "<primary>credentials</primary>"
msgstr " <primary> credenciais </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15408
#, fuzzy
msgid ""
"<varname remap=\"structname\">struct ucred</varname> is the kernel's "
"internal credential structure, and is generally used as the basis for "
"process-driven access control within the kernel. BSD-derived systems use a "
"<quote>copy-on-write</quote> model for credential data: multiple references "
"may exist for a credential structure, and when a change needs to be made, "
"the structure is duplicated, modified, and then the reference replaced. Due "
"to wide-spread caching of the credential to implement access control on "
"open, this results in substantial memory savings. With a move to fine-"
"grained SMP, this model also saves substantially on locking operations by "
"requiring that modification only occur on an unshared credential, avoiding "
"the need for explicit synchronization when consuming a known-shared "
"credential."
msgstr ""
" <varname remap=\"structname\"> structurred </varname> � a estrutura de "
"credenciais internas do kernel e � geralmente usada como base para o "
"controle de acesso orientado a processos dentro do kernel. Sistemas "
"derivados de BSD usam um <quote> copiar-em-escrever </quote> modelo para "
"dados de credencial: podem existir v�rias refer�ncias para uma estrutura de "
"credenciais e, quando uma altera��o precisa ser feita, a estrutura � "
"duplicada, modificada e, em seguida, a refer�ncia � substitu�da. Devido ao "
"amplo armazenamento em cache da credencial para implementar o controle de "
"acesso em aberto, isso resulta em economias substanciais de mem�ria. Com uma "
"mudan�a para o SMP refinado, esse modelo tamb�m economiza substancialmente "
"nas opera��es de bloqueio, exigindo que essa modifica��o ocorra apenas em "
"uma credencial n�o compartilhada, evitando a necessidade de sincroniza��o "
"expl�cita ao consumir uma credencial compartilhada conhecida. "

#. (itstool) path: sect2/para
#: book.translate.xml:15423
#, fuzzy
msgid ""
"Credential structures with a single reference are considered mutable; shared "
"credential structures must not be modified or a race condition is risked. A "
"mutex, <varname remap=\"structfield\">cr_mtxp</varname> protects the "
"reference count of <varname remap=\"structname\">struct ucred</varname> so "
"as to maintain consistency. Any use of the structure requires a valid "
"reference for the duration of the use, or the structure may be released out "
"from under the illegitimate consumer."
msgstr ""
"Estruturas de credenciais com uma �nica refer�ncia s�o consideradas "
"mut�veis; estruturas de credenciais compartilhadas n�o devem ser modificadas "
"ou uma condi��o de corrida � arriscada. Um mutex, <varname remap="
"\"structfield\"> cr_mtxp </varname> protege a contagem de refer�ncia de "
"<varname remap=\"structname\"> structurred </varname> de modo a manter a "
"consist�ncia. Qualquer uso da estrutura requer uma refer�ncia v�lida para a "
"dura��o do uso, ou a estrutura pode ser liberada sob o consumidor ileg�timo "
"\""

#. (itstool) path: sect2/para
#: book.translate.xml:15433
#, fuzzy
msgid ""
"The <varname remap=\"structname\">struct ucred</varname> mutex is a leaf "
"mutex and is implemented via a mutex pool for performance reasons."
msgstr ""
"O <varname remap=\"structname\"> structurred </varname> mutex � um mutex de "
"folha e � implementado por meio de um pool mutex por motivos de desempenho. "

#. (itstool) path: sect2/para
#: book.translate.xml:15437
#, fuzzy
msgid ""
"Usually, credentials are used in a read-only manner for access control "
"decisions, and in this case <varname remap=\"structfield\">td_ucred</"
"varname> is generally preferred because it requires no locking. When a "
"process' credential is updated the <literal>proc</literal> lock must be held "
"across the check and update operations thus avoid races. The process "
"credential <varname remap=\"structfield\">p_ucred</varname> must be used for "
"check and update operations to prevent time-of-check, time-of-use races."
msgstr ""
"Geralmente, as credenciais s�o usadas de maneira somente leitura para "
"decis�es de controle de acesso e, nesse caso, <varname remap=\"structfield"
"\"> td_ucred </varname> � geralmente preferido porque n�o requer bloqueio. "
"Quando a credencial de um processo � atualizada, <literal> proc </literal> o "
"bloqueio deve ser mantido entre as opera��es de verifica��o e atualiza��o, "
"evitando assim as corridas. A credencial do processo <varname remap="
"\"structfield\"> p_ucred </varname> deve ser usado para verificar e "
"atualizar as opera��es para evitar corridas de tempo de verifica��o e tempo "
"de uso. "

#. (itstool) path: sect2/para
#: book.translate.xml:15447
#, fuzzy
msgid ""
"If system call invocations will perform access control after an update to "
"the process credential, the value of <varname remap=\"structfield"
"\">td_ucred</varname> must also be refreshed to the current process value. "
"This will prevent use of a stale credential following a change. The kernel "
"automatically refreshes the <varname remap=\"structfield\">td_ucred</"
"varname> pointer in the thread structure from the process <varname remap="
"\"structfield\">p_ucred</varname> whenever a process enters the kernel, "
"permitting use of a fresh credential for kernel access control."
msgstr ""
"Se as invoca��es de chamada do sistema realizarem o controle de acesso ap�s "
"uma atualiza��o para a credencial do processo, o valor de <varname remap="
"\"structfield\"> td_ucred </varname> tamb�m deve ser atualizado para o valor "
"do processo atual. Isso impedir� o uso de uma credencial obsoleta ap�s uma "
"altera��o. O kernel atualiza automaticamente <varname remap=\"structfield\"> "
"td_ucred </varname> ponteiro na estrutura de thread do processo <varname "
"remap=\"structfield\"> p_ucred </varname> sempre que um processo entrar no "
"kernel, permitindo o uso de uma nova credencial para o controle de acesso ao "
"kernel. "

#. (itstool) path: sect2/title
#: book.translate.xml:15460
#, fuzzy
msgid "File Descriptors and File Descriptor Tables"
msgstr "Descritores de Arquivo e Tabelas de Descritor de Arquivo"

#. (itstool) path: sect2/para
#: book.translate.xml:15462
#, fuzzy
msgid "Details to follow."
msgstr "Detalhes para seguir."

#. (itstool) path: sect2/title
#: book.translate.xml:15466
#, fuzzy
msgid "Jail Structures"
msgstr "Estruturas da cadeia"

#. (itstool) path: sect2/para
#: book.translate.xml:15470
#, fuzzy
msgid ""
"<varname remap=\"structname\">struct prison</varname> stores administrative "
"details pertinent to the maintenance of jails created using the "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> API. This includes the per-jail hostname, IP address, and "
"related settings. This structure is reference-counted since pointers to "
"instances of the structure are shared by many credential structures. A "
"single mutex, <varname remap=\"structfield\">pr_mtx</varname> protects read "
"and write access to the reference count and all mutable variables inside the "
"struct jail. Some variables are set only when the jail is created, and a "
"valid reference to the <varname remap=\"structname\">struct prison</varname> "
"is sufficient to read these values. The precise locking of each entry is "
"documented via comments in <filename>sys/jail.h</filename>."
msgstr ""
" <varname remap=\"structname\"> pris�o de estrutura </varname> armazena "
"detalhes administrativos pertinentes � manuten��o de cadeias criadas usando "
"o <citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> API. Isso inclui o nome do host, endere�o IP e "
"configura��es relacionadas por jail. Essa estrutura � contada por "
"refer�ncia, pois os ponteiros para inst�ncias da estrutura s�o "
"compartilhados por muitas estruturas de credenciais. Um �nico mutex, "
"<varname remap=\"structfield\"> pr_mtx </varname> protege o acesso de "
"leitura e grava��o � contagem de refer�ncia e todas as vari�veis ​​mut�veis ​​"
"dentro da cadeia de struct. Algumas vari�veis ​​s�o definidas somente quando o "
"jail � criado e uma refer�ncia v�lida <varname remap=\"structname\"> pris�o "
"de estrutura </varname> � suficiente para ler esses valores. O bloqueio "
"preciso de cada entrada � documentado atrav�s de coment�rios em <filename> "
"sys / jail.h </filename> "

#. (itstool) path: sect2/title
#: book.translate.xml:15486
#, fuzzy
msgid "MAC Framework"
msgstr "MAC Framework"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15488
#, fuzzy
msgid "<primary>MAC</primary>"
msgstr " <primary> MAC </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15490
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework maintains data in a variety of kernel objects, "
"in the form of <varname remap=\"structname\">struct label</varname>. In "
"general, labels in kernel objects are protected by the same lock as the "
"remainder of the kernel object. For example, the <varname remap=\"structfield"
"\">v_label</varname> label in <varname remap=\"structname\">struct vnode</"
"varname> is protected by the vnode lock on the vnode."
msgstr ""
"O TrustedBSD MAC Framework mant�m dados em uma variedade de objetos do "
"kernel, na forma de <varname remap=\"structname\"> r�tulo struct </"
"varname> . Em geral, os r�tulos nos objetos do kernel s�o protegidos pelo "
"mesmo bloqueio que o restante do objeto do kernel. Por exemplo, o <varname "
"remap=\"structfield\"> v_label </varname> r�tulo em <varname remap="
"\"structname\"> struct vnode </varname> est� protegido pelo bloqueio vnode "
"no vnode. "

#. (itstool) path: sect2/para
#: book.translate.xml:15498
#, fuzzy
msgid ""
"In addition to labels maintained in standard kernel objects, the MAC "
"Framework also maintains a list of registered and active policies. The "
"policy list is protected by a global mutex (<varname>mac_policy_list_lock</"
"varname>) and a busy count (also protected by the mutex). Since many access "
"control checks may occur in parallel, entry to the framework for a read-only "
"access to the policy list requires holding the mutex while incrementing (and "
"later decrementing) the busy count. The mutex need not be held for the "
"duration of the MAC entry operation--some operations, such as label "
"operations on file system objects--are long-lived. To modify the policy "
"list, such as during policy registration and de-registration, the mutex must "
"be held and the reference count must be zero, to prevent modification of the "
"list while it is in use."
msgstr ""
"Al�m de r�tulos mantidos em objetos padr�o do kernel, o MAC Framework tamb�m "
"mant�m uma lista de pol�ticas registradas e ativas. A lista de pol�ticas � "
"protegida por um mutex global ( <varname> mac_policy_list_lock </varname> ) "
"e uma contagem ocupada (tamb�m protegida pelo mutex). Como muitas "
"verifica��es de controle de acesso podem ocorrer em paralelo, a entrada na "
"estrutura para um acesso somente leitura � lista de pol�ticas requer a "
"reten��o do mutex ao incrementar (e decrementar posteriormente) a contagem "
"de ocupa��es. O mutex n�o precisa ser mantido durante a opera��o de entrada "
"MAC - algumas opera��es, como opera��es de r�tulo em objetos do sistema de "
"arquivos - s�o de longa dura��o. Para modificar a lista de pol�ticas, como "
"durante o registro de pol�tica e o cancelamento de registro, o mutex deve "
"ser mantido e a contagem de refer�ncia deve ser zero, para evitar a "
"modifica��o da lista enquanto ela estiver em uso. "

#. (itstool) path: sect2/para
#: book.translate.xml:15513
#, fuzzy
msgid ""
"A condition variable, <varname>mac_policy_list_not_busy</varname>, is "
"available to threads that need to wait for the list to become unbusy, but "
"this condition variable must only be waited on if the caller is holding no "
"other locks, or a lock order violation may be possible. The busy count, in "
"effect, acts as a form of shared/exclusive lock over access to the "
"framework: the difference is that, unlike with an sx lock, consumers waiting "
"for the list to become unbusy may be starved, rather than permitting lock "
"order problems with regards to the busy count and other locks that may be "
"held on entry to (or inside) the MAC Framework."
msgstr ""
"Uma vari�vel de condi��o, <varname> mac_policy_list_not_busy </varname> , "
"est� dispon�vel para encadeamentos que precisam aguardar que a lista fique "
"desuniforme, mas essa vari�vel de condi��o s� deve ser aguardada se o "
"chamador n�o estiver segurando nenhum outro bloqueio ou se uma viola��o de "
"ordem de bloqueio for poss�vel. A contagem ocupada, na verdade, atua como "
"uma forma de bloqueio compartilhado / exclusivo sobre o acesso � estrutura: "
"a diferen�a � que, ao contr�rio de um bloqueio sx, os consumidores que "
"esperam que a lista se torne desusada podem ficar sem alimenta��o, em vez de "
"permitir a ordem de bloqueio problemas com rela��o � contagem de ocupa��es e "
"outros bloqueios que podem ser mantidos na entrada para (ou dentro) do MAC "
"Framework. "

#. (itstool) path: sect2/title
#: book.translate.xml:15527
#, fuzzy
msgid "Modules"
msgstr "M�dulos"

#. (itstool) path: sect2/para
#: book.translate.xml:15531
#, fuzzy
msgid ""
"For the module subsystem there exists a single lock that is used to protect "
"the shared data. This lock is a shared/exclusive (SX) lock and has a good "
"chance of needing to be acquired (shared or exclusively), therefore there "
"are a few macros that have been added to make access to the lock more easy. "
"These macros can be located in <filename>sys/module.h</filename> and are "
"quite basic in terms of usage. The main structures protected under this lock "
"are the <varname remap=\"structname\">module_t</varname> structures (when "
"shared) and the global <varname remap=\"structname\">modulelist_t</varname> "
"structure, modules. One should review the related source code in "
"<filename>kern/kern_module.c</filename> to further understand the locking "
"strategy."
msgstr ""
"Para o subsistema do m�dulo existe um �nico bloqueio que � usado para "
"proteger os dados compartilhados. Esse bloqueio � um bloqueio "
"compartilhado / exclusivo (SX) e tem uma boa chance de precisar ser "
"adquirido (compartilhado ou exclusivo), portanto, h� um bloqueio. algumas "
"macros que foram adicionadas para facilitar o acesso ao bloqueio. Essas "
"macros podem ser localizadas <filename> sys / module.h </filename> e s�o "
"bastante b�sicos em termos de uso. As principais estruturas protegidas sob "
"este bloqueio s�o as <varname remap=\"structname\"> module_t </varname> "
"estruturas (quando compartilhadas) e as <varname remap=\"structname\"> "
"modulelist_t </varname> estrutura, m�dulos. Deve-se rever o c�digo fonte "
"relacionado em <filename> kern / kern_module.c </filename> para entender "
"melhor a estrat�gia de bloqueio. "

#. (itstool) path: sect2/title
#: book.translate.xml:15546
#, fuzzy
msgid "Newbus Device Tree"
msgstr "�rvore de Dispositivos Newbus"

#. (itstool) path: sect2/indexterm
#. (itstool) path: sect1/indexterm
#: book.translate.xml:15548 book.translate.xml:22541
#, fuzzy
msgid "<primary>Newbus</primary>"
msgstr " <primary> Newbus </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15550
#, fuzzy
msgid ""
"The newbus system will have one sx lock. Readers will hold a shared (read) "
"lock (<citerefentry><refentrytitle>sx_slock</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry>) and writers will hold an exclusive (write) lock "
"(<citerefentry><refentrytitle>sx_xlock</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry>). Internal functions will not do locking at all. "
"Externally visible ones will lock as needed. Those items that do not matter "
"if the race is won or lost will not be locked, since they tend to be read "
"all over the place (e.g., <citerefentry><refentrytitle>device_get_softc</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>). There will be "
"relatively few changes to the newbus data structures, so a single lock "
"should be sufficient and not impose a performance penalty."
msgstr ""
"O sistema newbus ter� um bloqueio sx. Os leitores ter�o um bloqueio "
"compartilhado (leitura) ( <citerefentry><refentrytitle> sx_slock </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> ) e os escritores "
"ter�o um bloqueio exclusivo (grava��o) ( <citerefentry><refentrytitle> "
"sx_xlock </refentrytitle><manvolnum> 9 </manvolnum></citerefentry> ). "
"Fun��es internas n�o far�o nenhum bloqueio. Os vis�veis externamente ser�o "
"bloqueados conforme necess�rio. Os itens que n�o importam se a corrida for "
"vencida ou perdida n�o ser�o bloqueados, pois tendem a ser lidos em todo o "
"lugar (por exemplo, <citerefentry><refentrytitle> device_get_softc </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> ). Haver� "
"relativamente poucas altera��es nas estruturas de dados do newbus, portanto, "
"um �nico bloqueio deve ser suficiente e n�o impor uma penalidade de "
"desempenho. "

#. (itstool) path: sect2/title
#: book.translate.xml:15563
#, fuzzy
msgid "Pipes"
msgstr "Tubos"

#. (itstool) path: sect2/para
#: book.translate.xml:15565 book.translate.xml:15598
#, fuzzy
msgid "..."
msgstr "..."

#. (itstool) path: sect2/title
#: book.translate.xml:15569
#, fuzzy
msgid "Processes and Threads"
msgstr "Processos e Threads"

#. (itstool) path: sect2/para
#: book.translate.xml:15571
#, fuzzy
msgid "- process hierarchy"
msgstr "- hierarquia de processos"

#. (itstool) path: sect2/para
#: book.translate.xml:15572
#, fuzzy
msgid "- proc locks, references"
msgstr "- bloqueios proc, refer�ncias"

#. (itstool) path: sect2/para
#: book.translate.xml:15573
#, fuzzy
msgid ""
"- thread-specific copies of proc entries to freeze during system calls, "
"including td_ucred"
msgstr ""
"- c�pias espec�ficas de segmento de entradas proc para congelar durante as "
"chamadas do sistema, incluindo td_ucred"

#. (itstool) path: sect2/para
#: book.translate.xml:15575
#, fuzzy
msgid "- inter-process operations"
msgstr "- opera��es entre processos"

#. (itstool) path: sect2/para
#: book.translate.xml:15576
#, fuzzy
msgid "- process groups and sessions"
msgstr "- processar grupos e sess�es"

#. (itstool) path: sect2/title
#: book.translate.xml:15580
#, fuzzy
msgid "Scheduler"
msgstr "Agendador"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15582
#, fuzzy
msgid "<primary>scheduler</primary>"
msgstr " <primary> Agendador </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15584
#, fuzzy
msgid ""
"Lots of references to <varname>sched_lock</varname> and notes pointing at "
"specific primitives and related magic elsewhere in the document."
msgstr ""
"Muitas refer�ncias a <varname> sched_lock </varname> e notas apontando para "
"primitivos espec�ficos e magias relacionadas em outras partes do documento. "

#. (itstool) path: sect2/title
#: book.translate.xml:15590
#, fuzzy
msgid "Select and Poll"
msgstr "Selecione e Pesquise"

#. (itstool) path: sect2/para
#: book.translate.xml:15592
#, fuzzy
msgid ""
"The <function>select</function> and <function>poll</function> functions "
"permit threads to block waiting on events on file descriptors--most "
"frequently, whether or not the file descriptors are readable or writable."
msgstr ""
"O <function> selecione </function> e <function> vota��o </function> As "
"fun��es permitem que os encadeamentos bloqueiem a espera de eventos nos "
"descritores de arquivos - com mais freq��ncia, independentemente de os "
"descritores de arquivos serem leg�veis ou grav�veis. "

#. (itstool) path: sect2/title
#: book.translate.xml:15602
#, fuzzy
msgid "SIGIO"
msgstr "SIGIO"

#. (itstool) path: sect2/para
#: book.translate.xml:15604
#, fuzzy
msgid ""
"The SIGIO service permits processes to request the delivery of a SIGIO "
"signal to its process group when the read/write status of specified file "
"descriptors changes. At most one process or process group is permitted to "
"register for SIGIO from any given kernel object, and that process or group "
"is referred to as the owner. Each object supporting SIGIO registration "
"contains pointer field that is <constant>NULL</constant> if the object is "
"not registered, or points to a <varname remap=\"structname\">struct sigio</"
"varname> describing the registration. This field is protected by a global "
"mutex, <varname>sigio_lock</varname>. Callers to SIGIO maintenance functions "
"must pass in this field <quote>by reference</quote> so that local register "
"copies of the field are not made when unprotected by the lock."
msgstr ""
"O servi�o SIGIO permite que os processos solicitem a entrega de um sinal "
"SIGIO ao seu grupo de processos quando o status de leitura / grava��o dos "
"descritores de arquivo especificados muda. No m�ximo, um processo ou grupo "
"de processos tem permiss�o para se registrar no SIGIO de qualquer objeto do "
"kernel e esse processo ou grupo � chamado de propriet�rio. Cada objeto que "
"suporta o registro SIGIO cont�m um campo de ponteiro que � <constant> NULO </"
"constant> se o objeto n�o estiver registrado, ou apontar para um <varname "
"remap=\"structname\"> struct sigio </varname> descrevendo o registro. Este "
"campo � protegido por um mutex global, <varname> sigio_lock </varname> . Os "
"chamadores para as fun��es de manuten��o do SIGIO devem passar neste campo "
"<quote> por refer�ncia </quote> para que as c�pias de registro locais do "
"campo n�o sejam feitas quando desprotegidas pelo bloqueio. "

#. (itstool) path: sect2/para
#: book.translate.xml:15619
#, fuzzy
msgid ""
"One <varname remap=\"structname\">struct sigio</varname> is allocated for "
"each registered object associated with any process or process group, and "
"contains back-pointers to the object, owner, signal information, a "
"credential, and the general disposition of the registration. Each process or "
"progress group contains a list of registered <varname remap=\"structname"
"\">struct sigio</varname> structures, <varname remap=\"structfield"
"\">p_sigiolst</varname> for processes, and <varname remap=\"structfield"
"\">pg_sigiolst</varname> for process groups. These lists are protected by "
"the process or process group locks respectively. Most fields in each "
"<varname remap=\"structname\">struct sigio</varname> are constant for the "
"duration of the registration, with the exception of the <varname remap="
"\"structfield\">sio_pgsigio</varname> field which links the <varname remap="
"\"structname\">struct sigio</varname> into the process or process group "
"list. Developers implementing new kernel objects supporting SIGIO will, in "
"general, want to avoid holding structure locks while invoking SIGIO "
"supporting functions, such as <function>fsetown</function> or "
"<function>funsetown</function> to avoid defining a lock order between "
"structure locks and the global SIGIO lock. This is generally possible "
"through use of an elevated reference count on the structure, such as "
"reliance on a file descriptor reference to a pipe during a pipe operation."
msgstr ""
"1 <varname remap=\"structname\"> struct sigio </varname> � alocado para cada "
"objeto registrado associado a qualquer processo ou grupo de processos e "
"cont�m indicadores de retorno para o objeto, propriet�rio, informa��es de "
"sinal, uma credencial e a disposi��o geral do registro. Cada processo ou "
"grupo de progresso cont�m uma lista de <varname remap=\"structname\"> struct "
"sigio </varname> estruturas, <varname remap=\"structfield\"> p_sigiolst </"
"varname> para processos e <varname remap=\"structfield\"> pg_sigiolst </"
"varname> para grupos de processos. Essas listas s�o protegidas pelos "
"bloqueios de processos ou grupos de processos, respectivamente. A maioria "
"dos campos em cada <varname remap=\"structname\"> struct sigio </varname> "
"s�o constantes durante o per�odo de registro, com exce��o do <varname remap="
"\"structfield\"> sio_pgsigio </varname> campo que liga o <varname remap="
"\"structname\"> struct sigio </varname> na lista de processos ou grupos de "
"processos. Os desenvolvedores que implementam novos objetos de kernel que "
"suportam o SIGIO, em geral, querem evitar manter bloqueios de estrutura "
"enquanto invocam fun��es de suporte SIGIO, como <function> fsetown </"
"function> ou <function> funsetown </function> para evitar definir uma ordem "
"de bloqueio entre bloqueios de estrutura e o bloqueio global SIGIO. Isso "
"geralmente � poss�vel atrav�s do uso de uma contagem de refer�ncia elevada "
"na estrutura, como a depend�ncia de uma refer�ncia de descritor de arquivo a "
"um pipe durante uma opera��o de pipe. "

#. (itstool) path: sect2/title
#: book.translate.xml:15646
#, fuzzy
msgid "Sysctl"
msgstr "Sysctl"

#. (itstool) path: sect2/para
#: book.translate.xml:15648
#, fuzzy
msgid ""
"The <function>sysctl</function> MIB service is invoked from both within the "
"kernel and from userland applications using a system call. At least two "
"issues are raised in locking: first, the protection of the structures "
"maintaining the namespace, and second, interactions with kernel variables "
"and functions that are accessed by the sysctl interface. Since sysctl "
"permits the direct export (and modification) of kernel statistics and "
"configuration parameters, the sysctl mechanism must become aware of "
"appropriate locking semantics for those variables. Currently, sysctl makes "
"use of a single global sx lock to serialize use of <function>sysctl</"
"function>; however, it is assumed to operate under Giant and other "
"protections are not provided. The remainder of this section speculates on "
"locking and semantic changes to sysctl."
msgstr ""
"O <function> sysctl </function> O servi�o MIB � invocado a partir de ambos "
"dentro do kernel e de aplicativos da terra do usu�rio usando uma chamada de "
"sistema. Pelo menos dois problemas s�o levantados no bloqueio: primeiro, a "
"prote��o das estruturas que mant�m o namespace e, em segundo lugar, "
"intera��es com vari�veis ​​e fun��es do kernel que s�o acessadas pela "
"interface sysctl. Como sysctl permite a exporta��o direta (e modifica��o) de "
"estat�sticas do kernel e par�metros de configura��o, o mecanismo sysctl deve "
"estar ciente da sem�ntica de bloqueio apropriada para essas vari�veis. "
"Atualmente, o sysctl faz uso de um �nico sx lock global para serializar o "
"uso de <function> sysctl </function> ; no entanto, sup�e-se que ele opere "
"sob Gigante e outras prote��es n�o s�o fornecidas. O restante desta se��o "
"especula sobre o bloqueio e altera��es sem�nticas no sysctl. "

#. (itstool) path: sect2/para
#: book.translate.xml:15664
#, fuzzy
msgid ""
"- Need to change the order of operations for sysctl's that update values "
"from read old, copyin and copyout, write new to copyin, lock, read old and "
"write new, unlock, copyout. Normal sysctl's that just copyout the old value "
"and set a new value that they copyin may still be able to follow the old "
"model. However, it may be cleaner to use the second model for all of the "
"sysctl handlers to avoid lock operations."
msgstr ""
"- Necessidade de alterar a ordem das opera��es para sysctl';s que atualizam "
"valores de read old, copyin e copyout, write new para copyin, lock, read "
"old, new, unlock, copyout. Sysctls normais que apenas copiam o valor antigo "
"e definem um O novo valor que eles copiam ainda pode ser capaz de seguir o "
"modelo antigo. No entanto, pode ser mais limpo usar o segundo modelo para "
"todos os manipuladores sysctl para evitar opera��es de bloqueio. "

#. (itstool) path: sect2/para
#: book.translate.xml:15672
#, fuzzy
msgid ""
"- To allow for the common case, a sysctl could embed a pointer to a mutex in "
"the SYSCTL_FOO macros and in the struct. This would work for most sysctl's. "
"For values protected by sx locks, spin mutexes, or other locking strategies "
"besides a single sleep mutex, SYSCTL_PROC nodes could be used to get the "
"locking right."
msgstr ""
"- Para permitir o caso comum, um sysctl poderia incorporar um ponteiro a um "
"mutex nas macros SYSCTL_FOO e no struct. Isso funcionaria para a maioria dos "
"sysctl. Para valores protegidos por bloqueios sx, mutexes de rota��o ou "
"outras estrat�gias de bloqueio al�m de um single sleep mutex, n�s "
"SYSCTL_PROC poderiam ser usados ​​para obter o bloqueio certo \""

#. (itstool) path: sect2/title
#: book.translate.xml:15681
#, fuzzy
msgid "Taskqueue"
msgstr "Taskqueue"

#. (itstool) path: sect2/para
#: book.translate.xml:15683
#, fuzzy
msgid ""
"The taskqueue's interface has two basic locks associated with it in order to "
"protect the related shared data. The <varname>taskqueue_queues_mutex</"
"varname> is meant to serve as a lock to protect the "
"<varname>taskqueue_queues</varname> TAILQ. The other mutex lock associated "
"with this system is the one in the <varname remap=\"structname\">struct "
"taskqueue</varname> data structure. The use of the synchronization primitive "
"here is to protect the integrity of the data in the <varname remap="
"\"structname\">struct taskqueue</varname>. It should be noted that there are "
"no separate macros to assist the user in locking down his/her own work since "
"these locks are most likely not going to be used outside of <filename>kern/"
"subr_taskqueue.c</filename>."
msgstr ""
"A interface da fila de tarefas tem dois bloqueios b�sicos associados a ela "
"para proteger os dados compartilhados relacionados. <varname> "
"taskqueue_queues_mutex </varname> destina-se a servir como um bloqueio para "
"proteger o <varname> taskqueue_queues </varname> TAILQ O outro bloqueio "
"mutex associado a este sistema � aquele no <varname remap=\"structname\"> "
"structqueueue </varname> estrutura de dados. O uso da primitiva de "
"sincroniza��o aqui � para proteger a integridade dos dados no <varname remap="
"\"structname\"> structqueueue </varname> . Deve-se notar que n�o h� macros "
"separadas para ajudar o usu�rio a bloquear seu pr�prio trabalho, j� que "
"esses bloqueios n�o ser�o mais usados ​​fora <filename> kern / subr_taskqueue."
"c </filename> "

#. (itstool) path: sect1/title
#: book.translate.xml:15699
#, fuzzy
msgid "Implementation Notes"
msgstr "Notas de Implementa��o"

#. (itstool) path: sect2/title
#: book.translate.xml:15702
#, fuzzy
msgid "Sleep Queues"
msgstr "Filas do sono"

#. (itstool) path: sect2/para
#: book.translate.xml:15704
#, fuzzy
msgid ""
"A sleep queue is a structure that holds the list of threads asleep on a wait "
"channel. Each thread that is not asleep on a wait channel carries a sleep "
"queue structure around with it. When a thread blocks on a wait channel, it "
"donates its sleep queue structure to that wait channel. Sleep queues "
"associated with a wait channel are stored in a hash table."
msgstr ""
"Uma fila de espera � uma estrutura que mant�m a lista de threads adormecida "
"em um canal de espera. Cada thread que n�o est� dormindo em um canal de "
"espera carrega consigo uma estrutura de fila de espera. Quando um segmento "
"bloqueia em um canal de espera, ele doa estrutura da fila de espera para "
"esse canal de espera. As filas de espera associadas a um canal de espera s�o "
"armazenadas em uma tabela de hash. "

#. (itstool) path: sect2/para
#: book.translate.xml:15712
#, fuzzy
msgid ""
"The sleep queue hash table holds sleep queues for wait channels that have at "
"least one blocked thread. Each entry in the hash table is called a "
"sleepqueue chain. The chain contains a linked list of sleep queues and a "
"spin mutex. The spin mutex protects the list of sleep queues as well as the "
"contents of the sleep queue structures on the list. Only one sleep queue is "
"associated with a given wait channel. If multiple threads block on a wait "
"channel than the sleep queues associated with all but the first thread are "
"stored on a list of free sleep queues in the master sleep queue. When a "
"thread is removed from the sleep queue it is given one of the sleep queue "
"structures from the master queue's free list if it is not the only thread "
"asleep on the queue. The last thread is given the master sleep queue when it "
"is resumed. Since threads may be removed from the sleep queue in a different "
"order than they are added, a thread may depart from a sleep queue with a "
"different sleep queue structure than the one it arrived with."
msgstr ""
"A tabela hash da fila de espera cont�m filas de espera para canais de espera "
"que possuem pelo menos um thread bloqueado. Cada entrada na tabela de hash � "
"chamada de cadeia sleepqueue. A cadeia cont�m uma lista vinculada de filas "
"de espera e um mutex de rota��o. a lista de filas de espera, bem como o "
"conte�do das estruturas da fila de espera na lista.Somente uma fila de "
"espera est� associada a um determinado canal de espera.Se v�rios segmentos "
"bloquearem em um canal de espera que as filas de espera associadas a todos, "
"exceto ao primeiro segmento s�o armazenados em uma lista de filas de espera "
"livres na fila de espera principal.Quando um thread � removido da fila de "
"espera, � dada uma das estruturas de fila de espera a partir da lista livre "
"da fila mestre, se n�o for o �nico thread a adormecer na fila O �ltimo "
"segmento recebe a fila de espera principal quando � reiniciado.Como os "
"encadeamentos podem ser removidos da fila de espera em uma ordem diferente "
"da que foram inclu�dos, um encadeamento pode se afastar de uma fila de "
"espera com uma estrutura de fila de suspens�o diferente e aquele com quem "
"chegou. "

#. (itstool) path: sect2/para
#: book.translate.xml:15731
#, fuzzy
msgid ""
"The <function>sleepq_lock</function> function locks the spin mutex of the "
"sleep queue chain that maps to a specific wait channel. The "
"<function>sleepq_lookup</function> function looks in the hash table for the "
"master sleep queue associated with a given wait channel. If no master sleep "
"queue is found, it returns <constant>NULL</constant>. The "
"<function>sleepq_release</function> function unlocks the spin mutex "
"associated with a given wait channel."
msgstr ""
"O <function> sleepq_lock </function> function bloqueia o mutex de rota��o da "
"cadeia de fila de espera que mapeia para um canal de espera espec�fico. o "
"<function> sleepq_lookup </function> A fun��o procura na tabela de hash da "
"fila de espera principal associada a um determinado canal de espera. Se "
"nenhuma fila de espera principal for encontrada, ela retornar� <constant> "
"NULO </constant> . o <function> sleepq_release </function> A fun��o "
"desbloqueia o mutex de rota��o associado a um determinado canal de espera. "

#. (itstool) path: sect2/para
#: book.translate.xml:15740
#, fuzzy
msgid ""
"A thread is added to a sleep queue via the <function>sleepq_add</function>. "
"This function accepts the wait channel, a pointer to the mutex that protects "
"the wait channel, a wait message description string, and a mask of flags. "
"The sleep queue chain should be locked via <function>sleepq_lock</function> "
"before this function is called. If no mutex protects the wait channel (or it "
"is protected by Giant), then the mutex pointer argument should be "
"<constant>NULL</constant>. The flags argument contains a type field that "
"indicates the kind of sleep queue that the thread is being added to and a "
"flag to indicate if the sleep is interruptible "
"(<constant>SLEEPQ_INTERRUPTIBLE</constant>). Currently there are only two "
"types of sleep queues: traditional sleep queues managed via the "
"<function>msleep</function> and <function>wakeup</function> functions "
"(<constant>SLEEPQ_MSLEEP</constant>) and condition variable sleep queues "
"(<constant>SLEEPQ_CONDVAR</constant>). The sleep queue type and lock pointer "
"argument are used solely for internal assertion checking. Code that calls "
"<function>sleepq_add</function> should explicitly unlock any interlock "
"protecting the wait channel after the associated sleepqueue chain has been "
"locked via <function>sleepq_lock</function> and before blocking on the sleep "
"queue via one of the waiting functions."
msgstr ""
"Um encadeamento � adicionado a uma fila de espera atrav�s do <function> "
"sleepq_add </function> . Essa fun��o aceita o canal de espera, um ponteiro "
"para o mutex que protege o canal de espera, uma cadeia de descri��o da "
"mensagem de espera e uma m�scara de sinalizadores. A cadeia da fila de "
"espera deve ser bloqueada via <function> sleepq_lock </function> antes que "
"esta fun��o seja chamada. Se nenhum mutex protege o canal de espera (ou � "
"protegido pelo Gigante), ent�o o argumento do ponteiro do mutex deve ser "
"<constant> NULO </constant> . O argumento flags cont�m um campo type que "
"indica o tipo de fila de espera que o thread est� sendo adicionado e um flag "
"para indicar se o sleep � interromp�vel ( <constant> SLEEPQ_INTERRUPTIBLE </"
"constant> ). Atualmente, existem apenas dois tipos de filas de espera: filas "
"de sono tradicionais gerenciadas pelo <function> msleep </function> e "
"<function> acorde </function> fun��es ( <constant> SLEEPQ_MSLEEP </"
"constant> ) e filas de sono de vari�veis ​​de condi��o ( <constant> "
"SLEEPQ_CONDVAR </constant> ). O tipo de fila de espera e o argumento de "
"ponteiro de bloqueio s�o usados ​​somente para verifica��o de asser��o "
"interna. C�digo que chama <function> sleepq_add </function> deve desbloquear "
"explicitamente qualquer bloqueio protegendo o canal de espera ap�s a cadeia "
"de sleepqueue associada ter sido bloqueada via <function> sleepq_lock </"
"function> e antes de bloquear na fila de espera atrav�s de uma das fun��es "
"de espera. "

#. (itstool) path: sect2/para
#: book.translate.xml:15765
#, fuzzy
msgid ""
"A timeout for a sleep is set by invoking <function>sleepq_set_timeout</"
"function>. The function accepts the wait channel and the timeout time as a "
"relative tick count as its arguments. If a sleep should be interrupted by "
"arriving signals, the <function>sleepq_catch_signals</function> function "
"should be called as well. This function accepts the wait channel as its only "
"parameter. If there is already a signal pending for this thread, then "
"<function>sleepq_catch_signals</function> will return a signal number; "
"otherwise, it will return 0."
msgstr ""
"Um tempo limite para um sono � definido invocando <function> "
"sleepq_set_timeout </function> . A fun��o aceita o canal de espera e o tempo "
"de timeout como uma contagem relativa de toques como seus argumentos. Se um "
"sono deve ser interrompido por sinais de chegada, o <function> "
"sleepq_catch_signals </function> fun��o deve ser chamada tamb�m. Esta fun��o "
"aceita o canal de espera como seu �nico par�metro. Se j� houver um sinal "
"pendente para este encadeamento, <function> sleepq_catch_signals </function> "
"retornar� um n�mero de sinal; caso contr�rio, retornar� 0. "

#. (itstool) path: sect2/para
#: book.translate.xml:15776
#, fuzzy
msgid ""
"Once a thread has been added to a sleep queue, it blocks using one of the "
"<function>sleepq_wait</function> functions. There are four wait functions "
"depending on whether or not the caller wishes to use a timeout or have the "
"sleep aborted by caught signals or an interrupt from the userland thread "
"scheduler. The <function>sleepq_wait</function> function simply waits until "
"the current thread is explicitly resumed by one of the wakeup functions. The "
"<function>sleepq_timedwait</function> function waits until either the thread "
"is explicitly resumed or the timeout set by an earlier call to "
"<function>sleepq_set_timeout</function> expires. The "
"<function>sleepq_wait_sig</function> function waits until either the thread "
"is explicitly resumed or its sleep is aborted. The "
"<function>sleepq_timedwait_sig</function> function waits until either the "
"thread is explicitly resumed, the timeout set by an earlier call to "
"<function>sleepq_set_timeout</function> expires, or the thread's sleep is "
"aborted. All of the wait functions accept the wait channel as their first "
"parameter. In addition, the <function>sleepq_timedwait_sig</function> "
"function accepts a second boolean parameter to indicate if the earlier call "
"to <function>sleepq_catch_signals</function> found a pending signal."
msgstr ""
"Uma vez que um thread foi adicionado a uma fila de espera, ele bloqueia "
"usando um dos <function> sleepq_wait </function> fun��es. Existem quatro "
"fun��es de espera, dependendo se o chamador deseja ou n�o usar um tempo "
"limite ou interromper o sono por sinais capturados ou por uma interrup��o do "
"agendador de segmentos do espa�o do usu�rio. o <function> sleepq_wait </"
"function> fun��o simplesmente aguarda at� que o segmento atual seja "
"explicitamente retomado por uma das fun��es de ativa��o. o <function> "
"sleepq_timedwait </function> fun��o aguarda at� que o encadeamento seja "
"retomado explicitamente ou o tempo limite definido por uma chamada anterior "
"para <function> sleepq_set_timeout </function> expira. o <function> "
"sleepq_wait_sig </function> A fun��o aguarda at� que o encadeamento seja "
"explicitamente retomado ou que sua suspens�o seja interrompida. o <function> "
"sleepq_timedwait_sig </function> fun��o aguarda at� que o encadeamento seja "
"explicitamente retomado, o tempo limite definido por uma chamada anterior "
"para <function> sleepq_set_timeout </function> expira, ou o sono do segmento "
"� abortado. Todas as fun��es de espera aceitam o canal de espera como seu "
"primeiro par�metro. Al�m disso, o <function> sleepq_timedwait_sig </"
"function> fun��o aceita um segundo par�metro booleano para indicar se a "
"chamada anterior para <function> sleepq_catch_signals </function> encontrou "
"um sinal pendente \""

#. (itstool) path: sect2/para
#: book.translate.xml:15800
#, fuzzy
msgid ""
"If the thread is explicitly resumed or is aborted by a signal, then a value "
"of zero is returned by the wait function to indicate a successful sleep. If "
"the thread is resumed by either a timeout or an interrupt from the userland "
"thread scheduler then an appropriate errno value is returned instead. Note "
"that since <function>sleepq_wait</function> can only return 0 it does not "
"return anything and the caller should assume a successful sleep. Also, if a "
"thread's sleep times out and is aborted simultaneously then "
"<function>sleepq_timedwait_sig</function> will return an error indicating "
"that a timeout occurred. If an error value of 0 is returned and either "
"<function>sleepq_wait_sig</function> or <function>sleepq_timedwait_sig</"
"function> was used to block, then the function "
"<function>sleepq_calc_signal_retval</function> should be called to check for "
"any pending signals and calculate an appropriate return value if any are "
"found. The signal number returned by the earlier call to "
"<function>sleepq_catch_signals</function> should be passed as the sole "
"argument to <function>sleepq_calc_signal_retval</function>."
msgstr ""
"Se o thread � explicitamente retomado ou � abortado por um sinal, ent�o um "
"valor de zero � retornado pela fun��o de espera para indicar uma suspens�o "
"bem-sucedida. Se o thread for retomado por um tempo limite ou uma "
"interrup��o do agendador de segmento do usu�rio valor errno apropriado � "
"retornado. <function> sleepq_wait </function> s� pode retornar 0, ele n�o "
"retorna nada e o chamador deve assumir um sono bem-sucedido. Al�m disso, se "
"o tempo de espera de um thread expirar e for abortado simultaneamente, "
"<function> sleepq_timedwait_sig </function> retornar� um erro indicando que "
"ocorreu um tempo limite. Se um valor de erro de 0 for retornado e <function> "
"sleepq_wait_sig </function> ou <function> sleepq_timedwait_sig </function> "
"foi usado para bloquear, ent�o a fun��o <function> sleepq_calc_signal_retval "
"</function> deve ser chamado para verificar quaisquer sinais pendentes e "
"calcular um valor de retorno apropriado, se algum for encontrado. O n�mero "
"do sinal retornado pela chamada anterior para <function> "
"sleepq_catch_signals </function> deve ser passado como o �nico argumento "
"para <function> sleepq_calc_signal_retval </function> "

#. (itstool) path: sect2/para
#: book.translate.xml:15822
#, fuzzy
msgid ""
"Threads asleep on a wait channel are explicitly resumed by the "
"<function>sleepq_broadcast</function> and <function>sleepq_signal</function> "
"functions. Both functions accept the wait channel from which to resume "
"threads, a priority to raise resumed threads to, and a flags argument to "
"indicate which type of sleep queue is being resumed. The priority argument "
"is treated as a minimum priority. If a thread being resumed already has a "
"higher priority (numerically lower) than the priority argument then its "
"priority is not adjusted. The flags argument is used for internal assertions "
"to ensure that sleep queues are not being treated as the wrong type. For "
"example, the condition variable functions should not resume threads on a "
"traditional sleep queue. The <function>sleepq_broadcast</function> function "
"resumes all threads that are blocked on the specified wait channel while "
"<function>sleepq_signal</function> only resumes the highest priority thread "
"blocked on the wait channel. The sleep queue chain should first be locked "
"via the <function>sleepq_lock</function> function before calling these "
"functions."
msgstr ""
"Threads dormindo em um canal de espera s�o explicitamente retomados pelo "
"<function> sleepq_broadcast </function> e <function> sleepq_signal </"
"function> fun��es. Ambas as fun��es aceitam o canal de espera do qual "
"retomar os encadeamentos, uma prioridade para elevar os encadeamentos "
"iniciados e um argumento de sinalizadores para indicar qual tipo de fila de "
"espera est� sendo retomado. O argumento de prioridade � tratado como uma "
"prioridade m�nima. Se um encadeamento que est� sendo retomado j� tiver uma "
"prioridade mais alta (numericamente menor) que o argumento de prioridade, "
"sua prioridade n�o ser� ajustada. O argumento flags � usado para asser��es "
"internas para garantir que as filas de espera n�o estejam sendo tratadas "
"como o tipo errado. Por exemplo, as fun��es de vari�vel de condi��o n�o "
"devem retomar os encadeamentos em uma fila de espera tradicional. o "
"<function> sleepq_broadcast </function> fun��o retoma todos os threads que "
"est�o bloqueados no canal de espera especificado enquanto <function> "
"sleepq_signal </function> somente retoma o encadeamento de prioridade mais "
"alta bloqueado no canal de espera. A cadeia de fila de espera deve primeiro "
"ser bloqueada pelo <function> sleepq_lock </function> fun��o antes de chamar "
"essas fun��es. "

#. (itstool) path: sect2/para
#: book.translate.xml:15843
#, fuzzy
msgid ""
"A sleeping thread may have its sleep interrupted by calling the "
"<function>sleepq_abort</function> function. This function must be called "
"with <varname>sched_lock</varname> held and the thread must be queued on a "
"sleep queue. A thread may also be removed from a specific sleep queue via "
"the <function>sleepq_remove</function> function. This function accepts both "
"a thread and a wait channel as an argument and only awakens the thread if it "
"is on the sleep queue for the specified wait channel. If the thread is not "
"on a sleep queue or it is on a sleep queue for a different wait channel, "
"then this function does nothing."
msgstr ""
"Um fio de dormir pode ter seu sono interrompido chamando o <function> "
"sleepq_abort </function> fun��o. Esta fun��o deve ser chamada com <varname> "
"sched_lock </varname> mantido e o encadeamento deve estar enfileirado em uma "
"fila de espera. Um encadeamento tamb�m pode ser removido de uma fila de "
"espera espec�fica <function> sleepq_remove </function> fun��o. Essa fun��o "
"aceita um encadeamento e um canal de espera como um argumento e apenas ativa "
"o encadeamento, se estiver na fila de espera do canal de espera "
"especificado. Se o encadeamento n�o estiver em uma fila de espera ou estiver "
"em uma fila de espera para um canal de espera diferente, essa fun��o n�o "
"far� nada. "

#. (itstool) path: sect2/title
#: book.translate.xml:15857
#, fuzzy
msgid "Turnstiles"
msgstr "Torniquetes"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15859
#, fuzzy
msgid "<primary>turnstiles</primary>"
msgstr " <primary> torniquetes </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15861
#, fuzzy
msgid "- Compare/contrast with sleep queues."
msgstr "- Compare / contraste com filas de sono."

#. (itstool) path: sect2/para
#: book.translate.xml:15863
#, fuzzy
msgid "- Lookup/wait/release. - Describe TDF_TSNOBLOCK race."
msgstr "- Lookup / wait / release. - Descreva a corrida TDF_TSNOBLOCK."

#. (itstool) path: sect2/para
#: book.translate.xml:15866
#, fuzzy
msgid "- Priority propagation."
msgstr "- Propaga��o de prioridade."

#. (itstool) path: sect2/title
#: book.translate.xml:15870
#, fuzzy
msgid "Details of the Mutex Implementation"
msgstr "Detalhes da Implementa��o Mutex"

#. (itstool) path: sect2/para
#: book.translate.xml:15872
#, fuzzy
msgid ""
"- Should we require mutexes to be owned for mtx_destroy() since we can not "
"safely assert that they are unowned by anyone else otherwise?"
msgstr ""
"- Devemos exigir que os mutexes sejam de propriedade de mtx_destroy (), j� "
"que n�o podemos afirmar com seguran�a que eles s�o sem dono de outra pessoa?"

#. (itstool) path: sect3/title
#: book.translate.xml:15877
#, fuzzy
msgid "Spin Mutexes"
msgstr "Spin Mutexes"

#. (itstool) path: sect3/indexterm
#: book.translate.xml:15879
#, fuzzy
msgid "<primary>mutex</primary><secondary>spin</secondary>"
msgstr " <primary> mutex </primary><secondary> girar </secondary> "

#. (itstool) path: sect3/para
#: book.translate.xml:15881
#, fuzzy
msgid "- Use a critical section..."
msgstr "- Use uma se��o cr�tica ..."

#. (itstool) path: sect3/title
#: book.translate.xml:15885
#, fuzzy
msgid "Sleep Mutexes"
msgstr "Mutexes do sono"

#. (itstool) path: sect3/indexterm
#: book.translate.xml:15887
#, fuzzy
msgid "<primary>mutex</primary><secondary>sleep</secondary>"
msgstr " <primary> mutex </primary><secondary> dormir </secondary> "

#. (itstool) path: sect3/para
#: book.translate.xml:15888
#, fuzzy
msgid "- Describe the races with contested mutexes"
msgstr "- Descreva as ra�as com mutexes contestados"

#. (itstool) path: sect3/para
#: book.translate.xml:15890
#, fuzzy
msgid ""
"- Why it is safe to read mtx_lock of a contested mutex when holding the "
"turnstile chain lock."
msgstr ""
"- Por que � seguro ler o mtx_lock de um mutex contestado ao segurar a trava "
"da corrente do torniquete."

#. (itstool) path: sect2/title
#: book.translate.xml:15896
#, fuzzy
msgid "Witness"
msgstr "Testemunha"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15898
#, fuzzy
msgid "<primary>witness</primary>"
msgstr " <primary> testemunha </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15900
#, fuzzy
msgid "- What does it do"
msgstr "- O que isso faz"

#. (itstool) path: sect2/para
#: book.translate.xml:15902
#, fuzzy
msgid "- How does it work"
msgstr "- Como funciona"

#. (itstool) path: sect1/title
#: book.translate.xml:15907
#, fuzzy
msgid "Miscellaneous Topics"
msgstr "T�picos Diversos"

#. (itstool) path: sect2/title
#: book.translate.xml:15910
#, fuzzy
msgid "Interrupt Source and ICU Abstractions"
msgstr "Interromper fontes e abstra��es de ICU"

#. (itstool) path: sect2/para
#: book.translate.xml:15912
#, fuzzy
msgid "- struct isrc"
msgstr "- struct isrc"

#. (itstool) path: sect2/para
#: book.translate.xml:15914
#, fuzzy
msgid "- pic drivers"
msgstr "- drivers de pic"

#. (itstool) path: sect2/title
#: book.translate.xml:15918
#, fuzzy
msgid "Other Random Questions/Topics"
msgstr "Outras quest�es aleat�rias / t�picos"

#. (itstool) path: sect2/para
#: book.translate.xml:15920
#, fuzzy
msgid "- Should we pass an interlock into <function>sema_wait</function>?"
msgstr "- Devemos passar um bloqueio em <function> sema_wait </function> "

#. (itstool) path: sect2/para
#: book.translate.xml:15923
#, fuzzy
msgid "- Should we have non-sleepable sx locks?"
msgstr "- Devemos ter fechaduras sx n�o adormecidas?"

#. (itstool) path: sect2/para
#: book.translate.xml:15925
#, fuzzy
msgid "- Add some info about proper use of reference counts."
msgstr ""
"- Adicione algumas informa��es sobre o uso adequado de contagens de "
"refer�ncia."

#. (itstool) path: glossary/title
#: book.translate.xml:15930
#, fuzzy
msgid "Glossary"
msgstr "Gloss�rio"

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15933
#, fuzzy
msgid "atomic"
msgstr "at�mica"

#. (itstool) path: glossdef/para
#: book.translate.xml:15935
#, fuzzy
msgid ""
"An operation is atomic if all of its effects are visible to other CPUs "
"together when the proper access protocol is followed. In the degenerate case "
"are atomic instructions provided directly by machine architectures. At a "
"higher level, if several members of a structure are protected by a lock, "
"then a set of operations are atomic if they are all performed while holding "
"the lock without releasing the lock in between any of the operations."
msgstr ""
"Uma opera��o � at�mica se todos os seus efeitos s�o vis�veis para outras "
"CPUs juntos quando o protocolo de acesso apropriado � seguido. No caso "
"degenerado s�o fornecidas instru��es at�micas diretamente por arquiteturas "
"de m�quina. Em um n�vel superior, se v�rios membros de uma estrutura s�o "
"protegidos por um bloqueio, ent�o um conjunto de opera��es s�o at�micas, se "
"todas elas forem realizadas, mantendo a trava sem liberar a trava entre "
"qualquer uma das opera��es. "

#. (itstool) path: glossdef/glossseealso
#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15944 book.translate.xml:15995
#, fuzzy
msgid "operation"
msgstr "Opera��o"

#. (itstool) path: glossentry/glossterm
#. (itstool) path: glossdef/glossseealso
#: book.translate.xml:15949 book.translate.xml:16027
#, fuzzy
msgid "block"
msgstr "quadra"

#. (itstool) path: glossdef/para
#: book.translate.xml:15951
#, fuzzy
msgid ""
"A thread is blocked when it is waiting on a lock, resource, or condition. "
"Unfortunately this term is a bit overloaded as a result."
msgstr ""
"Um encadeamento � bloqueado quando est� aguardando um bloqueio, recurso ou "
"condi��o. Infelizmente, esse termo � um pouco sobrecarregado como resultado."

#. (itstool) path: glossdef/glossseealso
#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15955 book.translate.xml:16021 book.translate.xml:16040
#, fuzzy
msgid "sleep"
msgstr "dormir"

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15960
#, fuzzy
msgid "critical section"
msgstr "se��o Cr�tica"

#. (itstool) path: glossdef/para
#: book.translate.xml:15962
#, fuzzy
msgid ""
"A section of code that is not allowed to be preempted. A critical section is "
"entered and exited using the <citerefentry><refentrytitle>critical_enter</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> API."
msgstr ""
"Uma se��o de c�digo que n�o pode ser preterida. Uma se��o cr�tica � inserida "
"e encerrada usando o <citerefentry><refentrytitle> critical_enter </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> API \""

#. (itstool) path: glossentry/glossterm
#. (itstool) path: glossdef/glossseealso
#: book.translate.xml:15969 book.translate.xml:15990
#, fuzzy
msgid "MD"
msgstr "MD"

#. (itstool) path: glossdef/para
#: book.translate.xml:15971
#, fuzzy
msgid "Machine dependent."
msgstr "Dependente da m�quina"

#. (itstool) path: glossdef/glossseealso
#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15973 book.translate.xml:15986
#, fuzzy
msgid "MI"
msgstr "MI"

#. (itstool) path: glossentry/glossterm
#. (itstool) path: glossentry/glosssee
#: book.translate.xml:15978 book.translate.xml:15996
#, fuzzy
msgid "memory operation"
msgstr "opera��o de mem�ria"

#. (itstool) path: glossdef/para
#: book.translate.xml:15980
#, fuzzy
msgid "A memory operation reads and/or writes to a memory location."
msgstr "Uma opera��o de mem�ria l� e / ou grava em um local da mem�ria."

#. (itstool) path: glossdef/para
#: book.translate.xml:15988
#, fuzzy
msgid "Machine independent."
msgstr "M�quina independente\""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:16000
#, fuzzy
msgid "primary interrupt context"
msgstr "contexto de interrup��o prim�rio"

#. (itstool) path: glossdef/para
#: book.translate.xml:16002
#, fuzzy
msgid ""
"Primary interrupt context refers to the code that runs when an interrupt "
"occurs. This code can either run an interrupt handler directly or schedule "
"an asynchronous interrupt thread to execute the interrupt handlers for a "
"given interrupt source."
msgstr ""
"Contexto de interrup��o prim�ria refere-se ao c�digo que � executado quando "
"ocorre uma interrup��o. Esse c�digo pode executar um manipulador de "
"interrup��o diretamente ou agendar um thread de interrup��o ass�ncrono para "
"executar os manipuladores de interrup��o para uma determinada origem de "
"interrup��o."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:16011
#, fuzzy
msgid "realtime kernel thread"
msgstr "thread do kernel em tempo real"

#. (itstool) path: glossdef/para
#: book.translate.xml:16013
#, fuzzy
msgid ""
"A high priority kernel thread. Currently, the only realtime priority kernel "
"threads are interrupt threads."
msgstr ""
"Um encadeamento de kernel de alta prioridade. Atualmente, os �nicos "
"encadeamentos de kernel de prioridade em tempo real s�o encadeamentos de "
"interrup��o."

#. (itstool) path: glossdef/glossseealso
#. (itstool) path: glossentry/glossterm
#: book.translate.xml:16016 book.translate.xml:16045
#, fuzzy
msgid "thread"
msgstr "fio"

#. (itstool) path: glossdef/para
#: book.translate.xml:16023
#, fuzzy
msgid ""
"A thread is asleep when it is blocked on a condition variable or a sleep "
"queue via <function>msleep</function> or <function>tsleep</function>."
msgstr ""
"Um encadeamento est� adormecido quando � bloqueado em uma vari�vel de "
"condi��o ou em uma fila de espera via <function> msleep </function> ou "
"<function> tsleep </function> "

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:16032
#, fuzzy
msgid "sleepable lock"
msgstr "fecho adormecido"

#. (itstool) path: glossdef/para
#: book.translate.xml:16034
#, fuzzy
msgid ""
"A sleepable lock is a lock that can be held by a thread which is asleep. "
"Lockmgr locks and sx locks are currently the only sleepable locks in "
"FreeBSD. Eventually, some sx locks such as the allproc and proctree locks "
"may become non-sleepable locks."
msgstr ""
"Uma trava sleepable � uma trava que pode ser mantida por um thread que est� "
"adormecido. Bloqueios lockmgr e sx lock s�o atualmente os �nicos bloqueios "
"que podem ser suspensos no FreeBSD. Eventualmente, alguns bloqueios sx, como "
"os bloqueios allproc e proctree, podem se tornar bloqueios n�o adormecidos. "

#. (itstool) path: glossdef/para
#: book.translate.xml:16047
#, fuzzy
msgid ""
"A kernel thread represented by a struct thread. Threads own locks and hold a "
"single execution context."
msgstr ""
"Um encadeamento de kernel representado por um encadeamento de estrutura. "
"Encadeia os pr�prios bloqueios e mant�m um �nico contexto de execu��o."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:16053
#, fuzzy
msgid "wait channel"
msgstr "canal de espera"

#. (itstool) path: glossdef/para
#: book.translate.xml:16055
#, fuzzy
msgid "A kernel virtual address that threads may sleep on."
msgstr "Um endere�o virtual do kernel no qual os threads podem dormir\""

#. (itstool) path: part/title
#. (itstool) path: sect1/title
#: book.translate.xml:16065 book.translate.xml:22480
#, fuzzy
msgid "Device Drivers"
msgstr "Drivers de dispositivo"

#. (itstool) path: info/title
#: book.translate.xml:16077
#, fuzzy
msgid "Writing FreeBSD Device Drivers"
msgstr "Gravar drivers de dispositivo FreeBSD"

#. (itstool) path: authorgroup/author
#: book.translate.xml:16080
#, fuzzy
msgid ""
"<personname> <firstname>Murray</firstname> <surname>Stokely</surname> </"
"personname> <contrib>Written by </contrib>"
msgstr ""
" <personname><firstname> Murray </firstname><surname> Stokely </surname></"
"personname><contrib> Escrito por </contrib> "

#. (itstool) path: authorgroup/author
#: book.translate.xml:16091
#, fuzzy
msgid ""
"<personname> <firstname>Jörg</firstname> <surname>Wunsch</surname> </"
"personname> <contrib>Based on intro(4) manual page by </contrib>"
msgstr ""
" <personname><firstname> J�rg </firstname><surname> Wunsch </surname></"
"personname><contrib> Baseado na p�gina de manual intro (4) por </contrib> "

#. (itstool) path: sect1/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:16105 book.translate.xml:22485
#, fuzzy
msgid "<primary>device driver</primary>"
msgstr " <primary> driver do dispositivo </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16106
#, fuzzy
msgid "<primary>pseudo-device</primary>"
msgstr " <primary> pseudo-dispositivo </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16108
#, fuzzy
msgid ""
"This chapter provides a brief introduction to writing device drivers for "
"FreeBSD. A device in this context is a term used mostly for hardware-related "
"stuff that belongs to the system, like disks, printers, or a graphics "
"display with its keyboard. A device driver is the software component of the "
"operating system that controls a specific device. There are also so-called "
"pseudo-devices where a device driver emulates the behavior of a device in "
"software without any particular underlying hardware. Device drivers can be "
"compiled into the system statically or loaded on demand through the dynamic "
"kernel linker facility `kld'."
msgstr ""
"Este cap�tulo fornece uma breve introdu��o � grava��o de drivers de "
"dispositivo para o FreeBSD. Um dispositivo neste contexto � um termo usado "
"principalmente para material relacionado ao hardware que pertence ao "
"sistema, como discos, impressoras ou um monitor gr�fico com seu teclado. Um "
"dispositivo driver � o componente de software do sistema operacional que "
"controla um dispositivo espec�fico.Existem tamb�m os chamados pseudo-"
"dispositivos em que um driver de dispositivo emula o comportamento de um "
"dispositivo em um software sem qualquer hardware subjacente espec�fico.Os "
"drivers de dispositivo podem ser compilados no sistema estaticamente ou "
"carregado sob demanda atrav�s do recurso de linker do kernel din�mico `kld "
"';."

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16120
#, fuzzy
msgid "<primary>device nodes</primary>"
msgstr " <primary> n�s de dispositivo </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16122
#, fuzzy
msgid ""
"Most devices in a <trademark class=\"registered\">UNIX</trademark>-like "
"operating system are accessed through device-nodes, sometimes also called "
"special files. These files are usually located under the directory "
"<filename>/dev</filename> in the filesystem hierarchy."
msgstr ""
"A maioria dos dispositivos em um <trademark class=\"registered\"> UNIX </"
"trademark> como o sistema operacional s�o acessados ​​atrav�s de n�s de "
"dispositivos, �s vezes tamb�m chamados de arquivos especiais. Esses arquivos "
"geralmente est�o localizados no diret�rio <filename> / dev </filename> na "
"hierarquia do sistema de arquivos. "

#. (itstool) path: sect1/para
#: book.translate.xml:16127
#, fuzzy
msgid ""
"Device drivers can roughly be broken down into two categories; character and "
"network device drivers."
msgstr ""
"Os drivers de dispositivos podem ser divididos em duas categorias: drivers "
"de dispositivos e de rede."

#. (itstool) path: sect1/title
#: book.translate.xml:16133
#, fuzzy
msgid "Dynamic Kernel Linker Facility - KLD"
msgstr "Instala��o do Linker Kernel Din�mico - KLD"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16135
#, fuzzy
msgid "<primary>kernel linking</primary> <secondary>dynamic</secondary>"
msgstr ""
" <primary> liga��o do kernel </primary><secondary> din�mico </secondary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16139
#, fuzzy
msgid "<primary>kernel loadable modules (KLD)</primary>"
msgstr " <primary> m�dulos carreg�veis ​​de kernel (KLD) </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16143
#, fuzzy
msgid ""
"The kld interface allows system administrators to dynamically add and remove "
"functionality from a running system. This allows device driver writers to "
"load their new changes into a running kernel without constantly rebooting to "
"test changes."
msgstr ""
"A interface kld permite que os administradores do sistema adicionem e "
"removam dinamicamente a funcionalidade de um sistema em execu��o. Isso "
"permite que os gravadores de driver de dispositivo carreguem suas novas "
"altera��es em um kernel em execu��o sem constantemente reinicializar para "
"testar as altera��es."

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16149
#, fuzzy
msgid "<primary>kernel modules</primary> <secondary>loading</secondary>"
msgstr ""
" <primary> m�dulos do kernel </primary><secondary> Carregando </secondary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16153
#, fuzzy
msgid "<primary>kernel modules</primary> <secondary>unloading</secondary>"
msgstr ""
" <primary> m�dulos do kernel </primary><secondary> descarga </secondary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16157
#, fuzzy
msgid "<primary>kernel modules</primary> <secondary>listing</secondary>"
msgstr ""
" <primary> m�dulos do kernel </primary><secondary> listando </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16162
#, fuzzy
msgid "The kld interface is used through:"
msgstr "A interface kld � usada atrav�s de:"

#. (itstool) path: listitem/simpara
#: book.translate.xml:16166
#, fuzzy
msgid "<command>kldload</command> - loads a new kernel module"
msgstr " <command> kldload </command> - carrega um novo m�dulo do kernel "

#. (itstool) path: listitem/simpara
#: book.translate.xml:16169
#, fuzzy
msgid "<command>kldunload</command> - unloads a kernel module"
msgstr " <command> kldunload </command> - descarrega um m�dulo do kernel "

#. (itstool) path: listitem/simpara
#: book.translate.xml:16172
#, fuzzy
msgid "<command>kldstat</command> - lists loaded modules"
msgstr " <command> kldstat </command> - listas de m�dulos carregados "

#. (itstool) path: sect1/para
#: book.translate.xml:16176
#, fuzzy
msgid "Skeleton Layout of a kernel module"
msgstr "Layout do esqueleto de um m�dulo do kernel"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16178
#, no-wrap
msgid ""
"/*\n"
" * KLD Skeleton\n"
" * Inspired by Andrew Reiter's Daemonnews article\n"
" */\n"
"\n"
"#include &lt;sys/types.h&gt;\n"
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/systm.h&gt;  /* uprintf */\n"
"#include &lt;sys/errno.h&gt;\n"
"#include &lt;sys/param.h&gt;  /* defines used in kernel.h */\n"
"#include &lt;sys/kernel.h&gt; /* types used in module initialization */\n"
"\n"
"/*\n"
" * Load handler that deals with the loading and unloading of a KLD.\n"
" */\n"
"\n"
"static int\n"
"skel_loader(struct module *m, int what, void *arg)\n"
"{\n"
"  int err = 0;\n"
"\n"
"  switch (what) {\n"
"  case MOD_LOAD:                /* kldload */\n"
"    uprintf(\"Skeleton KLD loaded.\\n\");\n"
"    break;\n"
"  case MOD_UNLOAD:\n"
"    uprintf(\"Skeleton KLD unloaded.\\n\");\n"
"    break;\n"
"  default:\n"
"    err = EOPNOTSUPP;\n"
"    break;\n"
"  }\n"
"  return(err);\n"
"}\n"
"\n"
"/* Declare this module to the rest of the kernel */\n"
"\n"
"static moduledata_t skel_mod = {\n"
"  \"skel\",\n"
"  skel_loader,\n"
"  NULL\n"
"};\n"
"\n"
"DECLARE_MODULE(skeleton, skel_mod, SI_SUB_KLD, SI_ORDER_ANY);"
msgstr ""
"/*\n"
" * KLD Skeleton\n"
" * Inspired by Andrew Reiter's Daemonnews article\n"
" */\n"
"\n"
"#include &lt;sys/types.h&gt;\n"
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/systm.h&gt;  /* uprintf */\n"
"#include &lt;sys/errno.h&gt;\n"
"#include &lt;sys/param.h&gt;  /* defines used in kernel.h */\n"
"#include &lt;sys/kernel.h&gt; /* types used in module initialization */\n"
"\n"
"/*\n"
" * Load handler that deals with the loading and unloading of a KLD.\n"
" */\n"
"\n"
"static int\n"
"skel_loader(struct module *m, int what, void *arg)\n"
"{\n"
"  int err = 0;\n"
"\n"
"  switch (what) {\n"
"  case MOD_LOAD:                /* kldload */\n"
"    uprintf(\"Skeleton KLD loaded.\\n\");\n"
"    break;\n"
"  case MOD_UNLOAD:\n"
"    uprintf(\"Skeleton KLD unloaded.\\n\");\n"
"    break;\n"
"  default:\n"
"    err = EOPNOTSUPP;\n"
"    break;\n"
"  }\n"
"  return(err);\n"
"}\n"
"\n"
"/* Declare this module to the rest of the kernel */\n"
"\n"
"static moduledata_t skel_mod = {\n"
"  \"skel\",\n"
"  skel_loader,\n"
"  NULL\n"
"};\n"
"\n"
"DECLARE_MODULE(skeleton, skel_mod, SI_SUB_KLD, SI_ORDER_ANY);"

#. (itstool) path: sect2/title
#: book.translate.xml:16225
#, fuzzy
msgid "Makefile"
msgstr "Makefile"

#. (itstool) path: sect2/para
#: book.translate.xml:16227
#, fuzzy
msgid ""
"FreeBSD provides a system makefile to simplify compiling a kernel module."
msgstr ""
"O FreeBSD fornece um makefile do sistema para simplificar a compila��o de um "
"m�dulo do kernel."

#. (itstool) path: sect2/programlisting
#: book.translate.xml:16230
#, no-wrap
msgid ""
"SRCS=skeleton.c\n"
"KMOD=skeleton\n"
"\n"
".include &lt;bsd.kmod.mk&gt;"
msgstr ""
"SRCS=skeleton.c\n"
"KMOD=skeleton\n"
"\n"
".include &lt;bsd.kmod.mk&gt;"

#. (itstool) path: sect2/para
#: book.translate.xml:16235
#, fuzzy
msgid ""
"Running <command>make</command> with this makefile will create a file "
"<filename>skeleton.ko</filename> that can be loaded into the kernel by "
"typing:"
msgstr ""
"Corrida <command> fa�o </command> com este makefile ir� criar um arquivo "
"<filename> skeleton.ko </filename> que pode ser carregado no kernel "
"digitando: "

#. (itstool) path: sect2/screen
#: book.translate.xml:16239
#, no-wrap
msgid "<prompt>#</prompt> <userinput>kldload -v ./skeleton.ko</userinput>"
msgstr "<prompt>#</prompt> <userinput>kldload -v ./skeleton.ko</userinput>"

#. (itstool) path: sect1/title
#. (itstool) path: sect2/title
#: book.translate.xml:16244 book.translate.xml:22524
#, fuzzy
msgid "Character Devices"
msgstr "Dispositivos de Personagem"

#. (itstool) path: sect1/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:16246 book.translate.xml:22526
#, fuzzy
msgid "<primary>character devices</primary>"
msgstr " <primary> dispositivos de caracteres </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16249
#, fuzzy
msgid ""
"A character device driver is one that transfers data directly to and from a "
"user process. This is the most common type of device driver and there are "
"plenty of simple examples in the source tree."
msgstr ""
"Um driver de dispositivo de caracteres � aquele que transfere dados "
"diretamente para e de um processo do usu�rio. Esse � o tipo mais comum de "
"driver de dispositivo e h� v�rios exemplos simples na �rvore de c�digo-fonte."

#. (itstool) path: sect1/para
#: book.translate.xml:16254
#, fuzzy
msgid ""
"This simple example pseudo-device remembers whatever values are written to "
"it and can then echo them back when read."
msgstr ""
"Este pseudo-dispositivo de exemplo simples lembra-se de todos os valores que "
"foram escritos e pode, ent�o, eco�-los quando lidos."

#. (itstool) path: example/title
#: book.translate.xml:16259
#, fuzzy
msgid "Example of a Sample Echo Pseudo-Device Driver for FreeBSD 10.X - 12.X"
msgstr ""
"Exemplo de um driver de pseudo-dispositivo de eco de amostra para o FreeBSD "
"10.X - 12.X"

#. (itstool) path: example/programlisting
#: book.translate.xml:16262
#, no-wrap
msgid ""
"/*\n"
" * Simple Echo pseudo-device KLD\n"
" *\n"
" * Murray Stokely\n"
" * Søren (Xride) Straarup\n"
" * Eitan Adler\n"
" */\n"
"\n"
"#include &lt;sys/types.h&gt;\n"
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/systm.h&gt;  /* uprintf */\n"
"#include &lt;sys/param.h&gt;  /* defines used in kernel.h */\n"
"#include &lt;sys/kernel.h&gt; /* types used in module initialization */\n"
"#include &lt;sys/conf.h&gt;   /* cdevsw struct */\n"
"#include &lt;sys/uio.h&gt;    /* uio struct */\n"
"#include &lt;sys/malloc.h&gt;\n"
"\n"
"#define BUFFERSIZE 255\n"
"\n"
"/* Function prototypes */\n"
"static d_open_t      echo_open;\n"
"static d_close_t     echo_close;\n"
"static d_read_t      echo_read;\n"
"static d_write_t     echo_write;\n"
"\n"
"/* Character device entry points */\n"
"static struct cdevsw echo_cdevsw = {\n"
"\t.d_version = D_VERSION,\n"
"\t.d_open = echo_open,\n"
"\t.d_close = echo_close,\n"
"\t.d_read = echo_read,\n"
"\t.d_write = echo_write,\n"
"\t.d_name = \"echo\",\n"
"};\n"
"\n"
"struct s_echo {\n"
"\tchar msg[BUFFERSIZE + 1];\n"
"\tint len;\n"
"};\n"
"\n"
"/* vars */\n"
"static struct cdev *echo_dev;\n"
"static struct s_echo *echomsg;\n"
"\n"
"MALLOC_DECLARE(M_ECHOBUF);\n"
"MALLOC_DEFINE(M_ECHOBUF, \"echobuffer\", \"buffer for echo module\");\n"
"\n"
"/*\n"
" * This function is called by the kld[un]load(2) system calls to\n"
" * determine what actions to take when a module is loaded or unloaded.\n"
" */\n"
"static int\n"
"echo_loader(struct module *m __unused, int what, void *arg __unused)\n"
"{\n"
"\tint error = 0;\n"
"\n"
"\tswitch (what) {\n"
"\tcase MOD_LOAD:                /* kldload */\n"
"\t\terror = make_dev_p(MAKEDEV_CHECKNAME | MAKEDEV_WAITOK,\n"
"\t\t    &amp;echo_dev,\n"
"\t\t    &amp;echo_cdevsw,\n"
"\t\t    0,\n"
"\t\t    UID_ROOT,\n"
"\t\t    GID_WHEEL,\n"
"\t\t    0600,\n"
"\t\t    \"echo\");\n"
"\t\tif (error != 0)\n"
"\t\t\tbreak;\n"
"\n"
"\t\techomsg = malloc(sizeof(*echomsg), M_ECHOBUF, M_WAITOK |\n"
"\t\t    M_ZERO);\n"
"\t\tprintf(\"Echo device loaded.\\n\");\n"
"\t\tbreak;\n"
"\tcase MOD_UNLOAD:\n"
"\t\tdestroy_dev(echo_dev);\n"
"\t\tfree(echomsg, M_ECHOBUF);\n"
"\t\tprintf(\"Echo device unloaded.\\n\");\n"
"\t\tbreak;\n"
"\tdefault:\n"
"\t\terror = EOPNOTSUPP;\n"
"\t\tbreak;\n"
"\t}\n"
"\treturn (error);\n"
"}\n"
"\n"
"static int\n"
"echo_open(struct cdev *dev __unused, int oflags __unused, int devtype __unused,\n"
"    struct thread *td __unused)\n"
"{\n"
"\tint error = 0;\n"
"\n"
"\tuprintf(\"Opened device \\\"echo\\\" successfully.\\n\");\n"
"\treturn (error);\n"
"}\n"
"\n"
"static int\n"
"echo_close(struct cdev *dev __unused, int fflag __unused, int devtype __unused,\n"
"    struct thread *td __unused)\n"
"{\n"
"\n"
"\tuprintf(\"Closing device \\\"echo\\\".\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/*\n"
" * The read function just takes the buf that was saved via\n"
" * echo_write() and returns it to userland for accessing.\n"
" * uio(9)\n"
" */\n"
"static int\n"
"echo_read(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)\n"
"{\n"
"\tsize_t amt;\n"
"\tint error;\n"
"\n"
"\t/*\n"
"\t * How big is this read operation?  Either as big as the user wants,\n"
"\t * or as big as the remaining data.  Note that the 'len' does not\n"
"\t * include the trailing null character.\n"
"\t */\n"
"\tamt = MIN(uio-&gt;uio_resid, uio-&gt;uio_offset &gt;= echomsg-&gt;len + 1 ? 0 :\n"
"\t    echomsg-&gt;len + 1 - uio-&gt;uio_offset);\n"
"\n"
"\tif ((error = uiomove(echomsg-&gt;msg, amt, uio)) != 0)\n"
"\t\tuprintf(\"uiomove failed!\\n\");\n"
"\n"
"\treturn (error);\n"
"}\n"
"\n"
"/*\n"
" * echo_write takes in a character string and saves it\n"
" * to buf for later accessing.\n"
" */\n"
"static int\n"
"echo_write(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)\n"
"{\n"
"\tsize_t amt;\n"
"\tint error;\n"
"\n"
"\t/*\n"
"\t * We either write from the beginning or are appending -- do\n"
"\t * not allow random access.\n"
"\t */\n"
"\tif (uio-&gt;uio_offset != 0 &amp;&amp; (uio-&gt;uio_offset != echomsg-&gt;len))\n"
"\t\treturn (EINVAL);\n"
"\n"
"\t/* This is a new message, reset length */\n"
"\tif (uio-&gt;uio_offset == 0)\n"
"\t\techomsg-&gt;len = 0;\n"
"\n"
"\t/* Copy the string in from user memory to kernel memory */\n"
"\tamt = MIN(uio-&gt;uio_resid, (BUFFERSIZE - echomsg-&gt;len));\n"
"\n"
"\terror = uiomove(echomsg-&gt;msg + uio-&gt;uio_offset, amt, uio);\n"
"\n"
"\t/* Now we need to null terminate and record the length */\n"
"\techomsg-&gt;len = uio-&gt;uio_offset;\n"
"\techomsg-&gt;msg[echomsg-&gt;len] = 0;\n"
"\n"
"\tif (error != 0)\n"
"\t\tuprintf(\"Write failed: bad address!\\n\");\n"
"\treturn (error);\n"
"}\n"
"\n"
"DEV_MODULE(echo, echo_loader, NULL);"
msgstr ""
"/*\n"
" * Simple Echo pseudo-device KLD\n"
" *\n"
" * Murray Stokely\n"
" * Søren (Xride) Straarup\n"
" * Eitan Adler\n"
" */\n"
"\n"
"#include &lt;sys/types.h&gt;\n"
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/systm.h&gt;  /* uprintf */\n"
"#include &lt;sys/param.h&gt;  /* defines used in kernel.h */\n"
"#include &lt;sys/kernel.h&gt; /* types used in module initialization */\n"
"#include &lt;sys/conf.h&gt;   /* cdevsw struct */\n"
"#include &lt;sys/uio.h&gt;    /* uio struct */\n"
"#include &lt;sys/malloc.h&gt;\n"
"\n"
"#define BUFFERSIZE 255\n"
"\n"
"/* Function prototypes */\n"
"static d_open_t      echo_open;\n"
"static d_close_t     echo_close;\n"
"static d_read_t      echo_read;\n"
"static d_write_t     echo_write;\n"
"\n"
"/* Character device entry points */\n"
"static struct cdevsw echo_cdevsw = {\n"
"\t.d_version = D_VERSION,\n"
"\t.d_open = echo_open,\n"
"\t.d_close = echo_close,\n"
"\t.d_read = echo_read,\n"
"\t.d_write = echo_write,\n"
"\t.d_name = \"echo\",\n"
"};\n"
"\n"
"struct s_echo {\n"
"\tchar msg[BUFFERSIZE + 1];\n"
"\tint len;\n"
"};\n"
"\n"
"/* vars */\n"
"static struct cdev *echo_dev;\n"
"static struct s_echo *echomsg;\n"
"\n"
"MALLOC_DECLARE(M_ECHOBUF);\n"
"MALLOC_DEFINE(M_ECHOBUF, \"echobuffer\", \"buffer for echo module\");\n"
"\n"
"/*\n"
" * This function is called by the kld[un]load(2) system calls to\n"
" * determine what actions to take when a module is loaded or unloaded.\n"
" */\n"
"static int\n"
"echo_loader(struct module *m __unused, int what, void *arg __unused)\n"
"{\n"
"\tint error = 0;\n"
"\n"
"\tswitch (what) {\n"
"\tcase MOD_LOAD:                /* kldload */\n"
"\t\terror = make_dev_p(MAKEDEV_CHECKNAME | MAKEDEV_WAITOK,\n"
"\t\t    &amp;echo_dev,\n"
"\t\t    &amp;echo_cdevsw,\n"
"\t\t    0,\n"
"\t\t    UID_ROOT,\n"
"\t\t    GID_WHEEL,\n"
"\t\t    0600,\n"
"\t\t    \"echo\");\n"
"\t\tif (error != 0)\n"
"\t\t\tbreak;\n"
"\n"
"\t\techomsg = malloc(sizeof(*echomsg), M_ECHOBUF, M_WAITOK |\n"
"\t\t    M_ZERO);\n"
"\t\tprintf(\"Echo device loaded.\\n\");\n"
"\t\tbreak;\n"
"\tcase MOD_UNLOAD:\n"
"\t\tdestroy_dev(echo_dev);\n"
"\t\tfree(echomsg, M_ECHOBUF);\n"
"\t\tprintf(\"Echo device unloaded.\\n\");\n"
"\t\tbreak;\n"
"\tdefault:\n"
"\t\terror = EOPNOTSUPP;\n"
"\t\tbreak;\n"
"\t}\n"
"\treturn (error);\n"
"}\n"
"\n"
"static int\n"
"echo_open(struct cdev *dev __unused, int oflags __unused, int devtype __unused,\n"
"    struct thread *td __unused)\n"
"{\n"
"\tint error = 0;\n"
"\n"
"\tuprintf(\"Opened device \\\"echo\\\" successfully.\\n\");\n"
"\treturn (error);\n"
"}\n"
"\n"
"static int\n"
"echo_close(struct cdev *dev __unused, int fflag __unused, int devtype __unused,\n"
"    struct thread *td __unused)\n"
"{\n"
"\n"
"\tuprintf(\"Closing device \\\"echo\\\".\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/*\n"
" * The read function just takes the buf that was saved via\n"
" * echo_write() and returns it to userland for accessing.\n"
" * uio(9)\n"
" */\n"
"static int\n"
"echo_read(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)\n"
"{\n"
"\tsize_t amt;\n"
"\tint error;\n"
"\n"
"\t/*\n"
"\t * How big is this read operation?  Either as big as the user wants,\n"
"\t * or as big as the remaining data.  Note that the 'len' does not\n"
"\t * include the trailing null character.\n"
"\t */\n"
"\tamt = MIN(uio-&gt;uio_resid, uio-&gt;uio_offset &gt;= echomsg-&gt;len + 1 ? 0 :\n"
"\t    echomsg-&gt;len + 1 - uio-&gt;uio_offset);\n"
"\n"
"\tif ((error = uiomove(echomsg-&gt;msg, amt, uio)) != 0)\n"
"\t\tuprintf(\"uiomove failed!\\n\");\n"
"\n"
"\treturn (error);\n"
"}\n"
"\n"
"/*\n"
" * echo_write takes in a character string and saves it\n"
" * to buf for later accessing.\n"
" */\n"
"static int\n"
"echo_write(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)\n"
"{\n"
"\tsize_t amt;\n"
"\tint error;\n"
"\n"
"\t/*\n"
"\t * We either write from the beginning or are appending -- do\n"
"\t * not allow random access.\n"
"\t */\n"
"\tif (uio-&gt;uio_offset != 0 &amp;&amp; (uio-&gt;uio_offset != echomsg-&gt;len))\n"
"\t\treturn (EINVAL);\n"
"\n"
"\t/* This is a new message, reset length */\n"
"\tif (uio-&gt;uio_offset == 0)\n"
"\t\techomsg-&gt;len = 0;\n"
"\n"
"\t/* Copy the string in from user memory to kernel memory */\n"
"\tamt = MIN(uio-&gt;uio_resid, (BUFFERSIZE - echomsg-&gt;len));\n"
"\n"
"\terror = uiomove(echomsg-&gt;msg + uio-&gt;uio_offset, amt, uio);\n"
"\n"
"\t/* Now we need to null terminate and record the length */\n"
"\techomsg-&gt;len = uio-&gt;uio_offset;\n"
"\techomsg-&gt;msg[echomsg-&gt;len] = 0;\n"
"\n"
"\tif (error != 0)\n"
"\t\tuprintf(\"Write failed: bad address!\\n\");\n"
"\treturn (error);\n"
"}\n"
"\n"
"DEV_MODULE(echo, echo_loader, NULL);"

#. (itstool) path: sect1/para
#: book.translate.xml:16429
#, fuzzy
msgid "With this driver loaded try:"
msgstr "Com este driver carregado tente:"

#. (itstool) path: sect1/screen
#: book.translate.xml:16431
#, no-wrap
msgid ""
"<prompt>#</prompt> <userinput>echo -n \"Test Data\" &gt; /dev/echo</userinput>\n"
"<prompt>#</prompt> <userinput>cat /dev/echo</userinput>\n"
"Opened device \"echo\" successfully.\n"
"Test Data\n"
"Closing device \"echo\"."
msgstr ""
"<prompt>#</prompt> <userinput>echo -n \"Test Data\" &gt; /dev/echo</userinput>\n"
"<prompt>#</prompt> <userinput>cat /dev/echo</userinput>\n"
"Opened device \"echo\" successfully.\n"
"Test Data\n"
"Closing device \"echo\"."

#. (itstool) path: sect1/para
#: book.translate.xml:16437
#, fuzzy
msgid "Real hardware devices are described in the next chapter."
msgstr "Dispositivos de hardware reais s�o descritos no pr�ximo cap�tulo."

#. (itstool) path: sect1/title
#: book.translate.xml:16442
#, fuzzy
msgid "Block Devices (Are Gone)"
msgstr "Dispositivos de bloco (foram embora)"

#. (itstool) path: sect1/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:16444 book.translate.xml:22511
#, fuzzy
msgid "<primary>block devices</primary>"
msgstr " <primary> dispositivos de bloco </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16446
#, fuzzy
msgid ""
"Other <trademark class=\"registered\">UNIX</trademark> systems may support a "
"second type of disk device known as block devices. Block devices are disk "
"devices for which the kernel provides caching. This caching makes block-"
"devices almost unusable, or at least dangerously unreliable. The caching "
"will reorder the sequence of write operations, depriving the application of "
"the ability to know the exact disk contents at any one instant in time."
msgstr ""
"De outros <trademark class=\"registered\"> UNIX </trademark> sistemas podem "
"suportar um segundo tipo de dispositivo de disco conhecido como dispositivos "
"de bloco. Dispositivos de bloco s�o dispositivos de disco para os quais o "
"kernel fornece armazenamento em cache. Esse cache torna os dispositivos de "
"bloco quase inutiliz�veis, ou pelo menos perigosamente n�o confi�veis. O "
"cache ir� reordenar a sequ�ncia de opera��es de grava��o, privando o "
"aplicativo da capacidade de saber o conte�do exato do disco a qualquer "
"instante. "

#. (itstool) path: sect1/para
#: book.translate.xml:16454
#, fuzzy
msgid ""
"This makes predictable and reliable crash recovery of on-disk data "
"structures (filesystems, databases, etc.) impossible. Since writes may be "
"delayed, there is no way the kernel can report to the application which "
"particular write operation encountered a write error, this further compounds "
"the consistency problem."
msgstr ""
"Isso impossibilita a previs�vel e confi�vel recupera��o de falhas de "
"estruturas de dados em disco (sistemas de arquivos, bancos de dados, etc.). "
"Como as grava��es podem ser atrasadas, n�o h� como o kernel reportar ao "
"aplicativo qual opera��o de grava��o encontrou um erro de grava��o\" isso "
"complica ainda mais o problema de consist�ncia \""

#. (itstool) path: sect1/para
#: book.translate.xml:16461
#, fuzzy
msgid ""
"For this reason, no serious applications rely on block devices, and in fact, "
"almost all applications which access disks directly take great pains to "
"specify that character (or <quote>raw</quote>) devices should always be "
"used. Because the implementation of the aliasing of each disk (partition) to "
"two devices with different semantics significantly complicated the relevant "
"kernel code FreeBSD dropped support for cached disk devices as part of the "
"modernization of the disk I/O infrastructure."
msgstr ""
"Por essa raz�o, nenhum aplicativo s�rio depende de dispositivos de bloco e, "
"de fato, quase todos os aplicativos que acessam discos fazem um grande "
"esfor�o para especificar esse caractere (ou <quote> cru </quote> ) "
"dispositivos devem sempre ser usados. Como a implementa��o do aliasing de "
"cada disco (parti��o) para dois dispositivos com sem�ntica diferente "
"complicou significativamente o c�digo do kernel relevante, o FreeBSD removeu "
"o suporte para dispositivos de disco em cache como parte da moderniza��o da "
"infra-estrutura de E / S de disco. "

#. (itstool) path: sect1/title
#: book.translate.xml:16473
#, fuzzy
msgid "Network Drivers"
msgstr "Drivers de Rede"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16475
#, fuzzy
msgid "<primary>network devices</primary>"
msgstr " <primary> dispositivos de rede </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16478
#, fuzzy
msgid ""
"Drivers for network devices do not use device nodes in order to be accessed. "
"Their selection is based on other decisions made inside the kernel and "
"instead of calling open(), use of a network device is generally introduced "
"by using the system call socket(2)."
msgstr ""
"Drivers para dispositivos de rede n�o usam n�s de dispositivos para serem "
"acessados. Sua sele��o � baseada em outras decis�es feitas dentro do kernel "
"e em vez de chamar open (), o uso de um dispositivo de rede � geralmente "
"introduzido usando o socket de chamada do sistema ( 2) "

#. (itstool) path: sect1/para
#: book.translate.xml:16484
#, fuzzy
msgid ""
"For more information see ifnet(9), the source of the loopback device, and "
"Bill Paul's network drivers."
msgstr ""
"Para obter mais informa��es, consulte ifnet (9), a origem do dispositivo de "
"loopback e os drivers de rede de Bill Paul."

#. (itstool) path: info/title
#: book.translate.xml:16496
#, fuzzy
msgid "ISA Device Drivers"
msgstr "Drivers de dispositivo ISA"

#. (itstool) path: authorgroup/author
#: book.translate.xml:16498 book.translate.xml:19470
#, fuzzy
msgid ""
"<personname><firstname>Sergey</firstname><surname>Babkin</surname></"
"personname><contrib>Written by </contrib>"
msgstr ""
" <personname><firstname> Sergey </firstname><surname> Babkin </surname></"
"personname><contrib> Escrito por </contrib> "

#. (itstool) path: authorgroup/author
#: book.translate.xml:16501 book.translate.xml:19473
#, fuzzy
msgid ""
"<personname><firstname>Murray</firstname><surname>Stokely</surname></"
"personname><contrib>Modifications for Handbook made by </contrib>"
msgstr ""
" <personname><firstname> Murray </firstname><surname> Stokely </surname></"
"personname><contrib> Modifica��es para o manual feito por </contrib> "

#. (itstool) path: authorgroup/author
#: book.translate.xml:16502
#, fuzzy
msgid ""
"<personname><firstname>Valentino</firstname><surname>Vaschetto</surname></"
"personname>"
msgstr ""
" <personname><firstname> Valentino </firstname><surname> Vaschetto </"
"surname></personname> "

#. (itstool) path: authorgroup/author
#: book.translate.xml:16503
#, fuzzy
msgid ""
"<personname><firstname>Wylie</firstname><surname>Stilwell</surname></"
"personname>"
msgstr ""
" <personname><firstname> Wylie </firstname><surname> Stilwell </surname></"
"personname> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16512
#, fuzzy
msgid "<primary>ISA</primary>"
msgstr " <primary> ISA </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16513
#, fuzzy
msgid "<primary>device driver</primary><secondary>ISA</secondary>"
msgstr ""
" <primary> driver do dispositivo </primary><secondary> � UM </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16515
#, fuzzy
msgid ""
"This chapter introduces the issues relevant to writing a driver for an ISA "
"device. The pseudo-code presented here is rather detailed and reminiscent of "
"the real code but is still only pseudo-code. It avoids the details "
"irrelevant to the subject of the discussion. The real-life examples can be "
"found in the source code of real drivers. In particular the drivers "
"<literal>ep</literal> and <literal>aha</literal> are good sources of "
"information."
msgstr ""
"Este cap�tulo apresenta as quest�es relevantes para escrever um driver para "
"um dispositivo ISA. O pseudo-c�digo apresentado aqui � bastante detalhado e "
"lembra o c�digo real, mas ainda � apenas pseudo-c�digo. Evita os detalhes "
"irrelevantes para o assunto da discuss�o Os exemplos da vida real podem ser "
"encontrados no c�digo fonte dos drivers reais. <literal> ep </literal> e "
"<literal> aha </literal> s�o boas fontes de informa��o \""

#. (itstool) path: sect1/title
#: book.translate.xml:16525
#, fuzzy
msgid "Basic Information"
msgstr "Informa��o b�sica"

#. (itstool) path: sect1/para
#: book.translate.xml:16527
#, fuzzy
msgid "A typical ISA driver would need the following include files:"
msgstr "Um driver ISA t�pico precisaria dos seguintes arquivos include:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16530
#, no-wrap
msgid ""
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/bus.h&gt;\n"
"#include &lt;machine/bus.h&gt;\n"
"#include &lt;machine/resource.h&gt;\n"
"#include &lt;sys/rman.h&gt;\n"
"\n"
"#include &lt;isa/isavar.h&gt;\n"
"#include &lt;isa/pnpvar.h&gt;"
msgstr ""
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/bus.h&gt;\n"
"#include &lt;machine/bus.h&gt;\n"
"#include &lt;machine/resource.h&gt;\n"
"#include &lt;sys/rman.h&gt;\n"
"\n"
"#include &lt;isa/isavar.h&gt;\n"
"#include &lt;isa/pnpvar.h&gt;"

#. (itstool) path: sect1/para
#: book.translate.xml:16539
#, fuzzy
msgid "They describe the things specific to the ISA and generic bus subsystem."
msgstr ""
"Eles descrevem as coisas espec�ficas do ISA e do subsistema de barramento "
"gen�rico."

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16542
#, fuzzy
msgid "<primary>object-oriented</primary>"
msgstr " <primary> Orientado a Objeto </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16543
#, fuzzy
msgid ""
"The bus subsystem is implemented in an object-oriented fashion, its main "
"structures are accessed by associated method functions."
msgstr ""
"O subsistema de barramento � implementado de forma orientada a objeto, suas "
"principais estruturas s�o acessadas por fun��es de m�todo associadas."

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16547
#, fuzzy
msgid "<primary>bus methods</primary>"
msgstr " <primary> m�todos de �nibus </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16548
#, fuzzy
msgid ""
"The list of bus methods implemented by an ISA driver is like one for any "
"other bus. For a hypothetical driver named <quote>xxx</quote> they would be:"
msgstr ""
"A lista de m�todos de barramento implementados por um driver ISA � como um "
"para qualquer outro barramento. Para um driver hipot�tico chamado <quote> "
"xxx </quote> eles seriam:"

#. (itstool) path: listitem/para
#: book.translate.xml:16554
#, fuzzy
msgid ""
"<function>static void xxx_isa_identify (driver_t *, device_t);</function> "
"Normally used for bus drivers, not device drivers. But for ISA devices this "
"method may have special use: if the device provides some device-specific "
"(non-PnP) way to auto-detect devices this routine may implement it."
msgstr ""
" <function> Vazio est�tico xxx_isa_identify (driver_t *, device_t); </"
"function> Normalmente usado para motoristas de �nibus, n�o drivers de "
"dispositivo. Mas, para dispositivos ISA, esse m�todo pode ter um uso "
"especial: se o dispositivo fornecer alguma maneira espec�fica de dispositivo "
"(n�o PnP) de detectar dispositivos automaticamente, essa rotina poder� "
"implement�-lo. "

#. (itstool) path: listitem/para
#: book.translate.xml:16563
#, fuzzy
msgid ""
"<function>static int xxx_isa_probe (device_t dev);</function> Probe for a "
"device at a known (or PnP) location. This routine can also accommodate "
"device-specific auto-detection of parameters for partially configured "
"devices."
msgstr ""
" <function> est�tico int xxx_isa_probe (device_t dev); </function> Sonda "
"para um dispositivo em um local conhecido (ou PnP). Essa rotina tamb�m pode "
"acomodar a detec��o autom�tica espec�fica de dispositivos de par�metros para "
"dispositivos parcialmente configurados. "

#. (itstool) path: listitem/para
#: book.translate.xml:16571
#, fuzzy
msgid ""
"<function>static int xxx_isa_attach (device_t dev);</function> Attach and "
"initialize device."
msgstr ""
" <function> est�tico int xxx_isa_attach (device_t dev); </function> Anexe e "
"inicialize o dispositivo. "

#. (itstool) path: listitem/para
#: book.translate.xml:16576
#, fuzzy
msgid ""
"<function>static int xxx_isa_detach (device_t dev);</function> Detach device "
"before unloading the driver module."
msgstr ""
" <function> est�tico int xxx_isa_detach (device_t dev); </function> Retire o "
"dispositivo antes de descarregar o m�dulo do driver. "

#. (itstool) path: listitem/para
#: book.translate.xml:16582
#, fuzzy
msgid ""
"<function>static int xxx_isa_shutdown (device_t dev);</function> Execute "
"shutdown of the device before system shutdown."
msgstr ""
" <function> est�tico int xxx_isa_shutdown (device_t dev); </function> "
"Execute o desligamento do dispositivo antes do desligamento do sistema. "

#. (itstool) path: listitem/para
#: book.translate.xml:16588
#, fuzzy
msgid ""
"<function>static int xxx_isa_suspend (device_t dev);</function> Suspend the "
"device before the system goes to the power-save state. May also abort "
"transition to the power-save state."
msgstr ""
" <function> est�tico int xxx_isa_suspend (device_t dev); </function> "
"Suspenda o dispositivo antes que o sistema v� para o estado de economia de "
"energia. Pode tamb�m abortar a transi��o para o estado de economia de "
"energia. "

#. (itstool) path: listitem/para
#: book.translate.xml:16595
#, fuzzy
msgid ""
"<function>static int xxx_isa_resume (device_t dev);</function> Resume the "
"device activity after return from power-save state."
msgstr ""
" <function> est�tico int xxx_isa_resume (device_t dev); </function> Retomar "
"a atividade do dispositivo ap�s o retorno do estado de economia de energia. "

#. (itstool) path: sect1/para
#: book.translate.xml:16602
#, fuzzy
msgid ""
"<function>xxx_isa_probe()</function> and <function>xxx_isa_attach()</"
"function> are mandatory, the rest of the routines are optional, depending on "
"the device's needs."
msgstr ""
" <function> xxx_isa_probe () </function> e <function> xxx_isa_attach () </"
"function> s�o obrigat�rios, o resto das rotinas s�o opcionais, dependendo "
"das necessidades do dispositivo. "

#. (itstool) path: sect1/para
#: book.translate.xml:16607
#, fuzzy
msgid ""
"The driver is linked to the system with the following set of descriptions."
msgstr "O driver est� ligado ao sistema com o seguinte conjunto de descri��es."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16610
#, no-wrap
msgid ""
"    /* table of supported bus methods */\n"
"    static device_method_t xxx_isa_methods[] = {\n"
"        /* list all the bus method functions supported by the driver */\n"
"        /* omit the unsupported methods */\n"
"        DEVMETHOD(device_identify,  xxx_isa_identify),\n"
"        DEVMETHOD(device_probe,     xxx_isa_probe),\n"
"        DEVMETHOD(device_attach,    xxx_isa_attach),\n"
"        DEVMETHOD(device_detach,    xxx_isa_detach),\n"
"        DEVMETHOD(device_shutdown,  xxx_isa_shutdown),\n"
"        DEVMETHOD(device_suspend,   xxx_isa_suspend),\n"
"        DEVMETHOD(device_resume,    xxx_isa_resume),\n"
"\n"
"\tDEVMETHOD_END\n"
"    };\n"
"\n"
"    static driver_t xxx_isa_driver = {\n"
"        \"xxx\",\n"
"        xxx_isa_methods,\n"
"        sizeof(struct xxx_softc),\n"
"    };\n"
"\n"
"\n"
"    static devclass_t xxx_devclass;\n"
"\n"
"    DRIVER_MODULE(xxx, isa, xxx_isa_driver, xxx_devclass,\n"
"        load_function, load_argument);"
msgstr ""
"    /* table of supported bus methods */\n"
"    static device_method_t xxx_isa_methods[] = {\n"
"        /* list all the bus method functions supported by the driver */\n"
"        /* omit the unsupported methods */\n"
"        DEVMETHOD(device_identify,  xxx_isa_identify),\n"
"        DEVMETHOD(device_probe,     xxx_isa_probe),\n"
"        DEVMETHOD(device_attach,    xxx_isa_attach),\n"
"        DEVMETHOD(device_detach,    xxx_isa_detach),\n"
"        DEVMETHOD(device_shutdown,  xxx_isa_shutdown),\n"
"        DEVMETHOD(device_suspend,   xxx_isa_suspend),\n"
"        DEVMETHOD(device_resume,    xxx_isa_resume),\n"
"\n"
"\tDEVMETHOD_END\n"
"    };\n"
"\n"
"    static driver_t xxx_isa_driver = {\n"
"        \"xxx\",\n"
"        xxx_isa_methods,\n"
"        sizeof(struct xxx_softc),\n"
"    };\n"
"\n"
"\n"
"    static devclass_t xxx_devclass;\n"
"\n"
"    DRIVER_MODULE(xxx, isa, xxx_isa_driver, xxx_devclass,\n"
"        load_function, load_argument);"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16637
#, fuzzy
msgid "<primary>softc</primary>"
msgstr " <primary> softc </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16639
#, fuzzy
msgid ""
"Here struct <varname remap=\"structname\">xxx_softc</varname> is a device-"
"specific structure that contains private driver data and descriptors for the "
"driver's resources. The bus code automatically allocates one softc "
"descriptor per device as needed."
msgstr ""
"Aqui struct <varname remap=\"structname\"> xxx_softc </varname> � uma "
"estrutura espec�fica do dispositivo que cont�m dados do driver privado e "
"descritores para os recursos do driver. O c�digo de barramento aloca "
"automaticamente um descritor softc por dispositivo, conforme necess�rio. "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16645
#, fuzzy
msgid "<primary>kernel module</primary>"
msgstr " <primary> m�dulo do kernel </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16647
#, fuzzy
msgid ""
"If the driver is implemented as a loadable module then "
"<function>load_function()</function> is called to do driver-specific "
"initialization or clean-up when the driver is loaded or unloaded and "
"load_argument is passed as one of its arguments. If the driver does not "
"support dynamic loading (in other words it must always be linked into the "
"kernel) then these values should be set to 0 and the last definition would "
"look like:"
msgstr ""
"Se o driver for implementado como um m�dulo carreg�vel, <function> "
"load_function () </function> � chamado para fazer inicializa��o ou limpeza "
"espec�fica do driver quando o driver � carregado ou descarregado e "
"load_argument � passado como um dos seus argumentos. Se o driver n�o "
"suportar o carregamento din�mico (em outras palavras, ele deve estar sempre "
"vinculado ao kernel), ent�o esses valores devem ser definidos como 0 e a "
"�ltima defini��o deve ficar assim: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16656
#, no-wrap
msgid ""
" DRIVER_MODULE(xxx, isa, xxx_isa_driver,\n"
"       xxx_devclass, 0, 0);"
msgstr ""
" DRIVER_MODULE(xxx, isa, xxx_isa_driver,\n"
"       xxx_devclass, 0, 0);"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16659
#, fuzzy
msgid "<primary>PnP</primary>"
msgstr " <primary> PnP </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16661
#, fuzzy
msgid ""
"If the driver is for a device which supports PnP then a table of supported "
"PnP IDs must be defined. The table consists of a list of PnP IDs supported "
"by this driver and human-readable descriptions of the hardware types and "
"models having these IDs. It looks like:"
msgstr ""
"Se o driver for para um dispositivo que suporte PnP, uma tabela de IDs PnP "
"compat�veis deve ser definida. A tabela consiste em uma lista de IDs PnP "
"suportados por esse driver e descri��es leg�veis por humanos dos tipos e "
"modelos de hardware que possuem esses IDs. Parece: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16667
#, no-wrap
msgid ""
"    static struct isa_pnp_id xxx_pnp_ids[] = {\n"
"        /* a line for each supported PnP ID */\n"
"        { 0x12345678,   \"Our device model 1234A\" },\n"
"        { 0x12345679,   \"Our device model 1234B\" },\n"
"        { 0,        NULL }, /* end of table */\n"
"    };"
msgstr ""
"    static struct isa_pnp_id xxx_pnp_ids[] = {\n"
"        /* a line for each supported PnP ID */\n"
"        { 0x12345678,   \"Our device model 1234A\" },\n"
"        { 0x12345679,   \"Our device model 1234B\" },\n"
"        { 0,        NULL }, /* end of table */\n"
"    };"

#. (itstool) path: sect1/para
#: book.translate.xml:16674
#, fuzzy
msgid ""
"If the driver does not support PnP devices it still needs an empty PnP ID "
"table, like:"
msgstr ""
"Se o driver n�o suporta dispositivos PnP, ele ainda precisa de uma tabela "
"vazia de IDs PnP, como:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16677
#, no-wrap
msgid ""
"    static struct isa_pnp_id xxx_pnp_ids[] = {\n"
"        { 0,        NULL }, /* end of table */\n"
"    };"
msgstr ""
"    static struct isa_pnp_id xxx_pnp_ids[] = {\n"
"        { 0,        NULL }, /* end of table */\n"
"    };"

#. (itstool) path: sect1/title
#: book.translate.xml:16684
#, fuzzy
msgid "<varname remap=\"structname\">device_t</varname> Pointer"
msgstr " <varname remap=\"structname\"> device_t </varname> Ponteiro "

#. (itstool) path: sect1/para
#: book.translate.xml:16686
#, fuzzy
msgid ""
"<varname remap=\"structname\">device_t</varname> is the pointer type for the "
"device structure. Here we consider only the methods interesting from the "
"device driver writer's standpoint. The methods to manipulate values in the "
"device structure are:"
msgstr ""
" <varname remap=\"structname\"> device_t </varname> � o tipo de ponteiro "
"para a estrutura do dispositivo. Aqui consideramos apenas os m�todos "
"interessantes do ponto de vista do gravador do driver de dispositivo. Os "
"m�todos para manipular valores na estrutura do dispositivo s�o: "

#. (itstool) path: listitem/para
#: book.translate.xml:16694
#, fuzzy
msgid ""
"<function>device_t device_get_parent(dev)</function> Get the parent bus of a "
"device."
msgstr ""
" <function> device_t device_get_parent (dev) </function> Obtenha o "
"barramento pai de um dispositivo \""

#. (itstool) path: listitem/para
#: book.translate.xml:16698
#, fuzzy
msgid ""
"<function>driver_t device_get_driver(dev)</function> Get pointer to its "
"driver structure."
msgstr ""
" <function> driver_t device_get_driver (dev) </function> Obter ponteiro para "
"sua estrutura de driver \""

#. (itstool) path: listitem/para
#: book.translate.xml:16702
#, fuzzy
msgid ""
"<function>char *device_get_name(dev)</function> Get the driver name, such as "
"<literal>\"xxx\"</literal> for our example."
msgstr ""
" <function> char * device_get_name (dev) </function> Obtenha o nome do "
"driver, como <literal> \\ \"xxx \" </literal> para o nosso exemplo \""

#. (itstool) path: listitem/para
#: book.translate.xml:16706
#, fuzzy
msgid ""
"<function>int device_get_unit(dev)</function> Get the unit number (units are "
"numbered from 0 for the devices associated with each driver)."
msgstr ""
" <function> int device_get_unit (dev) </function> Obtenha o n�mero da "
"unidade (as unidades s�o numeradas de 0 para os dispositivos associados a "
"cada driver). "

#. (itstool) path: listitem/para
#: book.translate.xml:16710
#, fuzzy
msgid ""
"<function>char *device_get_nameunit(dev)</function> Get the device name "
"including the unit number, such as <quote>xxx0</quote>, <quote>xxx1</quote> "
"and so on."
msgstr ""
" <function> char * device_get_nameunit (dev) </function> Obtenha o nome do "
"dispositivo, incluindo o n�mero da unidade, como <quote> xxx0 </quote> , "
"<quote> xxx1 </quote> e assim por diante."

#. (itstool) path: listitem/para
#: book.translate.xml:16715
#, fuzzy
msgid ""
"<function>char *device_get_desc(dev)</function> Get the device description. "
"Normally it describes the exact model of device in human-readable form."
msgstr ""
" <function> char * device_get_desc (dev) </function> Obtenha a descri��o do "
"dispositivo. Normalmente, descreve o modelo exato do dispositivo em forma "
"leg�vel por humanos. "

#. (itstool) path: listitem/para
#: book.translate.xml:16720
#, fuzzy
msgid ""
"<function>device_set_desc(dev, desc)</function> Set the description. This "
"makes the device description point to the string desc which may not be "
"deallocated or changed after that."
msgstr ""
" <function> device_set_desc (dev, desc) </function> Defina a descri��o. Isso "
"faz com que a descri��o do dispositivo aponte para a string desc que n�o "
"pode ser desalocada ou alterada depois disso. "

#. (itstool) path: listitem/para
#: book.translate.xml:16725
#, fuzzy
msgid ""
"<function>device_set_desc_copy(dev, desc)</function> Set the description. "
"The description is copied into an internal dynamically allocated buffer, so "
"the string desc may be changed afterwards without adverse effects."
msgstr ""
" <function> device_set_desc_copy (dev, desc) </function> Defina a descri��o. "
"A descri��o � copiada em um buffer interno alocado dinamicamente, ent�o a "
"string desc pode ser alterada posteriormente sem efeitos adversos. "

#. (itstool) path: listitem/para
#: book.translate.xml:16731
#, fuzzy
msgid ""
"<function>void *device_get_softc(dev)</function> Get pointer to the device "
"descriptor (struct <varname remap=\"structname\">xxx_softc</varname>) "
"associated with this device."
msgstr ""
" <function> void * device_get_softc (dev) </function> Obt�m o ponteiro para "
"o descritor de dispositivo (struct <varname remap=\"structname\"> xxx_softc "
"</varname> ) associado a este dispositivo. "

#. (itstool) path: listitem/para
#: book.translate.xml:16736
#, fuzzy
msgid ""
"<function>u_int32_t device_get_flags(dev)</function> Get the flags specified "
"for the device in the configuration file."
msgstr ""
" <function> u_int32_t device_get_flags (dev) </function> Obtenha os "
"sinalizadores especificados para o dispositivo no arquivo de configura��o. "

#. (itstool) path: sect1/para
#: book.translate.xml:16742
#, fuzzy
msgid ""
"A convenience function <function>device_printf(dev, fmt, ...)</function> may "
"be used to print the messages from the device driver. It automatically "
"prepends the unitname and colon to the message."
msgstr ""
"Uma fun��o de conveni�ncia <function> device_printf (dev, fmt, ...) </"
"function> pode ser usado para imprimir as mensagens do driver de "
"dispositivo. Ele preenche automaticamente o nome da unidade e os dois pontos "
"da mensagem. "

#. (itstool) path: sect1/para
#: book.translate.xml:16747
#, fuzzy
msgid ""
"The device_t methods are implemented in the file <filename>kern/bus_subr.c</"
"filename>."
msgstr ""
"Os m�todos device_t s�o implementados no arquivo <filename> kern / bus_subr."
"c </filename> "

#. (itstool) path: sect1/title
#: book.translate.xml:16753
#, fuzzy
msgid ""
"Configuration File and the Order of Identifying and Probing During Auto-"
"Configuration"
msgstr ""
"Arquivo de configura��o e a ordem de identifica��o e pesquisa durante a "
"configura��o autom�tica"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16756
#, fuzzy
msgid "<primary>ISA</primary><secondary>probing</secondary>"
msgstr " <primary> � UM </primary><secondary> sondagem </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16758
#, fuzzy
msgid "The ISA devices are described in the kernel configuration file like:"
msgstr ""
"Os dispositivos ISA s�o descritos no arquivo de configura��o do kernel como:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16761
#, no-wrap
msgid ""
"device xxx0 at isa? port 0x300 irq 10 drq 5\n"
"       iomem 0xd0000 flags 0x1 sensitive"
msgstr ""
"device xxx0 at isa? port 0x300 irq 10 drq 5\n"
"       iomem 0xd0000 flags 0x1 sensitive"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16764
#, fuzzy
msgid "<primary>IRQ</primary>"
msgstr " <primary> IRQ </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16766
#, fuzzy
msgid ""
"The values of port, IRQ and so on are converted to the resource values "
"associated with the device. They are optional, depending on the device's "
"needs and abilities for auto-configuration. For example, some devices do not "
"need DRQ at all and some allow the driver to read the IRQ setting from the "
"device configuration ports. If a machine has multiple ISA buses the exact "
"bus may be specified in the configuration line, like <literal>isa0</literal> "
"or <literal>isa1</literal>, otherwise the device would be searched for on "
"all the ISA buses."
msgstr ""
"Os valores de porta, IRQ e assim por diante s�o convertidos para os valores "
"de recursos associados ao dispositivo. Eles s�o opcionais, dependendo das "
"necessidades e capacidades do dispositivo para a autoconfigura��o. Por "
"exemplo, alguns dispositivos n�o precisam de DRQ e alguns permite que o "
"driver leia a configura��o de IRQ a partir das portas de configura��o do "
"dispositivo.Se uma m�quina tiver v�rios barramentos ISA, o barramento exato "
"pode ser especificado na linha de configura��o, como <literal> isa0 </"
"literal> ou <literal> isa1 </literal> caso contr�rio, o dispositivo seria "
"procurado em todos os barramentos ISA. "

#. (itstool) path: sect1/para
#: book.translate.xml:16776
#, fuzzy
msgid ""
"<literal>sensitive</literal> is a resource requesting that this device must "
"be probed before all non-sensitive devices. It is supported but does not "
"seem to be used in any current driver."
msgstr ""
" <literal> sens�vel </literal> � um recurso que solicita que este "
"dispositivo seja analisado antes de todos os dispositivos n�o sens�veis. � "
"suportado, mas n�o parece ser usado em nenhum driver atual. "

#. (itstool) path: para/programlisting
#: book.translate.xml:16785
#, no-wrap
msgid "device xxx0 at isa?"
msgstr "device xxx0 at isa?"

#. (itstool) path: sect1/para
#: book.translate.xml:16780
#, fuzzy
msgid ""
"For legacy ISA devices in many cases the drivers are still able to detect "
"the configuration parameters. But each device to be configured in the system "
"must have a config line. If two devices of some type are installed in the "
"system but there is only one configuration line for the corresponding "
"driver, ie: <_:programlisting-1/> then only one device will be configured."
msgstr ""
"Para dispositivos ISA legados, em muitos casos, os drivers ainda s�o capazes "
"de detectar os par�metros de configura��o. Mas cada dispositivo a ser "
"configurado no sistema deve ter uma linha de configura��o. Se dois "
"dispositivos de algum tipo estiverem instalados no sistema, h� apenas um "
"linha de configura��o para o driver correspondente, ou seja: <_: "
"programlisting-1 /> ent�o apenas um dispositivo ser� configurado. "

#. (itstool) path: sect1/para
#: book.translate.xml:16788
#, fuzzy
msgid ""
"But for the devices supporting automatic identification by the means of Plug-"
"n-Play or some proprietary protocol one configuration line is enough to "
"configure all the devices in the system, like the one above or just simply:"
msgstr ""
"Mas para os dispositivos que suportam identifica��o autom�tica por meio do "
"Plug-n-Play ou algum protocolo propriet�rio, uma linha de configura��o � "
"suficiente para configurar todos os dispositivos no sistema, como o acima ou "
"simplesmente:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16793
#, no-wrap
msgid "device xxx at isa?"
msgstr "device xxx at isa?"

#. (itstool) path: sect1/para
#: book.translate.xml:16795
#, fuzzy
msgid ""
"If a driver supports both auto-identified and legacy devices and both kinds "
"are installed at once in one machine then it is enough to describe in the "
"config file the legacy devices only. The auto-identified devices will be "
"added automatically."
msgstr ""
"Se um driver suportar dispositivos legados e identificados automaticamente e "
"ambos os tipos forem instalados de uma s� vez em uma m�quina, ser� "
"suficiente descrever apenas no arquivo de configura��o os dispositivos "
"legados. Os dispositivos identificados automaticamente ser�o adicionados "
"automaticamente."

#. (itstool) path: sect1/para
#: book.translate.xml:16801
#, fuzzy
msgid "When an ISA bus is auto-configured the events happen as follows:"
msgstr ""
"Quando um barramento ISA � configurado automaticamente, os eventos acontecem "
"da seguinte maneira:"

#. (itstool) path: sect1/para
#: book.translate.xml:16804
#, fuzzy
msgid ""
"All the drivers' identify routines (including the PnP identify routine which "
"identifies all the PnP devices) are called in random order. As they identify "
"the devices they add them to the list on the ISA bus. Normally the drivers' "
"identify routines associate their drivers with the new devices. The PnP "
"identify routine does not know about the other drivers yet so it does not "
"associate any with the new devices it adds."
msgstr ""
"Todas as rotinas de identifica��o dos motoristas (incluindo a rotina de "
"identifica��o PnP que identifica todos os dispositivos PnP) s�o chamadas em "
"ordem aleat�ria. Ao identificar os dispositivos, elas s�o adicionadas � "
"lista no barramento ISA. Normalmente, as rotinas de identifica��o dos "
"motoristas associam drivers com os novos dispositivos. A rotina de "
"identifica��o do PnP ainda n�o conhece os outros drivers, por isso n�o "
"associa qualquer um aos novos dispositivos que ele adiciona. "

#. (itstool) path: sect1/para
#: book.translate.xml:16813
#, fuzzy
msgid ""
"The PnP devices are put to sleep using the PnP protocol to prevent them from "
"being probed as legacy devices."
msgstr ""
"Os dispositivos PnP s�o colocados em suspens�o usando o protocolo PnP para "
"impedir que sejam testados como dispositivos legados."

#. (itstool) path: sect1/para
#: book.translate.xml:16816
#, fuzzy
msgid ""
"The probe routines of non-PnP devices marked as <literal>sensitive</literal> "
"are called. If probe for a device went successfully, the attach routine is "
"called for it."
msgstr ""
"As rotinas de sondagem de dispositivos n�o PnP marcados como <literal> "
"sens�vel </literal> s�o chamados. Se o probe para um dispositivo foi bem-"
"sucedido, a rotina de anexa��o � chamada para ele. "

#. (itstool) path: sect1/para
#: book.translate.xml:16820
#, fuzzy
msgid ""
"The probe and attach routines of all non-PNP devices are called likewise."
msgstr ""
"As rotinas de teste e anexa��o de todos os dispositivos n�o-PNP s�o chamadas "
"da mesma forma."

#. (itstool) path: sect1/para
#: book.translate.xml:16823
#, fuzzy
msgid ""
"The PnP devices are brought back from the sleep state and assigned the "
"resources they request: I/O and memory address ranges, IRQs and DRQs, all of "
"them not conflicting with the attached legacy devices."
msgstr ""
"Os dispositivos PnP s�o trazidos de volta do estado de suspens�o e recebem "
"os recursos que eles solicitam: E / S e intervalos de endere�os de mem�ria, "
"IRQs e DRQs, todos eles n�o conflitam com os dispositivos legados anexados."

#. (itstool) path: sect1/para
#: book.translate.xml:16828
#, fuzzy
msgid ""
"Then for each PnP device the probe routines of all the present ISA drivers "
"are called. The first one that claims the device gets attached. It is "
"possible that multiple drivers would claim the device with different "
"priority; in this case, the highest-priority driver wins. The probe routines "
"must call <function>ISA_PNP_PROBE()</function> to compare the actual PnP ID "
"with the list of the IDs supported by the driver and if the ID is not in the "
"table return failure. That means that absolutely every driver, even the ones "
"not supporting any PnP devices must call <function>ISA_PNP_PROBE()</"
"function>, at least with an empty PnP ID table to return failure on unknown "
"PnP devices."
msgstr ""
"Ent�o, para cada dispositivo PnP, as rotinas de an�lise de todos os drivers "
"ISA atuais s�o chamadas. A primeira que reivindica o dispositivo � anexada. "
"� poss�vel que v�rios drivers reivindiquem o dispositivo com prioridade "
"diferente; nesse caso, a prioridade mais alta o driver ganha.As rotinas de "
"teste devem chamar <function> ISA_PNP_PROBE () </function> para comparar o "
"ID PnP real com a lista de IDs suportados pelo driver e se o ID n�o estiver "
"na falha de retorno da tabela. Isso significa que absolutamente todos os "
"drivers, mesmo aqueles que n�o suportam qualquer dispositivo PnP, devem "
"ligar <function> ISA_PNP_PROBE () </function> , pelo menos com uma tabela "
"vazia de IDs PnP para retornar falhas em dispositivos PnP desconhecidos. "

#. (itstool) path: sect1/para
#: book.translate.xml:16841
#, fuzzy
msgid ""
"The probe routine returns a positive value (the error code) on error, zero "
"or negative value on success."
msgstr ""
"A rotina da sonda retorna um valor positivo (o c�digo de erro) no erro, "
"valor zero ou negativo no sucesso."

#. (itstool) path: sect1/para
#: book.translate.xml:16844
#, fuzzy
msgid ""
"The negative return values are used when a PnP device supports multiple "
"interfaces. For example, an older compatibility interface and a newer "
"advanced interface which are supported by different drivers. Then both "
"drivers would detect the device. The driver which returns a higher value in "
"the probe routine takes precedence (in other words, the driver returning 0 "
"has highest precedence, returning -1 is next, returning -2 is after it and "
"so on). In result the devices which support only the old interface will be "
"handled by the old driver (which should return -1 from the probe routine) "
"while the devices supporting the new interface as well will be handled by "
"the new driver (which should return 0 from the probe routine). If multiple "
"drivers return the same value then the one called first wins. So if a driver "
"returns value 0 it may be sure that it won the priority arbitration."
msgstr ""
"Os valores de retorno negativos s�o usados ​​quando um dispositivo PnP suporta "
"v�rias interfaces. Por exemplo, uma interface de compatibilidade mais antiga "
"e uma interface avan�ada mais recente suportada por drivers diferentes. "
"Ent�o, ambos os drivers detectariam o dispositivo. O driver que retorna um "
"valor mais alto a rotina da sonda tem preced�ncia (em outras palavras, o "
"driver retornando 0 tem a preced�ncia mais alta, retornando -1 � a pr�xima, "
"retornando -2 � depois dela e assim por diante.) Em resultado, os "
"dispositivos que suportam apenas a interface antiga ser�o manipulados pelo "
"driver antigo (que deve retornar -1 da rotina da sonda), enquanto os "
"dispositivos que suportam a nova interface tamb�m ser�o manipulados pelo "
"novo driver (que deve retornar 0 da rotina da sonda) .Se v�rios drivers "
"retornarem o mesmo valor, ent�o o chamadas primeiras vit�rias. Ent�o, se um "
"driver retornar o valor 0, pode ter certeza de que ganhou a arbitragem "
"priorit�ria. "

#. (itstool) path: sect1/para
#: book.translate.xml:16860
#, fuzzy
msgid ""
"The device-specific identify routines can also assign not a driver but a "
"class of drivers to the device. Then all the drivers in the class are probed "
"for this device, like the case with PnP. This feature is not implemented in "
"any existing driver and is not considered further in this document."
msgstr ""
"As rotinas de identifica��o espec�ficas do dispositivo tamb�m podem designar "
"n�o um driver, mas uma classe de drivers para o dispositivo. Ent�o, todos os "
"drivers da classe s�o testados para esse dispositivo, como no caso do PnP. "
"Esse recurso n�o � implementado em nenhum driver existente. e n�o � "
"considerado mais adiante neste documento. "

#. (itstool) path: sect1/para
#: book.translate.xml:16866
#, fuzzy
msgid ""
"Because the PnP devices are disabled when probing the legacy devices they "
"will not be attached twice (once as legacy and once as PnP). But in case of "
"device-dependent identify routines it is the responsibility of the driver to "
"make sure that the same device will not be attached by the driver twice: "
"once as legacy user-configured and once as auto-identified."
msgstr ""
"Como os dispositivos PnP s�o desativados ao sondar os dispositivos herdados, "
"eles n�o ser�o conectados duas vezes (uma vez como legado e uma vez como "
"PnP). Mas, no caso de rotinas de identifica��o dependentes de dispositivo, � "
"responsabilidade do motorista certificar-se de que o dispositivo n�o ser� "
"conectado pelo driver duas vezes: uma vez como legado configurado pelo "
"usu�rio e uma vez como identificado automaticamente. "

#. (itstool) path: sect1/para
#: book.translate.xml:16874
#, fuzzy
msgid ""
"Another practical consequence for the auto-identified devices (both PnP and "
"device-specific) is that the flags can not be passed to them from the kernel "
"configuration file. So they must either not use the flags at all or use the "
"flags from the device unit 0 for all the auto-identified devices or use the "
"sysctl interface instead of flags."
msgstr ""
"Outra conseq��ncia pr�tica para os dispositivos identificados "
"automaticamente (tanto PnP quanto espec�ficos do dispositivo) � que os flags "
"n�o podem ser passados ​​para eles a partir do arquivo de configura��o do "
"kernel. Portanto, eles n�o devem usar as flags ou usar os sinalizadores do "
"unidade de dispositivo 0 para todos os dispositivos identificados "
"automaticamente ou use a interface sysctl em vez de sinalizadores. "

#. (itstool) path: sect1/para
#: book.translate.xml:16881
#, fuzzy
msgid ""
"Other unusual configurations may be accommodated by accessing the "
"configuration resources directly with functions of families "
"<function>resource_query_*()</function> and <function>resource_*_value()</"
"function>. Their implementations are located in <filename>kern/subr_bus.c</"
"filename>. The old IDE disk driver <filename>i386/isa/wd.c</filename> "
"contains examples of such use. But the standard means of configuration must "
"always be preferred. Leave parsing the configuration resources to the bus "
"configuration code."
msgstr ""
"Outras configura��es incomuns podem ser acomodadas acessando os recursos de "
"configura��o diretamente com as fun��es das fam�lias. <function> "
"resource_query _ * () </function> e <function> recurso _ * _ valor () </"
"function> . Suas implementa��es est�o localizadas em <filename> kern / "
"subr_bus.c </filename> . O antigo driver de disco IDE <filename> i386 / "
"isa / wd.c </filename> cont�m exemplos de tal uso. Mas os meios padr�o de "
"configura��o sempre devem ser preferidos. Deixe analisando os recursos de "
"configura��o para o c�digo de configura��o do barramento. "

#. (itstool) path: sect1/title
#: book.translate.xml:16894
#, fuzzy
msgid "Resources"
msgstr "Recursos"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16896
#, fuzzy
msgid "<primary>resources</primary>"
msgstr " <primary> Recursos </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16897
#, fuzzy
msgid "<primary>device driver</primary><secondary>resources</secondary>"
msgstr ""
" <primary> driver do dispositivo </primary><secondary> Recursos </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16899
#, fuzzy
msgid ""
"The information that a user enters into the kernel configuration file is "
"processed and passed to the kernel as configuration resources. This "
"information is parsed by the bus configuration code and transformed into a "
"value of structure device_t and the bus resources associated with it. The "
"drivers may access the configuration resources directly using functions "
"<function>resource_*</function> for more complex cases of configuration. "
"However, generally this is neither needed nor recommended, so this issue is "
"not discussed further here."
msgstr ""
"As informa��es que um usu�rio insere no arquivo de configura��o do kernel "
"s�o processadas e passadas para o kernel como recursos de configura��o. "
"Essas informa��es s�o analisadas pelo c�digo de configura��o do barramento e "
"transformadas em um valor de estrutura device_t e os recursos de barramento "
"associados a ele. pode acessar os recursos de configura��o diretamente "
"usando fun��es <function> recurso_* </function> para casos mais complexos de "
"configura��o. No entanto, geralmente isso n�o � necess�rio nem recomendado, "
"por isso esta quest�o n�o � discutida aqui. "

#. (itstool) path: sect1/para
#: book.translate.xml:16909
#, fuzzy
msgid ""
"The bus resources are associated with each device. They are identified by "
"type and number within the type. For the ISA bus the following types are "
"defined:"
msgstr ""
"Os recursos de barramento est�o associados a cada dispositivo. Eles s�o "
"identificados por tipo e n�mero dentro do tipo. Para o barramento ISA, os "
"seguintes tipos s�o definidos:"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16913
#, fuzzy
msgid "<primary>DMA channel</primary>"
msgstr " <primary> Canal de DMA </primary> "

#. (itstool) path: listitem/para
#: book.translate.xml:16917
#, fuzzy
msgid "<emphasis>SYS_RES_IRQ</emphasis> - interrupt number"
msgstr " <emphasis> SYS_RES_IRQ </emphasis> - n�mero de interrup��o "

#. (itstool) path: listitem/para
#: book.translate.xml:16922
#, fuzzy
msgid "<emphasis>SYS_RES_DRQ</emphasis> - ISA DMA channel number"
msgstr " <emphasis> SYS_RES_DRQ </emphasis> - n�mero do canal ISA DMA "

#. (itstool) path: listitem/para
#: book.translate.xml:16927
#, fuzzy
msgid ""
"<emphasis>SYS_RES_MEMORY</emphasis> - range of device memory mapped into the "
"system memory space"
msgstr ""
" <emphasis> SYS_RES_MEMORY </emphasis> - intervalo de mem�ria do dispositivo "
"mapeado no espa�o de mem�ria do sistema "

#. (itstool) path: listitem/para
#: book.translate.xml:16933
#, fuzzy
msgid "<emphasis>SYS_RES_IOPORT</emphasis> - range of device I/O registers"
msgstr ""
" <emphasis> SYS_RES_IOPORT </emphasis> - intervalo de registros de E / S do "
"dispositivo "

#. (itstool) path: sect1/para
#: book.translate.xml:16938
#, fuzzy
msgid ""
"The enumeration within types starts from 0, so if a device has two memory "
"regions it would have resources of type <literal>SYS_RES_MEMORY</literal> "
"numbered 0 and 1. The resource type has nothing to do with the C language "
"type, all the resource values have the C language type <literal>unsigned "
"long</literal> and must be cast as necessary. The resource numbers do not "
"have to be contiguous, although for ISA they normally would be. The "
"permitted resource numbers for ISA devices are:"
msgstr ""
"A enumera��o dentro de tipos come�a em 0, portanto, se um dispositivo tiver "
"duas regi�es de mem�ria, ele ter� recursos do tipo <literal> SYS_RES_MEMORY "
"</literal> numerados 0 e 1. O tipo de recurso n�o tem nada a ver com o tipo "
"de linguagem C, todos os valores de recursos t�m o tipo de linguagem C "
"<literal> sem assinatura longa </literal> e deve ser lan�ado conforme "
"necess�rio. Os n�meros de recursos n�o precisam ser cont�guos, embora, para "
"o ISA, eles normalmente sejam. Os n�meros de recursos permitidos para "
"dispositivos ISA s�o: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16947
#, no-wrap
msgid ""
"          IRQ: 0-1\n"
"          DRQ: 0-1\n"
"          MEMORY: 0-3\n"
"          IOPORT: 0-7"
msgstr ""
"          IRQ: 0-1\n"
"          DRQ: 0-1\n"
"          MEMORY: 0-3\n"
"          IOPORT: 0-7"

#. (itstool) path: sect1/para
#: book.translate.xml:16952
#, fuzzy
msgid ""
"All the resources are represented as ranges, with a start value and count. "
"For IRQ and DRQ resources the count would normally be equal to 1. The values "
"for memory refer to the physical addresses."
msgstr ""
"Todos os recursos s�o representados como intervalos, com um valor inicial e "
"uma contagem. Para recursos de IRQ e DRQ, a contagem normalmente seria igual "
"a 1. Os valores para mem�ria referem-se aos endere�os f�sicos."

#. (itstool) path: sect1/para
#: book.translate.xml:16957
#, fuzzy
msgid "Three types of activities can be performed on resources:"
msgstr "Tr�s tipos de atividades podem ser executadas em recursos:"

#. (itstool) path: listitem/para
#: book.translate.xml:16961
#, fuzzy
msgid "set/get"
msgstr "set / get"

#. (itstool) path: listitem/para
#: book.translate.xml:16962
#, fuzzy
msgid "allocate/release"
msgstr "alocar / liberar"

#. (itstool) path: listitem/para
#: book.translate.xml:16963
#, fuzzy
msgid "activate/deactivate"
msgstr "ativar / desativar"

#. (itstool) path: sect1/para
#: book.translate.xml:16966
#, fuzzy
msgid ""
"Setting sets the range used by the resource. Allocation reserves the "
"requested range that no other driver would be able to reserve it (and "
"checking that no other driver reserved this range already). Activation makes "
"the resource accessible to the driver by doing whatever is necessary for "
"that (for example, for memory it would be mapping into the kernel virtual "
"address space)."
msgstr ""
"A configura��o define o intervalo usado pelo recurso. A aloca��o reserva o "
"intervalo solicitado que nenhum outro driver poder� reserv�-lo (e verificar "
"se nenhum outro driver j� reservou esse intervalo). A ativa��o torna o "
"recurso acess�vel ao driver fazendo o que for necess�rio para isso (por "
"exemplo, para mem�ria, seria mapeado para o espa�o de endere�o virtual do "
"kernel). "

#. (itstool) path: sect1/para
#: book.translate.xml:16974
#, fuzzy
msgid "The functions to manipulate resources are:"
msgstr "As fun��es para manipular recursos s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:16978
#, fuzzy
msgid ""
"<function>int bus_set_resource(device_t dev, int type, int rid, u_long "
"start, u_long count)</function>"
msgstr ""
" <function> int bus_set_resource (device_t dev, int tipo, int rid, u_long "
"start, u_long count) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:16981
#, fuzzy
msgid ""
"Set a range for a resource. Returns 0 if successful, error code otherwise. "
"Normally, this function will return an error only if one of <literal>type</"
"literal>, <literal>rid</literal>, <literal>start</literal> or "
"<literal>count</literal> has a value that falls out of the permitted range."
msgstr ""
"Definir um intervalo para um recurso. Retorna 0 se for bem-sucedido, c�digo "
"de erro. Normalmente, essa fun��o retornar� um erro somente se um dos "
"<literal> tipo </literal> , <literal> livrar </literal> , <literal> come�ar "
"</literal> ou <literal> contagem </literal> tem um valor que cai fora do "
"intervalo permitido \""

#. (itstool) path: listitem/para
#: book.translate.xml:16990
#, fuzzy
msgid "dev - driver's device"
msgstr "dev - dispositivo do motorista"

#. (itstool) path: listitem/para
#: book.translate.xml:16993
#, fuzzy
msgid "type - type of resource, SYS_RES_*"
msgstr "tipo - tipo de recurso, SYS_RES_ *"

#. (itstool) path: listitem/para
#: book.translate.xml:16996
#, fuzzy
msgid "rid - resource number (ID) within type"
msgstr "rid - n�mero do recurso (ID) dentro do tipo"

#. (itstool) path: listitem/para
#: book.translate.xml:16999
#, fuzzy
msgid "start, count - resource range"
msgstr "start, count - intervalo de recursos"

#. (itstool) path: listitem/para
#: book.translate.xml:17005
#, fuzzy
msgid ""
"<function>int bus_get_resource(device_t dev, int type, int rid, u_long "
"*startp, u_long *countp)</function>"
msgstr ""
" <function> int bus_get_resource (device_t dev, tipo int, int livrar, u_long "
"* startp, u_long * countp) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17008
#, fuzzy
msgid ""
"Get the range of resource. Returns 0 if successful, error code if the "
"resource is not defined yet."
msgstr ""
"Obt�m o intervalo de recursos. Retorna 0 se for bem-sucedido, c�digo de erro "
"se o recurso ainda n�o estiver definido."

#. (itstool) path: listitem/para
#: book.translate.xml:17013
#, fuzzy
msgid ""
"<function>u_long bus_get_resource_start(device_t dev, int type, int rid) "
"u_long bus_get_resource_count (device_t dev, int type, int rid)</function>"
msgstr ""
" <function> u_long bus_get_resource_start (device_t dev, int tipo, int rid) "
"u_long bus_get_resource_count (device_t dev, tipo int, int livrado) </"
"function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17017
#, fuzzy
msgid ""
"Convenience functions to get only the start or count. Return 0 in case of "
"error, so if the resource start has 0 among the legitimate values it would "
"be impossible to tell if the value is 0 or an error occurred. Luckily, no "
"ISA resources for add-on drivers may have a start value equal to 0."
msgstr ""
"Fun��es de conveni�ncia para obter apenas o in�cio ou a contagem. Retorna 0 "
"em caso de erro, portanto, se o in�cio do recurso tiver 0 entre os valores "
"leg�timos, seria imposs�vel dizer se o valor � 0 ou ocorreu um erro. "
"Felizmente, n�o h� recursos do ISA para drivers add-on pode ter um valor "
"inicial igual a 0. "

#. (itstool) path: listitem/para
#: book.translate.xml:17026
#, fuzzy
msgid ""
"<function>void bus_delete_resource(device_t dev, int type, int rid)</"
"function>"
msgstr ""
" <function> void bus_delete_resource (device_t dev, tipo int, int rid) </"
"function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17028
#, fuzzy
msgid "Delete a resource, make it undefined."
msgstr "Excluir um recurso, torn�-lo indefinido."

#. (itstool) path: listitem/para
#: book.translate.xml:17032
#, fuzzy
msgid ""
"<function>struct resource * bus_alloc_resource(device_t dev, int type, int "
"*rid, u_long start, u_long end, u_long count, u_int flags)</function>"
msgstr ""
" <function> struct resource * bus_alloc_resource (device_t dev, int tipo, "
"int * rid, u_long in�cio, u_long end, u_long count, u_int flags) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17037
#, fuzzy
msgid ""
"Allocate a resource as a range of count values not allocated by anyone else, "
"somewhere between start and end. Alas, alignment is not supported. If the "
"resource was not set yet it is automatically created. The special values of "
"start 0 and end ~0 (all ones) means that the fixed values previously set by "
"<function>bus_set_resource()</function> must be used instead: start and "
"count as themselves and end=(start+count), in this case if the resource was "
"not defined before then an error is returned. Although rid is passed by "
"reference it is not set anywhere by the resource allocation code of the ISA "
"bus. (The other buses may use a different approach and modify it)."
msgstr ""
"Alocar um recurso como um intervalo de valores de contagem n�o alocado por "
"mais ningu�m, em algum lugar entre o in�cio e o final. Infelizmente, o "
"alinhamento n�o � suportado. Se o recurso ainda n�o foi definido, ele � "
"criado automaticamente. Os valores especiais de in�cio 0 e final ~ 0 (todos "
"os) significa que os valores fixos previamente definidos <function> "
"bus_set_resource () </function> deve ser usado em vez disso: start e count "
"como si mesmo e end = (start + count), neste caso, se o recurso n�o foi "
"definido antes, um erro ser� retornado. Embora o rid seja passado por "
"refer�ncia, ele n�o � definido em nenhum lugar pelo c�digo de aloca��o de "
"recursos do barramento ISA. (Os outros �nibus podem usar uma abordagem "
"diferente e modific�-lo). "

#. (itstool) path: sect1/para
#: book.translate.xml:17053
#, fuzzy
msgid "Flags are a bitmap, the flags interesting for the caller are:"
msgstr ""
"Bandeiras s�o um bitmap, as bandeiras interessantes para o chamador s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:17058
#, fuzzy
msgid ""
"<emphasis>RF_ACTIVE</emphasis> - causes the resource to be automatically "
"activated after allocation."
msgstr ""
" <emphasis> RF_ACTIVE </emphasis> - faz com que o recurso seja ativado "
"automaticamente ap�s a aloca��o. "

#. (itstool) path: listitem/para
#: book.translate.xml:17063
#, fuzzy
msgid ""
"<emphasis>RF_SHAREABLE</emphasis> - resource may be shared at the same time "
"by multiple drivers."
msgstr ""
" <emphasis> RF_SHAREABLE </emphasis> - recurso pode ser compartilhado ao "
"mesmo tempo por v�rios drivers. "

#. (itstool) path: listitem/para
#: book.translate.xml:17068
#, fuzzy
msgid ""
"<emphasis>RF_TIMESHARE</emphasis> - resource may be time-shared by multiple "
"drivers, i.e., allocated at the same time by many but activated only by one "
"at any given moment of time."
msgstr ""
" <emphasis> RF_TIMESHARE </emphasis> - o recurso pode ser compartilhado no "
"tempo por v�rios drivers, isto �, alocado ao mesmo tempo por muitos, mas "
"ativado apenas por um em qualquer momento. "

#. (itstool) path: listitem/para
#: book.translate.xml:17075
#, fuzzy
msgid ""
"Returns 0 on error. The allocated values may be obtained from the returned "
"handle using methods <function>rhand_*()</function>."
msgstr ""
"Retorna 0 no erro. Os valores alocados podem ser obtidos a partir do "
"identificador retornado usando m�todos <function> rhand _ * () </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17080
#, fuzzy
msgid ""
"<function>int bus_release_resource(device_t dev, int type, int rid, struct "
"resource *r)</function>"
msgstr ""
" <function> int bus_release_resource (device_t dev, tipo int, int rid, "
"recurso struct * r) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17085
#, fuzzy
msgid ""
"Release the resource, r is the handle returned by "
"<function>bus_alloc_resource()</function>. Returns 0 on success, error code "
"otherwise."
msgstr ""
"Libere o recurso, r � o identificador retornado por <function> "
"bus_alloc_resource () </function> . Retorna 0 em caso de sucesso, c�digo de "
"erro. "

#. (itstool) path: listitem/para
#: book.translate.xml:17091
#, fuzzy
msgid ""
"<function>int bus_activate_resource(device_t dev, int type, int rid, struct "
"resource *r)</function> <function>int bus_deactivate_resource(device_t dev, "
"int type, int rid, struct resource *r)</function>"
msgstr ""
" <function> int bus_activate_resource (device_t dev, tipo int, int rid, "
"recurso struct * r) </function><function> int bus_deactivate_resource "
"(device_t dev, int tipo, int rid, struct resource * r) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17098
#, fuzzy
msgid ""
"Activate or deactivate resource. Return 0 on success, error code otherwise. "
"If the resource is time-shared and currently activated by another driver "
"then <literal>EBUSY</literal> is returned."
msgstr ""
"Ativar ou desativar o recurso. Retornar 0 em caso de sucesso, c�digo de erro "
"de outra forma. Se o recurso for compartilhado por tempo e atualmente "
"ativado por outro driver, ent�o <literal> EBUSY </literal> � devolvido \""

#. (itstool) path: listitem/para
#: book.translate.xml:17105
#, fuzzy
msgid ""
"<function>int bus_setup_intr(device_t dev, struct resource *r, int flags, "
"driver_intr_t *handler, void *arg, void **cookiep)</function> <function>int "
"bus_teardown_intr(device_t dev, struct resource *r, void *cookie)</function>"
msgstr ""
" <function> int bus_setup_intr (device_t dev, struct recurso * r, int flags, "
"driver_intr_t * manipulador, void * arg, void ** cookiep) </"
"function><function> int bus_teardown_intr (device_t dev, struct recurso * r, "
"void * cookie) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17113
#, fuzzy
msgid ""
"Associate or de-associate the interrupt handler with a device. Return 0 on "
"success, error code otherwise."
msgstr ""
"Associe ou desassocie o manipulador de interrup��o com um dispositivo. "
"Retorne 0 ao sucesso, caso contr�rio, o c�digo de erro."

#. (itstool) path: listitem/para
#: book.translate.xml:17118
#, fuzzy
msgid "r - the activated resource handler describing the IRQ"
msgstr "r - o manipulador de recursos ativado que descreve o IRQ"

#. (itstool) path: listitem/para
#: book.translate.xml:17120
#, fuzzy
msgid "flags - the interrupt priority level, one of:"
msgstr "flags - o n�vel de prioridade de interrup��o, um dos seguintes:"

#. (itstool) path: listitem/para
#: book.translate.xml:17124
#, fuzzy
msgid ""
"<function>INTR_TYPE_TTY</function> - terminals and other likewise character-"
"type devices. To mask them use <function>spltty()</function>."
msgstr ""
" <function> INTR_TYPE_TTY </function> - terminais e outros dispositivos do "
"tipo caractere. Para mascar�-los, use <function> spltty () </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17129
#, fuzzy
msgid ""
"<function>(INTR_TYPE_TTY | INTR_TYPE_FAST)</function> - terminal type "
"devices with small input buffer, critical to the data loss on input (such as "
"the old-fashioned serial ports). To mask them use <function>spltty()</"
"function>."
msgstr ""
" <function> (INTR_TYPE_TTY | INTR_TYPE_FAST) </function> - dispositivos do "
"tipo terminal com pequeno buffer de entrada, cr�tico para a perda de dados "
"na entrada (como as portas seriais antigas). Para mascar�-los, use "
"<function> spltty () </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17136
#, fuzzy
msgid ""
"<function>INTR_TYPE_BIO</function> - block-type devices, except those on the "
"CAM controllers. To mask them use <function>splbio()</function>."
msgstr ""
" <function> INTR_TYPE_BIO </function> - dispositivos do tipo bloco, exceto "
"aqueles nos controladores CAM. Para mascar�-los, use <function> splbio () </"
"function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17141
#, fuzzy
msgid ""
"<function>INTR_TYPE_CAM</function> - CAM (Common Access Method) bus "
"controllers. To mask them use <function>splcam()</function>."
msgstr ""
" <function> INTR_TYPE_CAM </function> - Controladores de barramento CAM "
"(Common Access Method). Para mascar�-los, use <function> splcam () </"
"function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17146
#, fuzzy
msgid ""
"<function>INTR_TYPE_NET</function> - network interface controllers. To mask "
"them use <function>splimp()</function>."
msgstr ""
" <function> INTR_TYPE_NET </function> - controladores de interface de rede. "
"Para mascar�-los, use <function> splimp () </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17151
#, fuzzy
msgid ""
"<function>INTR_TYPE_MISC</function> - miscellaneous devices. There is no "
"other way to mask them than by <function>splhigh()</function> which masks "
"all interrupts."
msgstr ""
" <function> INTR_TYPE_MISC </function> - dispositivos diversos. N�o h� outra "
"maneira de mascar�-los do que <function> splhigh () </function> que mascara "
"todas as interrup��es. "

#. (itstool) path: sect1/para
#: book.translate.xml:17160
#, fuzzy
msgid ""
"When an interrupt handler executes all the other interrupts matching its "
"priority level will be masked. The only exception is the MISC level for "
"which no other interrupts are masked and which is not masked by any other "
"interrupt."
msgstr ""
"Quando um manipulador de interrup��es executa todas as outras interrup��es "
"correspondentes ao seu n�vel de prioridade ser� mascarado. A �nica exce��o � "
"o n�vel MISC para o qual nenhuma outra interrup��o � mascarada e que n�o � "
"mascarada por qualquer outra interrup��o."

#. (itstool) path: listitem/para
#: book.translate.xml:17168
#, fuzzy
msgid ""
"<emphasis>handler</emphasis> - pointer to the handler function, the type "
"driver_intr_t is defined as <function>void driver_intr_t(void *)</function>"
msgstr ""
" <emphasis> manipulador </emphasis> - ponteiro para a fun��o de manipulador, "
"o tipo driver_intr_t � definido como <function> void driver_intr_t (void *) "
"</function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17173
#, fuzzy
msgid ""
"<emphasis>arg</emphasis> - the argument passed to the handler to identify "
"this particular device. It is cast from void* to any real type by the "
"handler. The old convention for the ISA interrupt handlers was to use the "
"unit number as argument, the new (recommended) convention is using a pointer "
"to the device softc structure."
msgstr ""
" <emphasis> arg </emphasis> - o argumento passado para o manipulador para "
"identificar esse dispositivo em particular. Ele � convertido de void * para "
"qualquer tipo real pelo manipulador. A antiga conven��o para os "
"manipuladores de interrup��o do ISA era usar o n�mero da unidade como "
"argumento, a nova conven��o (recomendada) est� usando um ponteiro para a "
"estrutura do dispositivo. "

#. (itstool) path: listitem/para
#: book.translate.xml:17181
#, fuzzy
msgid ""
"<emphasis>cookie[p]</emphasis> - the value received from <function>setup()</"
"function> is used to identify the handler when passed to "
"<function>teardown()</function>"
msgstr ""
" <emphasis> cookie [p] </emphasis> - o valor recebido de <function> "
"configura��o() </function> � usado para identificar o manipulador quando "
"passado para <function> destruir() </function> "

#. (itstool) path: sect1/para
#: book.translate.xml:17188
#, fuzzy
msgid ""
"A number of methods are defined to operate on the resource handlers (struct "
"resource *). Those of interest to the device driver writers are:"
msgstr ""
"V�rios m�todos s�o definidos para operar nos manipuladores de recursos "
"(struct resource *). Aqueles de interesse para os gravadores de driver de "
"dispositivo s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:17194
#, fuzzy
msgid ""
"<function>u_long rman_get_start(r) u_long rman_get_end(r)</function> Get the "
"start and end of allocated resource range."
msgstr ""
" <function> u_long rman_get_start (r) u_long rman_get_end (r) </function> "
"Obtenha o in�cio e o fim do intervalo de recursos alocados. "

#. (itstool) path: listitem/para
#: book.translate.xml:17199
#, fuzzy
msgid ""
"<function>void *rman_get_virtual(r)</function> Get the virtual address of "
"activated memory resource."
msgstr ""
" <function> void * rman_get_virtual (r) </function> Obtenha o endere�o "
"virtual do recurso de mem�ria ativada. "

#. (itstool) path: sect1/title
#: book.translate.xml:17207
#, fuzzy
msgid "Bus Memory Mapping"
msgstr "Mapeamento de mem�ria de barramento"

#. (itstool) path: sect1/para
#: book.translate.xml:17209
#, fuzzy
msgid ""
"In many cases data is exchanged between the driver and the device through "
"the memory. Two variants are possible:"
msgstr ""
"Em muitos casos, os dados s�o trocados entre o driver e o dispositivo "
"atrav�s da mem�ria. Duas variantes s�o poss�veis:"

#. (itstool) path: sect1/para
#: book.translate.xml:17212
#, fuzzy
msgid "(a) memory is located on the device card"
msgstr "(a) a mem�ria est� localizada no cart�o do dispositivo"

#. (itstool) path: sect1/para
#: book.translate.xml:17213
#, fuzzy
msgid "(b) memory is the main memory of the computer"
msgstr "(b) mem�ria � a mem�ria principal do computador"

#. (itstool) path: sect1/para
#: book.translate.xml:17215
#, fuzzy
msgid ""
"In case (a) the driver always copies the data back and forth between the on-"
"card memory and the main memory as necessary. To map the on-card memory into "
"the kernel virtual address space the physical address and length of the on-"
"card memory must be defined as a <literal>SYS_RES_MEMORY</literal> resource. "
"That resource can then be allocated and activated, and its virtual address "
"obtained using <function>rman_get_virtual()</function>. The older drivers "
"used the function <function>pmap_mapdev()</function> for this purpose, which "
"should not be used directly any more. Now it is one of the internal steps of "
"resource activation."
msgstr ""
"No caso (a), o driver sempre copia os dados entre a mem�ria no cart�o e a "
"mem�ria principal, conforme necess�rio. Para mapear a mem�ria no cart�o para "
"o espa�o de endere�o virtual do kernel, o endere�o f�sico eo comprimento do "
"mem�ria do cart�o deve ser definida como <literal> SYS_RES_MEMORY </literal> "
"recurso. Esse recurso pode ent�o ser alocado e ativado, e seu endere�o "
"virtual obtido usando <function> rman_get_virtual () </function> . Os "
"drivers mais antigos usavam a fun��o <function> pmap_mapdev () </function> "
"para este fim, que n�o deve ser usado diretamente mais. Agora � uma das "
"etapas internas da ativa��o de recursos. "

#. (itstool) path: sect1/para
#: book.translate.xml:17227
#, fuzzy
msgid ""
"Most of the ISA cards will have their memory configured for physical "
"location somewhere in range 640KB-1MB. Some of the ISA cards require larger "
"memory ranges which should be placed somewhere under 16MB (because of the 24-"
"bit address limitation on the ISA bus). In that case if the machine has more "
"memory than the start address of the device memory (in other words, they "
"overlap) a memory hole must be configured at the address range used by "
"devices. Many BIOSes allow configuration of a memory hole of 1MB starting at "
"14MB or 15MB. FreeBSD can handle the memory holes properly if the BIOS "
"reports them properly (this feature may be broken on old BIOSes)."
msgstr ""
"A maioria das placas ISA ter� sua mem�ria configurada para localiza��o "
"f�sica em algum lugar no intervalo de 640 KB-1 MB. Algumas das placas ISA "
"exigem intervalos de mem�ria maiores que devem ser colocados em algum lugar "
"abaixo de 16 MB (devido � limita��o de endere�o de 24 bits no barramento ISA "
"Nesse caso, se a m�quina tiver mais mem�ria do que o endere�o inicial da "
"mem�ria do dispositivo (em outras palavras, eles se sobrep�em), um orif�cio "
"de mem�ria deve ser configurado na faixa de endere�os usada pelos "
"dispositivos.Muitos BIOS permitem a configura��o de um orif�cio de mem�ria. "
"1MB a partir de 14MB ou 15MB O FreeBSD pode lidar com os buracos de mem�ria "
"se o BIOS reportar corretamente (este recurso pode estar quebrado em BIOS "
"antigas). "

#. (itstool) path: sect1/para
#: book.translate.xml:17239
#, fuzzy
msgid ""
"In case (b) just the address of the data is sent to the device, and the "
"device uses DMA to actually access the data in the main memory. Two "
"limitations are present: First, ISA cards can only access memory below 16MB. "
"Second, the contiguous pages in virtual address space may not be contiguous "
"in physical address space, so the device may have to do scatter/gather "
"operations. The bus subsystem provides ready solutions for some of these "
"problems, the rest has to be done by the drivers themselves."
msgstr ""
"No caso (b) apenas o endere�o dos dados � enviado para o dispositivo, e o "
"dispositivo usa DMA para acessar os dados na mem�ria principal. Duas "
"limita��es est�o presentes: Primeiro, as placas ISA s� podem acessar mem�ria "
"abaixo de 16MB. , as p�ginas cont�guas no espa�o de endere�o virtual podem "
"n�o ser cont�guas no espa�o de endere�o f�sico, portanto, o dispositivo pode "
"ter que fazer opera��es de dispers�o / coleta.O subsistema de barramento "
"fornece solu��es prontas para alguns desses problemas, o restante deve ser "
"feito pelos drivers si mesmos."

#. (itstool) path: sect1/para
#: book.translate.xml:17249
#, fuzzy
msgid ""
"Two structures are used for DMA memory allocation, <varname>bus_dma_tag_t</"
"varname> and <varname>bus_dmamap_t</varname>. Tag describes the properties "
"required for the DMA memory. Map represents a memory block allocated "
"according to these properties. Multiple maps may be associated with the same "
"tag."
msgstr ""
"Duas estruturas s�o usadas para aloca��o de mem�ria DMA, <varname> "
"bus_dma_tag_t </varname> e <varname> bus_dmamap_t </varname> . Tag descreve "
"as propriedades necess�rias para a mem�ria DMA. Mapa representa um bloco de "
"mem�ria alocado de acordo com essas propriedades. V�rios mapas podem estar "
"associados � mesma tag. "

#. (itstool) path: sect1/para
#: book.translate.xml:17255
#, fuzzy
msgid ""
"Tags are organized into a tree-like hierarchy with inheritance of the "
"properties. A child tag inherits all the requirements of its parent tag, and "
"may make them more strict but never more loose."
msgstr ""
"As tags s�o organizadas em uma hierarquia em forma de �rvore com heran�a das "
"propriedades. Uma tag filha herda todos os requisitos de sua tag pai e pode "
"torn�-los mais r�gidos, mas nunca mais frouxos."

#. (itstool) path: sect1/para
#: book.translate.xml:17260
#, fuzzy
msgid ""
"Normally one top-level tag (with no parent) is created for each device unit. "
"If multiple memory areas with different requirements are needed for each "
"device then a tag for each of them may be created as a child of the parent "
"tag."
msgstr ""
"Normalmente, uma tag de n�vel superior (sem pai) � criada para cada unidade "
"de dispositivo. Se v�rias �reas de mem�ria com requisitos diferentes forem "
"necess�rias para cada dispositivo, uma tag para cada uma delas poder� ser "
"criada como filha da tag pai."

#. (itstool) path: sect1/para
#: book.translate.xml:17265
#, fuzzy
msgid "The tags can be used to create a map in two ways."
msgstr "As tags podem ser usadas para criar um mapa de duas maneiras."

#. (itstool) path: sect1/para
#: book.translate.xml:17267
#, fuzzy
msgid ""
"First, a chunk of contiguous memory conformant with the tag requirements may "
"be allocated (and later may be freed). This is normally used to allocate "
"relatively long-living areas of memory for communication with the device. "
"Loading of such memory into a map is trivial: it is always considered as one "
"chunk in the appropriate physical memory range."
msgstr ""
"Primeiro, um peda�o de mem�ria cont�gua em conformidade com os requisitos de "
"tag pode ser alocado (e mais tarde pode ser liberado). Isso � normalmente "
"usado para alocar �reas de mem�ria relativamente longas para comunica��o com "
"o dispositivo. Carregamento de tal mem�ria em um mapa. � trivial: � sempre "
"considerado como um peda�o na faixa de mem�ria f�sica apropriada \""

#. (itstool) path: sect1/para
#: book.translate.xml:17275
#, fuzzy
msgid ""
"Second, an arbitrary area of virtual memory may be loaded into a map. Each "
"page of this memory will be checked for conformance to the map requirement. "
"If it conforms then it is left at its original location. If it is not then a "
"fresh conformant <quote>bounce page</quote> is allocated and used as "
"intermediate storage. When writing the data from the non-conformant original "
"pages they will be copied to their bounce pages first and then transferred "
"from the bounce pages to the device. When reading the data would go from the "
"device to the bounce pages and then copied to their non-conformant original "
"pages. The process of copying between the original and bounce pages is "
"called synchronization. This is normally used on a per-transfer basis: "
"buffer for each transfer would be loaded, transfer done and buffer unloaded."
msgstr ""
"Segundo, uma �rea arbitr�ria da mem�ria virtual pode ser carregada em um "
"mapa. Cada p�gina dessa mem�ria ser� verificada quanto � conformidade com o "
"requisito do mapa. Se estiver em conformidade, ela ser� deixada no local "
"original. Se n�o for, ent�o, um novo conformant <quote> p�gina de rejei��o </"
"quote> � alocado e usado como armazenamento intermedi�rio. Ao gravar os "
"dados das p�ginas originais n�o conformes, eles ser�o copiados primeiro para "
"suas p�ginas devolvidas e depois transferidos das p�ginas devolvidas para o "
"dispositivo. Ao ler os dados, eles iriam do dispositivo para as p�ginas "
"devolvidas e depois copiados para as p�ginas originais n�o conformes. O "
"processo de c�pia entre as p�ginas original e de retorno � chamado de "
"sincroniza��o. Isso � normalmente usado em uma base por transfer�ncia: "
"buffer para cada transfer�ncia seria carregado, transfer�ncia feita e buffer "
"descarregado. "

#. (itstool) path: sect1/para
#: book.translate.xml:17290
#, fuzzy
msgid "The functions working on the DMA memory are:"
msgstr "As fun��es que trabalham na mem�ria DMA s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:17294
#, fuzzy
msgid ""
"<function>int bus_dma_tag_create(bus_dma_tag_t parent, bus_size_t alignment, "
"bus_size_t boundary, bus_addr_t lowaddr, bus_addr_t highaddr, "
"bus_dma_filter_t *filter, void *filterarg, bus_size_t maxsize, int "
"nsegments, bus_size_t maxsegsz, int flags, bus_dma_tag_t *dmat)</function>"
msgstr ""
" <function> int bus_dma_tag_create (bus_dma_tag_t pai, bus_size_t "
"alinhamento, bus_size_t limite, bus_addr_t lowaddr, bus_addr_t highaddr, "
"bus_dma_filter_t * filtro, void * filterarg, bus_size_t maxsize, int "
"nsegmentos, bus_size_t maxsegsz, int sinalizadores, bus_dma_tag_t * dmat) </"
"function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17300
#, fuzzy
msgid "Create a new tag. Returns 0 on success, the error code otherwise."
msgstr ""
"Crie uma nova tag. Retorna 0 em caso de sucesso, caso contr�rio, o c�digo de "
"erro."

#. (itstool) path: listitem/para
#: book.translate.xml:17305
#, fuzzy
msgid ""
"<emphasis>parent</emphasis> - parent tag, or NULL to create a top-level tag."
msgstr ""
" <emphasis> pai </emphasis> - tag pai ou NULL para criar uma tag de n�vel "
"superior. "

#. (itstool) path: listitem/para
#: book.translate.xml:17310
#, fuzzy
msgid ""
"<emphasis>alignment</emphasis> - required physical alignment of the memory "
"area to be allocated for this tag. Use value 1 for <quote>no specific "
"alignment</quote>. Applies only to the future <function>bus_dmamem_alloc()</"
"function> but not <function>bus_dmamap_create()</function> calls."
msgstr ""
" <emphasis> alinhamento </emphasis> - necess�rio alinhamento f�sico da �rea "
"de mem�ria a ser alocada para esta tag. Use o valor 1 para <quote> sem "
"alinhamento espec�fico </quote> . Aplica-se apenas ao futuro <function> "
"bus_dmamem_alloc () </function> mas n�o <function> bus_dmamap_create () </"
"function> chama \""

#. (itstool) path: listitem/para
#: book.translate.xml:17319
#, fuzzy
msgid ""
"<emphasis>boundary</emphasis> - physical address boundary that must not be "
"crossed when allocating the memory. Use value 0 for <quote>no boundary</"
"quote>. Applies only to the future <function>bus_dmamem_alloc()</function> "
"but not <function>bus_dmamap_create()</function> calls. Must be power of 2. "
"If the memory is planned to be used in non-cascaded DMA mode (i.e., the DMA "
"addresses will be supplied not by the device itself but by the ISA DMA "
"controller) then the boundary must be no larger than 64KB (64*1024) due to "
"the limitations of the DMA hardware."
msgstr ""
" <emphasis> fronteira </emphasis> - limite de endere�o f�sico que n�o deve "
"ser ultrapassado ao alocar a mem�ria. Use o valor 0 para <quote> sem limite "
"</quote> . Aplica-se apenas ao futuro <function> bus_dmamem_alloc () </"
"function> mas n�o <function> bus_dmamap_create () </function> chamadas. Deve "
"ser a pot�ncia de 2. Se a mem�ria for planejada para ser usada no modo DMA "
"n�o em cascata (ou seja, os endere�os DMA ser�o fornecidos n�o pelo pr�prio "
"dispositivo, mas pelo controlador ISA DMA), o limite n�o dever� ser maior "
"que 64 KB (64 * 1024) devido �s limita��es do hardware DMA. "

#. (itstool) path: listitem/para
#: book.translate.xml:17333
#, fuzzy
msgid ""
"<emphasis>lowaddr, highaddr</emphasis> - the names are slightly misleading; "
"these values are used to limit the permitted range of physical addresses "
"used to allocate the memory. The exact meaning varies depending on the "
"planned future use:"
msgstr ""
" <emphasis> lowaddr, highaddr </emphasis> - os nomes s�o ligeiramente "
"enganadores; esses valores s�o usados ​​para limitar o intervalo permitido de "
"endere�os f�sicos usados ​​para alocar a mem�ria. O significado exato varia "
"dependendo do uso futuro planejado: "

#. (itstool) path: listitem/para
#: book.translate.xml:17341
#, fuzzy
msgid ""
"For <function>bus_dmamem_alloc()</function> all the addresses from 0 to "
"lowaddr-1 are considered permitted, the higher ones are forbidden."
msgstr ""
"Para <function> bus_dmamem_alloc () </function> todos os endere�os de 0 a "
"lowaddr-1 s�o considerados permitidos, os mais altos s�o proibidos. "

#. (itstool) path: listitem/para
#: book.translate.xml:17347
#, fuzzy
msgid ""
"For <function>bus_dmamap_create()</function> all the addresses outside the "
"inclusive range [lowaddr; highaddr] are considered accessible. The addresses "
"of pages inside the range are passed to the filter function which decides if "
"they are accessible. If no filter function is supplied then all the range is "
"considered unaccessible."
msgstr ""
"Para <function> bus_dmamap_create () </function> todos os endere�os fora do "
"intervalo inclusivo [lowaddr; highaddr] s�o considerados acess�veis. Os "
"endere�os das p�ginas dentro do intervalo s�o passados ​​para a fun��o de "
"filtro que decide se eles est�o acess�veis. Se nenhuma fun��o de filtro for "
"fornecida, todo o intervalo ser� considerado inacess�vel. "

#. (itstool) path: listitem/para
#: book.translate.xml:17357
#, fuzzy
msgid "For the ISA devices the normal values (with no filter function) are:"
msgstr ""
"Para os dispositivos ISA, os valores normais (sem fun��o de filtro) s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:17359
#, fuzzy
msgid "lowaddr = BUS_SPACE_MAXADDR_24BIT"
msgstr "lowaddr = BUS_SPACE_MAXADDR_24BIT"

#. (itstool) path: listitem/para
#: book.translate.xml:17360
#, fuzzy
msgid "highaddr = BUS_SPACE_MAXADDR"
msgstr "highaddr = BUS_SPACE_MAXADDR"

#. (itstool) path: listitem/para
#: book.translate.xml:17367
#, fuzzy
msgid ""
"<emphasis>filter, filterarg</emphasis> - the filter function and its "
"argument. If NULL is passed for filter then the whole range [lowaddr, "
"highaddr] is considered unaccessible when doing "
"<function>bus_dmamap_create()</function>. Otherwise the physical address of "
"each attempted page in range [lowaddr; highaddr] is passed to the filter "
"function which decides if it is accessible. The prototype of the filter "
"function is: <function>int filterfunc(void *arg, bus_addr_t paddr)</"
"function>. It must return 0 if the page is accessible, non-zero otherwise."
msgstr ""
" <emphasis> filtrar, filtrar </emphasis> - a fun��o de filtro e seu "
"argumento. Se NULL for passado para filtro, todo o intervalo [lowaddr, "
"highaddr] ser� considerado inacess�vel ao fazer <function> bus_dmamap_create "
"() </function> . Caso contr�rio, o endere�o f�sico de cada p�gina tentada no "
"intervalo [lowaddr; highaddr] � passado para a fun��o de filtro que decide "
"se � acess�vel. O prot�tipo da fun��o de filtro �: <function> int filterfunc "
"(void * arg, bus_addr_t paddr) </function> . Ele deve retornar 0 se a p�gina "
"estiver acess�vel, diferente de zero. "

#. (itstool) path: listitem/para
#: book.translate.xml:17381
#, fuzzy
msgid ""
"<emphasis>maxsize</emphasis> - the maximal size of memory (in bytes) that "
"may be allocated through this tag. In case it is difficult to estimate or "
"could be arbitrarily big, the value for ISA devices would be "
"<literal>BUS_SPACE_MAXSIZE_24BIT</literal>."
msgstr ""
" <emphasis> tamanho m�ximo </emphasis> - o tamanho m�ximo de mem�ria (em "
"bytes) que pode ser alocado atrav�s desta tag. No caso de ser dif�cil "
"estimar ou ser arbitrariamente grande, o valor dos dispositivos ISA seria "
"<literal> BUS_SPACE_MAXSIZE_24BIT </literal> "

#. (itstool) path: listitem/para
#: book.translate.xml:17389
#, fuzzy
msgid ""
"<emphasis>nsegments</emphasis> - maximal number of scatter-gather segments "
"supported by the device. If unrestricted then the value "
"<literal>BUS_SPACE_UNRESTRICTED</literal> should be used. This value is "
"recommended for the parent tags, the actual restrictions would then be "
"specified for the descendant tags. Tags with nsegments equal to "
"<literal>BUS_SPACE_UNRESTRICTED</literal> may not be used to actually load "
"maps, they may be used only as parent tags. The practical limit for "
"nsegments seems to be about 250-300, higher values will cause kernel stack "
"overflow (the hardware can not normally support that many scatter-gather "
"buffers anyway)."
msgstr ""
" <emphasis> nsegmentos </emphasis> - N�mero m�ximo de segmentos de coleta "
"dispersa suportados pelo dispositivo. Se irrestrito, ent�o o valor <literal> "
"BUS_SPACE_UNRESTRICTED </literal> deve ser usado. Esse valor � recomendado "
"para as tags pai, as restri��es reais seriam, ent�o, especificadas para as "
"tags descendentes. Tags com nsegmentos iguais a <literal> "
"BUS_SPACE_UNRESTRICTED </literal> n�o podem ser usados ​​para carregar mapas, "
"eles podem ser usados ​​apenas como tags pai. O limite pr�tico para nsegments "
"parece ser de cerca de 250-300, valores mais altos causar�o estouro de pilha "
"do kernel (o hardware normalmente n�o suporta muitos buffers de dispers�o de "
"coleta). "

#. (itstool) path: listitem/para
#: book.translate.xml:17404
#, fuzzy
msgid ""
"<emphasis>maxsegsz</emphasis> - maximal size of a scatter-gather segment "
"supported by the device. The maximal value for ISA device would be "
"<literal>BUS_SPACE_MAXSIZE_24BIT</literal>."
msgstr ""
" <emphasis> maxsegsz </emphasis> - tamanho m�ximo de um segmento de coleta "
"dispersa suportado pelo dispositivo. O valor m�ximo para o dispositivo ISA "
"seria <literal> BUS_SPACE_MAXSIZE_24BIT </literal> "

#. (itstool) path: listitem/para
#: book.translate.xml:17411
#, fuzzy
msgid ""
"<emphasis>flags</emphasis> - a bitmap of flags. The only interesting flags "
"are:"
msgstr ""
" <emphasis> bandeiras </emphasis> - um bitmap de bandeiras. As �nicas "
"bandeiras interessantes s�o: "

#. (itstool) path: listitem/para
#: book.translate.xml:17416
#, fuzzy
msgid ""
"<emphasis>BUS_DMA_ALLOCNOW</emphasis> - requests to allocate all the "
"potentially needed bounce pages when creating the tag."
msgstr ""
" <emphasis> BUS_DMA_ALLOCNOW </emphasis> - solicita��es para alocar todas as "
"p�ginas de rejei��o potencialmente necess�rias ao criar a tag. "

#. (itstool) path: listitem/para
#: book.translate.xml:17422
#, fuzzy
msgid ""
"<emphasis>BUS_DMA_ISA</emphasis> - mysterious flag used only on Alpha "
"machines. It is not defined for the i386 machines. Probably it should be "
"used by all the ISA drivers for Alpha machines but it looks like there are "
"no such drivers yet."
msgstr ""
" <emphasis> BUS_DMA_ISA </emphasis> - bandeira misteriosa usada somente em "
"m�quinas Alpha. N�o est� definido para as m�quinas i386. Provavelmente deve "
"ser usado por todos os drivers ISA para m�quinas Alpha, mas parece que ainda "
"n�o existem drivers. "

#. (itstool) path: listitem/para
#: book.translate.xml:17432
#, fuzzy
msgid ""
"<emphasis>dmat</emphasis> - pointer to the storage for the new tag to be "
"returned."
msgstr ""
" <emphasis> dmat </emphasis> - ponteiro para o armazenamento para a nova tag "
"a ser devolvida. "

#. (itstool) path: listitem/para
#: book.translate.xml:17441
#, fuzzy
msgid "<function>int bus_dma_tag_destroy(bus_dma_tag_t dmat)</function>"
msgstr " <function> int bus_dma_tag_destroy (bus_dma_tag_t dmat) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17444
#, fuzzy
msgid "Destroy a tag. Returns 0 on success, the error code otherwise."
msgstr ""
"Destrua uma tag. Retorna 0 em caso de sucesso, caso contr�rio, o c�digo de "
"erro."

#. (itstool) path: listitem/para
#: book.translate.xml:17447
#, fuzzy
msgid "dmat - the tag to be destroyed."
msgstr "dmat - a tag a ser destru�da."

#. (itstool) path: listitem/para
#: book.translate.xml:17452
#, fuzzy
msgid ""
"<function>int bus_dmamem_alloc(bus_dma_tag_t dmat, void** vaddr, int flags, "
"bus_dmamap_t *mapp)</function>"
msgstr ""
" <function> int bus_dmamem_alloc (bus_dma_tag_t_dmat, void ** vaddr, int "
"flags, bus_dmamap_t * mapp) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17456
#, fuzzy
msgid ""
"Allocate an area of contiguous memory described by the tag. The size of "
"memory to be allocated is tag's maxsize. Returns 0 on success, the error "
"code otherwise. The result still has to be loaded by "
"<function>bus_dmamap_load()</function> before being used to get the physical "
"address of the memory."
msgstr ""
"Aloca uma �rea de mem�ria cont�gua descrita pela tag. O tamanho da mem�ria a "
"ser alocada � maxsize da tag. Retorna 0 em caso de sucesso, caso contr�rio o "
"c�digo de erro. O resultado ainda tem que ser carregado por <function> "
"bus_dmamap_load () </function> antes de ser usado para obter o endere�o "
"f�sico da mem�ria \""

#. (itstool) path: listitem/para
#: book.translate.xml:17465 book.translate.xml:17521 book.translate.xml:17552
#: book.translate.xml:17624
#, fuzzy
msgid "<emphasis>dmat</emphasis> - the tag"
msgstr " <emphasis> dmat </emphasis> - a etiqueta"

#. (itstool) path: listitem/para
#: book.translate.xml:17470
#, fuzzy
msgid ""
"<emphasis>vaddr</emphasis> - pointer to the storage for the kernel virtual "
"address of the allocated area to be returned."
msgstr ""
" <emphasis> vaddr </emphasis> - ponteiro para o armazenamento do endere�o "
"virtual do kernel da �rea alocada a ser retornada. "

#. (itstool) path: listitem/para
#: book.translate.xml:17477
#, fuzzy
msgid "flags - a bitmap of flags. The only interesting flag is:"
msgstr "flags - um bitmap de bandeiras. A �nica bandeira interessante �:"

#. (itstool) path: listitem/para
#: book.translate.xml:17482
#, fuzzy
msgid ""
"<emphasis>BUS_DMA_NOWAIT</emphasis> - if the memory is not immediately "
"available return the error. If this flag is not set then the routine is "
"allowed to sleep until the memory becomes available."
msgstr ""
" <emphasis> BUS_DMA_NOWAIT </emphasis> - se a mem�ria n�o estiver "
"imediatamente dispon�vel, devolva o erro. Se esse sinalizador n�o estiver "
"definido, a rotina poder� ser suspensa at� que a mem�ria fique dispon�vel. "

#. (itstool) path: listitem/para
#: book.translate.xml:17493
#, fuzzy
msgid ""
"<emphasis>mapp</emphasis> - pointer to the storage for the new map to be "
"returned."
msgstr ""
" <emphasis> mapp </emphasis> - ponteiro para o armazenamento para o novo "
"mapa a ser devolvido. "

#. (itstool) path: listitem/para
#: book.translate.xml:17502
#, fuzzy
msgid ""
"<function>void bus_dmamem_free(bus_dma_tag_t dmat, void *vaddr, bus_dmamap_t "
"map)</function>"
msgstr ""
" <function> void bus_dmamem_free (bus_dma_tag_t dmat, void * vaddr, mapa de "
"bus_dmamap_t) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17506
#, fuzzy
msgid ""
"Free the memory allocated by <function>bus_dmamem_alloc()</function>. At "
"present, freeing of the memory allocated with ISA restrictions is not "
"implemented. Because of this the recommended model of use is to keep and re-"
"use the allocated areas for as long as possible. Do not lightly free some "
"area and then shortly allocate it again. That does not mean that "
"<function>bus_dmamem_free()</function> should not be used at all: hopefully "
"it will be properly implemented soon."
msgstr ""
"Libere a mem�ria alocada por <function> bus_dmamem_alloc () </function> . "
"Atualmente, a libera��o da mem�ria alocada com restri��es ISA n�o est� "
"implementada. Por isso, o modelo de uso recomendado � manter e reutilizar as "
"�reas alocadas pelo maior tempo poss�vel. N�o liberte levemente alguma �rea "
"e, em seguida, aloque-a de novo. Isso n�o significa que <function> "
"bus_dmamem_free () </function> n�o deve ser usado: esperamos que seja "
"implementado em breve. "

#. (itstool) path: listitem/para
#: book.translate.xml:17525
#, fuzzy
msgid "<emphasis>vaddr</emphasis> - the kernel virtual address of the memory"
msgstr ""
" <emphasis> vaddr </emphasis> - o endere�o virtual do kernel da mem�ria "

#. (itstool) path: listitem/para
#: book.translate.xml:17531
#, fuzzy
msgid ""
"<emphasis>map</emphasis> - the map of the memory (as returned from "
"<function>bus_dmamem_alloc()</function>)"
msgstr ""
" <emphasis> mapa </emphasis> - o mapa da mem�ria (conforme retornado de "
"<function> bus_dmamem_alloc () </function> ) "

#. (itstool) path: listitem/para
#: book.translate.xml:17541
#, fuzzy
msgid ""
"<function>int bus_dmamap_create(bus_dma_tag_t dmat, int flags, bus_dmamap_t "
"*mapp)</function>"
msgstr ""
" <function> int bus_dmamap_create (bus_dma_tag_t dmat, sinalizadores int, "
"bus_dmamap_t * mapp) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17545
#, fuzzy
msgid ""
"Create a map for the tag, to be used in <function>bus_dmamap_load()</"
"function> later. Returns 0 on success, the error code otherwise."
msgstr ""
"Crie um mapa para a tag, para ser usado em <function> bus_dmamap_load () </"
"function> mais tarde. Retorna 0 em caso de sucesso, caso contr�rio, o c�digo "
"de erro. "

#. (itstool) path: listitem/para
#: book.translate.xml:17557
#, fuzzy
msgid ""
"<emphasis>flags</emphasis> - theoretically, a bit map of flags. But no flags "
"are defined yet, so at present it will be always 0."
msgstr ""
" <emphasis> bandeiras </emphasis> - teoricamente, um pouco mapa de "
"bandeiras. Mas nenhum sinalizador ainda est� definido, ent�o no momento ser� "
"sempre 0. "

#. (itstool) path: listitem/para
#: book.translate.xml:17564
#, fuzzy
msgid ""
"<emphasis>mapp</emphasis> - pointer to the storage for the new map to be "
"returned"
msgstr ""
" <emphasis> mapp </emphasis> - ponteiro para o armazenamento para o novo "
"mapa a ser devolvido "

#. (itstool) path: listitem/para
#: book.translate.xml:17573
#, fuzzy
msgid ""
"<function>int bus_dmamap_destroy(bus_dma_tag_t dmat, bus_dmamap_t map)</"
"function>"
msgstr ""
" <function> int bus_dmamap_destroy (bus_dma_tag_t dmat, bus_dmamap_t map) </"
"function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17577
#, fuzzy
msgid "Destroy a map. Returns 0 on success, the error code otherwise."
msgstr ""
"Destrua um mapa. Retorna 0 em sucesso, o c�digo de erro de outra forma."

#. (itstool) path: listitem/para
#: book.translate.xml:17583
#, fuzzy
msgid "dmat - the tag to which the map is associated"
msgstr "dmat - a tag � qual o mapa est� associado"

#. (itstool) path: listitem/para
#: book.translate.xml:17588
#, fuzzy
msgid "map - the map to be destroyed"
msgstr "mapa - o mapa a ser destru�do"

#. (itstool) path: listitem/para
#: book.translate.xml:17596
#, fuzzy
msgid ""
"<function>int bus_dmamap_load(bus_dma_tag_t dmat, bus_dmamap_t map, void "
"*buf, bus_size_t buflen, bus_dmamap_callback_t *callback, void "
"*callback_arg, int flags)</function>"
msgstr ""
" <function> int bus_dmamap_load (bus_dma_tag_t dmat, bus_dmamap_t mapa, void "
"* buf, bus_size_t buflen, bus_dmamap_callback_t * retorno de chamada, void * "
"callback_arg, int flags) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17602
#, fuzzy
msgid ""
"Load a buffer into the map (the map must be previously created by "
"<function>bus_dmamap_create()</function> or <function>bus_dmamem_alloc()</"
"function>). All the pages of the buffer are checked for conformance to the "
"tag requirements and for those not conformant the bounce pages are "
"allocated. An array of physical segment descriptors is built and passed to "
"the callback routine. This callback routine is then expected to handle it in "
"some way. The number of bounce buffers in the system is limited, so if the "
"bounce buffers are needed but not immediately available the request will be "
"queued and the callback will be called when the bounce buffers will become "
"available. Returns 0 if the callback was executed immediately or "
"<errorname>EINPROGRESS</errorname> if the request was queued for future "
"execution. In the latter case the synchronization with queued callback "
"routine is the responsibility of the driver."
msgstr ""
"Carregue um buffer no mapa (o mapa deve ser criado anteriormente por "
"<function> bus_dmamap_create () </function> ou <function> bus_dmamem_alloc "
"() </function> ). Todas as p�ginas do buffer s�o verificadas quanto � "
"conformidade com os requisitos da tag e, para aqueles que n�o est�o em "
"conformidade, as p�ginas devolvidas s�o alocadas. Uma matriz de descritores "
"de segmento f�sico � criada e passada para a rotina de retorno de chamada. "
"Espera-se, ent�o, que essa rotina de retorno de chamada lide com isso de "
"alguma forma. O n�mero de buffers de rejei��o no sistema � limitado, "
"portanto, se os buffers de rejei��o forem necess�rios, mas n�o estiverem "
"dispon�veis imediatamente, a solicita��o ser� enfileirada e o retorno de "
"chamada ser� chamado quando os buffers de rejei��o ficar�o dispon�veis. "
"Retorna 0 se o retorno de chamada foi executado imediatamente ou <errorname> "
"EINPROGRESS </errorname> se a solicita��o foi enfileirada para execu��o "
"futura. Neste �ltimo caso, a sincroniza��o com a rotina de retorno de "
"chamada em fila � de responsabilidade do driver. "

#. (itstool) path: listitem/para
#: book.translate.xml:17629
#, fuzzy
msgid "<emphasis>map</emphasis> - the map"
msgstr " <emphasis> mapa </emphasis> - o mapa"

#. (itstool) path: listitem/para
#: book.translate.xml:17634
#, fuzzy
msgid "<emphasis>buf</emphasis> - kernel virtual address of the buffer"
msgstr " <emphasis> buf </emphasis> - endere�o virtual do kernel do buffer "

#. (itstool) path: listitem/para
#: book.translate.xml:17640
#, fuzzy
msgid "<emphasis>buflen</emphasis> - length of the buffer"
msgstr " <emphasis> buflen </emphasis> - comprimento do buffer "

#. (itstool) path: listitem/para
#: book.translate.xml:17645
#, fuzzy
msgid ""
"<emphasis>callback</emphasis>,<function> callback_arg</function> - the "
"callback function and its argument"
msgstr ""
" <emphasis> ligue de volta </emphasis> , <function> callback_arg </function> "
"- a fun��o de retorno de chamada e seu argumento "

#. (itstool) path: listitem/para
#: book.translate.xml:17653
#, fuzzy
msgid "The prototype of callback function is:"
msgstr "O prot�tipo da fun��o de retorno de chamada �:"

#. (itstool) path: listitem/para
#: book.translate.xml:17656
#, fuzzy
msgid ""
"<function>void callback(void *arg, bus_dma_segment_t *seg, int nseg, int "
"error)</function>"
msgstr ""
" <function> void callback (erro void * arg, bus_dma_segment_t * seg, int "
"nseg, int) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17663
#, fuzzy
msgid ""
"<emphasis>arg</emphasis> - the same as callback_arg passed to "
"<function>bus_dmamap_load()</function>"
msgstr ""
" <emphasis> arg </emphasis> - o mesmo que callback_arg passado para "
"<function> bus_dmamap_load () </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17669
#, fuzzy
msgid "<emphasis>seg</emphasis> - array of the segment descriptors"
msgstr " <emphasis> seg </emphasis> - matriz dos descritores de segmento "

#. (itstool) path: listitem/para
#: book.translate.xml:17675
#, fuzzy
msgid "<emphasis>nseg</emphasis> - number of descriptors in array"
msgstr " <emphasis> nseg </emphasis> - n�mero de descritores na matriz "

#. (itstool) path: listitem/para
#: book.translate.xml:17681
#, fuzzy
msgid ""
"<emphasis>error</emphasis> - indication of the segment number overflow: if "
"it is set to <errorname>EFBIG</errorname> then the buffer did not fit into "
"the maximal number of segments permitted by the tag. In this case only the "
"permitted number of descriptors will be in the array. Handling of this "
"situation is up to the driver: depending on the desired semantics it can "
"either consider this an error or split the buffer in two and handle the "
"second part separately"
msgstr ""
" <emphasis> erro </emphasis> - indica��o do excesso de n�mero de segmento: "
"se estiver configurado para <errorname> EFBIG </errorname> ent�o o buffer "
"n�o se encaixava no n�mero m�ximo de segmentos permitido pela tag. Nesse "
"caso, apenas o n�mero permitido de descritores estar� na matriz. O manuseio "
"desta situa��o depende do driver: dependendo da sem�ntica desejada, ele pode "
"considerar isso como um erro ou dividir o buffer em dois e manipular a "
"segunda parte separadamente "

#. (itstool) path: listitem/para
#: book.translate.xml:17695
#, fuzzy
msgid "Each entry in the segments array contains the fields:"
msgstr "Cada entrada na matriz de segmentos cont�m os campos:"

#. (itstool) path: listitem/para
#: book.translate.xml:17702
#, fuzzy
msgid "<emphasis>ds_addr</emphasis> - physical bus address of the segment"
msgstr ""
" <emphasis> ds_addr </emphasis> - endere�o de barramento f�sico do segmento "

#. (itstool) path: listitem/para
#: book.translate.xml:17708
#, fuzzy
msgid "<emphasis>ds_len</emphasis> - length of the segment"
msgstr " <emphasis> ds_len </emphasis> - comprimento do segmento "

#. (itstool) path: listitem/para
#: book.translate.xml:17717
#, fuzzy
msgid ""
"<function>void bus_dmamap_unload(bus_dma_tag_t dmat, bus_dmamap_t map)</"
"function>"
msgstr ""
" <function> void bus_dmamap_unload (bus_dma_tag_t dmat, bus_dmamap_t map) </"
"function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17721
#, fuzzy
msgid "unload the map."
msgstr "descarregar o mapa."

#. (itstool) path: listitem/para
#: book.translate.xml:17726 book.translate.xml:17755
#, fuzzy
msgid "<emphasis>dmat</emphasis> - tag"
msgstr " <emphasis> DMAT </emphasis> - dia "

#. (itstool) path: listitem/para
#: book.translate.xml:17731 book.translate.xml:17760
#, fuzzy
msgid "<emphasis>map</emphasis> - loaded map"
msgstr " <emphasis> mapa </emphasis> - mapa carregado "

#. (itstool) path: listitem/para
#: book.translate.xml:17740
#, fuzzy
msgid ""
"<function>void bus_dmamap_sync (bus_dma_tag_t dmat, bus_dmamap_t map, "
"bus_dmasync_op_t op)</function>"
msgstr ""
" <function> void bus_dmamap_sync (bus_dma_tag_t dmat, bus_dmamap_t mapa, "
"bus_dmasync_op_t op) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17744
#, fuzzy
msgid ""
"Synchronise a loaded buffer with its bounce pages before and after physical "
"transfer to or from device. This is the function that does all the necessary "
"copying of data between the original buffer and its mapped version. The "
"buffers must be synchronized both before and after doing the transfer."
msgstr ""
"Sincronize um buffer carregado com suas p�ginas de rejei��o antes e depois "
"da transfer�ncia f�sica para ou do dispositivo. Essa � a fun��o que faz toda "
"a c�pia necess�ria de dados entre o buffer original e sua vers�o mapeada. Os "
"buffers devem ser sincronizados antes e depois de fazer a transfer�ncia."

#. (itstool) path: listitem/para
#: book.translate.xml:17765
#, fuzzy
msgid "<emphasis>op</emphasis> - type of synchronization operation to perform:"
msgstr ""
" <emphasis> op </emphasis> - tipo de opera��o de sincroniza��o a executar: "

#. (itstool) path: listitem/para
#: book.translate.xml:17774
#, fuzzy
msgid ""
"<function>BUS_DMASYNC_PREREAD</function> - before reading from device into "
"buffer"
msgstr ""
" <function> BUS_DMASYNC_PREREAD </function> - antes de ler do dispositivo "
"para o buffer "

#. (itstool) path: listitem/para
#: book.translate.xml:17780
#, fuzzy
msgid ""
"<function>BUS_DMASYNC_POSTREAD</function> - after reading from device into "
"buffer"
msgstr ""
" <function> BUS_DMASYNC_POSTREAD </function> - depois de ler do dispositivo "
"no buffer "

#. (itstool) path: listitem/para
#: book.translate.xml:17786
#, fuzzy
msgid ""
"<function>BUS_DMASYNC_PREWRITE</function> - before writing the buffer to "
"device"
msgstr ""
" <function> BUS_DMASYNC_PREWRITE </function> - antes de escrever o buffer "
"para o dispositivo "

#. (itstool) path: listitem/para
#: book.translate.xml:17792
#, fuzzy
msgid ""
"<function>BUS_DMASYNC_POSTWRITE</function> - after writing the buffer to "
"device"
msgstr ""
" <function> BUS_DMASYNC_POSTWRITE </function> - depois de escrever o buffer "
"para o dispositivo "

#. (itstool) path: sect1/para
#: book.translate.xml:17803
#, fuzzy
msgid ""
"As of now PREREAD and POSTWRITE are null operations but that may change in "
"the future, so they must not be ignored in the driver. Synchronization is "
"not needed for the memory obtained from <function>bus_dmamem_alloc()</"
"function>."
msgstr ""
"A partir de agora, PREREAD e POSTWRITE s�o opera��es nulas, mas que podem "
"mudar no futuro, portanto, elas n�o devem ser ignoradas no driver. A "
"sincroniza��o n�o � necess�ria para a mem�ria obtida de <function> "
"bus_dmamem_alloc () </function> "

#. (itstool) path: sect1/para
#: book.translate.xml:17809
#, fuzzy
msgid ""
"Before calling the callback function from <function>bus_dmamap_load()</"
"function> the segment array is stored in the stack. And it gets pre-"
"allocated for the maximal number of segments allowed by the tag. Because of "
"this the practical limit for the number of segments on i386 architecture is "
"about 250-300 (the kernel stack is 4KB minus the size of the user structure, "
"size of a segment array entry is 8 bytes, and some space must be left). "
"Because the array is allocated based on the maximal number this value must "
"not be set higher than really needed. Fortunately, for most of hardware the "
"maximal supported number of segments is much lower. But if the driver wants "
"to handle buffers with a very large number of scatter-gather segments it "
"should do that in portions: load part of the buffer, transfer it to the "
"device, load next part of the buffer, and so on."
msgstr ""
"Antes de chamar a fun��o de retorno de chamada <function> bus_dmamap_load () "
"</function> o array de segmentos � armazenado na pilha. E ele � pr�-alocado "
"para o n�mero m�ximo de segmentos permitido pela tag. Devido a isso, o "
"limite pr�tico para o n�mero de segmentos na arquitetura i386 � de cerca de "
"250-300 (a pilha do kernel � 4KB menos o tamanho da estrutura do usu�rio, o "
"tamanho de uma entrada de matriz de segmento � de 8 bytes e algum espa�o "
"deve ser deixado) . Como a matriz � alocada com base no n�mero m�ximo, esse "
"valor n�o deve ser definido mais alto do que o realmente necess�rio. "
"Felizmente, para a maioria do hardware, o n�mero m�ximo de segmentos "
"suportados � muito menor. Mas se o driver quiser manipular buffers com um "
"n�mero muito grande de segmentos de dispers�o, ele deve fazer isso em "
"partes: carregar parte do buffer, transferi-lo para o dispositivo, carregar "
"a pr�xima parte do buffer e assim por diante. "

#. (itstool) path: sect1/para
#: book.translate.xml:17826
#, fuzzy
msgid ""
"Another practical consequence is that the number of segments may limit the "
"size of the buffer. If all the pages in the buffer happen to be physically "
"non-contiguous then the maximal supported buffer size for that fragmented "
"case would be (nsegments * page_size). For example, if a maximal number of "
"10 segments is supported then on i386 maximal guaranteed supported buffer "
"size would be 40K. If a higher size is desired then special tricks should be "
"used in the driver."
msgstr ""
"Outra conseq��ncia pr�tica � que o n�mero de segmentos pode limitar o "
"tamanho do buffer. Se todas as p�ginas no buffer forem fisicamente n�o "
"cont�guas, o tamanho m�ximo do buffer suportado para esse caso fragmentado "
"seria (nsegments * page_size). Por exemplo, se um n�mero m�ximo de 10 "
"segmentos for suportado, em i386 o tamanho m�ximo do buffer suportado "
"garantido seria 40 K. Se um tamanho maior for desejado, ent�o truques "
"especiais devem ser usados ​​no driver. "

#. (itstool) path: sect1/para
#: book.translate.xml:17836
#, fuzzy
msgid ""
"If the hardware does not support scatter-gather at all or the driver wants "
"to support some buffer size even if it is heavily fragmented then the "
"solution is to allocate a contiguous buffer in the driver and use it as "
"intermediate storage if the original buffer does not fit."
msgstr ""
"Se o hardware n�o suporta scatter-gather ou se o driver quiser suportar "
"algum tamanho de buffer mesmo que seja muito fragmentado, a solu��o � alocar "
"um buffer cont�guo no driver e us�-lo como armazenamento intermedi�rio se o "
"buffer original n�o serve."

#. (itstool) path: sect1/para
#: book.translate.xml:17843
#, fuzzy
msgid ""
"Below are the typical call sequences when using a map depend on the use of "
"the map. The characters -&gt; are used to show the flow of time."
msgstr ""
"Abaixo est�o as seq��ncias de chamadas t�picas ao usar um mapa dependem do "
"uso do mapa. Os caracteres -&gt; s�o usados ​​para mostrar o fluxo de tempo."

#. (itstool) path: sect1/para
#: book.translate.xml:17848
#, fuzzy
msgid ""
"For a buffer which stays practically fixed during all the time between "
"attachment and detachment of a device:"
msgstr ""
"Para um buffer que fica praticamente fixo durante todo o tempo entre a "
"conex�o e o desligamento de um dispositivo:"

#. (itstool) path: sect1/para
#: book.translate.xml:17851
#, fuzzy
msgid ""
"bus_dmamem_alloc -&gt; bus_dmamap_load -&gt; ...use buffer... -&gt; -&gt; "
"bus_dmamap_unload -&gt; bus_dmamem_free"
msgstr ""
"bus_dmamem_alloc -&gt; bus_dmamap_load -&gt; ... use buffer ... -&gt; -&gt; "
"bus_dmamap_unload -&gt; bus_dmamem_free"

#. (itstool) path: para/programlisting
#: book.translate.xml:17860
#, no-wrap
msgid ""
"          bus_dmamap_create -&gt;\n"
"          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do transfer -&gt;\n"
"          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;\n"
"          ...\n"
"          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do transfer -&gt;\n"
"          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;\n"
"          -&gt; bus_dmamap_destroy        "
msgstr ""
"          bus_dmamap_create -&gt;\n"
"          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do transfer -&gt;\n"
"          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;\n"
"          ...\n"
"          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do transfer -&gt;\n"
"          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;\n"
"          -&gt; bus_dmamap_destroy        "

#. (itstool) path: sect1/para
#: book.translate.xml:17856
#, fuzzy
msgid ""
"For a buffer that changes frequently and is passed from outside the driver: "
"<_:programlisting-1/>"
msgstr ""
"Para um buffer que muda com freq��ncia e � passado de fora do driver: <_: "
"programlisting-1 />"

#. (itstool) path: sect1/para
#: book.translate.xml:17869
#, fuzzy
msgid ""
"When loading a map created by <function>bus_dmamem_alloc()</function> the "
"passed address and size of the buffer must be the same as used in "
"<function>bus_dmamem_alloc()</function>. In this case it is guaranteed that "
"the whole buffer will be mapped as one segment (so the callback may be based "
"on this assumption) and the request will be executed immediately "
"(EINPROGRESS will never be returned). All the callback needs to do in this "
"case is to save the physical address."
msgstr ""
"Ao carregar um mapa criado por <function> bus_dmamem_alloc () </function> o "
"endere�o passado e tamanho do buffer deve ser o mesmo usado em <function> "
"bus_dmamem_alloc () </function> . Nesse caso, � garantido que o buffer "
"inteiro ser� mapeado como um segmento (para que o retorno de chamada possa "
"se basear nessa suposi��o) e a solicita��o ser� executada imediatamente (o "
"EINPROGRESS nunca ser� retornado). Todo o retorno de chamada que precisa ser "
"feito neste caso � salvar o endere�o f�sico. "

#. (itstool) path: sect1/para
#: book.translate.xml:17880
#, fuzzy
msgid "A typical example would be:"
msgstr "Um exemplo t�pico seria:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:17884
#, no-wrap
msgid ""
"          static void\n"
"        alloc_callback(void *arg, bus_dma_segment_t *seg, int nseg, int error)\n"
"        {\n"
"          *(bus_addr_t *)arg = seg[0].ds_addr;\n"
"        }\n"
"\n"
"          ...\n"
"          int error;\n"
"          struct somedata {\n"
"            ....\n"
"          };\n"
"          struct somedata *vsomedata; /* virtual address */\n"
"          bus_addr_t psomedata; /* physical bus-relative address */\n"
"          bus_dma_tag_t tag_somedata;\n"
"          bus_dmamap_t map_somedata;\n"
"          ...\n"
"\n"
"          error=bus_dma_tag_create(parent_tag, alignment,\n"
"           boundary, lowaddr, highaddr, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"           /*maxsize*/ sizeof(struct somedata), /*nsegments*/ 1,\n"
"           /*maxsegsz*/ sizeof(struct somedata), /*flags*/ 0,\n"
"           &amp;tag_somedata);\n"
"          if(error)\n"
"          return error;\n"
"\n"
"          error = bus_dmamem_alloc(tag_somedata, &amp;vsomedata, /* flags*/ 0,\n"
"             &amp;map_somedata);\n"
"          if(error)\n"
"             return error;\n"
"\n"
"          bus_dmamap_load(tag_somedata, map_somedata, (void *)vsomedata,\n"
"             sizeof (struct somedata), alloc_callback,\n"
"             (void *) &amp;psomedata, /*flags*/0);        "
msgstr ""
"          static void\n"
"        alloc_callback(void *arg, bus_dma_segment_t *seg, int nseg, int error)\n"
"        {\n"
"          *(bus_addr_t *)arg = seg[0].ds_addr;\n"
"        }\n"
"\n"
"          ...\n"
"          int error;\n"
"          struct somedata {\n"
"            ....\n"
"          };\n"
"          struct somedata *vsomedata; /* virtual address */\n"
"          bus_addr_t psomedata; /* physical bus-relative address */\n"
"          bus_dma_tag_t tag_somedata;\n"
"          bus_dmamap_t map_somedata;\n"
"          ...\n"
"\n"
"          error=bus_dma_tag_create(parent_tag, alignment,\n"
"           boundary, lowaddr, highaddr, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"           /*maxsize*/ sizeof(struct somedata), /*nsegments*/ 1,\n"
"           /*maxsegsz*/ sizeof(struct somedata), /*flags*/ 0,\n"
"           &amp;tag_somedata);\n"
"          if(error)\n"
"          return error;\n"
"\n"
"          error = bus_dmamem_alloc(tag_somedata, &amp;vsomedata, /* flags*/ 0,\n"
"             &amp;map_somedata);\n"
"          if(error)\n"
"             return error;\n"
"\n"
"          bus_dmamap_load(tag_somedata, map_somedata, (void *)vsomedata,\n"
"             sizeof (struct somedata), alloc_callback,\n"
"             (void *) &amp;psomedata, /*flags*/0);        "

#. (itstool) path: sect1/para
#: book.translate.xml:17918
#, fuzzy
msgid ""
"Looks a bit long and complicated but that is the way to do it. The practical "
"consequence is: if multiple memory areas are allocated always together it "
"would be a really good idea to combine them all into one structure and "
"allocate as one (if the alignment and boundary limitations permit)."
msgstr ""
"Parece um pouco longo e complicado, mas � assim. A consequ�ncia pr�tica �: "
"se v�rias �reas de mem�ria forem alocadas sempre juntas, seria uma boa id�ia "
"combin�-las em uma estrutura e alocar como uma (se a limita��es de "
"alinhamento e limite permitem). "

#. (itstool) path: sect1/para
#: book.translate.xml:17925
#, fuzzy
msgid ""
"When loading an arbitrary buffer into the map created by "
"<function>bus_dmamap_create()</function> special measures must be taken to "
"synchronize with the callback in case it would be delayed. The code would "
"look like:"
msgstr ""
"Ao carregar um buffer arbitr�rio no mapa criado por <function> "
"bus_dmamap_create () </function> Medidas especiais devem ser tomadas para "
"sincronizar com o retorno de chamada caso ele seja atrasado. O c�digo "
"ficaria assim: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:17932
#, no-wrap
msgid ""
"          {\n"
"           int s;\n"
"           int error;\n"
"\n"
"           s = splsoftvm();\n"
"           error = bus_dmamap_load(\n"
"               dmat,\n"
"               dmamap,\n"
"               buffer_ptr,\n"
"               buffer_len,\n"
"               callback,\n"
"               /*callback_arg*/ buffer_descriptor,\n"
"               /*flags*/0);\n"
"           if (error == EINPROGRESS) {\n"
"               /*\n"
"                * Do whatever is needed to ensure synchronization\n"
"                * with callback. Callback is guaranteed not to be started\n"
"                * until we do splx() or tsleep().\n"
"                */\n"
"              }\n"
"           splx(s);\n"
"          }        "
msgstr ""
"          {\n"
"           int s;\n"
"           int error;\n"
"\n"
"           s = splsoftvm();\n"
"           error = bus_dmamap_load(\n"
"               dmat,\n"
"               dmamap,\n"
"               buffer_ptr,\n"
"               buffer_len,\n"
"               callback,\n"
"               /*callback_arg*/ buffer_descriptor,\n"
"               /*flags*/0);\n"
"           if (error == EINPROGRESS) {\n"
"               /*\n"
"                * Do whatever is needed to ensure synchronization\n"
"                * with callback. Callback is guaranteed not to be started\n"
"                * until we do splx() or tsleep().\n"
"                */\n"
"              }\n"
"           splx(s);\n"
"          }        "

#. (itstool) path: sect1/para
#: book.translate.xml:17955
#, fuzzy
msgid "Two possible approaches for the processing of requests are:"
msgstr "Duas abordagens poss�veis para o processamento de pedidos s�o:"

#. (itstool) path: sect1/para
#: book.translate.xml:17958
#, fuzzy
msgid ""
"1. If requests are completed by marking them explicitly as done (such as the "
"CAM requests) then it would be simpler to put all the further processing "
"into the callback driver which would mark the request when it is done. Then "
"not much extra synchronization is needed. For the flow control reasons it "
"may be a good idea to freeze the request queue until this request gets "
"completed."
msgstr ""
"1. Se as solicita��es forem conclu�das marcando-as explicitamente como "
"conclu�das (como as solicita��es de CAM), seria mais simples colocar todo o "
"processamento adicional no driver de retorno de chamada que marcaria a "
"solicita��o quando isso � feito. Para os motivos de controle de fluxo, pode "
"ser uma boa ideia congelar a fila de solicita��es at� que essa solicita��o "
"seja conclu�da. "

#. (itstool) path: sect1/para
#: book.translate.xml:17967
#, fuzzy
msgid ""
"2. If requests are completed when the function returns (such as classic read "
"or write requests on character devices) then a synchronization flag should "
"be set in the buffer descriptor and <function>tsleep()</function> called. "
"Later when the callback gets called it will do its processing and check this "
"synchronization flag. If it is set then the callback should issue a wakeup. "
"In this approach the callback function could either do all the needed "
"processing (just like the previous case) or simply save the segments array "
"in the buffer descriptor. Then after callback completes the calling function "
"could use this saved segments array and do all the processing."
msgstr ""
"2. Se as solicita��es forem conclu�das quando a fun��o retornar (como "
"solicita��es cl�ssicas de leitura ou grava��o em dispositivos de "
"caracteres), um sinalizador de sincroniza��o dever� ser definido no "
"descritor de buffer e <function> tsleep () </function> chamado. Mais tarde, "
"quando o retorno de chamada for chamado, ele far� seu processamento e "
"verificar� esse sinalizador de sincroniza��o. Se estiver definido, o retorno "
"de chamada deve emitir uma ativa��o. Nessa abordagem, a fun��o de retorno de "
"chamada poderia fazer todo o processamento necess�rio (como no caso "
"anterior) ou simplesmente salvar a matriz de segmentos no descritor de "
"buffer. Ent�o, depois que o retorno de chamada for conclu�do, a fun��o de "
"chamada poder� usar essa matriz de segmentos salvos e fazer todo o "
"processamento. "

#. (itstool) path: sect1/title
#. (itstool) path: sect2/title
#: book.translate.xml:17987 book.translate.xml:19414
#, fuzzy
msgid "DMA"
msgstr "DMA"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:17990
#, fuzzy
msgid "<primary>Direct Memory Access (DMA)</primary>"
msgstr " <primary> Acesso Direto � Mem�ria (DMA) </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:17992
#, fuzzy
msgid ""
"The Direct Memory Access (DMA) is implemented in the ISA bus through the DMA "
"controller (actually, two of them but that is an irrelevant detail). To make "
"the early ISA devices simple and cheap the logic of the bus control and "
"address generation was concentrated in the DMA controller. Fortunately, "
"FreeBSD provides a set of functions that mostly hide the annoying details of "
"the DMA controller from the device drivers."
msgstr ""
"O Direct Memory Access (DMA) � implementado no barramento ISA atrav�s do "
"controlador DMA (na verdade, dois deles, mas isso � um detalhe irrelevante). "
"Para tornar os primeiros dispositivos ISA simples e baratos, a l�gica do "
"controle de barramento e gera��o de endere�os estava concentrada no "
"controlador de DMA. Felizmente, o FreeBSD fornece um conjunto de fun��es que "
"ocultam principalmente os detalhes irritantes do controlador de DMA dos "
"drivers de dispositivos. "

#. (itstool) path: sect1/para
#: book.translate.xml:18003
#, fuzzy
msgid ""
"The simplest case is for the fairly intelligent devices. Like the bus master "
"devices on PCI they can generate the bus cycles and memory addresses all by "
"themselves. The only thing they really need from the DMA controller is bus "
"arbitration. So for this purpose they pretend to be cascaded slave DMA "
"controllers. And the only thing needed from the system DMA controller is to "
"enable the cascaded mode on a DMA channel by calling the following function "
"when attaching the driver:"
msgstr ""
"O caso mais simples � para os dispositivos razoavelmente inteligentes. Como "
"os dispositivos mestre de barramento em PCI, eles podem gerar os ciclos de "
"barramento e os endere�os de mem�ria sozinhos. A �nica coisa que eles "
"realmente precisam do controlador de DMA � a arbitragem de barramento. "
"fingir ser controladores DMA escravo em cascata. E a �nica coisa necess�ria "
"do controlador DMA do sistema � ativar o modo em cascata em um canal DMA "
"chamando a seguinte fun��o ao anexar o driver: "

#. (itstool) path: sect1/para
#: book.translate.xml:18015
#, fuzzy
msgid "<function>void isa_dmacascade(int channel_number)</function>"
msgstr " <function> void isa_dmacascade (int channel_number) </function> "

#. (itstool) path: sect1/para
#: book.translate.xml:18019
#, fuzzy
msgid ""
"All the further activity is done by programming the device. When detaching "
"the driver no DMA-related functions need to be called."
msgstr ""
"Toda a atividade adicional � feita pela programa��o do dispositivo. Ao "
"desconectar o driver, nenhuma fun��o relacionada ao DMA precisa ser chamada."

#. (itstool) path: sect1/para
#: book.translate.xml:18025
#, fuzzy
msgid ""
"For the simpler devices things get more complicated. The functions used are:"
msgstr ""
"Para os dispositivos mais simples, as coisas ficam mais complicadas. As "
"fun��es usadas s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:18033
#, fuzzy
msgid "<function>int isa_dma_acquire(int chanel_number)</function>"
msgstr " <function> int isa_dma_acquire (int chanel_number) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:18036
#, fuzzy
msgid ""
"Reserve a DMA channel. Returns 0 on success or EBUSY if the channel was "
"already reserved by this or a different driver. Most of the ISA devices are "
"not able to share DMA channels anyway, so normally this function is called "
"when attaching a device. This reservation was made redundant by the modern "
"interface of bus resources but still must be used in addition to the latter. "
"If not used then later, other DMA routines will panic."
msgstr ""
"Reserve um canal DMA. Retorna 0 em sucesso ou EBUSY se o canal j� estiver "
"reservado por este ou um driver diferente. A maioria dos dispositivos ISA "
"n�o � capaz de compartilhar canais DMA, ent�o normalmente essa fun��o � "
"chamada ao conectar um dispositivo. Essa reserva foi tornada redundante pela "
"interface moderna dos recursos de barramento, mas ainda deve ser usada em "
"adi��o a esta �ltima. Se n�o for usada, mais tarde, outras rotinas de DMA "
"entrar�o em p�nico. "

#. (itstool) path: listitem/para
#: book.translate.xml:18050
#, fuzzy
msgid "<function>int isa_dma_release(int chanel_number)</function>"
msgstr " <function> int isa_dma_release (int chanel_number) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:18053
#, fuzzy
msgid ""
"Release a previously reserved DMA channel. No transfers must be in progress "
"when the channel is released (in addition the device must not try to "
"initiate transfer after the channel is released)."
msgstr ""
"Liberar um canal de DMA previamente reservado. Nenhuma transfer�ncia deve "
"estar em progresso quando o canal for liberado (al�m disso, o dispositivo "
"n�o deve tentar iniciar a transfer�ncia ap�s o canal ser liberado)."

#. (itstool) path: listitem/para
#: book.translate.xml:18062
#, fuzzy
msgid "<function>void isa_dmainit(int chan, u_int bouncebufsize)</function>"
msgstr ""
" <function> void isa_dmainit (int chan, u_int bouncebufsize) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:18066
#, fuzzy
msgid ""
"Allocate a bounce buffer for use with the specified channel. The requested "
"size of the buffer can not exceed 64KB. This bounce buffer will be "
"automatically used later if a transfer buffer happens to be not physically "
"contiguous or outside of the memory accessible by the ISA bus or crossing "
"the 64KB boundary. If the transfers will be always done from buffers which "
"conform to these conditions (such as those allocated by "
"<function>bus_dmamem_alloc()</function> with proper limitations) then "
"<function>isa_dmainit()</function> does not have to be called. But it is "
"quite convenient to transfer arbitrary data using the DMA controller. The "
"bounce buffer will automatically care of the scatter-gather issues."
msgstr ""
"Alocar um buffer de rejei��o para uso com o canal especificado. O tamanho "
"solicitado do buffer n�o pode exceder 64 KB. Esse buffer de rejei��o ser� "
"usado automaticamente mais tarde se um buffer de transfer�ncia n�o estiver "
"fisicamente cont�guo ou fora da mem�ria acess�vel pelo ISA barramento ou "
"cruzando o limite de 64 Kb. Se as transfer�ncias forem sempre feitas a "
"partir de buffers que estejam de acordo com estas condi��es (tais <function> "
"bus_dmamem_alloc () </function> com limita��es adequadas) <function> "
"isa_dmainit () </function> n�o precisa ser chamado. Mas � bastante "
"conveniente transferir dados arbitr�rios usando o controlador de DMA. O "
"buffer de rejei��o cuidar� automaticamente dos problemas de dispers�o e "
"coleta. "

#. (itstool) path: listitem/para
#: book.translate.xml:18086
#, fuzzy
msgid "<emphasis>chan</emphasis> - channel number"
msgstr " <emphasis> chan </emphasis> - n�mero do canal"

#. (itstool) path: listitem/para
#: book.translate.xml:18091
#, fuzzy
msgid "<emphasis>bouncebufsize</emphasis> - size of the bounce buffer in bytes"
msgstr ""
" <emphasis> bouncebufsize </emphasis> - tamanho do buffer de rejei��o em "
"bytes "

#. (itstool) path: listitem/para
#: book.translate.xml:18102
#, fuzzy
msgid ""
"<function>void isa_dmastart(int flags, caddr_t addr, u_int nbytes, int "
"chan)</function>"
msgstr ""
" <function> void isa_dmastart (sinalizadores int, caddr_t addr, u_int "
"nbytes, int chan) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:18106
#, fuzzy
msgid ""
"Prepare to start a DMA transfer. This function must be called to set up the "
"DMA controller before actually starting transfer on the device. It checks "
"that the buffer is contiguous and falls into the ISA memory range, if not "
"then the bounce buffer is automatically used. If bounce buffer is required "
"but not set up by <function>isa_dmainit()</function> or too small for the "
"requested transfer size then the system will panic. In case of a write "
"request with bounce buffer the data will be automatically copied to the "
"bounce buffer."
msgstr ""
"Prepare-se para iniciar uma transfer�ncia de DMA. Esta fun��o deve ser "
"chamada para configurar o controlador de DMA antes de iniciar a "
"transfer�ncia no dispositivo. Ele verifica se o buffer � cont�guo e cai no "
"intervalo de mem�ria ISA, sen�o o buffer de rejei��o � automaticamente Se o "
"buffer de rejei��o for necess�rio, mas n�o configurado <function> "
"isa_dmainit () </function> ou muito pequeno para o tamanho de transfer�ncia "
"solicitado, o sistema entra em p�nico. No caso de uma solicita��o de "
"grava��o com buffer de rejei��o, os dados ser�o automaticamente copiados "
"para o buffer de rejei��o. "

#. (itstool) path: listitem/para
#: book.translate.xml:18121
#, fuzzy
msgid ""
"flags - a bitmask determining the type of operation to be done. The "
"direction bits B_READ and B_WRITE are mutually exclusive."
msgstr ""
"flags - um bitmask que determina o tipo de opera��o a ser executada. Os bits "
"de dire��o B_READ e B_WRITE s�o mutuamente exclusivos."

#. (itstool) path: listitem/para
#: book.translate.xml:18128
#, fuzzy
msgid "B_READ - read from the ISA bus into memory"
msgstr "B_READ - ler do barramento ISA na mem�ria"

#. (itstool) path: listitem/para
#: book.translate.xml:18133
#, fuzzy
msgid "B_WRITE - write from the memory to the ISA bus"
msgstr "B_WRITE - escreva da mem�ria para o barramento ISA"

#. (itstool) path: listitem/para
#: book.translate.xml:18138
#, fuzzy
msgid ""
"B_RAW - if set then the DMA controller will remember the buffer and after "
"the end of transfer will automatically re-initialize itself to repeat "
"transfer of the same buffer again (of course, the driver may change the data "
"in the buffer before initiating another transfer in the device). If not set "
"then the parameters will work only for one transfer, and "
"<function>isa_dmastart()</function> will have to be called again before "
"initiating the next transfer. Using B_RAW makes sense only if the bounce "
"buffer is not used."
msgstr ""
"B_RAW - se configurado, o controlador de DMA se lembrar� do buffer e, ap�s o "
"t�rmino da transfer�ncia, reinicializar� automaticamente para repetir a "
"transfer�ncia do mesmo buffer novamente (� claro, o driver pode alterar os "
"dados no buffer antes de iniciar outra transfer�ncia Se n�o estiver "
"definido, os par�metros funcionar�o apenas para uma transfer�ncia e "
"<function> isa_dmastart () </function> ter� que ser chamado novamente antes "
"de iniciar a pr�xima transfer�ncia. O uso de B_RAW faz sentido apenas se o "
"buffer de rejei��o n�o for usado. "

#. (itstool) path: listitem/para
#: book.translate.xml:18156
#, fuzzy
msgid "addr - virtual address of the buffer"
msgstr "addr - endere�o virtual do buffer"

#. (itstool) path: listitem/para
#: book.translate.xml:18161
#, fuzzy
msgid ""
"nbytes - length of the buffer. Must be less or equal to 64KB. Length of 0 is "
"not allowed: the DMA controller will understand it as 64KB while the kernel "
"code will understand it as 0 and that would cause unpredictable effects. For "
"channels number 4 and higher the length must be even because these channels "
"transfer 2 bytes at a time. In case of an odd length the last byte will not "
"be transferred."
msgstr ""
"nbytes - comprimento do buffer. Deve ser menor ou igual a 64 KB. Comprimento "
"de 0 n�o � permitido: o controlador de DMA o entender� como 64 KB enquanto o "
"c�digo do kernel o entender� como 0 e isso causaria efeitos imprevis�veis. "
"Para o n�mero de canais 4 e maior o comprimento deve ser mesmo porque estes "
"canais transferem 2 bytes de cada vez. No caso de um comprimento �mpar, o "
"�ltimo byte n�o ser� transferido. "

#. (itstool) path: listitem/para
#: book.translate.xml:18173
#, fuzzy
msgid "chan - channel number"
msgstr "chan - n�mero do canal"

#. (itstool) path: listitem/para
#: book.translate.xml:18179
#, fuzzy
msgid ""
"<function>void isa_dmadone(int flags, caddr_t addr, int nbytes, int chan)</"
"function>"
msgstr ""
" <function> void isa_dmadone (sinalizadores int, caddr_t addr, int nbytes, "
"int chan) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:18183
#, fuzzy
msgid ""
"Synchronize the memory after device reports that transfer is done. If that "
"was a read operation with a bounce buffer then the data will be copied from "
"the bounce buffer to the original buffer. Arguments are the same as for "
"<function>isa_dmastart()</function>. Flag B_RAW is permitted but it does not "
"affect <function>isa_dmadone()</function> in any way."
msgstr ""
"Sincronize a mem�ria ap�s o dispositivo informar que a transfer�ncia est� "
"conclu�da. Se essa foi uma opera��o de leitura com um buffer de rejei��o, os "
"dados ser�o copiados do buffer de rejei��o para o buffer original. Os "
"argumentos s�o os mesmos que para <function> isa_dmastart () </function> . A "
"sinaliza��o B_RAW � permitida, mas n�o afeta <function> isa_dmadone () </"
"function> de qualquer forma \""

#. (itstool) path: listitem/para
#: book.translate.xml:18195
#, fuzzy
msgid "<function>int isa_dmastatus(int channel_number)</function>"
msgstr " <function> int isa_dmastatus (int channel_number) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:18198
#, fuzzy
msgid ""
"Returns the number of bytes left in the current transfer to be transferred. "
"In case the flag B_READ was set in <function>isa_dmastart()</function> the "
"number returned will never be equal to zero. At the end of transfer it will "
"be automatically reset back to the length of buffer. The normal use is to "
"check the number of bytes left after the device signals that the transfer is "
"completed. If the number of bytes is not 0 then something probably went "
"wrong with that transfer."
msgstr ""
"Retorna o n�mero de bytes restantes na transfer�ncia atual a ser "
"transferida. Caso o sinalizador B_READ tenha sido configurado em <function> "
"isa_dmastart () </function> o n�mero retornado nunca ser� igual a zero. No "
"final da transfer�ncia, ele ser� redefinido automaticamente de volta ao "
"tamanho do buffer. O uso normal � verificar o n�mero de bytes restantes "
"depois que o dispositivo sinaliza que a transfer�ncia foi conclu�da. Se o "
"n�mero de bytes n�o for 0, ent�o algo provavelmente deu errado com essa "
"transfer�ncia. "

#. (itstool) path: listitem/para
#: book.translate.xml:18212
#, fuzzy
msgid "<function>int isa_dmastop(int channel_number)</function>"
msgstr " <function> int isa_dmastop (int channel_number) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:18215
#, fuzzy
msgid ""
"Aborts the current transfer and returns the number of bytes left "
"untransferred."
msgstr ""
"Anula a transfer�ncia atual e retorna o n�mero de bytes n�o transferidos."

#. (itstool) path: sect1/title
#: book.translate.xml:18224
#, fuzzy
msgid "xxx_isa_probe"
msgstr "xxx_isa_probe"

#. (itstool) path: sect1/para
#: book.translate.xml:18227
#, fuzzy
msgid ""
"This function probes if a device is present. If the driver supports auto-"
"detection of some part of device configuration (such as interrupt vector or "
"memory address) this auto-detection must be done in this routine."
msgstr ""
"Esta fun��o investiga se um dispositivo est� presente. Se o driver suportar "
"a detec��o autom�tica de alguma parte da configura��o do dispositivo (como "
"vetor de interrup��o ou endere�o de mem�ria), esta detec��o autom�tica deve "
"ser feita nesta rotina."

#. (itstool) path: sect1/para
#: book.translate.xml:18234
#, fuzzy
msgid ""
"As for any other bus, if the device cannot be detected or is detected but "
"failed the self-test or some other problem happened then it returns a "
"positive value of error. The value <errorname>ENXIO</errorname> must be "
"returned if the device is not present. Other error values may mean other "
"conditions. Zero or negative values mean success. Most of the drivers return "
"zero as success."
msgstr ""
"Quanto a qualquer outro barramento, se o dispositivo n�o puder ser detectado "
"ou for detectado, mas falhar no autoteste ou algum outro problema ocorrer, "
"ele retornar� um valor positivo de erro. O valor <errorname> ENXIO </"
"errorname> deve ser devolvido se o dispositivo n�o estiver presente. Outros "
"valores de erro podem significar outras condi��es. Valores zero ou negativos "
"significam sucesso. A maioria dos motoristas retorna zero como sucesso. "

#. (itstool) path: sect1/para
#: book.translate.xml:18244
#, fuzzy
msgid ""
"The negative return values are used when a PnP device supports multiple "
"interfaces. For example, an older compatibility interface and a newer "
"advanced interface which are supported by different drivers. Then both "
"drivers would detect the device. The driver which returns a higher value in "
"the probe routine takes precedence (in other words, the driver returning 0 "
"has highest precedence, one returning -1 is next, one returning -2 is after "
"it and so on). In result the devices which support only the old interface "
"will be handled by the old driver (which should return -1 from the probe "
"routine) while the devices supporting the new interface as well will be "
"handled by the new driver (which should return 0 from the probe routine)."
msgstr ""
"Os valores de retorno negativos s�o usados ​​quando um dispositivo PnP suporta "
"v�rias interfaces. Por exemplo, uma interface de compatibilidade mais antiga "
"e uma interface avan�ada mais recente suportada por drivers diferentes. "
"Ent�o, ambos os drivers detectariam o dispositivo. O driver que retorna um "
"valor mais alto a rotina da sonda tem preced�ncia (em outras palavras, o "
"driver retornando 0 tem a preced�ncia mais alta, uma retornando -1 � a "
"pr�xima, uma retornando -2 � depois dela e assim por diante) Em resultado, "
"os dispositivos que suportam apenas a interface antiga ser�o manipulados "
"pelo driver antigo (que deve retornar -1 da rotina da sonda), enquanto os "
"dispositivos que suportam a nova interface tamb�m ser�o manipulados pelo "
"novo driver (que deve retornar 0 da rotina da sonda). "

#. (itstool) path: sect1/para
#: book.translate.xml:18260
#, fuzzy
msgid ""
"The device descriptor struct xxx_softc is allocated by the system before "
"calling the probe routine. If the probe routine returns an error the "
"descriptor will be automatically deallocated by the system. So if a probing "
"error occurs the driver must make sure that all the resources it used during "
"probe are deallocated and that nothing keeps the descriptor from being "
"safely deallocated. If the probe completes successfully the descriptor will "
"be preserved by the system and later passed to the routine "
"<function>xxx_isa_attach()</function>. If a driver returns a negative value "
"it can not be sure that it will have the highest priority and its attach "
"routine will be called. So in this case it also must release all the "
"resources before returning and if necessary allocate them again in the "
"attach routine. When <function>xxx_isa_probe()</function> returns 0 "
"releasing the resources before returning is also a good idea and a well-"
"behaved driver should do so. But in cases where there is some problem with "
"releasing the resources the driver is allowed to keep resources between "
"returning 0 from the probe routine and execution of the attach routine."
msgstr ""
"O descritor de dispositivo struct xxx_softc � alocado pelo sistema antes de "
"chamar a rotina de an�lise. Se a rotina de an�lise retornar um erro, o "
"descritor ser� desalocado automaticamente pelo sistema. Portanto, se ocorrer "
"um erro de an�lise, o driver deve certificar-se de que todos os recursos "
"usados ​​durante o probe s�o desalocados e nada impede que o descritor seja "
"desalocado com seguran�a.Se o probe for conclu�do com �xito, o descritor "
"ser� preservado pelo sistema e, posteriormente, passado para a rotina "
"<function> xxx_isa_attach () </function> . Se um driver retornar um valor "
"negativo, ele n�o pode ter certeza de que ter� a prioridade mais alta e sua "
"rotina de anexa��o ser� chamada. Portanto, neste caso, tamb�m deve liberar "
"todos os recursos antes de retornar e, se necess�rio, aloc�-los novamente na "
"rotina de anexa��o. Quando <function> xxx_isa_probe () </function> Retorna 0 "
"liberando os recursos antes de retornar tamb�m � uma boa id�ia e um driver "
"bem comportado deve faz�-lo. Mas nos casos em que houver algum problema com "
"a libera��o dos recursos, o driver poder� manter os recursos entre o retorno "
"de 0 da rotina de an�lise e a execu��o da rotina de anexa��o. "

#. (itstool) path: sect1/para
#: book.translate.xml:18284
#, fuzzy
msgid ""
"A typical probe routine starts with getting the device descriptor and unit:"
msgstr ""
"Uma rotina de sonda t�pica come�a com o descritor e a unidade do dispositivo:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18289
#, no-wrap
msgid ""
"         struct xxx_softc *sc = device_get_softc(dev);\n"
"          int unit = device_get_unit(dev);\n"
"          int pnperror;\n"
"          int error = 0;\n"
"\n"
"          sc-&gt;dev = dev; /* link it back */\n"
"          sc-&gt;unit = unit;        "
msgstr ""
"         struct xxx_softc *sc = device_get_softc(dev);\n"
"          int unit = device_get_unit(dev);\n"
"          int pnperror;\n"
"          int error = 0;\n"
"\n"
"          sc-&gt;dev = dev; /* link it back */\n"
"          sc-&gt;unit = unit;        "

#. (itstool) path: sect1/para
#: book.translate.xml:18297
#, fuzzy
msgid ""
"Then check for the PnP devices. The check is carried out by a table "
"containing the list of PnP IDs supported by this driver and human-readable "
"descriptions of the device models corresponding to these IDs."
msgstr ""
"Ent�o, verifique os dispositivos PnP. A verifica��o � realizada por uma "
"tabela contendo a lista de IDs PnP suportados por este driver e descri��es "
"leg�veis por humanos dos modelos de dispositivos correspondentes a esses IDs."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18304
#, no-wrap
msgid ""
"\n"
"        pnperror=ISA_PNP_PROBE(device_get_parent(dev), dev,\n"
"        xxx_pnp_ids); if(pnperror == ENXIO) return ENXIO;\n"
"        "
msgstr ""
"\n"
"        pnperror=ISA_PNP_PROBE(device_get_parent(dev), dev,\n"
"        xxx_pnp_ids); if(pnperror == ENXIO) return ENXIO;\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18309
#, fuzzy
msgid ""
"The logic of ISA_PNP_PROBE is the following: If this card (device unit) was "
"not detected as PnP then ENOENT will be returned. If it was detected as PnP "
"but its detected ID does not match any of the IDs in the table then ENXIO is "
"returned. Finally, if it has PnP support and it matches on of the IDs in the "
"table, 0 is returned and the appropriate description from the table is set "
"by <function>device_set_desc()</function>."
msgstr ""
"A l�gica de ISA_PNP_PROBE � a seguinte: Se esta placa (unidade de "
"dispositivo) n�o foi detectada como PnP, ent�o ENOENT ser� retornado. Se ela "
"foi detectada como PnP, mas sua ID detectada n�o corresponde a nenhuma das "
"IDs na tabela, ent�o ENXIO � Finalmente, se ele tiver suporte PnP e "
"corresponder aos IDs na tabela, 0 ser� retornado e a descri��o apropriada da "
"tabela ser� definida por <function> device_set_desc () </function> "

#. (itstool) path: sect1/para
#: book.translate.xml:18320
#, fuzzy
msgid ""
"If a driver supports only PnP devices then the condition would look like:"
msgstr ""
"Se um driver suporta apenas dispositivos PnP, a condi��o seria semelhante a:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18325
#, no-wrap
msgid ""
"          if(pnperror != 0)\n"
"              return pnperror;        "
msgstr ""
"          if(pnperror != 0)\n"
"              return pnperror;        "

#. (itstool) path: sect1/para
#: book.translate.xml:18328
#, fuzzy
msgid ""
"No special treatment is required for the drivers which do not support PnP "
"because they pass an empty PnP ID table and will always get ENXIO if called "
"on a PnP card."
msgstr ""
"Nenhum tratamento especial � requerido para os drivers que n�o suportam PnP "
"porque eles passam uma tabela vazia de ID PnP e sempre recebem ENXIO se "
"forem chamados em uma placa PnP."

#. (itstool) path: sect1/para
#: book.translate.xml:18334
#, fuzzy
msgid ""
"The probe routine normally needs at least some minimal set of resources, "
"such as I/O port number to find the card and probe it. Depending on the "
"hardware the driver may be able to discover the other necessary resources "
"automatically. The PnP devices have all the resources pre-set by the PnP "
"subsystem, so the driver does not need to discover them by itself."
msgstr ""
"A rotina de an�lise normalmente precisa de pelo menos um conjunto m�nimo de "
"recursos, como o n�mero da porta I / O para encontrar a placa e sond�-la. "
"Dependendo do hardware, o driver pode descobrir os outros recursos "
"necess�rios automaticamente. Os dispositivos PnP todos os recursos pr�-"
"definidos pelo subsistema PnP, para que o driver n�o precise descobri-los "
"sozinho. "

#. (itstool) path: sect1/para
#: book.translate.xml:18344
#, fuzzy
msgid ""
"Typically the minimal information required to get access to the device is "
"the I/O port number. Then some devices allow to get the rest of information "
"from the device configuration registers (though not all devices do that). So "
"first we try to get the port start value:"
msgstr ""
"Normalmente, a informa��o m�nima necess�ria para obter acesso ao dispositivo "
"� o n�mero da porta de E / S. Ent�o, alguns dispositivos permitem obter o "
"restante das informa��es dos registros de configura��o do dispositivo "
"(embora nem todos os dispositivos fa�am isso). o valor inicial da porta: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18352
#, no-wrap
msgid ""
" sc-&gt;port0 = bus_get_resource_start(dev,\n"
"        SYS_RES_IOPORT, 0 /*rid*/); if(sc-&gt;port0 == 0) return ENXIO;\n"
"        "
msgstr ""
" sc-&gt;port0 = bus_get_resource_start(dev,\n"
"        SYS_RES_IOPORT, 0 /*rid*/); if(sc-&gt;port0 == 0) return ENXIO;\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18356
#, fuzzy
msgid ""
"The base port address is saved in the structure softc for future use. If it "
"will be used very often then calling the resource function each time would "
"be prohibitively slow. If we do not get a port we just return an error. Some "
"device drivers can instead be clever and try to probe all the possible "
"ports, like this:"
msgstr ""
"O endere�o da porta base � salvo na estrutura softc para uso futuro. Se for "
"usado com muita freq��ncia, chamar a fun��o resource a cada vez seria "
"proibitivamente lento. Se n�o obtivermos uma porta, retornaremos um erro. "
"Alguns drivers de dispositivo em vez disso, pode ser inteligente e tentar "
"investigar todas as portas poss�veis, como esta: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18365
#, no-wrap
msgid ""
"\n"
"          /* table of all possible base I/O port addresses for this device */\n"
"          static struct xxx_allports {\n"
"              u_short port; /* port address */\n"
"              short used; /* flag: if this port is already used by some unit */\n"
"          } xxx_allports = {\n"
"              { 0x300, 0 },\n"
"              { 0x320, 0 },\n"
"              { 0x340, 0 },\n"
"              { 0, 0 } /* end of table */\n"
"          };\n"
"\n"
"          ...\n"
"          int port, i;\n"
"          ...\n"
"\n"
"          port =  bus_get_resource_start(dev, SYS_RES_IOPORT, 0 /*rid*/);\n"
"          if(port !=0 ) {\n"
"              for(i=0; xxx_allports[i].port!=0; i++) {\n"
"                  if(xxx_allports[i].used || xxx_allports[i].port != port)\n"
"                      continue;\n"
"\n"
"                  /* found it */\n"
"                  xxx_allports[i].used = 1;\n"
"                  /* do probe on a known port */\n"
"                  return xxx_really_probe(dev, port);\n"
"              }\n"
"              return ENXIO; /* port is unknown or already used */\n"
"          }\n"
"\n"
"          /* we get here only if we need to guess the port */\n"
"          for(i=0; xxx_allports[i].port!=0; i++) {\n"
"              if(xxx_allports[i].used)\n"
"                  continue;\n"
"\n"
"              /* mark as used - even if we find nothing at this port\n"
"               * at least we won't probe it in future\n"
"               */\n"
"               xxx_allports[i].used = 1;\n"
"\n"
"              error = xxx_really_probe(dev, xxx_allports[i].port);\n"
"              if(error == 0) /* found a device at that port */\n"
"                  return 0;\n"
"          }\n"
"          /* probed all possible addresses, none worked */\n"
"          return ENXIO;"
msgstr ""
"\n"
"          /* table of all possible base I/O port addresses for this device */\n"
"          static struct xxx_allports {\n"
"              u_short port; /* port address */\n"
"              short used; /* flag: if this port is already used by some unit */\n"
"          } xxx_allports = {\n"
"              { 0x300, 0 },\n"
"              { 0x320, 0 },\n"
"              { 0x340, 0 },\n"
"              { 0, 0 } /* end of table */\n"
"          };\n"
"\n"
"          ...\n"
"          int port, i;\n"
"          ...\n"
"\n"
"          port =  bus_get_resource_start(dev, SYS_RES_IOPORT, 0 /*rid*/);\n"
"          if(port !=0 ) {\n"
"              for(i=0; xxx_allports[i].port!=0; i++) {\n"
"                  if(xxx_allports[i].used || xxx_allports[i].port != port)\n"
"                      continue;\n"
"\n"
"                  /* found it */\n"
"                  xxx_allports[i].used = 1;\n"
"                  /* do probe on a known port */\n"
"                  return xxx_really_probe(dev, port);\n"
"              }\n"
"              return ENXIO; /* port is unknown or already used */\n"
"          }\n"
"\n"
"          /* we get here only if we need to guess the port */\n"
"          for(i=0; xxx_allports[i].port!=0; i++) {\n"
"              if(xxx_allports[i].used)\n"
"                  continue;\n"
"\n"
"              /* mark as used - even if we find nothing at this port\n"
"               * at least we won't probe it in future\n"
"               */\n"
"               xxx_allports[i].used = 1;\n"
"\n"
"              error = xxx_really_probe(dev, xxx_allports[i].port);\n"
"              if(error == 0) /* found a device at that port */\n"
"                  return 0;\n"
"          }\n"
"          /* probed all possible addresses, none worked */\n"
"          return ENXIO;"

#. (itstool) path: sect1/para
#: book.translate.xml:18412
#, fuzzy
msgid ""
"Of course, normally the driver's <function>identify()</function> routine "
"should be used for such things. But there may be one valid reason why it may "
"be better to be done in <function>probe()</function>: if this probe would "
"drive some other sensitive device crazy. The probe routines are ordered with "
"consideration of the <literal>sensitive</literal> flag: the sensitive "
"devices get probed first and the rest of the devices later. But the "
"<function>identify()</function> routines are called before any probes, so "
"they show no respect to the sensitive devices and may upset them."
msgstr ""
"Claro, normalmente o motorista <function> identificar() </function> rotina "
"deve ser usada para tais coisas. Mas pode haver uma raz�o v�lida para que "
"seja melhor ser feito <function> sonda () </function> : se esta sonda for�ar "
"algum outro dispositivo sens�vel louco. As rotinas de sondagem s�o ordenadas "
"com a considera��o do <literal> sens�vel </literal> sinalizador: os "
"dispositivos sens�veis s�o examinados primeiro e o restante dos dispositivos "
"posteriormente. Mas o <function> identificar() </function> rotinas s�o "
"chamadas antes de qualquer teste, ent�o elas n�o mostram respeito pelos "
"dispositivos sens�veis e podem perturb�-las. "

#. (itstool) path: sect1/para
#: book.translate.xml:18426
#, fuzzy
msgid ""
"Now, after we got the starting port we need to set the port count (except "
"for PnP devices) because the kernel does not have this information in the "
"configuration file."
msgstr ""
"Agora, depois que tivermos a porta inicial, precisamos configurar a contagem "
"de portas (exceto para dispositivos PnP), porque o kernel n�o tem essas "
"informa��es no arquivo de configura��o."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18432
#, no-wrap
msgid ""
"\n"
"         if(pnperror /* only for non-PnP devices */\n"
"         &amp;&amp; bus_set_resource(dev, SYS_RES_IOPORT, 0, sc-&gt;port0,\n"
"         XXX_PORT_COUNT)&lt;0)\n"
"             return ENXIO;"
msgstr ""
"\n"
"         if(pnperror /* only for non-PnP devices */\n"
"         &amp;&amp; bus_set_resource(dev, SYS_RES_IOPORT, 0, sc-&gt;port0,\n"
"         XXX_PORT_COUNT)&lt;0)\n"
"             return ENXIO;"

#. (itstool) path: sect1/para
#: book.translate.xml:18438
#, fuzzy
msgid ""
"Finally allocate and activate a piece of port address space (special values "
"of start and end mean <quote>use those we set by "
"<function>bus_set_resource()</function></quote>):"
msgstr ""
"Finalmente alocar e ativar um peda�o de espa�o de endere�o de porta (valores "
"especiais de in�cio e t�rmino significam <quote> usar aqueles que "
"estabelecemos <function> bus_set_resource () </function></quote> ): "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18444
#, no-wrap
msgid ""
"\n"
"          sc-&gt;port0_rid = 0;\n"
"          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,\n"
"          &amp;sc-&gt;port0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;port0_r == NULL)\n"
"              return ENXIO;"
msgstr ""
"\n"
"          sc-&gt;port0_rid = 0;\n"
"          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,\n"
"          &amp;sc-&gt;port0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;port0_r == NULL)\n"
"              return ENXIO;"

#. (itstool) path: sect1/para
#: book.translate.xml:18453
#, fuzzy
msgid ""
"Now having access to the port-mapped registers we can poke the device in "
"some way and check if it reacts like it is expected to. If it does not then "
"there is probably some other device or no device at all at this address."
msgstr ""
"Agora, tendo acesso aos registradores mapeados pela porta, podemos cutucar o "
"dispositivo de alguma forma e verificar se ele reage como esperado. Se isso "
"n�o ocorrer, provavelmente haver� algum outro dispositivo ou nenhum "
"dispositivo nesse endere�o."

#. (itstool) path: sect1/para
#: book.translate.xml:18460
#, fuzzy
msgid ""
"Normally drivers do not set up the interrupt handlers until the attach "
"routine. Instead they do probes in the polling mode using the "
"<function>DELAY()</function> function for timeout. The probe routine must "
"never hang forever, all the waits for the device must be done with timeouts. "
"If the device does not respond within the time it is probably broken or "
"misconfigured and the driver must return error. When determining the timeout "
"interval give the device some extra time to be on the safe side: although "
"<function>DELAY()</function> is supposed to delay for the same amount of "
"time on any machine it has some margin of error, depending on the exact CPU."
msgstr ""
"Normalmente, os drivers n�o configuram os manipuladores de interrup��o at� a "
"rotina de anexa��o. Em vez disso, eles fazem sondas no modo de pesquisa "
"<function> DEMORA() </function> fun��o para o tempo limite. A rotina de "
"an�lise nunca deve ser interrompida para sempre, todas as esperas do "
"dispositivo devem ser feitas com tempos limite. Se o dispositivo n�o "
"responder dentro do tempo provavelmente est� quebrado ou mal configurado e o "
"driver deve retornar um erro. Ao determinar o intervalo de timeout, d� ao "
"dispositivo algum tempo extra para estar no lado seguro: <function> DEMORA() "
"</function> � suposto para atrasar a mesma quantidade de tempo em qualquer "
"m�quina que tenha alguma margem de erro, dependendo da CPU exata \""

#. (itstool) path: sect1/para
#: book.translate.xml:18475
#, fuzzy
msgid ""
"If the probe routine really wants to check that the interrupts really work "
"it may configure and probe the interrupts too. But that is not recommended."
msgstr ""
"Se a rotina de an�lise realmente quer verificar se as interrup��es realmente "
"funcionam, pode configurar e investigar as interrup��es tamb�m. Mas isso n�o "
"� recomendado."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18481
#, no-wrap
msgid ""
"\n"
"          /* implemented in some very device-specific way */\n"
"          if(error = xxx_probe_ports(sc))\n"
"              goto bad; /* will deallocate the resources before returning */\n"
"        "
msgstr ""
"\n"
"          /* implemented in some very device-specific way */\n"
"          if(error = xxx_probe_ports(sc))\n"
"              goto bad; /* will deallocate the resources before returning */\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18487
#, fuzzy
msgid ""
"The function <function>xxx_probe_ports()</function> may also set the device "
"description depending on the exact model of device it discovers. But if "
"there is only one supported device model this can be as well done in a "
"hardcoded way. Of course, for the PnP devices the PnP support sets the "
"description from the table automatically."
msgstr ""
"A fun��o <function> xxx_probe_ports () </function> Tamb�m pode definir a "
"descri��o do dispositivo dependendo do modelo exato do dispositivo que ele "
"descobre. Mas se houver apenas um modelo de dispositivo suportado, isso "
"tamb�m pode ser feito de maneira codificada. � claro que, para os "
"dispositivos PnP, o suporte PnP define a descri��o da tabela "
"automaticamente. "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18497
#, no-wrap
msgid ""
"          if(pnperror)\n"
"              device_set_desc(dev, \"Our device model 1234\");\n"
"        "
msgstr ""
"          if(pnperror)\n"
"              device_set_desc(dev, \"Our device model 1234\");\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18501
#, fuzzy
msgid ""
"Then the probe routine should either discover the ranges of all the "
"resources by reading the device configuration registers or make sure that "
"they were set explicitly by the user. We will consider it with an example of "
"on-board memory. The probe routine should be as non-intrusive as possible, "
"so allocation and check of functionality of the rest of resources (besides "
"the ports) would be better left to the attach routine."
msgstr ""
"Ent�o, a rotina de an�lise deve descobrir os intervalos de todos os recursos "
"lendo os registros de configura��o do dispositivo ou certificar-se de que "
"eles foram definidos explicitamente pelo usu�rio. Vamos consider�-lo com um "
"exemplo de mem�ria on-board. A rotina de an�lise deve ser o mais n�o "
"intrusivo poss�vel, portanto, a aloca��o e a verifica��o da funcionalidade "
"do restante dos recursos (al�m das portas) seriam melhor deixadas para a "
"rotina de anexa��o \""

#. (itstool) path: sect1/para
#: book.translate.xml:18512
#, fuzzy
msgid ""
"The memory address may be specified in the kernel configuration file or on "
"some devices it may be pre-configured in non-volatile configuration "
"registers. If both sources are available and different, which one should be "
"used? Probably if the user bothered to set the address explicitly in the "
"kernel configuration file they know what they are doing and this one should "
"take precedence. An example of implementation could be:"
msgstr ""
"O endere�o de mem�ria pode ser especificado no arquivo de configura��o do "
"kernel ou em alguns dispositivos ele pode ser pr�-configurado em registros "
"de configura��o n�o vol�teis. Se ambas as fontes estiverem dispon�veis e "
"diferentes, qual deve ser usado? Provavelmente se o usu�rio se incomodou em "
"definir o endere�o explicitamente no arquivo de configura��o do kernel eles "
"sabem o que est�o fazendo e este deve ter preced�ncia. Um exemplo de "
"implementa��o poderia ser: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18522
#, no-wrap
msgid ""
"\n"
"          /* try to find out the config address first */\n"
"          sc-&gt;mem0_p = bus_get_resource_start(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"          if(sc-&gt;mem0_p == 0) { /* nope, not specified by user */\n"
"              sc-&gt;mem0_p = xxx_read_mem0_from_device_config(sc);\n"
"\n"
"\n"
"          if(sc-&gt;mem0_p == 0)\n"
"                  /* can't get it from device config registers either */\n"
"                  goto bad;\n"
"          } else {\n"
"              if(xxx_set_mem0_address_on_device(sc) &lt; 0)\n"
"                  goto bad; /* device does not support that address */\n"
"          }\n"
"\n"
"          /* just like the port, set the memory size,\n"
"           * for some devices the memory size would not be constant\n"
"           * but should be read from the device configuration registers instead\n"
"           * to accommodate different models of devices. Another option would\n"
"           * be to let the user set the memory size as \"msize\" configuration\n"
"           * resource which will be automatically handled by the ISA bus.\n"
"           */\n"
"           if(pnperror) { /* only for non-PnP devices */\n"
"              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"              if(sc-&gt;mem0_size == 0) /* not specified by user */\n"
"                  sc-&gt;mem0_size = xxx_read_mem0_size_from_device_config(sc);\n"
"\n"
"              if(sc-&gt;mem0_size == 0) {\n"
"                  /* suppose this is a very old model of device without\n"
"                   * auto-configuration features and the user gave no preference,\n"
"                   * so assume the minimalistic case\n"
"                   * (of course, the real value will vary with the driver)\n"
"                   */\n"
"                  sc-&gt;mem0_size = 8*1024;\n"
"              }\n"
"\n"
"              if(xxx_set_mem0_size_on_device(sc) &lt; 0)\n"
"                  goto bad; /* device does not support that size */\n"
"\n"
"              if(bus_set_resource(dev, SYS_RES_MEMORY, /*rid*/0,\n"
"                      sc-&gt;mem0_p, sc-&gt;mem0_size)&lt;0)\n"
"                  goto bad;\n"
"          } else {\n"
"              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"          }        "
msgstr ""
"\n"
"          /* try to find out the config address first */\n"
"          sc-&gt;mem0_p = bus_get_resource_start(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"          if(sc-&gt;mem0_p == 0) { /* nope, not specified by user */\n"
"              sc-&gt;mem0_p = xxx_read_mem0_from_device_config(sc);\n"
"\n"
"\n"
"          if(sc-&gt;mem0_p == 0)\n"
"                  /* can't get it from device config registers either */\n"
"                  goto bad;\n"
"          } else {\n"
"              if(xxx_set_mem0_address_on_device(sc) &lt; 0)\n"
"                  goto bad; /* device does not support that address */\n"
"          }\n"
"\n"
"          /* just like the port, set the memory size,\n"
"           * for some devices the memory size would not be constant\n"
"           * but should be read from the device configuration registers instead\n"
"           * to accommodate different models of devices. Another option would\n"
"           * be to let the user set the memory size as \"msize\" configuration\n"
"           * resource which will be automatically handled by the ISA bus.\n"
"           */\n"
"           if(pnperror) { /* only for non-PnP devices */\n"
"              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"              if(sc-&gt;mem0_size == 0) /* not specified by user */\n"
"                  sc-&gt;mem0_size = xxx_read_mem0_size_from_device_config(sc);\n"
"\n"
"              if(sc-&gt;mem0_size == 0) {\n"
"                  /* suppose this is a very old model of device without\n"
"                   * auto-configuration features and the user gave no preference,\n"
"                   * so assume the minimalistic case\n"
"                   * (of course, the real value will vary with the driver)\n"
"                   */\n"
"                  sc-&gt;mem0_size = 8*1024;\n"
"              }\n"
"\n"
"              if(xxx_set_mem0_size_on_device(sc) &lt; 0)\n"
"                  goto bad; /* device does not support that size */\n"
"\n"
"              if(bus_set_resource(dev, SYS_RES_MEMORY, /*rid*/0,\n"
"                      sc-&gt;mem0_p, sc-&gt;mem0_size)&lt;0)\n"
"                  goto bad;\n"
"          } else {\n"
"              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"          }        "

#. (itstool) path: sect1/para
#: book.translate.xml:18568
#, fuzzy
msgid "Resources for IRQ and DRQ are easy to check by analogy."
msgstr "Recursos para IRQ e DRQ s�o f�ceis de verificar por analogia."

#. (itstool) path: sect1/para
#: book.translate.xml:18572
#, fuzzy
msgid "If all went well then release all the resources and return success."
msgstr "Se tudo correu bem, libere todos os recursos e retorne o sucesso."

#. (itstool) path: sect1/programlisting
#. (itstool) path: para/programlisting
#: book.translate.xml:18576 book.translate.xml:18918
#, no-wrap
msgid ""
"          xxx_free_resources(sc);\n"
"          return 0;"
msgstr ""
"          xxx_free_resources(sc);\n"
"          return 0;"

#. (itstool) path: sect1/para
#: book.translate.xml:18579
#, fuzzy
msgid ""
"Finally, handle the troublesome situations. All the resources should be "
"deallocated before returning. We make use of the fact that before the "
"structure softc is passed to us it gets zeroed out, so we can find out if "
"some resource was allocated: then its descriptor is non-zero."
msgstr ""
"Finalmente, lide com as situa��es problem�ticas. Todos os recursos devem ser "
"desalocados antes de retornar. Usamos o fato de que antes que a estrutura "
"seja passada para n�s, ela � zerada, para que possamos descobrir se algum "
"recurso foi alocado. descritor � diferente de zero. "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18587
#, no-wrap
msgid ""
"          bad:\n"
"\n"
"          xxx_free_resources(sc);\n"
"          if(error)\n"
"                return error;\n"
"          else /* exact error is unknown */\n"
"              return ENXIO;"
msgstr ""
"          bad:\n"
"\n"
"          xxx_free_resources(sc);\n"
"          if(error)\n"
"                return error;\n"
"          else /* exact error is unknown */\n"
"              return ENXIO;"

#. (itstool) path: sect1/para
#: book.translate.xml:18595
#, fuzzy
msgid ""
"That would be all for the probe routine. Freeing of resources is done from "
"multiple places, so it is moved to a function which may look like:"
msgstr ""
"Isso seria tudo para a rotina da sonda. A libera��o de recursos � feita a "
"partir de v�rios lugares, ent�o � movida para uma fun��o que pode parecer:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18601
#, no-wrap
msgid ""
"static void\n"
"           xxx_free_resources(sc)\n"
"              struct xxx_softc *sc;\n"
"          {\n"
"              /* check every resource and free if not zero */\n"
"\n"
"              /* interrupt handler */\n"
"              if(sc-&gt;intr_r) {\n"
"                  bus_teardown_intr(sc-&gt;dev, sc-&gt;intr_r, sc-&gt;intr_cookie);\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_IRQ, sc-&gt;intr_rid,\n"
"                      sc-&gt;intr_r);\n"
"                  sc-&gt;intr_r = 0;\n"
"              }\n"
"\n"
"              /* all kinds of memory maps we could have allocated */\n"
"              if(sc-&gt;data_p) {\n"
"                  bus_dmamap_unload(sc-&gt;data_tag, sc-&gt;data_map);\n"
"                  sc-&gt;data_p = 0;\n"
"              }\n"
"               if(sc-&gt;data) { /* sc-&gt;data_map may be legitimately equal to 0 */\n"
"                  /* the map will also be freed */\n"
"                  bus_dmamem_free(sc-&gt;data_tag, sc-&gt;data, sc-&gt;data_map);\n"
"                  sc-&gt;data = 0;\n"
"              }\n"
"              if(sc-&gt;data_tag) {\n"
"                  bus_dma_tag_destroy(sc-&gt;data_tag);\n"
"                  sc-&gt;data_tag = 0;\n"
"              }\n"
"\n"
"              ... free other maps and tags if we have them ...\n"
"\n"
"              if(sc-&gt;parent_tag) {\n"
"                  bus_dma_tag_destroy(sc-&gt;parent_tag);\n"
"                  sc-&gt;parent_tag = 0;\n"
"              }\n"
"\n"
"              /* release all the bus resources */\n"
"              if(sc-&gt;mem0_r) {\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_MEMORY, sc-&gt;mem0_rid,\n"
"                      sc-&gt;mem0_r);\n"
"                  sc-&gt;mem0_r = 0;\n"
"              }\n"
"              ...\n"
"              if(sc-&gt;port0_r) {\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_IOPORT, sc-&gt;port0_rid,\n"
"                      sc-&gt;port0_r);\n"
"                  sc-&gt;port0_r = 0;\n"
"              }\n"
"          }"
msgstr ""
"static void\n"
"           xxx_free_resources(sc)\n"
"              struct xxx_softc *sc;\n"
"          {\n"
"              /* check every resource and free if not zero */\n"
"\n"
"              /* interrupt handler */\n"
"              if(sc-&gt;intr_r) {\n"
"                  bus_teardown_intr(sc-&gt;dev, sc-&gt;intr_r, sc-&gt;intr_cookie);\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_IRQ, sc-&gt;intr_rid,\n"
"                      sc-&gt;intr_r);\n"
"                  sc-&gt;intr_r = 0;\n"
"              }\n"
"\n"
"              /* all kinds of memory maps we could have allocated */\n"
"              if(sc-&gt;data_p) {\n"
"                  bus_dmamap_unload(sc-&gt;data_tag, sc-&gt;data_map);\n"
"                  sc-&gt;data_p = 0;\n"
"              }\n"
"               if(sc-&gt;data) { /* sc-&gt;data_map may be legitimately equal to 0 */\n"
"                  /* the map will also be freed */\n"
"                  bus_dmamem_free(sc-&gt;data_tag, sc-&gt;data, sc-&gt;data_map);\n"
"                  sc-&gt;data = 0;\n"
"              }\n"
"              if(sc-&gt;data_tag) {\n"
"                  bus_dma_tag_destroy(sc-&gt;data_tag);\n"
"                  sc-&gt;data_tag = 0;\n"
"              }\n"
"\n"
"              ... free other maps and tags if we have them ...\n"
"\n"
"              if(sc-&gt;parent_tag) {\n"
"                  bus_dma_tag_destroy(sc-&gt;parent_tag);\n"
"                  sc-&gt;parent_tag = 0;\n"
"              }\n"
"\n"
"              /* release all the bus resources */\n"
"              if(sc-&gt;mem0_r) {\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_MEMORY, sc-&gt;mem0_rid,\n"
"                      sc-&gt;mem0_r);\n"
"                  sc-&gt;mem0_r = 0;\n"
"              }\n"
"              ...\n"
"              if(sc-&gt;port0_r) {\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_IOPORT, sc-&gt;port0_rid,\n"
"                      sc-&gt;port0_r);\n"
"                  sc-&gt;port0_r = 0;\n"
"              }\n"
"          }"

#. (itstool) path: sect1/title
#: book.translate.xml:18654
#, fuzzy
msgid "xxx_isa_attach"
msgstr "xxx_isa_attach"

#. (itstool) path: sect1/para
#: book.translate.xml:18657
#, fuzzy
msgid ""
"The attach routine actually connects the driver to the system if the probe "
"routine returned success and the system had chosen to attach that driver. If "
"the probe routine returned 0 then the attach routine may expect to receive "
"the device structure softc intact, as it was set by the probe routine. Also "
"if the probe routine returns 0 it may expect that the attach routine for "
"this device shall be called at some point in the future. If the probe "
"routine returns a negative value then the driver may make none of these "
"assumptions."
msgstr ""
"A rotina anexar realmente conecta o driver ao sistema se a rotina da sonda "
"tiver retornado sucesso e o sistema tiver escolhido anexar esse driver. Se a "
"rotina da sonda retornasse 0, a rotina de anexa��o poderia receber a "
"estrutura do dispositivo softc intacta, como era Al�m disso, se a rotina da "
"sonda retornar 0, pode-se esperar que a rotina de anexa��o para este "
"dispositivo seja chamada em algum momento no futuro.Se a rotina da sonda "
"retornar um valor negativo, o motorista n�o far� nenhuma dessas suposi��es. "

#. (itstool) path: sect1/para
#: book.translate.xml:18669
#, fuzzy
msgid ""
"The attach routine returns 0 if it completed successfully or error code "
"otherwise."
msgstr ""
"A rotina de anexa��o retorna 0 se foi conclu�da com sucesso ou, caso "
"contr�rio, o c�digo de erro."

#. (itstool) path: sect1/para
#: book.translate.xml:18673
#, fuzzy
msgid ""
"The attach routine starts just like the probe routine, with getting some "
"frequently used data into more accessible variables."
msgstr ""
"A rotina de anexa��o come�a exatamente como a rotina de an�lise, com a "
"obten��o de alguns dados usados ​​com frequ�ncia em vari�veis ​​mais acess�veis."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18678
#, no-wrap
msgid ""
"          struct xxx_softc *sc = device_get_softc(dev);\n"
"          int unit = device_get_unit(dev);\n"
"          int error = 0;"
msgstr ""
"          struct xxx_softc *sc = device_get_softc(dev);\n"
"          int unit = device_get_unit(dev);\n"
"          int error = 0;"

#. (itstool) path: sect1/para
#: book.translate.xml:18682
#, fuzzy
msgid ""
"Then allocate and activate all the necessary resources. Because normally the "
"port range will be released before returning from probe, it has to be "
"allocated again. We expect that the probe routine had properly set all the "
"resource ranges, as well as saved them in the structure softc. If the probe "
"routine had left some resource allocated then it does not need to be "
"allocated again (which would be considered an error)."
msgstr ""
"Em seguida, aloque e ative todos os recursos necess�rios. Como normalmente o "
"intervalo de portas ser� liberado antes de retornar do probe, ele deve ser "
"alocado novamente. Esperamos que a rotina de an�lise tenha definido "
"corretamente todos os intervalos de recursos e os salvou em a estrutura "
"softc.Se a rotina de an�lise tiver deixado algum recurso alocado, ela n�o "
"precisar� ser alocada novamente (o que seria considerado um erro). "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18692
#, no-wrap
msgid ""
"          sc-&gt;port0_rid = 0;\n"
"          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,  &amp;sc-&gt;port0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;port0_r == NULL)\n"
"               return ENXIO;\n"
"\n"
"          /* on-board memory */\n"
"          sc-&gt;mem0_rid = 0;\n"
"          sc-&gt;mem0_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-&gt;mem0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;mem0_r == NULL)\n"
"                goto bad;\n"
"\n"
"          /* get its virtual address */\n"
"          sc-&gt;mem0_v = rman_get_virtual(sc-&gt;mem0_r);"
msgstr ""
"          sc-&gt;port0_rid = 0;\n"
"          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,  &amp;sc-&gt;port0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;port0_r == NULL)\n"
"               return ENXIO;\n"
"\n"
"          /* on-board memory */\n"
"          sc-&gt;mem0_rid = 0;\n"
"          sc-&gt;mem0_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-&gt;mem0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;mem0_r == NULL)\n"
"                goto bad;\n"
"\n"
"          /* get its virtual address */\n"
"          sc-&gt;mem0_v = rman_get_virtual(sc-&gt;mem0_r);"

#. (itstool) path: sect1/para
#: book.translate.xml:18710
#, fuzzy
msgid ""
"The DMA request channel (DRQ) is allocated likewise. To initialize it use "
"functions of the <function>isa_dma*()</function> family. For example:"
msgstr ""
"O canal de requisi��o DMA (DRQ) � alocado da mesma forma. Para inicializ�-"
"lo, use as fun��es do <function> isa_dma * () </function> fam�lia. Por "
"exemplo:"

#. (itstool) path: sect1/para
#: book.translate.xml:18715
#, fuzzy
msgid "<function>isa_dmacascade(sc-&gt;drq0);</function>"
msgstr " <function> isa_dmacascade (sc-&gt; drq0); </function> "

#. (itstool) path: sect1/para
#: book.translate.xml:18717
#, fuzzy
msgid ""
"The interrupt request line (IRQ) is a bit special. Besides allocation the "
"driver's interrupt handler should be associated with it. Historically in the "
"old ISA drivers the argument passed by the system to the interrupt handler "
"was the device unit number. But in modern drivers the convention suggests "
"passing the pointer to structure softc. The important reason is that when "
"the structures softc are allocated dynamically then getting the unit number "
"from softc is easy while getting softc from the unit number is difficult. "
"Also this convention makes the drivers for different buses look more uniform "
"and allows them to share the code: each bus gets its own probe, attach, "
"detach and other bus-specific routines while the bulk of the driver code may "
"be shared among them."
msgstr ""
"A linha de requisi��o de interrup��o (IRQ) � um pouco especial. Al�m da "
"aloca��o, o manipulador de interrup��o do driver deve estar associado a ela. "
"Historicamente, nos antigos drivers ISA, o argumento transmitido pelo "
"sistema ao manipulador de interrup��o era o n�mero da unidade. drivers a "
"conven��o sugere passar o ponteiro para a estrutura softc.A raz�o importante "
"� que quando o softc estruturas s�o alocados dinamicamente, em seguida, "
"obtendo o n�mero da unidade do softc � f�cil, enquanto obtendo softc do "
"n�mero da unidade � dif�cil.Tamb�m esta conven��o faz com que os drivers "
"para diferentes os barramentos parecem mais uniformes e permitem que eles "
"compartilhem o c�digo: cada barramento recebe sua pr�pria sonda, anexar, "
"desconectar e outras rotinas espec�ficas de barramento, enquanto a maior "
"parte do c�digo do driver pode ser compartilhada entre eles. "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18733
#, no-wrap
msgid ""
"\n"
"          sc-&gt;intr_rid = 0;\n"
"          sc-&gt;intr_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-&gt;intr_rid,\n"
"                /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;intr_r == NULL)\n"
"              goto bad;\n"
"\n"
"          /*\n"
"           * XXX_INTR_TYPE is supposed to be defined depending on the type of\n"
"           * the driver, for example as INTR_TYPE_CAM for a CAM driver\n"
"           */\n"
"          error = bus_setup_intr(dev, sc-&gt;intr_r, XXX_INTR_TYPE,\n"
"              (driver_intr_t *) xxx_intr, (void *) sc, &amp;sc-&gt;intr_cookie);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"        "
msgstr ""
"\n"
"          sc-&gt;intr_rid = 0;\n"
"          sc-&gt;intr_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-&gt;intr_rid,\n"
"                /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;intr_r == NULL)\n"
"              goto bad;\n"
"\n"
"          /*\n"
"           * XXX_INTR_TYPE is supposed to be defined depending on the type of\n"
"           * the driver, for example as INTR_TYPE_CAM for a CAM driver\n"
"           */\n"
"          error = bus_setup_intr(dev, sc-&gt;intr_r, XXX_INTR_TYPE,\n"
"              (driver_intr_t *) xxx_intr, (void *) sc, &amp;sc-&gt;intr_cookie);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18753
#, fuzzy
msgid ""
"If the device needs to make DMA to the main memory then this memory should "
"be allocated like described before:"
msgstr ""
"Se o dispositivo precisa fazer o DMA para a mem�ria principal, ent�o esta "
"mem�ria deve ser alocada como descrito anteriormente:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18757
#, no-wrap
msgid ""
"          error=bus_dma_tag_create(NULL, /*alignment*/ 4,\n"
"              /*boundary*/ 0, /*lowaddr*/ BUS_SPACE_MAXADDR_24BIT,\n"
"              /*highaddr*/ BUS_SPACE_MAXADDR, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"              /*maxsize*/ BUS_SPACE_MAXSIZE_24BIT,\n"
"              /*nsegments*/ BUS_SPACE_UNRESTRICTED,\n"
"              /*maxsegsz*/ BUS_SPACE_MAXSIZE_24BIT, /*flags*/ 0,\n"
"              &amp;sc-&gt;parent_tag);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          /* many things get inherited from the parent tag\n"
"           * sc-&gt;data is supposed to point to the structure with the shared data,\n"
"           * for example for a ring buffer it could be:\n"
"           * struct {\n"
"           *   u_short rd_pos;\n"
"           *   u_short wr_pos;\n"
"           *   char    bf[XXX_RING_BUFFER_SIZE]\n"
"           * } *data;\n"
"           */\n"
"          error=bus_dma_tag_create(sc-&gt;parent_tag, 1,\n"
"              0, BUS_SPACE_MAXADDR, 0, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"              /*maxsize*/ sizeof(* sc-&gt;data), /*nsegments*/ 1,\n"
"              /*maxsegsz*/ sizeof(* sc-&gt;data), /*flags*/ 0,\n"
"              &amp;sc-&gt;data_tag);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          error = bus_dmamem_alloc(sc-&gt;data_tag, &amp;sc-&gt;data, /* flags*/ 0,\n"
"              &amp;sc-&gt;data_map);\n"
"          if(error)\n"
"               goto bad;\n"
"\n"
"          /* xxx_alloc_callback() just saves the physical address at\n"
"           * the pointer passed as its argument, in this case &amp;sc-&gt;data_p.\n"
"           * See details in the section on bus memory mapping.\n"
"           * It can be implemented like:\n"
"           *\n"
"           * static void\n"
"           * xxx_alloc_callback(void *arg, bus_dma_segment_t *seg,\n"
"           *     int nseg, int error)\n"
"           * {\n"
"           *    *(bus_addr_t *)arg = seg[0].ds_addr;\n"
"           * }\n"
"           */\n"
"          bus_dmamap_load(sc-&gt;data_tag, sc-&gt;data_map, (void *)sc-&gt;data,\n"
"              sizeof (* sc-&gt;data), xxx_alloc_callback, (void *) &amp;sc-&gt;data_p,\n"
"              /*flags*/0);"
msgstr ""
"          error=bus_dma_tag_create(NULL, /*alignment*/ 4,\n"
"              /*boundary*/ 0, /*lowaddr*/ BUS_SPACE_MAXADDR_24BIT,\n"
"              /*highaddr*/ BUS_SPACE_MAXADDR, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"              /*maxsize*/ BUS_SPACE_MAXSIZE_24BIT,\n"
"              /*nsegments*/ BUS_SPACE_UNRESTRICTED,\n"
"              /*maxsegsz*/ BUS_SPACE_MAXSIZE_24BIT, /*flags*/ 0,\n"
"              &amp;sc-&gt;parent_tag);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          /* many things get inherited from the parent tag\n"
"           * sc-&gt;data is supposed to point to the structure with the shared data,\n"
"           * for example for a ring buffer it could be:\n"
"           * struct {\n"
"           *   u_short rd_pos;\n"
"           *   u_short wr_pos;\n"
"           *   char    bf[XXX_RING_BUFFER_SIZE]\n"
"           * } *data;\n"
"           */\n"
"          error=bus_dma_tag_create(sc-&gt;parent_tag, 1,\n"
"              0, BUS_SPACE_MAXADDR, 0, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"              /*maxsize*/ sizeof(* sc-&gt;data), /*nsegments*/ 1,\n"
"              /*maxsegsz*/ sizeof(* sc-&gt;data), /*flags*/ 0,\n"
"              &amp;sc-&gt;data_tag);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          error = bus_dmamem_alloc(sc-&gt;data_tag, &amp;sc-&gt;data, /* flags*/ 0,\n"
"              &amp;sc-&gt;data_map);\n"
"          if(error)\n"
"               goto bad;\n"
"\n"
"          /* xxx_alloc_callback() just saves the physical address at\n"
"           * the pointer passed as its argument, in this case &amp;sc-&gt;data_p.\n"
"           * See details in the section on bus memory mapping.\n"
"           * It can be implemented like:\n"
"           *\n"
"           * static void\n"
"           * xxx_alloc_callback(void *arg, bus_dma_segment_t *seg,\n"
"           *     int nseg, int error)\n"
"           * {\n"
"           *    *(bus_addr_t *)arg = seg[0].ds_addr;\n"
"           * }\n"
"           */\n"
"          bus_dmamap_load(sc-&gt;data_tag, sc-&gt;data_map, (void *)sc-&gt;data,\n"
"              sizeof (* sc-&gt;data), xxx_alloc_callback, (void *) &amp;sc-&gt;data_p,\n"
"              /*flags*/0);"

#. (itstool) path: sect1/para
#: book.translate.xml:18806
#, fuzzy
msgid ""
"After all the necessary resources are allocated the device should be "
"initialized. The initialization may include testing that all the expected "
"features are functional."
msgstr ""
"Depois que todos os recursos necess�rios s�o alocados, o dispositivo deve "
"ser inicializado. A inicializa��o pode incluir testes de que todos os "
"recursos esperados s�o funcionais."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18810
#, no-wrap
msgid ""
"          if(xxx_initialize(sc) &lt; 0)\n"
"               goto bad;        "
msgstr ""
"          if(xxx_initialize(sc) &lt; 0)\n"
"               goto bad;        "

#. (itstool) path: sect1/para
#: book.translate.xml:18814
#, fuzzy
msgid ""
"The bus subsystem will automatically print on the console the device "
"description set by probe. But if the driver wants to print some extra "
"information about the device it may do so, for example:"
msgstr ""
"O subsistema de barramento ir� imprimir automaticamente no console a "
"descri��o do dispositivo definida pela sonda. Mas se o motorista quiser "
"imprimir alguma informa��o extra sobre o dispositivo, pode faz�-lo, por "
"exemplo:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18819
#, no-wrap
msgid ""
"\n"
"        device_printf(dev, \"has on-card FIFO buffer of %d bytes\\n\", sc-&gt;fifosize);\n"
"        "
msgstr ""
"\n"
"        device_printf(dev, \"has on-card FIFO buffer of %d bytes\\n\", sc-&gt;fifosize);\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18823
#, fuzzy
msgid ""
"If the initialization routine experiences any problems then printing "
"messages about them before returning error is also recommended."
msgstr ""
"Se a rotina de inicializa��o apresentar algum problema, a impress�o de "
"mensagens sobre eles antes de retornar o erro tamb�m � recomendada."

#. (itstool) path: sect1/para
#: book.translate.xml:18827
#, fuzzy
msgid ""
"The final step of the attach routine is attaching the device to its "
"functional subsystem in the kernel. The exact way to do it depends on the "
"type of the driver: a character device, a block device, a network device, a "
"CAM SCSI bus device and so on."
msgstr ""
"A etapa final da rotina de anexa��o � anexar o dispositivo ao seu subsistema "
"funcional no kernel. A maneira exata de fazer isso depende do tipo do "
"driver: um dispositivo de caractere, um dispositivo de bloco, um dispositivo "
"de rede, um barramento CAM SCSI dispositivo e assim por diante. "

#. (itstool) path: sect1/para
#: book.translate.xml:18833
#, fuzzy
msgid "If all went well then return success."
msgstr "Se tudo correu bem, ent�o retorne o sucesso."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18835
#, no-wrap
msgid ""
"          error = xxx_attach_subsystem(sc);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          return 0;        "
msgstr ""
"          error = xxx_attach_subsystem(sc);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          return 0;        "

#. (itstool) path: sect1/para
#: book.translate.xml:18841
#, fuzzy
msgid ""
"Finally, handle the troublesome situations. All the resources should be "
"deallocated before returning an error. We make use of the fact that before "
"the structure softc is passed to us it gets zeroed out, so we can find out "
"if some resource was allocated: then its descriptor is non-zero."
msgstr ""
"Finalmente, lide com as situa��es problem�ticas. Todos os recursos devem ser "
"desalocados antes de retornar um erro. Fazemos uso do fato de que antes que "
"a estrutura seja passada para n�s, ela � zerada, para que possamos descobrir "
"se algum recurso foi alocado: ent�o seu descritor � diferente de zero. "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18848
#, no-wrap
msgid ""
"          bad:\n"
"\n"
"          xxx_free_resources(sc);\n"
"          if(error)\n"
"              return error;\n"
"          else /* exact error is unknown */\n"
"              return ENXIO;"
msgstr ""
"          bad:\n"
"\n"
"          xxx_free_resources(sc);\n"
"          if(error)\n"
"              return error;\n"
"          else /* exact error is unknown */\n"
"              return ENXIO;"

#. (itstool) path: sect1/para
#: book.translate.xml:18856
#, fuzzy
msgid "That would be all for the attach routine."
msgstr "Isso seria tudo para a rotina de anexar."

#. (itstool) path: sect1/title
#: book.translate.xml:18862
#, fuzzy
msgid "xxx_isa_detach"
msgstr "xxx_isa_detach"

#. (itstool) path: sect1/para
#: book.translate.xml:18864
#, fuzzy
msgid ""
"If this function is present in the driver and the driver is compiled as a "
"loadable module then the driver gets the ability to be unloaded. This is an "
"important feature if the hardware supports hot plug. But the ISA bus does "
"not support hot plug, so this feature is not particularly important for the "
"ISA devices. The ability to unload a driver may be useful when debugging it, "
"but in many cases installation of the new version of the driver would be "
"required only after the old version somehow wedges the system and a reboot "
"will be needed anyway, so the efforts spent on writing the detach routine "
"may not be worth it. Another argument that unloading would allow upgrading "
"the drivers on a production machine seems to be mostly theoretical. "
"Installing a new version of a driver is a dangerous operation which should "
"never be performed on a production machine (and which is not permitted when "
"the system is running in secure mode). Still, the detach routine may be "
"provided for the sake of completeness."
msgstr ""
"Se esta fun��o estiver presente no driver e o driver for compilado como um "
"m�dulo carreg�vel, o driver ter� a capacidade de ser descarregado. Esse � um "
"recurso importante se o hardware suportar hot plug. Mas o barramento ISA n�o "
"suporta hot plug, Portanto, esse recurso n�o � particularmente importante "
"para os dispositivos ISA.A capacidade de descarregar um driver pode ser �til "
"ao depur�-lo, mas em muitos casos a instala��o da nova vers�o do driver "
"seria necess�ria somente depois que a vers�o antiga de alguma forma for�ar o "
"sistema uma reinicializa��o ser� necess�ria de qualquer maneira, ent�o os "
"esfor�os gastos em escrever a rotina de desconex�o podem n�o valer a pena.Um "
"argumento de que descarregar permitiria a atualiza��o dos drivers em uma "
"m�quina de produ��o parece ser mais te�rico.A instala��o de uma nova vers�o "
"de um driver � opera��o perigosa que nunca deve ser executada em uma m�quina "
"de produ��o (e que n�o � permitida quando o sistema est� sendo executado no "
"modo seguro) .Ainda assim, a rotina de separa��o pode ser fornecida para "
"completar ess. "

#. (itstool) path: sect1/para
#: book.translate.xml:18885
#, fuzzy
msgid ""
"The detach routine returns 0 if the driver was successfully detached or the "
"error code otherwise."
msgstr ""
"A rotina de desanexa��o retorna 0 se o driver foi desconectado com sucesso "
"ou o c�digo de erro ocorreu de outra forma."

#. (itstool) path: para/programlisting
#: book.translate.xml:18899
#, no-wrap
msgid ""
"          struct xxx_softc *sc = device_get_softc(dev);\n"
"          int error;\n"
"\n"
"          error = xxx_detach_subsystem(sc);\n"
"          if(error)\n"
"              return error;"
msgstr ""
"          struct xxx_softc *sc = device_get_softc(dev);\n"
"          int error;\n"
"\n"
"          error = xxx_detach_subsystem(sc);\n"
"          if(error)\n"
"              return error;"

#. (itstool) path: sect1/para
#: book.translate.xml:18890
#, fuzzy
msgid ""
"The logic of detach is a mirror of the attach. The first thing to do is to "
"detach the driver from its kernel subsystem. If the device is currently open "
"then the driver has two choices: refuse to be detached or forcibly close and "
"proceed with detach. The choice used depends on the ability of the "
"particular kernel subsystem to do a forced close and on the preferences of "
"the driver's author. Generally the forced close seems to be the preferred "
"alternative. <_:programlisting-1/>"
msgstr ""
"A l�gica de desanexar � um espelho da conex�o. A primeira coisa a fazer � "
"separar o driver do subsistema do kernel. Se o dispositivo estiver aberto, o "
"driver tem duas op��es: recusar-se a ser desanexado ou for�osamente fechado "
"e continuar com A escolha usada depende da habilidade do subsistema do "
"kernel em fazer um fechamento for�ado e nas prefer�ncias do autor do driver."
"Geralmente, o fechamento for�ado parece ser a alternativa preferida. <_: "
"programlisting-1 /> "

#. (itstool) path: sect1/para
#: book.translate.xml:18906
#, fuzzy
msgid ""
"Next the driver may want to reset the hardware to some consistent state. "
"That includes stopping any ongoing transfers, disabling the DMA channels and "
"interrupts to avoid memory corruption by the device. For most of the drivers "
"this is exactly what the shutdown routine does, so if it is included in the "
"driver we can just call it."
msgstr ""
"Em seguida, o driver pode querer redefinir o hardware para algum estado "
"consistente. Isso inclui parar qualquer transfer�ncia em andamento, "
"desabilitar os canais DMA e interromper para evitar corrup��o de mem�ria "
"pelo dispositivo. Para a maioria dos drivers, isso � exatamente o que a "
"rotina de desligamento faz. por isso, se estiver inclu�do no driver, podemos "
"cham�-lo. "

#. (itstool) path: sect1/para
#: book.translate.xml:18914
#, fuzzy
msgid "<function>xxx_isa_shutdown(dev);</function>"
msgstr " <function> xxx_isa_shutdown (dev); </function> "

#. (itstool) path: sect1/para
#: book.translate.xml:18916
#, fuzzy
msgid ""
"And finally release all the resources and return success. <_:"
"programlisting-1/>"
msgstr ""
"E, finalmente, liberar todos os recursos e retornar o sucesso. <_: "
"Programlisting-1 />"

#. (itstool) path: sect1/title
#: book.translate.xml:18925
#, fuzzy
msgid "xxx_isa_shutdown"
msgstr "xxx_isa_shutdown"

#. (itstool) path: sect1/para
#: book.translate.xml:18927
#, fuzzy
msgid ""
"This routine is called when the system is about to be shut down. It is "
"expected to bring the hardware to some consistent state. For most of the ISA "
"devices no special action is required, so the function is not really "
"necessary because the device will be re-initialized on reboot anyway. But "
"some devices have to be shut down with a special procedure, to make sure "
"that they will be properly detected after soft reboot (this is especially "
"true for many devices with proprietary identification protocols). In any "
"case disabling DMA and interrupts in the device registers and stopping any "
"ongoing transfers is a good idea. The exact action depends on the hardware, "
"so we do not consider it here in any detail."
msgstr ""
"Essa rotina � chamada quando o sistema est� prestes a ser desligado. Espera-"
"se que o hardware fique em um estado consistente. Para a maioria dos "
"dispositivos ISA, nenhuma a��o especial � necess�ria, portanto, a fun��o n�o "
"� realmente necess�ria porque o dispositivo ser reinicializado na "
"reinicializa��o de qualquer maneira.Mas alguns dispositivos tem que ser "
"desligado com um procedimento especial, para se certificar de que eles ser�o "
"detectados corretamente ap�s a reinicializa��o suave (isso � especialmente "
"verdadeiro para muitos dispositivos com protocolos de identifica��o "
"propriet�rios). desabilitar o DMA e interromper os registros do dispositivo "
"e parar qualquer transfer�ncia em andamento � uma boa id�ia. A a��o exata "
"depende do hardware, portanto, n�o o consideramos aqui em detalhes. "

#. (itstool) path: sect1/title
#: book.translate.xml:18945
#, fuzzy
msgid "xxx_intr"
msgstr "Xxx_intr"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:18947
#, fuzzy
msgid "<primary>interrupt handler</primary>"
msgstr " <primary> manipulador de interrup��es </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:18949
#, fuzzy
msgid ""
"The interrupt handler is called when an interrupt is received which may be "
"from this particular device. The ISA bus does not support interrupt sharing "
"(except in some special cases) so in practice if the interrupt handler is "
"called then the interrupt almost for sure came from its device. Still, the "
"interrupt handler must poll the device registers and make sure that the "
"interrupt was generated by its device. If not it should just return."
msgstr ""
"O manipulador de interrup��o � chamado quando uma interrup��o � recebida, "
"que pode ser deste dispositivo em particular. O barramento ISA n�o suporta o "
"compartilhamento de interrup��es (exceto em alguns casos especiais), ent�o, "
"na pr�tica, se o manipulador de interrup��o for chamado, Ainda assim, o "
"manipulador de interrup��o deve pesquisar os registros do dispositivo e "
"certificar-se de que a interrup��o foi gerada por seu dispositivo. Caso "
"contr�rio, ele deve apenas retornar. "

#. (itstool) path: sect1/para
#: book.translate.xml:18960
#, fuzzy
msgid ""
"The old convention for the ISA drivers was getting the device unit number as "
"an argument. This is obsolete, and the new drivers receive whatever argument "
"was specified for them in the attach routine when calling "
"<function>bus_setup_intr()</function>. By the new convention it should be "
"the pointer to the structure softc. So the interrupt handler commonly starts "
"as:"
msgstr ""
"A antiga conven��o para os drivers ISA estava obtendo o n�mero da unidade do "
"dispositivo como um argumento. Isso � obsoleto e os novos drivers recebem "
"qualquer argumento especificado para eles na rotina anexar ao chamar "
"<function> bus_setup_intr () </function> . Pela nova conven��o deve ser o "
"ponteiro para a estrutura softc. Ent�o, o manipulador de interrup��o "
"geralmente come�a como: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18970
#, no-wrap
msgid ""
"\n"
"          static void\n"
"          xxx_intr(struct xxx_softc *sc)\n"
"          {\n"
"\n"
"        "
msgstr ""
"\n"
"          static void\n"
"          xxx_intr(struct xxx_softc *sc)\n"
"          {\n"
"\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18977
#, fuzzy
msgid ""
"It runs at the interrupt priority level specified by the interrupt type "
"parameter of <function>bus_setup_intr()</function>. That means that all the "
"other interrupts of the same type as well as all the software interrupts are "
"disabled."
msgstr ""
"Ele � executado no n�vel de prioridade de interrup��o especificado pelo "
"par�metro de tipo de interrup��o de <function> bus_setup_intr () </"
"function> . Isso significa que todas as outras interrup��es do mesmo tipo, "
"bem como todas as interrup��es de software, est�o desativadas. "

#. (itstool) path: sect1/para
#: book.translate.xml:18985
#, fuzzy
msgid "To avoid races it is commonly written as a loop:"
msgstr "Para evitar corridas, geralmente � escrito como um loop:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18989
#, no-wrap
msgid ""
"\n"
"          while(xxx_interrupt_pending(sc)) {\n"
"              xxx_process_interrupt(sc);\n"
"              xxx_acknowledge_interrupt(sc);\n"
"          }        "
msgstr ""
"\n"
"          while(xxx_interrupt_pending(sc)) {\n"
"              xxx_process_interrupt(sc);\n"
"              xxx_acknowledge_interrupt(sc);\n"
"          }        "

#. (itstool) path: sect1/para
#: book.translate.xml:18995
#, fuzzy
msgid ""
"The interrupt handler has to acknowledge interrupt to the device only but "
"not to the interrupt controller, the system takes care of the latter."
msgstr ""
"O handler de interrup��o tem que reconhecer a interrup��o apenas para o "
"dispositivo, mas n�o para o controlador de interrup��o, o sistema cuida do "
"�ltimo."

#. (itstool) path: chapter/title
#: book.translate.xml:19011
#, fuzzy
msgid "PCI Devices"
msgstr "Dispositivos PCI"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:19013
#, fuzzy
msgid "<primary>PCI bus</primary>"
msgstr " <primary> Barramento PCI </primary> "

#. (itstool) path: chapter/para
#: book.translate.xml:19015
#, fuzzy
msgid ""
"This chapter will talk about the FreeBSD mechanisms for writing a device "
"driver for a device on a PCI bus."
msgstr ""
"Este cap�tulo vai falar sobre os mecanismos do FreeBSD para escrever um "
"driver de dispositivo para um dispositivo em um barramento PCI."

#. (itstool) path: sect1/title
#: book.translate.xml:19019
#, fuzzy
msgid "Probe and Attach"
msgstr "Sonda e Anexar"

#. (itstool) path: sect1/para
#: book.translate.xml:19021
#, fuzzy
msgid ""
"Information here about how the PCI bus code iterates through the unattached "
"devices and see if a newly loaded kld will attach to any of them."
msgstr ""
"Informa��es aqui sobre como o c�digo de barramento PCI percorre os "
"dispositivos n�o conectados e ver se um kld rec�m-carregado ser� anexado a "
"qualquer um deles."

#. (itstool) path: sect2/title
#: book.translate.xml:19026
#, fuzzy
msgid "Sample Driver Source (<filename>mypci.c</filename>)"
msgstr "Exemplo de fonte de driver ( <filename> mypci.c </filename> ) "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19029
#, no-wrap
msgid ""
"/*\n"
" * Simple KLD to play with the PCI functions.\n"
" *\n"
" * Murray Stokely\n"
" */\n"
"\n"
"#include &lt;sys/param.h&gt;\t\t/* defines used in kernel.h */\n"
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/systm.h&gt;\n"
"#include &lt;sys/errno.h&gt;\n"
"#include &lt;sys/kernel.h&gt;\t\t/* types used in module initialization */\n"
"#include &lt;sys/conf.h&gt;\t\t/* cdevsw struct */\n"
"#include &lt;sys/uio.h&gt;\t\t/* uio struct */\n"
"#include &lt;sys/malloc.h&gt;\n"
"#include &lt;sys/bus.h&gt;\t\t/* structs, prototypes for pci bus stuff and DEVMETHOD macros! */\n"
"\n"
"#include &lt;machine/bus.h&gt;\n"
"#include &lt;sys/rman.h&gt;\n"
"#include &lt;machine/resource.h&gt;\n"
"\n"
"#include &lt;dev/pci/pcivar.h&gt;\t/* For pci_get macros! */\n"
"#include &lt;dev/pci/pcireg.h&gt;\n"
"\n"
"/* The softc holds our per-instance data. */\n"
"struct mypci_softc {\n"
"\tdevice_t\tmy_dev;\n"
"\tstruct cdev\t*my_cdev;\n"
"};\n"
"\n"
"/* Function prototypes */\n"
"static d_open_t\t\tmypci_open;\n"
"static d_close_t\tmypci_close;\n"
"static d_read_t\t\tmypci_read;\n"
"static d_write_t\tmypci_write;\n"
"\n"
"/* Character device entry points */\n"
"\n"
"static struct cdevsw mypci_cdevsw = {\n"
"\t.d_version =\tD_VERSION,\n"
"\t.d_open =\tmypci_open,\n"
"\t.d_close =\tmypci_close,\n"
"\t.d_read =\tmypci_read,\n"
"\t.d_write =\tmypci_write,\n"
"\t.d_name =\t\"mypci\",\n"
"};\n"
"\n"
"/*\n"
" * In the cdevsw routines, we find our softc by using the si_drv1 member\n"
" * of struct cdev.  We set this variable to point to our softc in our\n"
" * attach routine when we create the /dev entry.\n"
" */\n"
"\n"
"int\n"
"mypci_open(struct cdev *dev, int oflags, int devtype, struct thread *td)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\t/* Look up our softc. */\n"
"\tsc = dev-&gt;si_drv1;\n"
"\tdevice_printf(sc-&gt;my_dev, \"Opened successfully.\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"int\n"
"mypci_close(struct cdev *dev, int fflag, int devtype, struct thread *td)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\t/* Look up our softc. */\n"
"\tsc = dev-&gt;si_drv1;\n"
"\tdevice_printf(sc-&gt;my_dev, \"Closed.\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"int\n"
"mypci_read(struct cdev *dev, struct uio *uio, int ioflag)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\t/* Look up our softc. */\n"
"\tsc = dev-&gt;si_drv1;\n"
"\tdevice_printf(sc-&gt;my_dev, \"Asked to read %zd bytes.\\n\", uio-&gt;uio_resid);\n"
"\treturn (0);\n"
"}\n"
"\n"
"int\n"
"mypci_write(struct cdev *dev, struct uio *uio, int ioflag)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\t/* Look up our softc. */\n"
"\tsc = dev-&gt;si_drv1;\n"
"\tdevice_printf(sc-&gt;my_dev, \"Asked to write %zd bytes.\\n\", uio-&gt;uio_resid);\n"
"\treturn (0);\n"
"}\n"
"\n"
"/* PCI Support Functions */\n"
"\n"
"/*\n"
" * Compare the device ID of this device against the IDs that this driver\n"
" * supports.  If there is a match, set the description and return success.\n"
" */\n"
"static int\n"
"mypci_probe(device_t dev)\n"
"{\n"
"\n"
"\tdevice_printf(dev, \"MyPCI Probe\\nVendor ID : 0x%x\\nDevice ID : 0x%x\\n\",\n"
"\t    pci_get_vendor(dev), pci_get_device(dev));\n"
"\n"
"\tif (pci_get_vendor(dev) == 0x11c1) {\n"
"\t\tprintf(\"We've got the Winmodem, probe successful!\\n\");\n"
"\t\tdevice_set_desc(dev, \"WinModem\");\n"
"\t\treturn (BUS_PROBE_DEFAULT);\n"
"\t}\n"
"\treturn (ENXIO);\n"
"}\n"
"\n"
"/* Attach function is only called if the probe is successful. */\n"
"\n"
"static int\n"
"mypci_attach(device_t dev)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\tprintf(\"MyPCI Attach for : deviceID : 0x%x\\n\", pci_get_devid(dev));\n"
"\n"
"\t/* Look up our softc and initialize its fields. */\n"
"\tsc = device_get_softc(dev);\n"
"\tsc-&gt;my_dev = dev;\n"
"\n"
"\t/*\n"
"\t * Create a /dev entry for this device.  The kernel will assign us\n"
"\t * a major number automatically.  We use the unit number of this\n"
"\t * device as the minor number and name the character device\n"
"\t * \"mypci&lt;unit&gt;\".\n"
"\t */\n"
"\tsc-&gt;my_cdev = make_dev(<literal>&amp;</literal>mypci_cdevsw, device_get_unit(dev),\n"
"\t    UID_ROOT, GID_WHEEL, 0600, \"mypci%u\", device_get_unit(dev));\n"
"\tsc-&gt;my_cdev-&gt;si_drv1 = sc;\n"
"\tprintf(\"Mypci device loaded.\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/* Detach device. */\n"
"\n"
"static int\n"
"mypci_detach(device_t dev)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\t/* Teardown the state in our softc created in our attach routine. */\n"
"\tsc = device_get_softc(dev);\n"
"\tdestroy_dev(sc-&gt;my_cdev);\n"
"\tprintf(\"Mypci detach!\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/* Called during system shutdown after sync. */\n"
"\n"
"static int\n"
"mypci_shutdown(device_t dev)\n"
"{\n"
"\n"
"\tprintf(\"Mypci shutdown!\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/*\n"
" * Device suspend routine.\n"
" */\n"
"static int\n"
"mypci_suspend(device_t dev)\n"
"{\n"
"\n"
"\tprintf(\"Mypci suspend!\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/*\n"
" * Device resume routine.\n"
" */\n"
"static int\n"
"mypci_resume(device_t dev)\n"
"{\n"
"\n"
"\tprintf(\"Mypci resume!\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"static device_method_t mypci_methods[] = {\n"
"\t/* Device interface */\n"
"\tDEVMETHOD(device_probe,\t\tmypci_probe),\n"
"\tDEVMETHOD(device_attach,\tmypci_attach),\n"
"\tDEVMETHOD(device_detach,\tmypci_detach),\n"
"\tDEVMETHOD(device_shutdown,\tmypci_shutdown),\n"
"\tDEVMETHOD(device_suspend,\tmypci_suspend),\n"
"\tDEVMETHOD(device_resume,\tmypci_resume),\n"
"\n"
"\tDEVMETHOD_END\n"
"};\n"
"\n"
"static devclass_t mypci_devclass;\n"
"\n"
"DEFINE_CLASS_0(mypci, mypci_driver, mypci_methods, sizeof(struct mypci_softc));\n"
"DRIVER_MODULE(mypci, pci, mypci_driver, mypci_devclass, 0, 0);"
msgstr ""

#. (itstool) path: sect2/title
#: book.translate.xml:19237
#, fuzzy
msgid "<filename>Makefile</filename> for Sample Driver"
msgstr " <filename> Makefile </filename> para o driver de exemplo "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19239
#, no-wrap
msgid ""
"# Makefile for mypci driver\n"
"\n"
"KMOD=\tmypci\n"
"SRCS=\tmypci.c\n"
"SRCS+=\tdevice_if.h bus_if.h pci_if.h\n"
"\n"
".include &lt;bsd.kmod.mk&gt;"
msgstr ""
"# Makefile for mypci driver\n"
"\n"
"KMOD=\tmypci\n"
"SRCS=\tmypci.c\n"
"SRCS+=\tdevice_if.h bus_if.h pci_if.h\n"
"\n"
".include &lt;bsd.kmod.mk&gt;"

#. (itstool) path: sect2/para
#: book.translate.xml:19247
#, fuzzy
msgid ""
"If you place the above source file and <filename>Makefile</filename> into a "
"directory, you may run <command>make</command> to compile the sample driver. "
"Additionally, you may run <command>make load</command> to load the driver "
"into the currently running kernel and <command>make unload</command> to "
"unload the driver after it is loaded."
msgstr ""
"Se voc� colocar o arquivo de origem acima e <filename> Makefile </filename> "
"em um diret�rio, voc� pode executar <command> fa�o </command> para compilar "
"o driver de exemplo. Al�m disso, voc� pode executar <command> fazer carga </"
"command> para carregar o driver no kernel atualmente em execu��o e <command> "
"descarregar </command> para descarregar o driver depois que ele for "
"carregado. "

#. (itstool) path: sect2/title
#: book.translate.xml:19257
#, fuzzy
msgid "Additional Resources"
msgstr "Recursos adicionais"

#. (itstool) path: listitem/simpara
#: book.translate.xml:19261
#, fuzzy
msgid ""
"<link xlink:href=\"http://www.pcisig.org/\">PCI Special Interest Group</link>"
msgstr ""
" <link xlink:href=\"http://www.pcisig.org/\"> Grupo de Interesse Especial "
"PCI </link> "

#. (itstool) path: listitem/simpara
#: book.translate.xml:19265
#, fuzzy
msgid "PCI System Architecture, Fourth Edition by Tom Shanley, et al."
msgstr "PCI System Architecture, quarta edi��o por Tom Shanley, et al."

#. (itstool) path: sect1/title
#: book.translate.xml:19273
#, fuzzy
msgid "Bus Resources"
msgstr "Recursos de �nibus"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19275
#, fuzzy
msgid "<primary>PCI bus</primary><secondary>resources</secondary>"
msgstr " <primary> Barramento PCI </primary><secondary> Recursos </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:19277
#, fuzzy
msgid ""
"FreeBSD provides an object-oriented mechanism for requesting resources from "
"a parent bus. Almost all devices will be a child member of some sort of bus "
"(PCI, ISA, USB, SCSI, etc) and these devices need to acquire resources from "
"their parent bus (such as memory segments, interrupt lines, or DMA channels)."
msgstr ""
"O FreeBSD fornece um mecanismo orientado a objeto para solicitar recursos de "
"um barramento pai. Quase todos os dispositivos ser�o um membro filho de "
"algum tipo de barramento (PCI, ISA, USB, SCSI, etc) e esses dispositivos "
"precisam adquirir recursos de seus pais. barramento (como segmentos de "
"mem�ria, linhas de interrup��o ou canais DMA). "

#. (itstool) path: sect2/title
#: book.translate.xml:19284
#, fuzzy
msgid "Base Address Registers"
msgstr "Registros de endere�o base"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:19286
#, fuzzy
msgid "<primary>PCI bus</primary><secondary>Base Address Registers</secondary>"
msgstr ""
" <primary> Barramento PCI </primary><secondary> Registradores de endere�os "
"base </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:19289
#, fuzzy
msgid ""
"To do anything particularly useful with a PCI device you will need to obtain "
"the <emphasis>Base Address Registers</emphasis> (BARs) from the PCI "
"Configuration space. The PCI-specific details of obtaining the BAR are "
"abstracted in the <function>bus_alloc_resource()</function> function."
msgstr ""
"Para fazer algo particularmente �til com um dispositivo PCI, voc� precisar� "
"obter o <emphasis> Registradores de endere�os base </emphasis> (BARs) do "
"espa�o de configura��o PCI. Os detalhes espec�ficos do PCI para obter a BAR "
"s�o resumidos no <function> bus_alloc_resource () </function> fun��o."

#. (itstool) path: sect2/para
#: book.translate.xml:19296
#, fuzzy
msgid ""
"For example, a typical driver might have something similar to this in the "
"<function>attach()</function> function:"
msgstr ""
"Por exemplo, um driver t�pico pode ter algo semelhante a isso no <function> "
"anexar() </function> fun��o:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19299
#, no-wrap
msgid ""
"    sc-&gt;bar0id = PCIR_BAR(0);\n"
"    sc-&gt;bar0res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;sc-&gt;bar0id,\n"
"\t\t\t\t  0, ~0, 1, RF_ACTIVE);\n"
"    if (sc-&gt;bar0res == NULL) {\n"
"        printf(\"Memory allocation of PCI base register 0 failed!\\n\");\n"
"        error = ENXIO;\n"
"        goto fail1;\n"
"    }\n"
"\n"
"    sc-&gt;bar1id = PCIR_BAR(1);\n"
"    sc-&gt;bar1res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;sc-&gt;bar1id,\n"
"\t\t\t\t  0, ~0, 1, RF_ACTIVE);\n"
"    if (sc-&gt;bar1res == NULL) {\n"
"        printf(\"Memory allocation of PCI base register 1 failed!\\n\");\n"
"        error =  ENXIO;\n"
"        goto fail2;\n"
"    }\n"
"    sc-&gt;bar0_bt = rman_get_bustag(sc-&gt;bar0res);\n"
"    sc-&gt;bar0_bh = rman_get_bushandle(sc-&gt;bar0res);\n"
"    sc-&gt;bar1_bt = rman_get_bustag(sc-&gt;bar1res);\n"
"    sc-&gt;bar1_bh = rman_get_bushandle(sc-&gt;bar1res);"
msgstr ""
"    sc-&gt;bar0id = PCIR_BAR(0);\n"
"    sc-&gt;bar0res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;sc-&gt;bar0id,\n"
"\t\t\t\t  0, ~0, 1, RF_ACTIVE);\n"
"    if (sc-&gt;bar0res == NULL) {\n"
"        printf(\"Memory allocation of PCI base register 0 failed!\\n\");\n"
"        error = ENXIO;\n"
"        goto fail1;\n"
"    }\n"
"\n"
"    sc-&gt;bar1id = PCIR_BAR(1);\n"
"    sc-&gt;bar1res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;sc-&gt;bar1id,\n"
"\t\t\t\t  0, ~0, 1, RF_ACTIVE);\n"
"    if (sc-&gt;bar1res == NULL) {\n"
"        printf(\"Memory allocation of PCI base register 1 failed!\\n\");\n"
"        error =  ENXIO;\n"
"        goto fail2;\n"
"    }\n"
"    sc-&gt;bar0_bt = rman_get_bustag(sc-&gt;bar0res);\n"
"    sc-&gt;bar0_bh = rman_get_bushandle(sc-&gt;bar0res);\n"
"    sc-&gt;bar1_bt = rman_get_bustag(sc-&gt;bar1res);\n"
"    sc-&gt;bar1_bh = rman_get_bushandle(sc-&gt;bar1res);"

#. (itstool) path: sect2/para
#: book.translate.xml:19321
#, fuzzy
msgid ""
"Handles for each base address register are kept in the <varname remap="
"\"structname\">softc</varname> structure so that they can be used to write "
"to the device later."
msgstr ""
"As al�as para cada registro de endere�o base s�o mantidas na <varname remap="
"\"structname\"> softc </varname> estrutura para que eles possam ser usados ​​"
"para gravar no dispositivo mais tarde \""

#. (itstool) path: sect2/para
#: book.translate.xml:19325
#, fuzzy
msgid ""
"These handles can then be used to read or write from the device registers "
"with the <function>bus_space_*</function> functions. For example, a driver "
"might contain a shorthand function to read from a board specific register "
"like this:"
msgstr ""
"Essas al�as podem ser usadas para ler ou gravar nos registros do dispositivo "
"com o <function> bus_space_ * </function> fun��es. Por exemplo, um driver "
"pode conter uma fun��o abreviada para ler de um registro espec�fico da placa "
"como este: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19331
#, fuzzy, no-wrap
#| msgid ""
#| "uint16_t\n"
#| "board_read(struct ni_softc *sc, uint16_t address)\n"
#| "{\n"
#| "    return bus_space_read_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address);\n"
#| "}\n"
msgid ""
"uint16_t\n"
"board_read(struct ni_softc *sc, uint16_t address)\n"
"{\n"
"    return bus_space_read_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address);\n"
"}"
msgstr ""
"uint16_t\n"
"board_read(struct ni_softc *sc, uint16_t address)\n"
"{\n"
"    return bus_space_read_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address);\n"
"}\n"

#. (itstool) path: sect2/para
#: book.translate.xml:19337
#, fuzzy
msgid "Similarly, one could write to the registers with:"
msgstr "Da mesma forma, pode-se escrever para os registros com:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19339
#, fuzzy, no-wrap
#| msgid ""
#| "void\n"
#| "board_write(struct ni_softc *sc, uint16_t address, uint16_t value)\n"
#| "{\n"
#| "    bus_space_write_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address, value);\n"
#| "}\n"
msgid ""
"void\n"
"board_write(struct ni_softc *sc, uint16_t address, uint16_t value)\n"
"{\n"
"    bus_space_write_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address, value);\n"
"}"
msgstr ""
"void\n"
"board_write(struct ni_softc *sc, uint16_t address, uint16_t value)\n"
"{\n"
"    bus_space_write_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address, value);\n"
"}\n"

#. (itstool) path: sect2/para
#: book.translate.xml:19345
#, fuzzy
msgid ""
"These functions exist in 8bit, 16bit, and 32bit versions and you should use "
"<function>bus_space_{read|write}_{1|2|4}</function> accordingly."
msgstr ""
"Estas fun��es existem nas vers�es 8bit, 16bit e 32bit e voc� deve usar "
"<function> bus_space_ {leia | escreva} _ {1 | 2 | 4} </function> "
"adequadamente."

#. (itstool) path: note/para
#: book.translate.xml:19351
#, fuzzy
msgid ""
"In FreeBSD 7.0 and later, you can use the <function>bus_*</function> "
"functions instead of <function>bus_space_*</function>. The <function>bus_*</"
"function> functions take a <type>struct resource *</type> pointer instead of "
"a bus tag and handle. Thus, you could drop the bus tag and bus handle "
"members from the <varname remap=\"structname\">softc</varname> and rewrite "
"the <function>board_read()</function> function as:"
msgstr ""
"No FreeBSD 7.0 e posterior, voc� pode usar o <function> �nibus_* </function> "
"fun��es em vez de <function> bus_space_ * </function> . o <function> "
"�nibus_* </function> fun��es tomar um <type> recurso struct </type> ponteiro "
"em vez de uma marca de barramento e identificador. Assim, voc� pode soltar a "
"tag de barramento e os membros da barra de bus do <varname remap=\"structname"
"\"> softc </varname> e reescrever o <function> board_read () </function> "
"funciona como:"

#. (itstool) path: note/programlisting
#: book.translate.xml:19360
#, fuzzy, no-wrap
#| msgid ""
#| "uint16_t\n"
#| "board_read(struct ni_softc *sc, uint16_t address)\n"
#| "{\n"
#| "\treturn (bus_read(sc-&gt;bar1res, address));\n"
#| "}\n"
msgid ""
"uint16_t\n"
"board_read(struct ni_softc *sc, uint16_t address)\n"
"{\n"
"\treturn (bus_read(sc-&gt;bar1res, address));\n"
"}"
msgstr ""
"uint16_t\n"
"board_read(struct ni_softc *sc, uint16_t address)\n"
"{\n"
"\treturn (bus_read(sc-&gt;bar1res, address));\n"
"}\n"

#. (itstool) path: sect2/title
#. (itstool) path: sect1/title
#: book.translate.xml:19369 book.translate.xml:21178
#, fuzzy
msgid "Interrupts"
msgstr "Interrompe"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:19371
#, fuzzy
msgid "<primary>PCI bus</primary><secondary>interrupts</secondary>"
msgstr ""
" <primary> Barramento PCI </primary><secondary> interrompe </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:19374
#, fuzzy
msgid ""
"Interrupts are allocated from the object-oriented bus code in a way similar "
"to the memory resources. First an IRQ resource must be allocated from the "
"parent bus, and then the interrupt handler must be set up to deal with this "
"IRQ."
msgstr ""
"As interrup��es s�o alocadas a partir do c�digo de barramento orientado a "
"objetos de maneira semelhante aos recursos de mem�ria. Primeiro, um recurso "
"de IRQ deve ser alocado a partir do barramento pai e, em seguida, o "
"manipulador de interrup��o deve ser configurado para lidar com esse IRQ."

#. (itstool) path: sect2/para
#: book.translate.xml:19379
#, fuzzy
msgid ""
"Again, a sample from a device <function>attach()</function> function says "
"more than words."
msgstr ""
"Mais uma vez, uma amostra de um dispositivo <function> anexar() </function> "
"fun��o diz mais que palavras \""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19383
#, fuzzy, no-wrap
#| msgid ""
#| "/* Get the IRQ resource */\n"
#| "\n"
#| "    sc-&gt;irqid = 0x0;\n"
#| "    sc-&gt;irqres = bus_alloc_resource(dev, SYS_RES_IRQ, &amp;(sc-&gt;irqid),\n"
#| "\t\t\t\t  0, ~0, 1, RF_SHAREABLE | RF_ACTIVE);\n"
#| "    if (sc-&gt;irqres == NULL) {\n"
#| "\tprintf(\"IRQ allocation failed!\\n\");\n"
#| "\terror = ENXIO;\n"
#| "\tgoto fail3;\n"
#| "    }\n"
#| "\n"
#| "    /* Now we should set up the interrupt handler */\n"
#| "\n"
#| "    error = bus_setup_intr(dev, sc-&gt;irqres, INTR_TYPE_MISC,\n"
#| "\t\t\t   my_handler, sc, &amp;(sc-&gt;handler));\n"
#| "    if (error) {\n"
#| "\tprintf(\"Couldn't set up irq\\n\");\n"
#| "\tgoto fail4;\n"
#| "    }\n"
msgid ""
"/* Get the IRQ resource */\n"
"\n"
"    sc-&gt;irqid = 0x0;\n"
"    sc-&gt;irqres = bus_alloc_resource(dev, SYS_RES_IRQ, &amp;(sc-&gt;irqid),\n"
"\t\t\t\t  0, ~0, 1, RF_SHAREABLE | RF_ACTIVE);\n"
"    if (sc-&gt;irqres == NULL) {\n"
"\tprintf(\"IRQ allocation failed!\\n\");\n"
"\terror = ENXIO;\n"
"\tgoto fail3;\n"
"    }\n"
"\n"
"    /* Now we should set up the interrupt handler */\n"
"\n"
"    error = bus_setup_intr(dev, sc-&gt;irqres, INTR_TYPE_MISC,\n"
"\t\t\t   my_handler, sc, &amp;(sc-&gt;handler));\n"
"    if (error) {\n"
"\tprintf(\"Couldn't set up irq\\n\");\n"
"\tgoto fail4;\n"
"    }"
msgstr ""
"/* Get the IRQ resource */\n"
"\n"
"    sc-&gt;irqid = 0x0;\n"
"    sc-&gt;irqres = bus_alloc_resource(dev, SYS_RES_IRQ, &amp;(sc-&gt;irqid),\n"
"\t\t\t\t  0, ~0, 1, RF_SHAREABLE | RF_ACTIVE);\n"
"    if (sc-&gt;irqres == NULL) {\n"
"\tprintf(\"IRQ allocation failed!\\n\");\n"
"\terror = ENXIO;\n"
"\tgoto fail3;\n"
"    }\n"
"\n"
"    /* Now we should set up the interrupt handler */\n"
"\n"
"    error = bus_setup_intr(dev, sc-&gt;irqres, INTR_TYPE_MISC,\n"
"\t\t\t   my_handler, sc, &amp;(sc-&gt;handler));\n"
"    if (error) {\n"
"\tprintf(\"Couldn't set up irq\\n\");\n"
"\tgoto fail4;\n"
"    }\n"

#. (itstool) path: sect2/para
#: book.translate.xml:19403
#, fuzzy
msgid ""
"Some care must be taken in the detach routine of the driver. You must "
"quiesce the device's interrupt stream, and remove the interrupt handler. "
"Once <function>bus_teardown_intr()</function> has returned, you know that "
"your interrupt handler will no longer be called and that all threads that "
"might have been executing this interrupt handler have returned. Since this "
"function can sleep, you must not hold any mutexes when calling this function."
msgstr ""
"Alguns cuidados devem ser tomados na rotina de desconex�o do driver. Voc� "
"deve desativar o fluxo de interrup��o do dispositivo e remover o manipulador "
"de interrup��o. <function> bus_teardown_intr () </function> retornou, voc� "
"sabe que seu manipulador de interrup��es n�o ser� mais chamado e que todos "
"os encadeamentos que podem estar executando este manipulador de interrup��es "
"retornaram. Como esta fun��o pode dormir, voc� n�o deve manter nenhum mutex "
"ao chamar esta fun��o. "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:19416
#, fuzzy
msgid "<primary>PCI bus</primary><secondary>DMA</secondary>"
msgstr " <primary> Barramento PCI </primary><secondary> DMA </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:19419
#, fuzzy
msgid ""
"This section is obsolete, and present only for historical reasons. The "
"proper methods for dealing with these issues is to use the "
"<function>bus_space_dma*()</function> functions instead. This paragraph can "
"be removed when this section is updated to reflect that usage. However, at "
"the moment, the API is in a bit of flux, so once that settles down, it would "
"be good to update this section to reflect that."
msgstr ""
"Esta se��o � obsoleta e est� presente apenas por raz�es hist�ricas. Os "
"m�todos apropriados para lidar com essas quest�es � usar <function> "
"bus_space_dma * () </function> funciona em vez disso. Este par�grafo pode "
"ser removido quando esta se��o for atualizada para refletir esse uso. No "
"entanto, no momento, a API est� em um pouco de fluxo, portanto, uma vez que "
"isso se resolva, seria bom atualizar esta se��o para refletir isso. "

#. (itstool) path: sect2/para
#: book.translate.xml:19427
#, fuzzy
msgid ""
"On the PC, peripherals that want to do bus-mastering DMA must deal with "
"physical addresses. This is a problem since FreeBSD uses virtual memory and "
"deals almost exclusively with virtual addresses. Fortunately, there is a "
"function, <function>vtophys()</function> to help."
msgstr ""
"No PC, perif�ricos que querem fazer bus masteriza��o devem lidar com "
"endere�os f�sicos. Isso � um problema j� que o FreeBSD usa mem�ria virtual e "
"lida quase exclusivamente com endere�os virtuais. Felizmente, existe uma "
"fun��o, <function> vtophys () </function> ajudar."

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19433
#, fuzzy, no-wrap
#| msgid ""
#| "#include &lt;vm/vm.h&gt;\n"
#| "#include &lt;vm/pmap.h&gt;\n"
#| "\n"
#| "#define vtophys(virtual_address) (...)\n"
msgid ""
"#include &lt;vm/vm.h&gt;\n"
"#include &lt;vm/pmap.h&gt;\n"
"\n"
"#define vtophys(virtual_address) (...)"
msgstr ""
"#include &lt;vm/vm.h&gt;\n"
"#include &lt;vm/pmap.h&gt;\n"
"\n"
"#define vtophys(virtual_address) (...)\n"

#. (itstool) path: sect2/para
#: book.translate.xml:19438
#, fuzzy
msgid ""
"The solution is a bit different on the alpha however, and what we really "
"want is a function called <function>vtobus()</function>."
msgstr ""
"A solu��o � um pouco diferente no alfa, e o que realmente queremos � uma "
"fun��o chamada <function> vtobus () </function> "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19442
#, fuzzy, no-wrap
#| msgid ""
#| "#if defined(__alpha__)\n"
#| "#define vtobus(va)      alpha_XXX_dmamap((vm_offset_t)va)\n"
#| "#else\n"
#| "#define vtobus(va)      vtophys(va)\n"
#| "#endif\n"
msgid ""
"#if defined(__alpha__)\n"
"#define vtobus(va)      alpha_XXX_dmamap((vm_offset_t)va)\n"
"#else\n"
"#define vtobus(va)      vtophys(va)\n"
"#endif"
msgstr ""
"#if defined(__alpha__)\n"
"#define vtobus(va)      alpha_XXX_dmamap((vm_offset_t)va)\n"
"#else\n"
"#define vtobus(va)      vtophys(va)\n"
"#endif\n"

#. (itstool) path: sect2/title
#: book.translate.xml:19450
#, fuzzy
msgid "Deallocating Resources"
msgstr "Recursos de desaloca��o"

#. (itstool) path: sect2/para
#: book.translate.xml:19452
#, fuzzy
msgid ""
"It is very important to deallocate all of the resources that were allocated "
"during <function>attach()</function>. Care must be taken to deallocate the "
"correct stuff even on a failure condition so that the system will remain "
"usable while your driver dies."
msgstr ""
"� muito importante desalocar todos os recursos que foram alocados durante a "
"<function> anexar() </function> . � preciso tomar cuidado para desalocar o "
"material correto, mesmo em uma condi��o de falha, para que o sistema "
"permane�a utiliz�vel enquanto o driver morre. "

#. (itstool) path: info/title
#: book.translate.xml:19468
#, fuzzy
msgid "Common Access Method SCSI Controllers"
msgstr "Controladores SCSI do M�todo de Acesso Comum"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19482
#, fuzzy
msgid "<primary>SCSI</primary>"
msgstr " <primary> SCSI </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:19483
#, fuzzy
msgid ""
"This document assumes that the reader has a general understanding of device "
"drivers in FreeBSD and of the SCSI protocol. Much of the information in this "
"document was extracted from the drivers:"
msgstr ""
"Este documento pressup�e que o leitor tenha uma compreens�o geral dos "
"drivers de dispositivos no FreeBSD e no protocolo SCSI. Muitas das "
"informa��es contidas neste documento foram extra�das dos drivers:"

#. (itstool) path: listitem/para
#: book.translate.xml:19490
#, fuzzy
msgid ""
"ncr (<filename>/sys/pci/ncr.c</filename>) by Wolfgang Stanglmeier and Stefan "
"Esser"
msgstr ""
"ncr ( <filename> /sys/pci/ncr.c </filename> ) de Wolfgang Stanglmeier e "
"Stefan Esser "

#. (itstool) path: listitem/para
#: book.translate.xml:19494
#, fuzzy
msgid "sym (<filename>/sys/dev/sym/sym_hipd.c</filename>) by Gerard Roudier"
msgstr ""
"sym ( <filename> /sys/dev/sym/sym_hipd.c </filename> ) de Gerard Roudier "

#. (itstool) path: listitem/para
#: book.translate.xml:19499
#, fuzzy
msgid ""
"aic7xxx (<filename>/sys/dev/aic7xxx/aic7xxx.c</filename>) by Justin T. Gibbs"
msgstr ""
"aic7xxx ( <filename> /sys/dev/aic7xxx/aic7xxx.c </filename> ) por Justin T. "
"Gibbs "

#. (itstool) path: sect1/para
#: book.translate.xml:19505
#, fuzzy
msgid ""
"and from the CAM code itself (by Justin T. Gibbs, see <filename>/sys/cam/*</"
"filename>). When some solution looked the most logical and was essentially "
"verbatim extracted from the code by Justin T. Gibbs, I marked it as "
"<quote>recommended</quote>."
msgstr ""
"e do pr�prio c�digo CAM (por Justin T. Gibbs, veja <filename> / sys / cam / "
"* </filename> ). Quando alguma solu��o parecia a mais l�gica e "
"essencialmente extra�da do c�digo por Justin T. Gibbs, eu a marquei como "
"<quote> recomendado </quote> "

#. (itstool) path: sect1/para
#: book.translate.xml:19511
#, fuzzy
msgid ""
"The document is illustrated with examples in pseudo-code. Although sometimes "
"the examples have many details and look like real code, it is still pseudo-"
"code. It was written to demonstrate the concepts in an understandable way. "
"For a real driver other approaches may be more modular and efficient. It "
"also abstracts from the hardware details, as well as issues that would cloud "
"the demonstrated concepts or that are supposed to be described in the other "
"chapters of the developers handbook. Such details are commonly shown as "
"calls to functions with descriptive names, comments or pseudo-statements. "
"Fortunately real life full-size examples with all the details can be found "
"in the real drivers."
msgstr ""
"O documento � ilustrado com exemplos em pseudo-c�digo. Embora algumas vezes "
"os exemplos tenham muitos detalhes e pare�am com c�digo real, ainda � pseudo-"
"c�digo. Foi escrito para demonstrar os conceitos de uma maneira "
"compreens�vel. Para um driver real outras abordagens pode ser mais modular e "
"eficiente, al�m de abstrair os detalhes do hardware, bem como problemas que "
"poderiam ofuscar os conceitos demonstrados ou que deveriam ser descritos nos "
"outros cap�tulos do manual do desenvolvedor.Tais detalhes s�o comumente "
"mostrados como chamadas para fun��es com nomes descritivos, coment�rios ou "
"pseudo-declara��es. Felizmente exemplos em tamanho real com todos os "
"detalhes podem ser encontrados nos drivers reais. "

#. (itstool) path: sect1/title
#: book.translate.xml:19526
#, fuzzy
msgid "General Architecture"
msgstr "Arquitetura Geral"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19528
#, fuzzy
msgid "<primary>Common Access Method (CAM)</primary>"
msgstr " <primary> M�todo de acesso comum (CAM) </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:19532
#, fuzzy
msgid ""
"CAM stands for Common Access Method. It is a generic way to address the I/O "
"buses in a SCSI-like way. This allows a separation of the generic device "
"drivers from the drivers controlling the I/O bus: for example the disk "
"driver becomes able to control disks on both SCSI, IDE, and/or any other bus "
"so the disk driver portion does not have to be rewritten (or copied and "
"modified) for every new I/O bus. Thus the two most important active entities "
"are:"
msgstr ""
"CAM significa Common Access Method. � uma maneira gen�rica de endere�ar os "
"barramentos de E / S de maneira SCSI. Isso permite uma separa��o dos drivers "
"de dispositivos gen�ricos dos drivers que controlam o barramento de E / S: "
"por exemplo, o disco O driver torna-se capaz de controlar discos em SCSI, "
"IDE e / ou qualquer outro barramento, portanto a parte do driver de disco "
"n�o precisa ser reescrita (ou copiada e modificada) para cada novo "
"barramento de E / S. estamos:"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19541
#, fuzzy
msgid "<primary>CD-ROM</primary>"
msgstr " <primary> CD-ROM </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19542
#, fuzzy
msgid "<primary>tape</primary>"
msgstr " <primary> fita </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19543
#, fuzzy
msgid "<primary>IDE</primary>"
msgstr " <primary> AQUI </primary> "

#. (itstool) path: listitem/para
#: book.translate.xml:19546
#, fuzzy
msgid ""
"<emphasis>Peripheral Modules</emphasis> - a driver for peripheral devices "
"(disk, tape, CD-ROM, etc.)"
msgstr ""
" <emphasis> M�dulos Perif�ricos </emphasis> - um driver para dispositivos "
"perif�ricos (disco, fita, CD-ROM, etc.) "

#. (itstool) path: listitem/para
#: book.translate.xml:19552
#, fuzzy
msgid ""
"<emphasis>SCSI Interface Modules </emphasis>(SIM) - a Host Bus Adapter "
"drivers for connecting to an I/O bus such as SCSI or IDE."
msgstr ""
" <emphasis> M�dulos de Interface SCSI </emphasis> (SIM) - drivers do Host "
"Bus Adapter para conex�o com um barramento de E / S, como SCSI ou IDE. "

#. (itstool) path: sect1/para
#: book.translate.xml:19558
#, fuzzy
msgid ""
"A peripheral driver receives requests from the OS, converts them to a "
"sequence of SCSI commands and passes these SCSI commands to a SCSI Interface "
"Module. The SCSI Interface Module is responsible for passing these commands "
"to the actual hardware (or if the actual hardware is not SCSI but, for "
"example, IDE then also converting the SCSI commands to the native commands "
"of the hardware)."
msgstr ""
"Um driver perif�rico recebe solicita��es do SO, converte-as em uma sequ�ncia "
"de comandos SCSI e passa esses comandos SCSI para um M�dulo de Interface "
"SCSI. O M�dulo de Interface SCSI � respons�vel por passar esses comandos ao "
"hardware real (ou se o hardware real for n�o SCSI mas, por exemplo, IDE, em "
"seguida, tamb�m convertendo os comandos SCSI para os comandos nativos do "
"hardware). "

#. (itstool) path: sect1/para
#: book.translate.xml:19566
#, fuzzy
msgid ""
"Because we are interested in writing a SCSI adapter driver here, from this "
"point on we will consider everything from the SIM standpoint."
msgstr ""
"Porque estamos interessados ​​em escrever um driver de adaptador SCSI aqui, a "
"partir deste ponto consideraremos tudo do ponto de vista do SIM."

#. (itstool) path: sect1/para
#: book.translate.xml:19570
#, fuzzy
msgid ""
"A typical SIM driver needs to include the following CAM-related header files:"
msgstr ""
"Um driver SIM t�pico precisa incluir os seguintes arquivos de cabe�alho "
"relacionados ao CAM:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19573
#, no-wrap
msgid ""
"#include &lt;cam/cam.h&gt;\n"
"#include &lt;cam/cam_ccb.h&gt;\n"
"#include &lt;cam/cam_sim.h&gt;\n"
"#include &lt;cam/cam_xpt_sim.h&gt;\n"
"#include &lt;cam/cam_debug.h&gt;\n"
"#include &lt;cam/scsi/scsi_all.h&gt;"
msgstr ""
"#include &lt;cam/cam.h&gt;\n"
"#include &lt;cam/cam_ccb.h&gt;\n"
"#include &lt;cam/cam_sim.h&gt;\n"
"#include &lt;cam/cam_xpt_sim.h&gt;\n"
"#include &lt;cam/cam_debug.h&gt;\n"
"#include &lt;cam/scsi/scsi_all.h&gt;"

#. (itstool) path: sect1/para
#: book.translate.xml:19580
#, fuzzy
msgid ""
"The first thing each SIM driver must do is register itself with the CAM "
"subsystem. This is done during the driver's <function>xxx_attach()</"
"function> function (here and further xxx_ is used to denote the unique "
"driver name prefix). The <function>xxx_attach()</function> function itself "
"is called by the system bus auto-configuration code which we do not describe "
"here."
msgstr ""
"A primeira coisa que cada driver SIM deve fazer � registrar-se no subsistema "
"CAM. Isso � feito durante o <function> xxx_attach () </function> function "
"(aqui e mais xxx_ � usado para denotar o prefixo do nome do driver "
"exclusivo). o <function> xxx_attach () </function> A pr�pria fun��o � "
"chamada pelo c�digo de configura��o autom�tica do barramento do sistema, que "
"n�o descrevemos aqui. "

#. (itstool) path: sect1/para
#: book.translate.xml:19588
#, fuzzy
msgid ""
"This is achieved in multiple steps: first it is necessary to allocate the "
"queue of requests associated with this SIM:"
msgstr ""
"Isso � conseguido em v�rias etapas: primeiro � necess�rio alocar a fila de "
"solicita��es associadas a este SIM:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19591
#, no-wrap
msgid ""
"    struct cam_devq *devq;\n"
"\n"
"    if(( devq = cam_simq_alloc(SIZE) )==NULL) {\n"
"        error; /* some code to handle the error */\n"
"    }"
msgstr ""
"    struct cam_devq *devq;\n"
"\n"
"    if(( devq = cam_simq_alloc(SIZE) )==NULL) {\n"
"        error; /* some code to handle the error */\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:19597
#, fuzzy
msgid ""
"Here <literal>SIZE</literal> is the size of the queue to be allocated, "
"maximal number of requests it could contain. It is the number of requests "
"that the SIM driver can handle in parallel on one SCSI card. Commonly it can "
"be calculated as:"
msgstr ""
"Aqui <literal> TAMANHO </literal> � o tamanho da fila a ser alocada, o "
"n�mero m�ximo de solicita��es que ela pode conter. � o n�mero de "
"solicita��es que o driver do SIM pode manipular em paralelo em uma placa "
"SCSI. Comumente, pode ser calculado como: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19603
#, no-wrap
msgid "SIZE = NUMBER_OF_SUPPORTED_TARGETS * MAX_SIMULTANEOUS_COMMANDS_PER_TARGET"
msgstr "SIZE = NUMBER_OF_SUPPORTED_TARGETS * MAX_SIMULTANEOUS_COMMANDS_PER_TARGET"

#. (itstool) path: sect1/para
#: book.translate.xml:19605
#, fuzzy
msgid "Next we create a descriptor of our SIM:"
msgstr "Em seguida, criamos um descritor do nosso SIM:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19607
#, no-wrap
msgid ""
"    struct cam_sim *sim;\n"
"\n"
"    if(( sim = cam_sim_alloc(action_func, poll_func, driver_name,\n"
"            softc, unit, mtx, max_dev_transactions,\n"
"            max_tagged_dev_transactions, devq) )==NULL) {\n"
"        cam_simq_free(devq);\n"
"        error; /* some code to handle the error */\n"
"    }"
msgstr ""
"    struct cam_sim *sim;\n"
"\n"
"    if(( sim = cam_sim_alloc(action_func, poll_func, driver_name,\n"
"            softc, unit, mtx, max_dev_transactions,\n"
"            max_tagged_dev_transactions, devq) )==NULL) {\n"
"        cam_simq_free(devq);\n"
"        error; /* some code to handle the error */\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:19616
#, fuzzy
msgid ""
"Note that if we are not able to create a SIM descriptor we free the <varname "
"remap=\"structname\">devq</varname> also because we can do nothing else with "
"it and we want to conserve memory."
msgstr ""
"Note que se n�o formos capazes de criar um descritor SIM, n�s liberaremos o "
"<varname remap=\"structname\"> devq </varname> tamb�m porque n�o podemos "
"fazer mais nada e queremos conservar a mem�ria. "

#. (itstool) path: para/indexterm
#: book.translate.xml:19621
#, fuzzy
msgid "<primary>SCSI</primary><secondary>bus</secondary>"
msgstr " <primary> SCSI </primary><secondary> �nibus </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:19620
#, fuzzy
msgid ""
"If a SCSI card has multiple SCSI buses<_:indexterm-1/> on it then each bus "
"requires its own <varname remap=\"structname\">cam_sim</varname> structure."
msgstr ""
"Se uma placa SCSI tem v�rios barramentos SCSI <_: indexterm-1 />, cada "
"barramento requer o seu pr�prio <varname remap=\"structname\"> cam_sim </"
"varname> estrutura."

#. (itstool) path: sect1/para
#: book.translate.xml:19625
#, fuzzy
msgid ""
"An interesting question is what to do if a SCSI card has more than one SCSI "
"bus, do we need one <varname remap=\"structname\">devq</varname> structure "
"per card or per SCSI bus? The answer given in the comments to the CAM code "
"is: either way, as the driver's author prefers."
msgstr ""
"Uma quest�o interessante � o que fazer se uma placa SCSI tem mais de um "
"barramento SCSI, precisamos de um <varname remap=\"structname\"> devq </"
"varname> estrutura por cart�o ou por barramento SCSI? A resposta dada nos "
"coment�rios ao c�digo do CAM �: de qualquer forma, como o autor do motorista "
"prefere. "

#. (itstool) path: sect1/para
#: book.translate.xml:19631
#, fuzzy
msgid "The arguments are:"
msgstr "Os argumentos s�o:"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:19638 book.translate.xml:19828
#, fuzzy
msgid ""
"<funcdef>static void <function>xxx_action</function> </funcdef> <paramdef> "
"<parameter>struct cam_sim *sim</parameter>, <parameter>union ccb *ccb</"
"parameter> </paramdef>"
msgstr ""
" <funcdef> vazio est�tico <function> xxx_action </function></"
"funcdef><paramdef><parameter> struct cam_sim * sim </parameter> , "
"<parameter> uni�o ccb * ccb </parameter></paramdef> "

#. (itstool) path: listitem/para
#: book.translate.xml:19635
#, fuzzy
msgid ""
"<function>action_func</function> - pointer to the driver's "
"<function>xxx_action</function> function. <_:funcsynopsis-1/>"
msgstr ""
" <function> action_func </function> - ponteiro para o motorista <function> "
"xxx_action </function> fun��o. <_: funcsynopsis-1 /> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:19654 book.translate.xml:21079
#, fuzzy
msgid ""
"<funcdef>static void <function>xxx_poll</function> </funcdef> <paramdef> "
"<parameter>struct cam_sim *sim</parameter> </paramdef>"
msgstr ""
" <funcdef> vazio est�tico <function> xxx_poll </function></"
"funcdef><paramdef><parameter> struct cam_sim * sim </parameter></paramdef> "

#. (itstool) path: listitem/para
#: book.translate.xml:19651
#, fuzzy
msgid ""
"<function>poll_func</function> - pointer to the driver's "
"<function>xxx_poll()</function> <_:funcsynopsis-1/>"
msgstr ""
" <function> poll_func </function> - ponteiro para o motorista <function> "
"xxx_poll () </function> <_: funcsynopsis-1 /> "

#. (itstool) path: listitem/para
#: book.translate.xml:19666
#, fuzzy
msgid ""
"driver_name - the name of the actual driver, such as <quote>ncr</quote> or "
"<quote>wds</quote>."
msgstr ""
"driver_name - o nome do driver real, como <quote> ncr </quote> ou <quote> "
"wds </quote> "

#. (itstool) path: listitem/para
#: book.translate.xml:19672
#, fuzzy
msgid ""
"<varname remap=\"structname\">softc</varname> - pointer to the driver's "
"internal descriptor for this SCSI card. This pointer will be used by the "
"driver in future to get private data."
msgstr ""
" <varname remap=\"structname\"> softc </varname> - ponteiro para o descritor "
"interno do driver para esta placa SCSI. Esse ponteiro ser� usado pelo driver "
"no futuro para obter dados privados. "

#. (itstool) path: listitem/para
#: book.translate.xml:19679
#, fuzzy
msgid ""
"unit - the controller unit number, for example for controller <quote>mps0</"
"quote> this number will be 0"
msgstr ""
"unidade - o n�mero da unidade do controlador, por exemplo, para o "
"controlador <quote> mps0 </quote> esse n�mero ser� 0 "

#. (itstool) path: listitem/para
#: book.translate.xml:19685
#, fuzzy
msgid ""
"mtx - Lock associated with this SIM. For SIMs that don't know about locking, "
"pass in Giant. For SIMs that do, pass in the lock used to guard this SIM's "
"data structures. This lock will be held when xxx_action and xxx_poll are "
"called."
msgstr ""
"mtx - Bloqueio associado a este SIM. Para SIMs que n�o sabem sobre bloqueio, "
"passe para Gigante. Para os SIMs, passe o bloqueio usado para proteger as "
"estruturas de dados deste SIM. Este bloqueio ser� mantido quando xxx_action "
"e xxx_poll estiverem chamado."

#. (itstool) path: listitem/para
#: book.translate.xml:19692
#, fuzzy
msgid ""
"max_dev_transactions - maximal number of simultaneous transactions per SCSI "
"target in the non-tagged mode. This value will be almost universally equal "
"to 1, with possible exceptions only for the non-SCSI cards. Also the drivers "
"that hope to take advantage by preparing one transaction while another one "
"is executed may set it to 2 but this does not seem to be worth the "
"complexity."
msgstr ""
"max_dev_transactions - n�mero m�ximo de transa��es simult�neas por destino "
"SCSI no modo n�o marcado. Esse valor ser� quase universalmente igual a 1, "
"com poss�veis exce��es apenas para as placas n�o-SCSI. Al�m disso, os "
"drivers que esperam tirar proveito preparando um transa��o enquanto outro � "
"executado pode configur�-lo para 2, mas isso n�o parece valer a complexidade "
"\""

#. (itstool) path: listitem/para
#: book.translate.xml:19702
#, fuzzy
msgid ""
"max_tagged_dev_transactions - the same thing, but in the tagged mode. Tags "
"are the SCSI way to initiate multiple transactions on a device: each "
"transaction is assigned a unique tag and the transaction is sent to the "
"device. When the device completes some transaction it sends back the result "
"together with the tag so that the SCSI adapter (and the driver) can tell "
"which transaction was completed. This argument is also known as the maximal "
"tag depth. It depends on the abilities of the SCSI adapter."
msgstr ""
"max_tagged_dev_transactions - a mesma coisa, mas no modo marcado. Tags s�o a "
"maneira SCSI de iniciar v�rias transa��es em um dispositivo: a cada "
"transa��o � atribu�da uma tag �nica e a transa��o � enviada para o "
"dispositivo. Quando o dispositivo conclui alguma transa��o, ele envia "
"retorne o resultado junto com a tag para que o adaptador SCSI (e o driver) "
"possa dizer qual transa��o foi conclu�da. Esse argumento tamb�m � conhecido "
"como a profundidade m�xima da marca��o. Depende das capacidades do adaptador "
"SCSI. "

#. (itstool) path: para/indexterm
#: book.translate.xml:19716
#, fuzzy
msgid "<primary>SCSI</primary><secondary>adapter</secondary>"
msgstr " <primary> SCSI </primary><secondary> adaptador </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:19715
#, fuzzy
msgid ""
"Finally we register the SCSI buses associated with our SCSI adapter<_:"
"indexterm-1/>:"
msgstr ""
"Finalmente, registramos os barramentos SCSI associados ao nosso adaptador "
"SCSI <_: indexterm-1 />:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19718
#, no-wrap
msgid ""
"    if(xpt_bus_register(sim, softc, bus_number) != CAM_SUCCESS) {\n"
"        cam_sim_free(sim, /*free_devq*/ TRUE);\n"
"        error; /* some code to handle the error */\n"
"    }"
msgstr ""
"    if(xpt_bus_register(sim, softc, bus_number) != CAM_SUCCESS) {\n"
"        cam_sim_free(sim, /*free_devq*/ TRUE);\n"
"        error; /* some code to handle the error */\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:19723
#, fuzzy
msgid ""
"If there is one <varname remap=\"structname\">devq</varname> structure per "
"SCSI bus (i.e., we consider a card with multiple buses as multiple cards "
"with one bus each) then the bus number will always be 0, otherwise each bus "
"on the SCSI card should be get a distinct number. Each bus needs its own "
"separate structure cam_sim."
msgstr ""
"Se houver um <varname remap=\"structname\"> devq </varname> estrutura por "
"barramento SCSI (isto �, consideramos uma placa com m�ltiplos barramentos "
"como m�ltiplas placas com um barramento cada), ent�o o n�mero do barramento "
"ser� sempre 0, caso contr�rio, cada barramento na placa SCSI deve receber um "
"n�mero distinto. Cada �nibus precisa de sua pr�pria estrutura separada, "
"cam_sim. "

#. (itstool) path: sect1/para
#: book.translate.xml:19730
#, fuzzy
msgid ""
"After that our controller is completely hooked to the CAM system. The value "
"of <varname remap=\"structname\">devq</varname> can be discarded now: sim "
"will be passed as an argument in all further calls from CAM and devq can be "
"derived from it."
msgstr ""
"Depois disso, nosso controlador � completamente conectado ao sistema CAM. O "
"valor de <varname remap=\"structname\"> devq </varname> pode ser descartado "
"agora: o sim ser� passado como um argumento em todas as outras chamadas do "
"CAM e o devq pode ser derivado dele. "

#. (itstool) path: sect1/para
#: book.translate.xml:19735
#, fuzzy
msgid ""
"CAM provides the framework for such asynchronous events. Some events "
"originate from the lower levels (the SIM drivers), some events originate "
"from the peripheral drivers, some events originate from the CAM subsystem "
"itself. Any driver can register callbacks for some types of the asynchronous "
"events, so that it would be notified if these events occur."
msgstr ""
"O CAM fornece a estrutura para tais eventos ass�ncronos. Alguns eventos se "
"originam dos n�veis mais baixos (os drivers SIM), alguns eventos s�o "
"originados dos drivers perif�ricos, alguns eventos s�o originados do pr�prio "
"subsistema CAM. Qualquer driver pode registrar retornos de chamada para "
"alguns tipos de eventos. eventos ass�ncronos, para que seja notificado se "
"esses eventos ocorrerem. "

#. (itstool) path: sect1/para
#: book.translate.xml:19742
#, fuzzy
msgid ""
"A typical example of such an event is a device reset. Each transaction and "
"event identifies the devices to which it applies by the means of "
"<quote>path</quote>. The target-specific events normally occur during a "
"transaction with this device. So the path from that transaction may be re-"
"used to report this event (this is safe because the event path is copied in "
"the event reporting routine but not deallocated nor passed anywhere "
"further). Also it is safe to allocate paths dynamically at any time "
"including the interrupt routines, although that incurs certain overhead, and "
"a possible problem with this approach is that there may be no free memory at "
"that time. For a bus reset event we need to define a wildcard path including "
"all devices on the bus. So we can create the path for the future bus reset "
"events in advance and avoid problems with the future memory shortage:"
msgstr ""
"Um exemplo t�pico de tal evento � uma reinicializa��o do dispositivo. Cada "
"transa��o e evento identifica os dispositivos aos quais ele se aplica por "
"meio de <quote> caminho </quote> . Os eventos espec�ficos de destino "
"normalmente ocorrem durante uma transa��o com este dispositivo. Portanto, o "
"caminho dessa transa��o pode ser reutilizado para relatar esse evento (isso "
"� seguro porque o caminho do evento � copiado na rotina de relat�rio de "
"evento, mas n�o desalocado nem transmitido em nenhum outro lugar). Tamb�m � "
"seguro alocar caminhos dinamicamente a qualquer momento, incluindo as "
"rotinas de interrup��o, embora isso incorra em certa sobrecarga, e um "
"poss�vel problema com essa abordagem � que pode n�o haver mem�ria livre "
"naquele momento. Para um evento de redefini��o de barramento, precisamos "
"definir um caminho curinga incluindo todos os dispositivos no barramento. "
"Assim, podemos criar o caminho para os futuros eventos de redefini��o de "
"barramento com anteced�ncia e evitar problemas com a falta de mem�ria "
"futura: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19758
#, no-wrap
msgid ""
"    struct cam_path *path;\n"
"\n"
"    if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                cam_sim_path(sim), CAM_TARGET_WILDCARD,\n"
"                CAM_LUN_WILDCARD) != CAM_REQ_CMP) {\n"
"        xpt_bus_deregister(cam_sim_path(sim));\n"
"        cam_sim_free(sim, /*free_devq*/TRUE);\n"
"        error; /* some code to handle the error */\n"
"    }\n"
"\n"
"    softc-&gt;wpath = path;\n"
"    softc-&gt;sim = sim;"
msgstr ""
"    struct cam_path *path;\n"
"\n"
"    if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                cam_sim_path(sim), CAM_TARGET_WILDCARD,\n"
"                CAM_LUN_WILDCARD) != CAM_REQ_CMP) {\n"
"        xpt_bus_deregister(cam_sim_path(sim));\n"
"        cam_sim_free(sim, /*free_devq*/TRUE);\n"
"        error; /* some code to handle the error */\n"
"    }\n"
"\n"
"    softc-&gt;wpath = path;\n"
"    softc-&gt;sim = sim;"

#. (itstool) path: sect1/para
#: book.translate.xml:19771
#, fuzzy
msgid "As you can see the path includes:"
msgstr "Como voc� pode ver o caminho inclui:"

#. (itstool) path: listitem/para
#: book.translate.xml:19775
#, fuzzy
msgid "ID of the peripheral driver (NULL here because we have none)"
msgstr "ID do driver perif�rico (NULL aqui porque n�o temos nenhum)"

#. (itstool) path: listitem/para
#: book.translate.xml:19780
#, fuzzy
msgid "ID of the SIM driver (<function>cam_sim_path(sim)</function>)"
msgstr "ID do driver do SIM ( <function> cam_sim_path (sim) </function> ) "

#. (itstool) path: listitem/para
#: book.translate.xml:19785
#, fuzzy
msgid ""
"SCSI target number of the device (CAM_TARGET_WILDCARD means <quote>all "
"devices</quote>)"
msgstr ""
"N�mero alvo SCSI do dispositivo (CAM_TARGET_WILDCARD significa <quote> todos "
"os dispositivos </quote> ) "

#. (itstool) path: listitem/para
#: book.translate.xml:19790
#, fuzzy
msgid ""
"SCSI LUN number of the subdevice (CAM_LUN_WILDCARD means <quote>all LUNs</"
"quote>)"
msgstr ""
"N�mero SCSI LUN do subdivice (CAM_LUN_WILDCARD significa <quote> todas as "
"LUNs </quote> ) "

#. (itstool) path: sect1/para
#: book.translate.xml:19795
#, fuzzy
msgid ""
"If the driver can not allocate this path it will not be able to work "
"normally, so in that case we dismantle that SCSI bus."
msgstr ""
"Se o driver n�o puder alocar este caminho, ele n�o poder� funcionar "
"normalmente, ent�o, nesse caso, desmontaremos esse barramento SCSI."

#. (itstool) path: sect1/para
#: book.translate.xml:19799
#, fuzzy
msgid ""
"And we save the path pointer in the <varname remap=\"structname\">softc</"
"varname> structure for future use. After that we save the value of sim (or "
"we can also discard it on the exit from <function>xxx_probe()</function> if "
"we wish)."
msgstr ""
"E n�s salvamos o ponteiro do caminho no <varname remap=\"structname\"> softc "
"</varname> estrutura para uso futuro. Depois disso, salvamos o valor de sim "
"(ou tamb�m podemos descart�-lo na sa�da de <function> xxx_probe () </"
"function> se quisermos. "

#. (itstool) path: sect1/para
#: book.translate.xml:19804
#, fuzzy
msgid ""
"That is all for a minimalistic initialization. To do things right there is "
"one more issue left."
msgstr ""
"Isso � tudo para uma inicializa��o minimalista. Para fazer as coisas certas, "
"resta mais uma quest�o."

#. (itstool) path: sect1/para
#: book.translate.xml:19807
#, fuzzy
msgid ""
"For a SIM driver there is one particularly interesting event: when a target "
"device is considered lost. In this case resetting the SCSI negotiations with "
"this device may be a good idea. So we register a callback for this event "
"with CAM. The request is passed to CAM by requesting CAM action on a CAM "
"control block for this type of request:"
msgstr ""
"Para um driver SIM h� um evento particularmente interessante: quando um "
"dispositivo de destino � considerado perdido. Neste caso, a reinicializa��o "
"das negocia��es SCSI com este dispositivo pode ser uma boa id�ia. Portanto, "
"registramos um retorno de chamada para este evento com o CAM. passou para "
"CAM solicitando a��o CAM em um bloco de controle CAM para este tipo de "
"solicita��o: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19814
#, no-wrap
msgid ""
"    struct ccb_setasync csa;\n"
"\n"
"    xpt_setup_ccb(&amp;csa.ccb_h, path, /*priority*/5);\n"
"    csa.ccb_h.func_code = XPT_SASYNC_CB;\n"
"    csa.event_enable = AC_LOST_DEVICE;\n"
"    csa.callback = xxx_async;\n"
"    csa.callback_arg = sim;\n"
"    xpt_action((union ccb *)&amp;csa);"
msgstr ""
"    struct ccb_setasync csa;\n"
"\n"
"    xpt_setup_ccb(&amp;csa.ccb_h, path, /*priority*/5);\n"
"    csa.ccb_h.func_code = XPT_SASYNC_CB;\n"
"    csa.event_enable = AC_LOST_DEVICE;\n"
"    csa.callback = xxx_async;\n"
"    csa.callback_arg = sim;\n"
"    xpt_action((union ccb *)&amp;csa);"

#. (itstool) path: sect1/para
#: book.translate.xml:19823
#, fuzzy
msgid ""
"Now we take a look at the <function>xxx_action()</function> and "
"<function>xxx_poll()</function> driver entry points."
msgstr ""
"Agora vamos dar uma olhada no <function> xxx_action () </function> e "
"<function> xxx_poll () </function> pontos de entrada do motorista. "

#. (itstool) path: sect1/para
#: book.translate.xml:19839
#, fuzzy
msgid ""
"Do some action on request of the CAM subsystem. Sim describes the SIM for "
"the request, CCB is the request itself. CCB stands for <quote>CAM Control "
"Block</quote>. It is a union of many specific instances, each describing "
"arguments for some type of transactions. All of these instances share the "
"CCB header where the common part of arguments is stored."
msgstr ""
"Fa�a alguma a��o a pedido do subsistema CAM. Sim descreve o SIM para o "
"pedido, CCB � o pr�prio pedido. CCB significa <quote> Bloco de Controle CAM "
"</quote> . � uma uni�o de v�rias inst�ncias espec�ficas, cada uma "
"descrevendo argumentos para algum tipo de transa��o. Todas essas inst�ncias "
"compartilham o cabe�alho do CCB onde a parte comum dos argumentos � "
"armazenada. "

#. (itstool) path: sect1/para
#: book.translate.xml:19846
#, fuzzy
msgid ""
"CAM supports the SCSI controllers working in both initiator (<quote>normal</"
"quote>) mode and target (simulating a SCSI device) mode. Here we only "
"consider the part relevant to the initiator mode."
msgstr ""
"O CAM suporta os controladores SCSI que funcionam no iniciador ( <quote> "
"normal </quote> ) Modo e modo de destino (simulando um dispositivo SCSI). "
"Aqui n�s consideramos apenas a parte relevante para o modo iniciador \""

#. (itstool) path: sect1/para
#: book.translate.xml:19851
#, fuzzy
msgid ""
"There are a few function and macros (in other words, methods) defined to "
"access the public data in the struct sim:"
msgstr ""
"Existem algumas fun��es e macros (em outras palavras, m�todos) definidas "
"para acessar os dados p�blicos no struct sim:"

#. (itstool) path: listitem/para
#: book.translate.xml:19857
#, fuzzy
msgid "<function>cam_sim_path(sim)</function> - the path ID (see above)"
msgstr ""
" <function> cam_sim_path (sim) </function> - o ID do caminho (veja acima) "

#. (itstool) path: listitem/para
#: book.translate.xml:19862
#, fuzzy
msgid "<function>cam_sim_name(sim)</function> - the name of the sim"
msgstr " <function> cam_sim_name (sim) </function> - o nome do sim "

#. (itstool) path: listitem/para
#: book.translate.xml:19867
#, fuzzy
msgid ""
"<function>cam_sim_softc(sim)</function> - the pointer to the softc (driver "
"private data) structure"
msgstr ""
" <function> cam_sim_softc (sim) </function> - o ponteiro para a estrutura do "
"softc (driver private data) "

#. (itstool) path: listitem/para
#: book.translate.xml:19872
#, fuzzy
msgid "<function> cam_sim_unit(sim)</function> - the unit number"
msgstr " <function> cam_sim_unit (sim) </function> - o n�mero da unidade "

#. (itstool) path: listitem/para
#: book.translate.xml:19877
#, fuzzy
msgid "<function> cam_sim_bus(sim)</function> - the bus ID"
msgstr " <function> cam_sim_bus (sim) </function> - o ID do �nibus "

#. (itstool) path: sect1/para
#: book.translate.xml:19882
#, fuzzy
msgid ""
"To identify the device, <function>xxx_action()</function> can get the unit "
"number and pointer to its structure softc using these functions."
msgstr ""
"Para identificar o dispositivo, <function> xxx_action () </function> pode "
"obter o n�mero da unidade e o ponteiro para sua estrutura usando essas "
"fun��es. "

#. (itstool) path: sect1/para
#: book.translate.xml:19886
#, fuzzy
msgid ""
"The type of request is stored in <varname remap=\"structfield\">ccb-&gt;"
"ccb_h.func_code</varname>. So generally <function>xxx_action()</function> "
"consists of a big switch:"
msgstr ""
"O tipo de solicita��o � armazenado em <varname remap=\"structfield\"> ccb-"
"&gt; ccb_h.func_code </varname> . Ent�o geralmente <function> xxx_action () "
"</function> consiste em um grande interruptor: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19891
#, no-wrap
msgid ""
"    struct xxx_softc *softc = (struct xxx_softc *) cam_sim_softc(sim);\n"
"    struct ccb_hdr *ccb_h = &amp;ccb-&gt;ccb_h;\n"
"    int unit = cam_sim_unit(sim);\n"
"    int bus = cam_sim_bus(sim);\n"
"\n"
"    switch(ccb_h-&gt;func_code) {\n"
"    case ...:\n"
"        ...\n"
"    default:\n"
"        ccb_h-&gt;status = CAM_REQ_INVALID;\n"
"        xpt_done(ccb);\n"
"        break;\n"
"    }"
msgstr ""
"    struct xxx_softc *softc = (struct xxx_softc *) cam_sim_softc(sim);\n"
"    struct ccb_hdr *ccb_h = &amp;ccb-&gt;ccb_h;\n"
"    int unit = cam_sim_unit(sim);\n"
"    int bus = cam_sim_bus(sim);\n"
"\n"
"    switch(ccb_h-&gt;func_code) {\n"
"    case ...:\n"
"        ...\n"
"    default:\n"
"        ccb_h-&gt;status = CAM_REQ_INVALID;\n"
"        xpt_done(ccb);\n"
"        break;\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:19905
#, fuzzy
msgid ""
"As can be seen from the default case (if an unknown command was received) "
"the return code of the command is set into <varname remap=\"structfield"
"\">ccb-&gt;ccb_h.status</varname> and the completed CCB is returned back to "
"CAM by calling <function>xpt_done(ccb)</function>."
msgstr ""
"Como pode ser visto a partir do caso padr�o (se um comando desconhecido foi "
"recebido) o c�digo de retorno do comando � definido em <varname remap="
"\"structfield\"> ccb-&gt; ccb_h.status </varname> e o CCB preenchido � "
"devolvido ao CAM, chamando <function> xpt_done (ccb) </function> "

#. (itstool) path: sect1/para
#: book.translate.xml:19911
#, fuzzy
msgid ""
"<function>xpt_done()</function> does not have to be called from "
"<function>xxx_action()</function>: For example an I/O request may be "
"enqueued inside the SIM driver and/or its SCSI controller. Then when the "
"device would post an interrupt signaling that the processing of this request "
"is complete <function>xpt_done()</function> may be called from the interrupt "
"handling routine."
msgstr ""
" <function> xpt_done () </function> n�o precisa ser chamado de <function> "
"xxx_action () </function> Por exemplo, uma solicita��o de E / S pode ser "
"enfileirada dentro do driver do SIM e / ou seu controlador SCSI. Ent�o, "
"quando o dispositivo postar uma interrup��o, sinalizando que o processamento "
"desta solicita��o est� completo <function> xpt_done () </function> pode ser "
"chamado a partir da rotina de tratamento de interrup��es. "

#. (itstool) path: sect1/para
#: book.translate.xml:19919
#, fuzzy
msgid ""
"Actually, the CCB status is not only assigned as a return code but a CCB has "
"some status all the time. Before CCB is passed to the "
"<function>xxx_action()</function> routine it gets the status CCB_REQ_INPROG "
"meaning that it is in progress. There are a surprising number of status "
"values defined in <filename>/sys/cam/cam.h</filename> which should be able "
"to represent the status of a request in great detail. More interesting yet, "
"the status is in fact a <quote>bitwise or</quote> of an enumerated status "
"value (the lower 6 bits) and possible additional flag-like bits (the upper "
"bits). The enumerated values will be discussed later in more detail. The "
"summary of them can be found in the Errors Summary section. The possible "
"status flags are:"
msgstr ""
"Na verdade, o status do CCB n�o � atribu�do apenas como um c�digo de "
"retorno, mas um CCB tem algum status o tempo todo. Antes de o CCB ser "
"passado para o <function> xxx_action () </function> rotina obt�m o status "
"CCB_REQ_INPROG, o que significa que est� em andamento. H� um n�mero "
"surpreendente de valores de status definidos em <filename> /sys/cam/cam.h </"
"filename> que deve ser capaz de representar o status de uma solicita��o em "
"grande detalhe. Mais interessante ainda, o status � de fato um <quote> bit a "
"bit ou </quote> de um valor de status enumerado (os 6 bits inferiores) e "
"poss�veis bits semelhantes a sinalizadores adicionais (os bits superiores). "
"Os valores enumerados ser�o discutidos mais adiante com mais detalhes. O "
"resumo deles pode ser encontrado na se��o Resumo de Erros. Os poss�veis "
"flags de status s�o: "

#. (itstool) path: listitem/para
#: book.translate.xml:19935
#, fuzzy
msgid ""
"<emphasis>CAM_DEV_QFRZN</emphasis> - if the SIM driver gets a serious error "
"(for example, the device does not respond to the selection or breaks the "
"SCSI protocol) when processing a CCB it should freeze the request queue by "
"calling <function>xpt_freeze_simq()</function>, return the other enqueued "
"but not processed yet CCBs for this device back to the CAM queue, then set "
"this flag for the troublesome CCB and call <function>xpt_done()</function>. "
"This flag causes the CAM subsystem to unfreeze the queue after it handles "
"the error."
msgstr ""
" <emphasis> CAM_DEV_QFRZN </emphasis> - se o driver SIM receber um erro "
"grave (por exemplo, o dispositivo n�o responder � sele��o ou quebrar o "
"protocolo SCSI) ao processar um CCB, ele dever� congelar a fila de "
"solicita��o chamando <function> xpt_freeze_simq () </function> , retorne os "
"outros enfileirados mas n�o processados ​​ainda aos CCBs para este dispositivo "
"de volta para a fila do CAM, defina esse sinalizador para o CCB problem�tico "
"e chame <function> xpt_done () </function> . Esse sinalizador faz com que o "
"subsistema CAM descongele a fila depois que ela manipula o erro. "

#. (itstool) path: listitem/para
#: book.translate.xml:19948
#, fuzzy
msgid ""
"<emphasis>CAM_AUTOSNS_VALID</emphasis> - if the device returned an error "
"condition and the flag CAM_DIS_AUTOSENSE is not set in CCB the SIM driver "
"must execute the REQUEST SENSE command automatically to extract the sense "
"(extended error information) data from the device. If this attempt was "
"successful the sense data should be saved in the CCB and this flag set."
msgstr ""
" <emphasis> CAM_AUTOSNS_VALID </emphasis> - se o dispositivo retornou uma "
"condi��o de erro e o sinalizador CAM_DIS_AUTOSENSE n�o est� definido no CCB, "
"o driver SIM deve executar o comando REQUEST SENSE automaticamente para "
"extrair os dados de sentido (informa��es de erro estendidas) do dispositivo. "
"Se esta tentativa foi bem sucedida, os dados do sentido devem ser salvos no "
"CCB e este sinalizador definido. "

#. (itstool) path: listitem/para
#: book.translate.xml:19958
#, fuzzy
msgid ""
"<emphasis>CAM_RELEASE_SIMQ</emphasis> - like CAM_DEV_QFRZN but used in case "
"there is some problem (or resource shortage) with the SCSI controller "
"itself. Then all the future requests to the controller should be stopped by "
"<function>xpt_freeze_simq()</function>. The controller queue will be "
"restarted after the SIM driver overcomes the shortage and informs CAM by "
"returning some CCB with this flag set."
msgstr ""
" <emphasis> CAM_RELEASE_SIMQ </emphasis> - como o CAM_DEV_QFRZN mas usado no "
"caso de haver algum problema (ou escassez de recursos) com o pr�prio "
"controlador SCSI. Ent�o todos os pedidos futuros ao controlador devem ser "
"interrompidos por <function> xpt_freeze_simq () </function> . A fila do "
"controlador ser� reiniciada ap�s o driver do SIM superar a falta e informar "
"o CAM retornando algum CCB com este sinalizador definido. "

#. (itstool) path: listitem/para
#: book.translate.xml:19969
#, fuzzy
msgid ""
"<emphasis>CAM_SIM_QUEUED</emphasis> - when SIM puts a CCB into its request "
"queue this flag should be set (and removed when this CCB gets dequeued "
"before being returned back to CAM). This flag is not used anywhere in the "
"CAM code now, so its purpose is purely diagnostic."
msgstr ""
" <emphasis> CAM_SIM_QUEUED </emphasis> - quando o SIM coloca um CCB em sua "
"fila de pedidos, este sinalizador deve ser definido (e removido quando este "
"CCB � retirado da fila antes de ser devolvido ao CAM). Este sinalizador n�o "
"� usado em qualquer lugar no c�digo CAM agora, ent�o seu prop�sito � "
"puramente diagn�stico. "

#. (itstool) path: listitem/para
#: book.translate.xml:19977
#, fuzzy
msgid "<emphasis>CAM_QOS_VALID</emphasis> - The QOS data is now valid."
msgstr ""
" <emphasis> CAM_QOS_VALID </emphasis> - Os dados QOS agora s�o v�lidos. "

#. (itstool) path: sect1/para
#: book.translate.xml:19982
#, fuzzy
msgid ""
"The function <function>xxx_action()</function> is not allowed to sleep, so "
"all the synchronization for resource access must be done using SIM or device "
"queue freezing. Besides the aforementioned flags the CAM subsystem provides "
"functions <function>xpt_release_simq()</function> and "
"<function>xpt_release_devq()</function> to unfreeze the queues directly, "
"without passing a CCB to CAM."
msgstr ""
"A fun��o <function> xxx_action () </function> n�o � permitido dormir, "
"portanto, toda a sincroniza��o para acesso ao recurso deve ser feita usando "
"o congelamento da fila do SIM ou do dispositivo. Al�m das bandeiras acima "
"mencionadas, o subsistema CAM fornece fun��es <function> xpt_release_simq () "
"</function> e <function> xpt_release_devq () </function> para descongelar as "
"filas diretamente, sem passar um CCB para CAM \""

#. (itstool) path: sect1/para
#: book.translate.xml:19990
#, fuzzy
msgid "The CCB header contains the following fields:"
msgstr "O cabe�alho do CCB cont�m os seguintes campos:"

#. (itstool) path: listitem/para
#: book.translate.xml:19994
#, fuzzy
msgid "<emphasis>path</emphasis> - path ID for the request"
msgstr " <emphasis> caminho </emphasis> - ID do caminho para o pedido "

#. (itstool) path: listitem/para
#: book.translate.xml:19999
#, fuzzy
msgid "<emphasis>target_id</emphasis> - target device ID for the request"
msgstr ""
" <emphasis> target_id </emphasis> - ID do dispositivo de destino para o "
"pedido "

#. (itstool) path: listitem/para
#: book.translate.xml:20004
#, fuzzy
msgid "<emphasis>target_lun</emphasis> - LUN ID of the target device"
msgstr ""
" <emphasis> target_lun </emphasis> - ID do LUN do dispositivo de destino "

#. (itstool) path: listitem/para
#: book.translate.xml:20009
#, fuzzy
msgid ""
"<emphasis>timeout</emphasis> - timeout interval for this command, in "
"milliseconds"
msgstr ""
" <emphasis> tempo esgotado </emphasis> - intervalo de tempo limite para este "
"comando, em milissegundos "

#. (itstool) path: listitem/para
#: book.translate.xml:20014
#, fuzzy
msgid ""
"<emphasis>timeout_ch</emphasis> - a convenience place for the SIM driver to "
"store the timeout handle (the CAM subsystem itself does not make any "
"assumptions about it)"
msgstr ""
" <emphasis> timeout_ch </emphasis> - um local de conveni�ncia para o driver "
"do SIM armazenar o identificador de tempo limite (o pr�prio subsistema CAM "
"n�o faz nenhuma suposi��o sobre ele) "

#. (itstool) path: listitem/para
#: book.translate.xml:20021
#, fuzzy
msgid ""
"<emphasis>flags</emphasis> - various bits of information about the request "
"spriv_ptr0, spriv_ptr1 - fields reserved for private use by the SIM driver "
"(such as linking to the SIM queues or SIM private control blocks); actually, "
"they exist as unions: spriv_ptr0 and spriv_ptr1 have the type (void *), "
"spriv_field0 and spriv_field1 have the type unsigned long, sim_priv."
"entries[0].bytes and sim_priv.entries[1].bytes are byte arrays of the size "
"consistent with the other incarnations of the union and sim_priv.bytes is "
"one array, twice bigger."
msgstr ""
" <emphasis> bandeiras </emphasis> - v�rios bits de informa��o sobre o pedido "
"spriv_ptr0, spriv_ptr1 - campos reservados para uso privado pelo driver do "
"SIM (como links para as filas do SIM ou blocos de controle privados do SIM); "
"na verdade, eles existem como unions: spriv_ptr0 e spriv_ptr1 tem o tipo "
"(void *), spriv_field0 e spriv_field1 tem o tipo unsigned long, sim_priv."
"entries [0] .bytes e sim_priv.entries [1] .bytes s�o matrizes de byte do "
"tamanho consistente com as outras encarna��es da uni�o e sim_priv.bytes � "
"uma matriz, duas vezes maior \""

#. (itstool) path: sect1/para
#: book.translate.xml:20034
#, fuzzy
msgid ""
"The recommended way of using the SIM private fields of CCB is to define some "
"meaningful names for them and use these meaningful names in the driver, like:"
msgstr ""
"A maneira recomendada de usar os campos privados do SIM do CCB � definir "
"alguns nomes significativos para eles e usar esses nomes significativos no "
"driver, como:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:20038
#, no-wrap
msgid ""
"#define ccb_some_meaningful_name    sim_priv.entries[0].bytes\n"
"#define ccb_hcb spriv_ptr1 /* for hardware control block */"
msgstr ""
"#define ccb_some_meaningful_name    sim_priv.entries[0].bytes\n"
"#define ccb_hcb spriv_ptr1 /* for hardware control block */"

#. (itstool) path: sect1/para
#: book.translate.xml:20041
#, fuzzy
msgid "The most common initiator mode requests are:"
msgstr "As solicita��es de modo de iniciador mais comuns s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:20045
#, fuzzy
msgid "<emphasis>XPT_SCSI_IO</emphasis> - execute an I/O transaction"
msgstr " <emphasis> XPT_SCSI_IO </emphasis> - executar uma transa��o de E / S "

#. (itstool) path: listitem/para
#: book.translate.xml:20048
#, fuzzy
msgid ""
"The instance <quote>struct ccb_scsiio csio</quote> of the union ccb is used "
"to transfer the arguments. They are:"
msgstr ""
"A inst�ncia <quote> struct ccb_scsiio csio </quote> da uni�o ccb � usado "
"para transferir os argumentos. Eles s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:20054
#, fuzzy
msgid ""
"<emphasis>cdb_io</emphasis> - pointer to the SCSI command buffer or the "
"buffer itself"
msgstr ""
" <emphasis> cdb_io </emphasis> - ponteiro para o buffer de comando SCSI ou o "
"pr�prio buffer "

#. (itstool) path: listitem/para
#: book.translate.xml:20059
#, fuzzy
msgid "<emphasis>cdb_len</emphasis> - SCSI command length"
msgstr " <emphasis> cdb_len </emphasis> - comprimento do comando SCSI "

#. (itstool) path: listitem/para
#: book.translate.xml:20064
#, fuzzy
msgid ""
"<emphasis>data_ptr</emphasis> - pointer to the data buffer (gets a bit "
"complicated if scatter/gather is used)"
msgstr ""
" <emphasis> data_ptr </emphasis> - ponteiro para o buffer de dados (fica um "
"pouco complicado se scatter / gather for usado) "

#. (itstool) path: listitem/para
#: book.translate.xml:20070
#, fuzzy
msgid "<emphasis>dxfer_len</emphasis> - length of the data to transfer"
msgstr ""
" <emphasis> dxfer_len </emphasis> - comprimento dos dados a transferir "

#. (itstool) path: listitem/para
#: book.translate.xml:20075
#, fuzzy
msgid ""
"<emphasis>sglist_cnt</emphasis> - counter of the scatter/gather segments"
msgstr ""
" <emphasis> sglist_cnt </emphasis> - contador dos segmentos scatter / gather "

#. (itstool) path: listitem/para
#: book.translate.xml:20080
#, fuzzy
msgid "<emphasis>scsi_status</emphasis> - place to return the SCSI status"
msgstr ""
" <emphasis> scsi_status </emphasis> - local para retornar o status SCSI "

#. (itstool) path: listitem/para
#: book.translate.xml:20085
#, fuzzy
msgid ""
"<emphasis>sense_data</emphasis> - buffer for the SCSI sense information if "
"the command returns an error (the SIM driver is supposed to run the REQUEST "
"SENSE command automatically in this case if the CCB flag CAM_DIS_AUTOSENSE "
"is not set)"
msgstr ""
" <emphasis> sense_data </emphasis> - buffer para as informa��es do sentido "
"SCSI, se o comando retornar um erro (o driver SIM dever� executar o comando "
"REQUEST SENSE automaticamente, neste caso, se o sinalizador do CCB "
"CAM_DIS_AUTOSENSE n�o estiver definido) "

#. (itstool) path: listitem/para
#: book.translate.xml:20093
#, fuzzy
msgid ""
"<emphasis>sense_len</emphasis> - the length of that buffer (if it happens to "
"be higher than size of sense_data the SIM driver must silently assume the "
"smaller value) resid, sense_resid - if the transfer of data or SCSI sense "
"returned an error these are the returned counters of the residual (not "
"transferred) data. They do not seem to be especially meaningful, so in a "
"case when they are difficult to compute (say, counting bytes in the SCSI "
"controller's FIFO buffer) an approximate value will do as well. For a "
"successfully completed transfer they must be set to zero."
msgstr ""
" <emphasis> sense_len </emphasis> - o comprimento desse buffer (se for maior "
"que o tamanho de sense_data que o driver do SIM deve assumir silenciosamente "
"o valor menor) resid, sense_resid - se a transfer�ncia de dados ou o sentido "
"SCSI retornar um erro, esses s�o os contadores retornados do valor residual. "
"dados (n�o transferidos). Eles n�o parecem ser especialmente significativos, "
"portanto, em um caso em que � dif�cil computar (digamos, contar bytes no "
"buffer FIFO do controlador SCSI), um valor aproximado tamb�m funcionar�. "
"Para uma transfer�ncia conclu�da com sucesso, eles devem ser definidos como "
"zero. "

#. (itstool) path: listitem/para
#: book.translate.xml:20108
#, fuzzy
msgid "<emphasis>tag_action</emphasis> - the kind of tag to use:"
msgstr " <emphasis> tag_action </emphasis> - o tipo de tag a usar: "

#. (itstool) path: listitem/para
#: book.translate.xml:20113
#, fuzzy
msgid "CAM_TAG_ACTION_NONE - do not use tags for this transaction"
msgstr "CAM_TAG_ACTION_NONE - n�o use tags para esta transa��o"

#. (itstool) path: listitem/para
#: book.translate.xml:20118
#, fuzzy
msgid ""
"MSG_SIMPLE_Q_TAG, MSG_HEAD_OF_Q_TAG, MSG_ORDERED_Q_TAG - value equal to the "
"appropriate tag message (see /sys/cam/scsi/scsi_message.h); this gives only "
"the tag type, the SIM driver must assign the tag value itself"
msgstr ""
"MSG_SIMPLE_Q_TAG, MSG_HEAD_OF_Q_TAG, MSG_ORDERED_Q_TAG - valor igual � "
"mensagem de tag apropriada (consulte /sys/cam/scsi/scsi_message.h); isso "
"fornece apenas o tipo de tag, o driver do SIM deve atribuir o pr�prio valor "
"de tag"

#. (itstool) path: listitem/para
#: book.translate.xml:20128
#, fuzzy
msgid "The general logic of handling this request is the following:"
msgstr "A l�gica geral de lidar com essa solicita��o � a seguinte:"

#. (itstool) path: listitem/para
#: book.translate.xml:20131
#, fuzzy
msgid ""
"The first thing to do is to check for possible races, to make sure that the "
"command did not get aborted when it was sitting in the queue:"
msgstr ""
"A primeira coisa a fazer � verificar poss�veis corridas, para garantir que o "
"comando n�o seja abortado quando estiver na fila:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20135
#, no-wrap
msgid ""
"    struct ccb_scsiio *csio = &amp;ccb-&gt;csio;\n"
"\n"
"    if ((ccb_h-&gt;status &amp; CAM_STATUS_MASK) != CAM_REQ_INPROG) {\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"
msgstr ""
"    struct ccb_scsiio *csio = &amp;ccb-&gt;csio;\n"
"\n"
"    if ((ccb_h-&gt;status &amp; CAM_STATUS_MASK) != CAM_REQ_INPROG) {\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"

#. (itstool) path: listitem/para
#: book.translate.xml:20142
#, fuzzy
msgid "Also we check that the device is supported at all by our controller:"
msgstr ""
"Tamb�m verificamos se o dispositivo � suportado pelo nosso controlador:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20145
#, no-wrap
msgid ""
"    if(ccb_h-&gt;target_id &gt; OUR_MAX_SUPPORTED_TARGET_ID\n"
"    || cch_h-&gt;target_id == OUR_SCSI_CONTROLLERS_OWN_ID) {\n"
"        ccb_h-&gt;status = CAM_TID_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"    if(ccb_h-&gt;target_lun &gt; OUR_MAX_SUPPORTED_LUN) {\n"
"        ccb_h-&gt;status = CAM_LUN_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"
msgstr ""
"    if(ccb_h-&gt;target_id &gt; OUR_MAX_SUPPORTED_TARGET_ID\n"
"    || cch_h-&gt;target_id == OUR_SCSI_CONTROLLERS_OWN_ID) {\n"
"        ccb_h-&gt;status = CAM_TID_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"    if(ccb_h-&gt;target_lun &gt; OUR_MAX_SUPPORTED_LUN) {\n"
"        ccb_h-&gt;status = CAM_LUN_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"

#. (itstool) path: para/indexterm
#: book.translate.xml:20159
#, fuzzy
msgid "<primary>hardware control block</primary>"
msgstr " <primary> bloco de controle de hardware </primary> "

#. (itstool) path: listitem/para
#: book.translate.xml:20157
#, fuzzy
msgid ""
"Then allocate whatever data structures (such as card-dependent hardware "
"control block<_:indexterm-1/>) we need to process this request. If we can "
"not then freeze the SIM queue and remember that we have a pending operation, "
"return the CCB back and ask CAM to re-queue it. Later when the resources "
"become available the SIM queue must be unfrozen by returning a ccb with the "
"<literal>CAM_SIMQ_RELEASE</literal> bit set in its status. Otherwise, if all "
"went well, link the CCB with the hardware control block (HCB) and mark it as "
"queued."
msgstr ""
"Ent�o aloque quaisquer estruturas de dados (como o bloco de controle de "
"hardware dependente de cart�o <_: indexterm-1 />) que precisamos processar "
"esta requisi��o. Se n�o pudermos, congelar a fila do SIM e lembrar que temos "
"uma opera��o pendente, retornar o CCB de volta e pe�a ao CAM para reenvi�-"
"lo. Mais tarde, quando os recursos estiverem dispon�veis, a fila do SIM deve "
"ser descongelada retornando um ccb com o <literal> CAM_SIMQ_RELEASE </"
"literal> bit definido em seu status. Caso contr�rio, se tudo correr bem, "
"vincule o CCB ao bloco de controle de hardware (HCB) e marque-o como na "
"fila. "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20170
#, no-wrap
msgid ""
"    struct xxx_hcb *hcb = allocate_hcb(softc, unit, bus);\n"
"\n"
"    if(hcb == NULL) {\n"
"        softc-&gt;flags |= RESOURCE_SHORTAGE;\n"
"        xpt_freeze_simq(sim, /*count*/1);\n"
"        ccb_h-&gt;status = CAM_REQUEUE_REQ;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"\n"
"    hcb-&gt;ccb = ccb; ccb_h-&gt;ccb_hcb = (void *)hcb;\n"
"    ccb_h-&gt;status |= CAM_SIM_QUEUED;"
msgstr ""
"    struct xxx_hcb *hcb = allocate_hcb(softc, unit, bus);\n"
"\n"
"    if(hcb == NULL) {\n"
"        softc-&gt;flags |= RESOURCE_SHORTAGE;\n"
"        xpt_freeze_simq(sim, /*count*/1);\n"
"        ccb_h-&gt;status = CAM_REQUEUE_REQ;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"\n"
"    hcb-&gt;ccb = ccb; ccb_h-&gt;ccb_hcb = (void *)hcb;\n"
"    ccb_h-&gt;status |= CAM_SIM_QUEUED;"

#. (itstool) path: listitem/para
#: book.translate.xml:20183
#, fuzzy
msgid ""
"Extract the target data from CCB into the hardware control block. Check if "
"we are asked to assign a tag and if yes then generate an unique tag and "
"build the SCSI tag messages. The SIM driver is also responsible for "
"negotiations with the devices to set the maximal mutually supported bus "
"width, synchronous rate and offset."
msgstr ""
"Extraia os dados de destino do CCB no bloco de controle de hardware. "
"Verifique se somos solicitados a atribuir uma tag e, se sim, gerar uma tag "
"�nica e criar as mensagens de tag SCSI. O driver do SIM tamb�m � respons�vel "
"pelas negocia��es com os dispositivos a serem definidos a largura de "
"barramento m�xima mutuamente suportada, a taxa s�ncrona e o deslocamento \""

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20190
#, no-wrap
msgid ""
"    hcb-&gt;target = ccb_h-&gt;target_id; hcb-&gt;lun = ccb_h-&gt;target_lun;\n"
"    generate_identify_message(hcb);\n"
"    if( ccb_h-&gt;tag_action != CAM_TAG_ACTION_NONE )\n"
"        generate_unique_tag_message(hcb, ccb_h-&gt;tag_action);\n"
"    if( !target_negotiated(hcb) )\n"
"        generate_negotiation_messages(hcb);"
msgstr ""
"    hcb-&gt;target = ccb_h-&gt;target_id; hcb-&gt;lun = ccb_h-&gt;target_lun;\n"
"    generate_identify_message(hcb);\n"
"    if( ccb_h-&gt;tag_action != CAM_TAG_ACTION_NONE )\n"
"        generate_unique_tag_message(hcb, ccb_h-&gt;tag_action);\n"
"    if( !target_negotiated(hcb) )\n"
"        generate_negotiation_messages(hcb);"

#. (itstool) path: listitem/para
#: book.translate.xml:20197
#, fuzzy
msgid ""
"Then set up the SCSI command. The command storage may be specified in the "
"CCB in many interesting ways, specified by the CCB flags. The command buffer "
"can be contained in CCB or pointed to, in the latter case the pointer may be "
"physical or virtual. Since the hardware commonly needs physical address we "
"always convert the address to the physical one, typically using the busdma "
"API."
msgstr ""
"Em seguida, configure o comando SCSI. O armazenamento de comando pode ser "
"especificado no CCB de muitas maneiras interessantes, especificado pelos "
"sinalizadores do CCB. O buffer de comando pode estar contido no CCB ou "
"apontado, no �ltimo caso, o ponteiro pode ser f�sico ou Como o hardware "
"normalmente precisa de endere�o f�sico, sempre convertemos o endere�o para o "
"f�sico, geralmente usando a API busdma. "

#. (itstool) path: listitem/para
#: book.translate.xml:20205
#, fuzzy
msgid ""
"In case if a physical address is requested it is OK to return the CCB with "
"the status <errorname>CAM_REQ_INVALID</errorname>, the current drivers do "
"that. If necessary a physical address can be also converted or mapped back "
"to a virtual address but with big pain, so we do not do that."
msgstr ""
"No caso de um endere�o f�sico ser solicitado, � OK retornar o CCB com o "
"status <errorname> CAM_REQ_INVALID </errorname> , os drivers atuais fazem "
"isso. Se necess�rio, um endere�o f�sico tamb�m pode ser convertido ou "
"mapeado de volta para um endere�o virtual, mas com grande dificuldade, por "
"isso n�o fazemos isso. "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20212
#, no-wrap
msgid ""
"    if(ccb_h-&gt;flags &amp; CAM_CDB_POINTER) {\n"
"        /* CDB is a pointer */\n"
"        if(!(ccb_h-&gt;flags &amp; CAM_CDB_PHYS)) {\n"
"            /* CDB pointer is virtual */\n"
"            hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_ptr);\n"
"        } else {\n"
"            /* CDB pointer is physical */\n"
"            hcb-&gt;cmd = csio-&gt;cdb_io.cdb_ptr ;\n"
"        }\n"
"    } else {\n"
"        /* CDB is in the ccb (buffer) */\n"
"        hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_bytes);\n"
"    }\n"
"    hcb-&gt;cmdlen = csio-&gt;cdb_len;"
msgstr ""
"    if(ccb_h-&gt;flags &amp; CAM_CDB_POINTER) {\n"
"        /* CDB is a pointer */\n"
"        if(!(ccb_h-&gt;flags &amp; CAM_CDB_PHYS)) {\n"
"            /* CDB pointer is virtual */\n"
"            hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_ptr);\n"
"        } else {\n"
"            /* CDB pointer is physical */\n"
"            hcb-&gt;cmd = csio-&gt;cdb_io.cdb_ptr ;\n"
"        }\n"
"    } else {\n"
"        /* CDB is in the ccb (buffer) */\n"
"        hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_bytes);\n"
"    }\n"
"    hcb-&gt;cmdlen = csio-&gt;cdb_len;"

#. (itstool) path: listitem/para
#: book.translate.xml:20227
#, fuzzy
msgid ""
"Now it is time to set up the data. Again, the data storage may be specified "
"in the CCB in many interesting ways, specified by the CCB flags. First we "
"get the direction of the data transfer. The simplest case is if there is no "
"data to transfer:"
msgstr ""
"Agora � hora de configurar os dados. Novamente, o armazenamento de dados "
"pode ser especificado no CCB de muitas maneiras interessantes, especificado "
"pelos sinalizadores do CCB. Primeiro, obtemos a dire��o da transfer�ncia de "
"dados. O caso mais simples � se houver nenhum dado para transferir: "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20233
#, no-wrap
msgid ""
"    int dir = (ccb_h-&gt;flags &amp; CAM_DIR_MASK);\n"
"\n"
"    if (dir == CAM_DIR_NONE)\n"
"        goto end_data;"
msgstr ""
"    int dir = (ccb_h-&gt;flags &amp; CAM_DIR_MASK);\n"
"\n"
"    if (dir == CAM_DIR_NONE)\n"
"        goto end_data;"

#. (itstool) path: listitem/para
#: book.translate.xml:20238
#, fuzzy
msgid ""
"Then we check if the data is in one chunk or in a scatter-gather list, and "
"the addresses are physical or virtual. The SCSI controller may be able to "
"handle only a limited number of chunks of limited length. If the request "
"hits this limitation we return an error. We use a special function to return "
"the CCB to handle in one place the HCB resource shortages. The functions to "
"add chunks are driver-dependent, and here we leave them without detailed "
"implementation. See description of the SCSI command (CDB) handling for the "
"details on the address-translation issues. If some variation is too "
"difficult or impossible to implement with a particular card it is OK to "
"return the status <errorname>CAM_REQ_INVALID</errorname>. Actually, it seems "
"like the scatter-gather ability is not used anywhere in the CAM code now. "
"But at least the case for a single non-scattered virtual buffer must be "
"implemented, it is actively used by CAM."
msgstr ""
"Em seguida, verificamos se os dados est�o em um fragmento ou em uma lista de "
"dispers�o-coleta, e os endere�os s�o f�sicos ou virtuais. O controlador SCSI "
"pode manipular apenas um n�mero limitado de fragmentos de tamanho limitado. "
"Se a solicita��o atingir esse limita��o n�s retornamos um erro.N�s usamos "
"uma fun��o especial para retornar o CCB para lidar em um lugar a escassez de "
"recursos HCB.As fun��es para adicionar peda�os s�o dependentes do driver, e "
"aqui n�s deix�-los sem implementa��o detalhada.Veja a descri��o do comando "
"SCSI (CDB) tratando dos detalhes sobre os problemas de tradu��o de endere�os."
"Se alguma varia��o for muito dif�cil ou imposs�vel de implementar com um "
"cart�o espec�fico, n�o h� problema em retornar o status <errorname> "
"CAM_REQ_INVALID </errorname> . Na verdade, parece que a habilidade de "
"espalhar-reunir n�o � usada em nenhum lugar no c�digo CAM agora. Mas pelo "
"menos o caso de um �nico buffer virtual n�o disperso deve ser implementado, "
"ele � usado ativamente pelo CAM. "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20256
#, no-wrap
msgid ""
"    int rv;\n"
"\n"
"    initialize_hcb_for_data(hcb);\n"
"\n"
"    if((!(ccb_h-&gt;flags &amp; CAM_SCATTER_VALID)) {\n"
"        /* single buffer */\n"
"        if(!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {\n"
"            rv = add_virtual_chunk(hcb, csio-&gt;data_ptr, csio-&gt;dxfer_len, dir);\n"
"            }\n"
"        } else {\n"
"            rv = add_physical_chunk(hcb, csio-&gt;data_ptr, csio-&gt;dxfer_len, dir);\n"
"        }\n"
"    } else {\n"
"        int i;\n"
"        struct bus_dma_segment *segs;\n"
"        segs = (struct bus_dma_segment *)csio-&gt;data_ptr;\n"
"\n"
"        if ((ccb_h-&gt;flags &amp; CAM_SG_LIST_PHYS) != 0) {\n"
"            /* The SG list pointer is physical */\n"
"            rv = setup_hcb_for_physical_sg_list(hcb, segs, csio-&gt;sglist_cnt);\n"
"        } else if (!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {\n"
"            /* SG buffer pointers are virtual */\n"
"            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {\n"
"                rv = add_virtual_chunk(hcb, segs[i].ds_addr,\n"
"                    segs[i].ds_len, dir);\n"
"                if (rv != CAM_REQ_CMP)\n"
"                    break;\n"
"            }\n"
"        } else {\n"
"            /* SG buffer pointers are physical */\n"
"            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {\n"
"                rv = add_physical_chunk(hcb, segs[i].ds_addr,\n"
"                    segs[i].ds_len, dir);\n"
"                if (rv != CAM_REQ_CMP)\n"
"                    break;\n"
"            }\n"
"        }\n"
"    }\n"
"    if(rv != CAM_REQ_CMP) {\n"
"        /* we expect that add_*_chunk() functions return CAM_REQ_CMP\n"
"         * if they added a chunk successfully, CAM_REQ_TOO_BIG if\n"
"         * the request is too big (too many bytes or too many chunks),\n"
"         * CAM_REQ_INVALID in case of other troubles\n"
"         */\n"
"        free_hcb_and_ccb_done(hcb, ccb, rv);\n"
"        return;\n"
"    }\n"
"    end_data:"
msgstr ""
"    int rv;\n"
"\n"
"    initialize_hcb_for_data(hcb);\n"
"\n"
"    if((!(ccb_h-&gt;flags &amp; CAM_SCATTER_VALID)) {\n"
"        /* single buffer */\n"
"        if(!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {\n"
"            rv = add_virtual_chunk(hcb, csio-&gt;data_ptr, csio-&gt;dxfer_len, dir);\n"
"            }\n"
"        } else {\n"
"            rv = add_physical_chunk(hcb, csio-&gt;data_ptr, csio-&gt;dxfer_len, dir);\n"
"        }\n"
"    } else {\n"
"        int i;\n"
"        struct bus_dma_segment *segs;\n"
"        segs = (struct bus_dma_segment *)csio-&gt;data_ptr;\n"
"\n"
"        if ((ccb_h-&gt;flags &amp; CAM_SG_LIST_PHYS) != 0) {\n"
"            /* The SG list pointer is physical */\n"
"            rv = setup_hcb_for_physical_sg_list(hcb, segs, csio-&gt;sglist_cnt);\n"
"        } else if (!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {\n"
"            /* SG buffer pointers are virtual */\n"
"            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {\n"
"                rv = add_virtual_chunk(hcb, segs[i].ds_addr,\n"
"                    segs[i].ds_len, dir);\n"
"                if (rv != CAM_REQ_CMP)\n"
"                    break;\n"
"            }\n"
"        } else {\n"
"            /* SG buffer pointers are physical */\n"
"            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {\n"
"                rv = add_physical_chunk(hcb, segs[i].ds_addr,\n"
"                    segs[i].ds_len, dir);\n"
"                if (rv != CAM_REQ_CMP)\n"
"                    break;\n"
"            }\n"
"        }\n"
"    }\n"
"    if(rv != CAM_REQ_CMP) {\n"
"        /* we expect that add_*_chunk() functions return CAM_REQ_CMP\n"
"         * if they added a chunk successfully, CAM_REQ_TOO_BIG if\n"
"         * the request is too big (too many bytes or too many chunks),\n"
"         * CAM_REQ_INVALID in case of other troubles\n"
"         */\n"
"        free_hcb_and_ccb_done(hcb, ccb, rv);\n"
"        return;\n"
"    }\n"
"    end_data:"

#. (itstool) path: listitem/para
#: book.translate.xml:20305
#, fuzzy
msgid ""
"If disconnection is disabled for this CCB we pass this information to the "
"hcb:"
msgstr ""
"Se a desconex�o estiver desativada para este CCB, n�s passamos esta "
"informa��o para o hcb:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20308
#, no-wrap
msgid ""
"    if(ccb_h-&gt;flags &amp; CAM_DIS_DISCONNECT)\n"
"        hcb_disable_disconnect(hcb);"
msgstr ""
"    if(ccb_h-&gt;flags &amp; CAM_DIS_DISCONNECT)\n"
"        hcb_disable_disconnect(hcb);"

#. (itstool) path: listitem/para
#: book.translate.xml:20311
#, fuzzy
msgid ""
"If the controller is able to run REQUEST SENSE command all by itself then "
"the value of the flag CAM_DIS_AUTOSENSE should also be passed to it, to "
"prevent automatic REQUEST SENSE if the CAM subsystem does not want it."
msgstr ""
"Se o controlador puder executar o comando REQUEST SENSE sozinho, o valor do "
"sinalizador CAM_DIS_AUTOSENSE tamb�m dever� ser passado para ele, para "
"evitar o REQUEST SENSE autom�tico se o subsistema CAM n�o o quiser."

#. (itstool) path: listitem/para
#: book.translate.xml:20316
#, fuzzy
msgid ""
"The only thing left is to set up the timeout, pass our hcb to the hardware "
"and return, the rest will be done by the interrupt handler (or timeout "
"handler)."
msgstr ""
"A �nica coisa que resta � configurar o tempo limite, passar o nosso hcb para "
"o hardware e retornar, o resto ser� feito pelo manipulador de interrup��o "
"(ou manipulador de tempo limite)."

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20320
#, no-wrap
msgid ""
"    ccb_h-&gt;timeout_ch = timeout(xxx_timeout, (caddr_t) hcb,\n"
"        (ccb_h-&gt;timeout * hz) / 1000); /* convert milliseconds to ticks */\n"
"    put_hcb_into_hardware_queue(hcb);\n"
"    return;"
msgstr ""
"    ccb_h-&gt;timeout_ch = timeout(xxx_timeout, (caddr_t) hcb,\n"
"        (ccb_h-&gt;timeout * hz) / 1000); /* convert milliseconds to ticks */\n"
"    put_hcb_into_hardware_queue(hcb);\n"
"    return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20325
#, fuzzy
msgid "And here is a possible implementation of the function returning CCB:"
msgstr "E aqui est� uma implementa��o poss�vel da fun��o que retorna o CCB:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20328
#, no-wrap
msgid ""
"    static void\n"
"    free_hcb_and_ccb_done(struct xxx_hcb *hcb, union ccb *ccb, u_int32_t status)\n"
"    {\n"
"        struct xxx_softc *softc = hcb-&gt;softc;\n"
"\n"
"        ccb-&gt;ccb_h.ccb_hcb = 0;\n"
"        if(hcb != NULL) {\n"
"            untimeout(xxx_timeout, (caddr_t) hcb, ccb-&gt;ccb_h.timeout_ch);\n"
"            /* we're about to free a hcb, so the shortage has ended */\n"
"            if(softc-&gt;flags &amp; RESOURCE_SHORTAGE)  {\n"
"                softc-&gt;flags &amp;= ~RESOURCE_SHORTAGE;\n"
"                status |= CAM_RELEASE_SIMQ;\n"
"            }\n"
"            free_hcb(hcb); /* also removes hcb from any internal lists */\n"
"        }\n"
"        ccb-&gt;ccb_h.status = status |\n"
"            (ccb-&gt;ccb_h.status &amp; ~(CAM_STATUS_MASK|CAM_SIM_QUEUED));\n"
"        xpt_done(ccb);\n"
"    }"
msgstr ""
"    static void\n"
"    free_hcb_and_ccb_done(struct xxx_hcb *hcb, union ccb *ccb, u_int32_t status)\n"
"    {\n"
"        struct xxx_softc *softc = hcb-&gt;softc;\n"
"\n"
"        ccb-&gt;ccb_h.ccb_hcb = 0;\n"
"        if(hcb != NULL) {\n"
"            untimeout(xxx_timeout, (caddr_t) hcb, ccb-&gt;ccb_h.timeout_ch);\n"
"            /* we're about to free a hcb, so the shortage has ended */\n"
"            if(softc-&gt;flags &amp; RESOURCE_SHORTAGE)  {\n"
"                softc-&gt;flags &amp;= ~RESOURCE_SHORTAGE;\n"
"                status |= CAM_RELEASE_SIMQ;\n"
"            }\n"
"            free_hcb(hcb); /* also removes hcb from any internal lists */\n"
"        }\n"
"        ccb-&gt;ccb_h.status = status |\n"
"            (ccb-&gt;ccb_h.status &amp; ~(CAM_STATUS_MASK|CAM_SIM_QUEUED));\n"
"        xpt_done(ccb);\n"
"    }"

#. (itstool) path: listitem/para
#: book.translate.xml:20350
#, fuzzy
msgid ""
"<emphasis>XPT_RESET_DEV</emphasis> - send the SCSI <quote>BUS DEVICE RESET</"
"quote> message to a device"
msgstr ""
" <emphasis> XPT_RESET_DEV </emphasis> - enviar o SCSI <quote> REDU��O DO "
"DISPOSITIVO DE BARRAMENTO </quote> mensagem para um dispositivo "

#. (itstool) path: listitem/para
#: book.translate.xml:20353
#, fuzzy
msgid ""
"There is no data transferred in CCB except the header and the most "
"interesting argument of it is target_id. Depending on the controller "
"hardware a hardware control block just like for the XPT_SCSI_IO request may "
"be constructed (see XPT_SCSI_IO request description) and sent to the "
"controller or the SCSI controller may be immediately programmed to send this "
"RESET message to the device or this request may be just not supported (and "
"return the status <errorname>CAM_REQ_INVALID</errorname>). Also on "
"completion of the request all the disconnected transactions for this target "
"must be aborted (probably in the interrupt routine)."
msgstr ""
"N�o h� dados transferidos no CCB, exceto o cabe�alho e o argumento mais "
"interessante dele � target_id. Dependendo do hardware do controlador, um "
"bloco de controle de hardware como para o pedido XPT_SCSI_IO pode ser "
"constru�do (ver descri��o da solicita��o XPT_SCSI_IO) e enviado ao "
"controlador ou o controlador SCSI pode ser programado imediatamente para "
"enviar esta mensagem RESET para o dispositivo ou esta solicita��o pode n�o "
"ser suportada (e retornar o status <errorname> CAM_REQ_INVALID </"
"errorname> ). Tamb�m na conclus�o da solicita��o, todas as transa��es "
"desconectadas para este destino devem ser abortadas (provavelmente na rotina "
"de interrup��o). "

#. (itstool) path: listitem/para
#: book.translate.xml:20366
#, fuzzy
msgid ""
"Also all the current negotiations for the target are lost on reset, so they "
"might be cleaned too. Or they clearing may be deferred, because anyway the "
"target would request re-negotiation on the next transaction."
msgstr ""
"Al�m disso, todas as negocia��es atuais para a meta s�o perdidas na "
"redefini��o, para que possam ser limpas tamb�m. Ou a compensa��o pode ser "
"adiada, porque, de qualquer maneira, a meta solicitaria a renegocia��o na "
"pr�xima transa��o."

#. (itstool) path: listitem/para
#: book.translate.xml:20374
#, fuzzy
msgid ""
"<emphasis>XPT_RESET_BUS</emphasis> - send the RESET signal to the SCSI bus"
msgstr ""
" <emphasis> XPT_RESET_BUS </emphasis> - envie o sinal RESET para o "
"barramento SCSI "

#. (itstool) path: listitem/para
#: book.translate.xml:20377
#, fuzzy
msgid ""
"No arguments are passed in the CCB, the only interesting argument is the "
"SCSI bus indicated by the struct sim pointer."
msgstr ""
"Nenhum argumento � passado no CCB, o �nico argumento interessante � o "
"barramento SCSI indicado pelo ponteiro struct sim."

#. (itstool) path: listitem/para
#: book.translate.xml:20381
#, fuzzy
msgid ""
"A minimalistic implementation would forget the SCSI negotiations for all the "
"devices on the bus and return the status CAM_REQ_CMP."
msgstr ""
"Uma implementa��o minimalista esqueceria as negocia��es do SCSI para todos "
"os dispositivos no barramento e retornaria o status CAM_REQ_CMP."

#. (itstool) path: listitem/para
#: book.translate.xml:20385
#, fuzzy
msgid ""
"The proper implementation would in addition actually reset the SCSI bus "
"(possible also reset the SCSI controller) and mark all the CCBs being "
"processed, both those in the hardware queue and those being disconnected, as "
"done with the status CAM_SCSI_BUS_RESET. Like:"
msgstr ""
"A implementa��o adequada, al�m disso, realmente redefinir o barramento SCSI "
"(poss�vel tamb�m redefinir o controlador SCSI) e marcar todos os CCBs sendo "
"processados, tanto aqueles na fila de hardware quanto aqueles desconectados, "
"como feito com o status CAM_SCSI_BUS_RESET. Como:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20391
#, no-wrap
msgid ""
"    int targ, lun;\n"
"    struct xxx_hcb *h, *hh;\n"
"    struct ccb_trans_settings neg;\n"
"    struct cam_path *path;\n"
"\n"
"    /* The SCSI bus reset may take a long time, in this case its completion\n"
"     * should be checked by interrupt or timeout. But for simplicity\n"
"     * we assume here that it is really fast.\n"
"     */\n"
"    reset_scsi_bus(softc);\n"
"\n"
"    /* drop all enqueued CCBs */\n"
"    for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"        hh = h-&gt;next;\n"
"        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"    }\n"
"\n"
"    /* the clean values of negotiations to report */\n"
"    neg.bus_width = 8;\n"
"    neg.sync_period = neg.sync_offset = 0;\n"
"    neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"        | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"\n"
"    /* drop all disconnected CCBs and clean negotiations  */\n"
"    for(targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {\n"
"        clean_negotiations(softc, targ);\n"
"\n"
"        /* report the event if possible */\n"
"        if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                cam_sim_path(sim), targ,\n"
"                CAM_LUN_WILDCARD) == CAM_REQ_CMP) {\n"
"            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"            xpt_free_path(path);\n"
"        }\n"
"\n"
"        for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"            for(h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h = hh) {\n"
"                hh=h-&gt;next;\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"            }\n"
"    }\n"
"\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"\n"
"    /* report the event */\n"
"    xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);\n"
"    return;"
msgstr ""
"    int targ, lun;\n"
"    struct xxx_hcb *h, *hh;\n"
"    struct ccb_trans_settings neg;\n"
"    struct cam_path *path;\n"
"\n"
"    /* The SCSI bus reset may take a long time, in this case its completion\n"
"     * should be checked by interrupt or timeout. But for simplicity\n"
"     * we assume here that it is really fast.\n"
"     */\n"
"    reset_scsi_bus(softc);\n"
"\n"
"    /* drop all enqueued CCBs */\n"
"    for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"        hh = h-&gt;next;\n"
"        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"    }\n"
"\n"
"    /* the clean values of negotiations to report */\n"
"    neg.bus_width = 8;\n"
"    neg.sync_period = neg.sync_offset = 0;\n"
"    neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"        | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"\n"
"    /* drop all disconnected CCBs and clean negotiations  */\n"
"    for(targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {\n"
"        clean_negotiations(softc, targ);\n"
"\n"
"        /* report the event if possible */\n"
"        if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                cam_sim_path(sim), targ,\n"
"                CAM_LUN_WILDCARD) == CAM_REQ_CMP) {\n"
"            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"            xpt_free_path(path);\n"
"        }\n"
"\n"
"        for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"            for(h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h = hh) {\n"
"                hh=h-&gt;next;\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"            }\n"
"    }\n"
"\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"\n"
"    /* report the event */\n"
"    xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);\n"
"    return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20440
#, fuzzy
msgid ""
"Implementing the SCSI bus reset as a function may be a good idea because it "
"would be re-used by the timeout function as a last resort if the things go "
"wrong."
msgstr ""
"Implementar a reinicializa��o do barramento SCSI como uma fun��o pode ser "
"uma boa id�ia, porque ela seria reutilizada pela fun��o de tempo limite como "
"�ltimo recurso se as coisas derem errado."

#. (itstool) path: listitem/para
#: book.translate.xml:20447
#, fuzzy
msgid "<emphasis>XPT_ABORT</emphasis> - abort the specified CCB"
msgstr " <emphasis> XPT_ABORT </emphasis> - abortar o CCB especificad"

#. (itstool) path: listitem/para
#: book.translate.xml:20450
#, fuzzy
msgid ""
"The arguments are transferred in the instance <quote>struct ccb_abort cab</"
"quote> of the union ccb. The only argument field in it is:"
msgstr ""
"Os argumentos s�o transferidos na inst�ncia <quote> t�xi do struct ccb_abort "
"</quote> da uni�o ccb. O �nico campo de argumento �: "

#. (itstool) path: listitem/para
#: book.translate.xml:20454
#, fuzzy
msgid "<emphasis>abort_ccb</emphasis> - pointer to the CCB to be aborted"
msgstr " <emphasis> abort_ccb </emphasis> - apontador para o CCB ser abortado "

#. (itstool) path: listitem/para
#: book.translate.xml:20457
#, fuzzy
msgid ""
"If the abort is not supported just return the status CAM_UA_ABORT. This is "
"also the easy way to minimally implement this call, return CAM_UA_ABORT in "
"any case."
msgstr ""
"Se o cancelamento n�o for suportado, apenas retorne o status CAM_UA_ABORT. "
"Esta � tamb�m a maneira mais f�cil de implementar minimamente esta chamada, "
"retornando CAM_UA_ABORT em qualquer caso."

#. (itstool) path: listitem/para
#: book.translate.xml:20461
#, fuzzy
msgid ""
"The hard way is to implement this request honestly. First check that abort "
"applies to a SCSI transaction:"
msgstr ""
"A maneira mais dif�cil � implementar essa solicita��o com honestidade. "
"Primeiro, verifique se a anula��o se aplica a uma transa��o SCSI:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20464
#, no-wrap
msgid ""
"    struct ccb *abort_ccb;\n"
"    abort_ccb = ccb-&gt;cab.abort_ccb;\n"
"\n"
"    if(abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {\n"
"        ccb-&gt;ccb_h.status = CAM_UA_ABORT;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"
msgstr ""
"    struct ccb *abort_ccb;\n"
"    abort_ccb = ccb-&gt;cab.abort_ccb;\n"
"\n"
"    if(abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {\n"
"        ccb-&gt;ccb_h.status = CAM_UA_ABORT;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"

#. (itstool) path: listitem/para
#: book.translate.xml:20473
#, fuzzy
msgid ""
"Then it is necessary to find this CCB in our queue. This can be done by "
"walking the list of all our hardware control blocks in search for one "
"associated with this CCB:"
msgstr ""
"Ent�o � necess�rio encontrar este CCB em nossa fila. Isso pode ser feito "
"andando a lista de todos os nossos blocos de controle de hardware em busca "
"de um associado a este CCB:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20478
#, no-wrap
msgid ""
"    struct xxx_hcb *hcb, *h;\n"
"\n"
"    hcb = NULL;\n"
"\n"
"    /* We assume that softc-&gt;first_hcb is the head of the list of all\n"
"     * HCBs associated with this bus, including those enqueued for\n"
"     * processing, being processed by hardware and disconnected ones.\n"
"     */\n"
"    for(h = softc-&gt;first_hcb; h != NULL; h = h-&gt;next) {\n"
"        if(h-&gt;ccb == abort_ccb) {\n"
"            hcb = h;\n"
"            break;\n"
"        }\n"
"    }\n"
"\n"
"    if(hcb == NULL) {\n"
"        /* no such CCB in our queue */\n"
"        ccb-&gt;ccb_h.status = CAM_PATH_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"\n"
"    hcb=found_hcb;"
msgstr ""
"    struct xxx_hcb *hcb, *h;\n"
"\n"
"    hcb = NULL;\n"
"\n"
"    /* We assume that softc-&gt;first_hcb is the head of the list of all\n"
"     * HCBs associated with this bus, including those enqueued for\n"
"     * processing, being processed by hardware and disconnected ones.\n"
"     */\n"
"    for(h = softc-&gt;first_hcb; h != NULL; h = h-&gt;next) {\n"
"        if(h-&gt;ccb == abort_ccb) {\n"
"            hcb = h;\n"
"            break;\n"
"        }\n"
"    }\n"
"\n"
"    if(hcb == NULL) {\n"
"        /* no such CCB in our queue */\n"
"        ccb-&gt;ccb_h.status = CAM_PATH_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"\n"
"    hcb=found_hcb;"

#. (itstool) path: listitem/para
#: book.translate.xml:20502
#, fuzzy
msgid ""
"Now we look at the current processing status of the HCB. It may be either "
"sitting in the queue waiting to be sent to the SCSI bus, being transferred "
"right now, or disconnected and waiting for the result of the command, or "
"actually completed by hardware but not yet marked as done by software. To "
"make sure that we do not get in any races with hardware we mark the HCB as "
"being aborted, so that if this HCB is about to be sent to the SCSI bus the "
"SCSI controller will see this flag and skip it."
msgstr ""
"Agora olhamos para o status atual do processamento do HCB. Ele pode estar na "
"fila esperando para ser enviado para o barramento SCSI, sendo transferido "
"agora ou desconectado e aguardando o resultado do comando, ou realmente "
"conclu�do por hardware, mas ainda n�o marcado como feito por software.Para "
"ter certeza de que n�o entraremos em nenhuma corrida com hardware, "
"marcaremos o HCB como sendo abortado, de modo que, se esse HCB estiver "
"prestes a ser enviado para o barramento SCSI, o controlador SCSI ver� esta "
"bandeira e pule-a. "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20512
#, no-wrap
msgid ""
"    int hstatus;\n"
"\n"
"    /* shown as a function, in case special action is needed to make\n"
"     * this flag visible to hardware\n"
"     */\n"
"    set_hcb_flags(hcb, HCB_BEING_ABORTED);\n"
"\n"
"    abort_again:\n"
"\n"
"    hstatus = get_hcb_status(hcb);\n"
"    switch(hstatus) {\n"
"    case HCB_SITTING_IN_QUEUE:\n"
"        remove_hcb_from_hardware_queue(hcb);\n"
"        /* FALLTHROUGH */\n"
"    case HCB_COMPLETED:\n"
"        /* this is an easy case */\n"
"        free_hcb_and_ccb_done(hcb, abort_ccb, CAM_REQ_ABORTED);\n"
"        break;"
msgstr ""
"    int hstatus;\n"
"\n"
"    /* shown as a function, in case special action is needed to make\n"
"     * this flag visible to hardware\n"
"     */\n"
"    set_hcb_flags(hcb, HCB_BEING_ABORTED);\n"
"\n"
"    abort_again:\n"
"\n"
"    hstatus = get_hcb_status(hcb);\n"
"    switch(hstatus) {\n"
"    case HCB_SITTING_IN_QUEUE:\n"
"        remove_hcb_from_hardware_queue(hcb);\n"
"        /* FALLTHROUGH */\n"
"    case HCB_COMPLETED:\n"
"        /* this is an easy case */\n"
"        free_hcb_and_ccb_done(hcb, abort_ccb, CAM_REQ_ABORTED);\n"
"        break;"

#. (itstool) path: listitem/para
#: book.translate.xml:20531
#, fuzzy
msgid ""
"If the CCB is being transferred right now we would like to signal to the "
"SCSI controller in some hardware-dependent way that we want to abort the "
"current transfer. The SCSI controller would set the SCSI ATTENTION signal "
"and when the target responds to it send an ABORT message. We also reset the "
"timeout to make sure that the target is not sleeping forever. If the command "
"would not get aborted in some reasonable time like 10 seconds the timeout "
"routine would go ahead and reset the whole SCSI bus. Because the command "
"will be aborted in some reasonable time we can just return the abort request "
"now as successfully completed, and mark the aborted CCB as aborted (but not "
"mark it as done yet)."
msgstr ""
"Se o CCB est� sendo transferido agora, gostar�amos de sinalizar para o "
"controlador SCSI de alguma maneira dependente de hardware que queremos "
"abortar a transfer�ncia atual. O controlador SCSI configuraria o sinal SCSI "
"ATTENTION e quando o destino responder a ele, enviar�amos uma mensagem ABORT."
"N�s tamb�m redefinimos o tempo limite para ter certeza de que o alvo n�o "
"est� dormindo para sempre.Se o comando n�o fosse abortado em algum tempo "
"razo�vel como 10 segundos, a rotina de tempo limite iria adiante e "
"reinicializaria todo o barramento SCSI. ser� abortado em algum tempo "
"razo�vel, podemos simplesmente retornar a requisi��o abortar agora como "
"conclu�da com sucesso, e marcar o CCB abortado como abortado (mas n�o marc�-"
"lo como feito ainda). "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20545
#, no-wrap
msgid ""
"    case HCB_BEING_TRANSFERRED:\n"
"        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h.timeout_ch);\n"
"        abort_ccb-&gt;ccb_h.timeout_ch =\n"
"            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);\n"
"        abort_ccb-&gt;ccb_h.status = CAM_REQ_ABORTED;\n"
"        /* ask the controller to abort that HCB, then generate\n"
"         * an interrupt and stop\n"
"         */\n"
"        if(signal_hardware_to_abort_hcb_and_stop(hcb) &lt; 0) {\n"
"            /* oops, we missed the race with hardware, this transaction\n"
"             * got off the bus before we aborted it, try again */\n"
"            goto abort_again;\n"
"        }\n"
"\n"
"        break;"
msgstr ""
"    case HCB_BEING_TRANSFERRED:\n"
"        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h.timeout_ch);\n"
"        abort_ccb-&gt;ccb_h.timeout_ch =\n"
"            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);\n"
"        abort_ccb-&gt;ccb_h.status = CAM_REQ_ABORTED;\n"
"        /* ask the controller to abort that HCB, then generate\n"
"         * an interrupt and stop\n"
"         */\n"
"        if(signal_hardware_to_abort_hcb_and_stop(hcb) &lt; 0) {\n"
"            /* oops, we missed the race with hardware, this transaction\n"
"             * got off the bus before we aborted it, try again */\n"
"            goto abort_again;\n"
"        }\n"
"\n"
"        break;"

#. (itstool) path: listitem/para
#: book.translate.xml:20561
#, fuzzy
msgid ""
"If the CCB is in the list of disconnected then set it up as an abort request "
"and re-queue it at the front of hardware queue. Reset the timeout and report "
"the abort request to be completed."
msgstr ""
"Se o CCB estiver na lista de desconectados, configure-o como uma solicita��o "
"de interrup��o e enfileire-o novamente na frente da fila de hardware. "
"Redefina o tempo limite e informe a solicita��o de interrup��o a ser "
"conclu�da."

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20566
#, no-wrap
msgid ""
"    case HCB_DISCONNECTED:\n"
"        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h.timeout_ch);\n"
"        abort_ccb-&gt;ccb_h.timeout_ch =\n"
"            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);\n"
"        put_abort_message_into_hcb(hcb);\n"
"        put_hcb_at_the_front_of_hardware_queue(hcb);\n"
"        break;\n"
"    }\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"
msgstr ""
"    case HCB_DISCONNECTED:\n"
"        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h.timeout_ch);\n"
"        abort_ccb-&gt;ccb_h.timeout_ch =\n"
"            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);\n"
"        put_abort_message_into_hcb(hcb);\n"
"        put_hcb_at_the_front_of_hardware_queue(hcb);\n"
"        break;\n"
"    }\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20578
#, fuzzy
msgid ""
"That is all for the ABORT request, although there is one more issue. Because "
"the ABORT message cleans all the ongoing transactions on a LUN we have to "
"mark all the other active transactions on this LUN as aborted. That should "
"be done in the interrupt routine, after the transaction gets aborted."
msgstr ""
"Isso � tudo para o pedido ABORT, embora haja mais um problema. Como a "
"mensagem ABORT limpa todas as transa��es em andamento em um LUN, temos que "
"marcar todas as outras transa��es ativas neste LUN como abortadas. Isso deve "
"ser feito na interrup��o rotina, ap�s a transa��o ser anulada. "

#. (itstool) path: listitem/para
#: book.translate.xml:20585
#, fuzzy
msgid ""
"Implementing the CCB abort as a function may be quite a good idea, this "
"function can be re-used if an I/O transaction times out. The only difference "
"would be that the timed out transaction would return the status "
"CAM_CMD_TIMEOUT for the timed out request. Then the case XPT_ABORT would be "
"small, like that:"
msgstr ""
"Implementar o cancelamento do CCB como uma fun��o pode ser uma boa id�ia, "
"essa fun��o pode ser reutilizada se uma transa��o de E / S atingir o tempo "
"limite. A �nica diferen�a seria que a transa��o expirada retornaria o status "
"CAM_CMD_TIMEOUT para o tempo limite esgotado. Ent�o, o caso XPT_ABORT seria "
"pequeno, assim: "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20592
#, no-wrap
msgid ""
"    case XPT_ABORT:\n"
"        struct ccb *abort_ccb;\n"
"        abort_ccb = ccb-&gt;cab.abort_ccb;\n"
"\n"
"        if(abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {\n"
"            ccb-&gt;ccb_h.status = CAM_UA_ABORT;\n"
"            xpt_done(ccb);\n"
"            return;\n"
"        }\n"
"        if(xxx_abort_ccb(abort_ccb, CAM_REQ_ABORTED) &lt; 0)\n"
"            /* no such CCB in our queue */\n"
"            ccb-&gt;ccb_h.status = CAM_PATH_INVALID;\n"
"        else\n"
"            ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"        xpt_done(ccb);\n"
"        return;"
msgstr ""
"    case XPT_ABORT:\n"
"        struct ccb *abort_ccb;\n"
"        abort_ccb = ccb-&gt;cab.abort_ccb;\n"
"\n"
"        if(abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {\n"
"            ccb-&gt;ccb_h.status = CAM_UA_ABORT;\n"
"            xpt_done(ccb);\n"
"            return;\n"
"        }\n"
"        if(xxx_abort_ccb(abort_ccb, CAM_REQ_ABORTED) &lt; 0)\n"
"            /* no such CCB in our queue */\n"
"            ccb-&gt;ccb_h.status = CAM_PATH_INVALID;\n"
"        else\n"
"            ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"        xpt_done(ccb);\n"
"        return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20611
#, fuzzy
msgid ""
"<emphasis>XPT_SET_TRAN_SETTINGS</emphasis> - explicitly set values of SCSI "
"transfer settings"
msgstr ""
" <emphasis> XPT_SET_TRAN_SETTINGS </emphasis> - definir explicitamente "
"valores de configura��es de transfer�ncia SCSI "

#. (itstool) path: listitem/para
#: book.translate.xml:20614
#, fuzzy
msgid ""
"The arguments are transferred in the instance <quote>struct "
"ccb_trans_setting cts</quote> of the union ccb:"
msgstr ""
"Os argumentos s�o transferidos na inst�ncia <quote> struct ccb_trans_setting "
"cts </quote> da uni�o ccb: "

#. (itstool) path: listitem/para
#: book.translate.xml:20620
#, fuzzy
msgid ""
"<emphasis>valid</emphasis> - a bitmask showing which settings should be "
"updated:"
msgstr ""
" <emphasis> v�lido </emphasis> - uma bitmask mostrando quais configura��es "
"devem ser atualizadas: "

#. (itstool) path: listitem/para
#: book.translate.xml:20625
#, fuzzy
msgid ""
"<emphasis>CCB_TRANS_SYNC_RATE_VALID</emphasis> - synchronous transfer rate"
msgstr ""
" <emphasis> CCB_TRANS_SYNC_RATE_VALID </emphasis> - taxa de transfer�ncia "
"s�ncrona "

#. (itstool) path: listitem/para
#: book.translate.xml:20630
#, fuzzy
msgid "<emphasis>CCB_TRANS_SYNC_OFFSET_VALID</emphasis> - synchronous offset"
msgstr ""
" <emphasis> CCB_TRANS_SYNC_OFFSET_VALID </emphasis> - deslocamento s�ncrono "

#. (itstool) path: listitem/para
#: book.translate.xml:20635
#, fuzzy
msgid "<emphasis>CCB_TRANS_BUS_WIDTH_VALID</emphasis> - bus width"
msgstr " <emphasis> CCB_TRANS_BUS_WIDTH_VALID </emphasis> - largura do �nibus"

#. (itstool) path: listitem/para
#: book.translate.xml:20640
#, fuzzy
msgid ""
"<emphasis>CCB_TRANS_DISC_VALID</emphasis> - set enable/disable disconnection"
msgstr ""
" <emphasis> CCB_TRANS_DISC_VALID </emphasis> - definir ativar / desativar a "
"desconex�o "

#. (itstool) path: listitem/para
#: book.translate.xml:20645
#, fuzzy
msgid ""
"<emphasis>CCB_TRANS_TQ_VALID</emphasis> - set enable/disable tagged queuing"
msgstr ""
" <emphasis> CCB_TRANS_TQ_VALID </emphasis> - definir ativar / desativar "
"enfileiramento marcado "

#. (itstool) path: listitem/para
#: book.translate.xml:20650
#, fuzzy
msgid ""
"<emphasis>flags</emphasis> - consists of two parts, binary arguments and "
"identification of sub-operations. The binary arguments are:"
msgstr ""
" <emphasis> bandeiras </emphasis> - consiste em duas partes, argumentos "
"bin�rios e identifica��o de subopera��es. Os argumentos bin�rios s�o: "

#. (itstool) path: listitem/para
#: book.translate.xml:20656
#, fuzzy
msgid "<emphasis>CCB_TRANS_DISC_ENB</emphasis> - enable disconnection"
msgstr " <emphasis> CCB_TRANS_DISC_ENB </emphasis> - habilitar a desconex�o "

#. (itstool) path: listitem/para
#: book.translate.xml:20661
#, fuzzy
msgid "<emphasis>CCB_TRANS_TAG_ENB</emphasis> - enable tagged queuing"
msgstr ""
" <emphasis> CCB_TRANS_TAG_ENB </emphasis> - ativar enfileiramento marcado "

#. (itstool) path: listitem/para
#: book.translate.xml:20668
#, fuzzy
msgid "the sub-operations are:"
msgstr "as subopera��es s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:20672
#, fuzzy
msgid ""
"<emphasis>CCB_TRANS_CURRENT_SETTINGS</emphasis> - change the current "
"negotiations"
msgstr ""
" <emphasis> CCB_TRANS_CURRENT_SETTINGS </emphasis> - mudar as negocia��es "
"atuais "

#. (itstool) path: listitem/para
#: book.translate.xml:20677
#, fuzzy
msgid ""
"<emphasis>CCB_TRANS_USER_SETTINGS</emphasis> - remember the desired user "
"values sync_period, sync_offset - self-explanatory, if sync_offset==0 then "
"the asynchronous mode is requested bus_width - bus width, in bits (not bytes)"
msgstr ""
" <emphasis> CCB_TRANS_USER_SETTINGS </emphasis> - lembre-se dos valores de "
"usu�rio desejados sync_period, sync_offset - autoexplicativos, se "
"sync_offset == 0 ent�o o modo ass�ncrono � solicitado bus_width - largura do "
"barramento, em bits (n�o bytes) "

#. (itstool) path: listitem/para
#: book.translate.xml:20687
#, fuzzy
msgid ""
"Two sets of negotiated parameters are supported, the user settings and the "
"current settings. The user settings are not really used much in the SIM "
"drivers, this is mostly just a piece of memory where the upper levels can "
"store (and later recall) its ideas about the parameters. Setting the user "
"parameters does not cause re-negotiation of the transfer rates. But when the "
"SCSI controller does a negotiation it must never set the values higher than "
"the user parameters, so it is essentially the top boundary."
msgstr ""
"Dois conjuntos de par�metros negociados s�o suportados, as configura��es do "
"usu�rio e as configura��es atuais. As configura��es do usu�rio n�o s�o muito "
"usadas nos drivers do SIM, isso � apenas uma parte da mem�ria onde os n�veis "
"superiores podem armazenar (e mais tarde chamar) id�ias sobre os par�metros. "
"Definir os par�metros do usu�rio n�o causa renegocia��o das taxas de "
"transfer�ncia. Mas quando o controlador SCSI faz uma negocia��o, ele nunca "
"deve definir os valores mais altos que os par�metros do usu�rio, portanto, � "
"essencialmente o limite superior. "

#. (itstool) path: listitem/para
#: book.translate.xml:20698
#, fuzzy
msgid ""
"The current settings are, as the name says, current. Changing them means "
"that the parameters must be re-negotiated on the next transfer. Again, these "
"<quote>new current settings</quote> are not supposed to be forced on the "
"device, just they are used as the initial step of negotiations. Also they "
"must be limited by actual capabilities of the SCSI controller: for example, "
"if the SCSI controller has 8-bit bus and the request asks to set 16-bit wide "
"transfers this parameter must be silently truncated to 8-bit transfers "
"before sending it to the device."
msgstr ""
"As configura��es atuais s�o, como o nome diz, atuais. Alter�-las significa "
"que os par�metros devem ser renegociados na pr�xima transfer�ncia. "
"Novamente, esses <quote> novas configura��es atuais </quote> N�o � suposto "
"ser for�ado no dispositivo, apenas eles s�o usados ​​como o passo inicial das "
"negocia��es. Al�m disso, eles devem ser limitados pelos recursos reais do "
"controlador SCSI: por exemplo, se o controlador SCSI tiver um barramento de "
"8 bits e a solicita��o solicitar a configura��o de transfer�ncias de 16 "
"bits, esse par�metro deve ser silenciosamente truncado para transfer�ncias "
"de 8 bits antes de envi�-lo para o dispositivo. "

#. (itstool) path: listitem/para
#: book.translate.xml:20710
#, fuzzy
msgid ""
"One caveat is that the bus width and synchronous parameters are per target "
"while the disconnection and tag enabling parameters are per lun."
msgstr ""
"Uma ressalva � que a largura do barramento e os par�metros s�ncronos s�o por "
"alvo enquanto os par�metros de habilita��o de desconex�o e tag s�o por lun."

#. (itstool) path: listitem/para
#: book.translate.xml:20714
#, fuzzy
msgid ""
"The recommended implementation is to keep 3 sets of negotiated (bus width "
"and synchronous transfer) parameters:"
msgstr ""
"A implementa��o recomendada � manter 3 conjuntos de par�metros negociados "
"(largura de barramento e transfer�ncia s�ncrona):"

#. (itstool) path: listitem/para
#: book.translate.xml:20720
#, fuzzy
msgid "<emphasis>user</emphasis> - the user set, as above"
msgstr ""
" <emphasis> do utilizador </emphasis> - o usu�rio definido, como acima "

#. (itstool) path: listitem/para
#: book.translate.xml:20725
#, fuzzy
msgid "<emphasis>current</emphasis> - those actually in effect"
msgstr " <emphasis> atual </emphasis> - aqueles realmente em vigor "

#. (itstool) path: listitem/para
#: book.translate.xml:20730
#, fuzzy
msgid ""
"<emphasis>goal</emphasis> - those requested by setting of the "
"<quote>current</quote> parameters"
msgstr ""
" <emphasis> objetivo </emphasis> - os pedidos pela fixa��o do <quote> atual "
"</quote> par�metros "

#. (itstool) path: listitem/para
#: book.translate.xml:20736
#, fuzzy
msgid "The code looks like:"
msgstr "O c�digo parece:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20738
#, no-wrap
msgid ""
"    struct ccb_trans_settings *cts;\n"
"    int targ, lun;\n"
"    int flags;\n"
"\n"
"    cts = &amp;ccb-&gt;cts;\n"
"    targ = ccb_h-&gt;target_id;\n"
"    lun = ccb_h-&gt;target_lun;\n"
"    flags = cts-&gt;flags;\n"
"    if(flags &amp; CCB_TRANS_USER_SETTINGS) {\n"
"        if(flags &amp; CCB_TRANS_SYNC_RATE_VALID)\n"
"            softc-&gt;user_sync_period[targ] = cts-&gt;sync_period;\n"
"        if(flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)\n"
"            softc-&gt;user_sync_offset[targ] = cts-&gt;sync_offset;\n"
"        if(flags &amp; CCB_TRANS_BUS_WIDTH_VALID)\n"
"            softc-&gt;user_bus_width[targ] = cts-&gt;bus_width;\n"
"\n"
"        if(flags &amp; CCB_TRANS_DISC_VALID) {\n"
"            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;\n"
"            softc-&gt;user_tflags[targ][lun] |= flags &amp; CCB_TRANS_DISC_ENB;\n"
"        }\n"
"        if(flags &amp; CCB_TRANS_TQ_VALID) {\n"
"            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;\n"
"            softc-&gt;user_tflags[targ][lun] |= flags &amp; CCB_TRANS_TQ_ENB;\n"
"        }\n"
"    }\n"
"    if(flags &amp; CCB_TRANS_CURRENT_SETTINGS) {\n"
"        if(flags &amp; CCB_TRANS_SYNC_RATE_VALID)\n"
"            softc-&gt;goal_sync_period[targ] =\n"
"                max(cts-&gt;sync_period, OUR_MIN_SUPPORTED_PERIOD);\n"
"        if(flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)\n"
"            softc-&gt;goal_sync_offset[targ] =\n"
"                min(cts-&gt;sync_offset, OUR_MAX_SUPPORTED_OFFSET);\n"
"        if(flags &amp; CCB_TRANS_BUS_WIDTH_VALID)\n"
"            softc-&gt;goal_bus_width[targ] = min(cts-&gt;bus_width, OUR_BUS_WIDTH);\n"
"\n"
"        if(flags &amp; CCB_TRANS_DISC_VALID) {\n"
"            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;\n"
"            softc-&gt;current_tflags[targ][lun] |= flags &amp; CCB_TRANS_DISC_ENB;\n"
"        }\n"
"        if(flags &amp; CCB_TRANS_TQ_VALID) {\n"
"            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;\n"
"            softc-&gt;current_tflags[targ][lun] |= flags &amp; CCB_TRANS_TQ_ENB;\n"
"        }\n"
"    }\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"
msgstr ""
"    struct ccb_trans_settings *cts;\n"
"    int targ, lun;\n"
"    int flags;\n"
"\n"
"    cts = &amp;ccb-&gt;cts;\n"
"    targ = ccb_h-&gt;target_id;\n"
"    lun = ccb_h-&gt;target_lun;\n"
"    flags = cts-&gt;flags;\n"
"    if(flags &amp; CCB_TRANS_USER_SETTINGS) {\n"
"        if(flags &amp; CCB_TRANS_SYNC_RATE_VALID)\n"
"            softc-&gt;user_sync_period[targ] = cts-&gt;sync_period;\n"
"        if(flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)\n"
"            softc-&gt;user_sync_offset[targ] = cts-&gt;sync_offset;\n"
"        if(flags &amp; CCB_TRANS_BUS_WIDTH_VALID)\n"
"            softc-&gt;user_bus_width[targ] = cts-&gt;bus_width;\n"
"\n"
"        if(flags &amp; CCB_TRANS_DISC_VALID) {\n"
"            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;\n"
"            softc-&gt;user_tflags[targ][lun] |= flags &amp; CCB_TRANS_DISC_ENB;\n"
"        }\n"
"        if(flags &amp; CCB_TRANS_TQ_VALID) {\n"
"            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;\n"
"            softc-&gt;user_tflags[targ][lun] |= flags &amp; CCB_TRANS_TQ_ENB;\n"
"        }\n"
"    }\n"
"    if(flags &amp; CCB_TRANS_CURRENT_SETTINGS) {\n"
"        if(flags &amp; CCB_TRANS_SYNC_RATE_VALID)\n"
"            softc-&gt;goal_sync_period[targ] =\n"
"                max(cts-&gt;sync_period, OUR_MIN_SUPPORTED_PERIOD);\n"
"        if(flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)\n"
"            softc-&gt;goal_sync_offset[targ] =\n"
"                min(cts-&gt;sync_offset, OUR_MAX_SUPPORTED_OFFSET);\n"
"        if(flags &amp; CCB_TRANS_BUS_WIDTH_VALID)\n"
"            softc-&gt;goal_bus_width[targ] = min(cts-&gt;bus_width, OUR_BUS_WIDTH);\n"
"\n"
"        if(flags &amp; CCB_TRANS_DISC_VALID) {\n"
"            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;\n"
"            softc-&gt;current_tflags[targ][lun] |= flags &amp; CCB_TRANS_DISC_ENB;\n"
"        }\n"
"        if(flags &amp; CCB_TRANS_TQ_VALID) {\n"
"            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;\n"
"            softc-&gt;current_tflags[targ][lun] |= flags &amp; CCB_TRANS_TQ_ENB;\n"
"        }\n"
"    }\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20786
#, fuzzy
msgid ""
"Then when the next I/O request will be processed it will check if it has to "
"re-negotiate, for example by calling the function target_negotiated(hcb). It "
"can be implemented like this:"
msgstr ""
"Ent�o, quando a pr�xima requisi��o de I / O for processada, ela verificar� "
"se ela precisa renegociar, por exemplo, chamando a fun��o target_negotiated "
"(hcb). Ela pode ser implementada assim:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20791
#, no-wrap
msgid ""
"    int\n"
"    target_negotiated(struct xxx_hcb *hcb)\n"
"    {\n"
"        struct softc *softc = hcb-&gt;softc;\n"
"        int targ = hcb-&gt;targ;\n"
"\n"
"        if( softc-&gt;current_sync_period[targ] != softc-&gt;goal_sync_period[targ]\n"
"        || softc-&gt;current_sync_offset[targ] != softc-&gt;goal_sync_offset[targ]\n"
"        || softc-&gt;current_bus_width[targ] != softc-&gt;goal_bus_width[targ] )\n"
"            return 0; /* FALSE */\n"
"        else\n"
"            return 1; /* TRUE */\n"
"    }"
msgstr ""
"    int\n"
"    target_negotiated(struct xxx_hcb *hcb)\n"
"    {\n"
"        struct softc *softc = hcb-&gt;softc;\n"
"        int targ = hcb-&gt;targ;\n"
"\n"
"        if( softc-&gt;current_sync_period[targ] != softc-&gt;goal_sync_period[targ]\n"
"        || softc-&gt;current_sync_offset[targ] != softc-&gt;goal_sync_offset[targ]\n"
"        || softc-&gt;current_bus_width[targ] != softc-&gt;goal_bus_width[targ] )\n"
"            return 0; /* FALSE */\n"
"        else\n"
"            return 1; /* TRUE */\n"
"    }"

#. (itstool) path: listitem/para
#: book.translate.xml:20805
#, fuzzy
msgid ""
"After the values are re-negotiated the resulting values must be assigned to "
"both current and goal parameters, so for future I/O transactions the current "
"and goal parameters would be the same and <function>target_negotiated()</"
"function> would return TRUE. When the card is initialized (in "
"<function>xxx_attach()</function>) the current negotiation values must be "
"initialized to narrow asynchronous mode, the goal and current values must be "
"initialized to the maximal values supported by controller."
msgstr ""
"Depois que os valores s�o renegociados, os valores resultantes devem ser "
"atribu�dos aos par�metros atuais e de meta, portanto, para futuras "
"transa��es de E / S, os par�metros atuais e de meta seriam os mesmos e "
"<function> target_negotiated () </function> retornaria TRUE. Quando o cart�o "
"� inicializado (em <function> xxx_attach () </function> ) os valores de "
"negocia��o atuais devem ser inicializados para restringir o modo ass�ncrono, "
"a meta e os valores atuais devem ser inicializados para os valores m�ximos "
"suportados pelo controlador. "

#. (itstool) path: listitem/para
#: book.translate.xml:20816
#, fuzzy
msgid ""
"<emphasis>XPT_GET_TRAN_SETTINGS</emphasis> - get values of SCSI transfer "
"settings"
msgstr ""
" <emphasis> XPT_GET_TRAN_SETTINGS </emphasis> - obter valores de "
"configura��es de transfer�ncia SCSI "

#. (itstool) path: listitem/para
#: book.translate.xml:20819
#, fuzzy
msgid ""
"This operations is the reverse of XPT_SET_TRAN_SETTINGS. Fill up the CCB "
"instance <quote>struct ccb_trans_setting cts</quote> with data as requested "
"by the flags CCB_TRANS_CURRENT_SETTINGS or CCB_TRANS_USER_SETTINGS (if both "
"are set then the existing drivers return the current settings). Set all the "
"bits in the valid field."
msgstr ""
"Esta opera��o � o contr�rio de XPT_SET_TRAN_SETTINGS. Preencha a inst�ncia "
"do CCB <quote> struct ccb_trans_setting cts </quote> com dados conforme "
"solicitado pelos sinalizadores CCB_TRANS_CURRENT_SETTINGS ou "
"CCB_TRANS_USER_SETTINGS (se ambos estiverem configurados, os drivers "
"existentes retornar�o as configura��es atuais). Defina todos os bits no "
"campo v�lido. "

#. (itstool) path: listitem/para
#: book.translate.xml:20827
#, fuzzy
msgid ""
"<emphasis>XPT_CALC_GEOMETRY</emphasis> - calculate logical (BIOS)<_:"
"indexterm-1/> geometry of the disk"
msgstr ""
" <emphasis> XPT_CALC_GEOMETRY </emphasis> - calcular l�gica (BIOS) <_: "
"indexterm-1 /> geometria do disco "

#. (itstool) path: listitem/para
#: book.translate.xml:20831
#, fuzzy
msgid ""
"The arguments are transferred in the instance <quote>struct "
"ccb_calc_geometry ccg</quote> of the union ccb:"
msgstr ""
"Os argumentos s�o transferidos na inst�ncia <quote> struct ccb_calc_geometry "
"ccg </quote> da uni�o ccb: "

#. (itstool) path: listitem/para
#: book.translate.xml:20838
#, fuzzy
msgid ""
"<emphasis>block_size</emphasis> - input, block (A.K.A sector) size in bytes"
msgstr ""
" <emphasis> tamanho do bloco </emphasis> - entrada, bloco (setor AKA) "
"tamanho em bytes "

#. (itstool) path: listitem/para
#: book.translate.xml:20843
#, fuzzy
msgid "<emphasis>volume_size</emphasis> - input, volume size in bytes"
msgstr ""
" <emphasis> volume_size </emphasis> - entrada, tamanho do volume em bytes "

#. (itstool) path: listitem/para
#: book.translate.xml:20848
#, fuzzy
msgid "<emphasis>cylinders</emphasis> - output, logical cylinders"
msgstr " <emphasis> cilindros </emphasis> - sa�da, cilindros l�gicos "

#. (itstool) path: listitem/para
#: book.translate.xml:20853
#, fuzzy
msgid "<emphasis>heads</emphasis> - output, logical heads"
msgstr " <emphasis> cabe�as </emphasis> - sa�da, cabe�as l�gicas "

#. (itstool) path: listitem/para
#: book.translate.xml:20858
#, fuzzy
msgid "<emphasis>secs_per_track</emphasis> - output, logical sectors per track"
msgstr ""
" <emphasis> secs_per_track </emphasis> - sa�da, setores l�gicos por trilha "

#. (itstool) path: para/indexterm
#: book.translate.xml:20864
#, fuzzy
msgid "<primary>SCSI</primary> <secondary>BIOS</secondary>"
msgstr " <primary> SCSI </primary><secondary> BIOS </secondary> "

#. (itstool) path: listitem/para
#: book.translate.xml:20863
#, fuzzy
msgid ""
"If the returned geometry differs much enough from what the SCSI controller "
"BIOS<_:indexterm-1/> thinks and a disk on this SCSI controller is used as "
"bootable the system may not be able to boot. The typical calculation example "
"taken from the aic7xxx driver is:"
msgstr ""
"Se a geometria retornada difere o suficiente do que o BIOS do controlador "
"SCSI <_: indexterm-1 /> pensa e um disco neste controlador SCSI � usado como "
"inicializ�vel, o sistema pode n�o ser capaz de inicializar. O exemplo de "
"c�lculo t�pico obtido do driver aic7xxx �: "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20870
#, no-wrap
msgid ""
"    struct    ccb_calc_geometry *ccg;\n"
"    u_int32_t size_mb;\n"
"    u_int32_t secs_per_cylinder;\n"
"    int   extended;\n"
"\n"
"    ccg = &amp;ccb-&gt;ccg;\n"
"    size_mb = ccg-&gt;volume_size\n"
"        / ((1024L * 1024L) / ccg-&gt;block_size);\n"
"    extended = check_cards_EEPROM_for_extended_geometry(softc);\n"
"\n"
"    if (size_mb &gt; 1024 &amp;&amp; extended) {\n"
"        ccg-&gt;heads = 255;\n"
"        ccg-&gt;secs_per_track = 63;\n"
"    } else {\n"
"        ccg-&gt;heads = 64;\n"
"        ccg-&gt;secs_per_track = 32;\n"
"    }\n"
"    secs_per_cylinder = ccg-&gt;heads * ccg-&gt;secs_per_track;\n"
"    ccg-&gt;cylinders = ccg-&gt;volume_size / secs_per_cylinder;\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"
msgstr ""
"    struct    ccb_calc_geometry *ccg;\n"
"    u_int32_t size_mb;\n"
"    u_int32_t secs_per_cylinder;\n"
"    int   extended;\n"
"\n"
"    ccg = &amp;ccb-&gt;ccg;\n"
"    size_mb = ccg-&gt;volume_size\n"
"        / ((1024L * 1024L) / ccg-&gt;block_size);\n"
"    extended = check_cards_EEPROM_for_extended_geometry(softc);\n"
"\n"
"    if (size_mb &gt; 1024 &amp;&amp; extended) {\n"
"        ccg-&gt;heads = 255;\n"
"        ccg-&gt;secs_per_track = 63;\n"
"    } else {\n"
"        ccg-&gt;heads = 64;\n"
"        ccg-&gt;secs_per_track = 32;\n"
"    }\n"
"    secs_per_cylinder = ccg-&gt;heads * ccg-&gt;secs_per_track;\n"
"    ccg-&gt;cylinders = ccg-&gt;volume_size / secs_per_cylinder;\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20893
#, fuzzy
msgid ""
"This gives the general idea, the exact calculation depends on the quirks of "
"the particular BIOS. If BIOS provides no way set the <quote>extended "
"translation</quote> flag in EEPROM this flag should normally be assumed "
"equal to 1. Other popular geometries are:"
msgstr ""
"Isso d� a id�ia geral, o c�lculo exato depende das peculiaridades do BIOS em "
"particular. Se o BIOS n�o fornece nenhuma maneira de definir o <quote> "
"tradu��o estendida </quote> flag na EEPROM este sinalizador deve normalmente "
"ser assumido igual a 1. Outras geometrias populares s�o: "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20899
#, no-wrap
msgid ""
"    128 heads, 63 sectors - Symbios controllers\n"
"    16 heads, 63 sectors - old controllers"
msgstr ""
"    128 heads, 63 sectors - Symbios controllers\n"
"    16 heads, 63 sectors - old controllers"

#. (itstool) path: listitem/para
#: book.translate.xml:20902
#, fuzzy
msgid ""
"Some system BIOSes and SCSI BIOSes fight with each other with variable "
"success, for example a combination of Symbios 875/895 SCSI and Phoenix BIOS "
"can give geometry 128/63 after power up and 255/63 after a hard reset or "
"soft reboot."
msgstr ""
"Algumas BIOS de sistema e BIOS SCSI lutam entre si com sucesso vari�vel, por "
"exemplo, uma combina��o de Symbios 875/895 SCSI e Phoenix BIOS pode fornecer "
"uma geometria de 128/63 ap�s a energiza��o e 255/63 ap�s uma reinicializa��o "
"a frio ou reinicializa��o suave."

#. (itstool) path: listitem/para
#: book.translate.xml:20910
#, fuzzy
msgid ""
"<emphasis>XPT_PATH_INQ</emphasis> - path inquiry, in other words get the SIM "
"driver and SCSI controller (also known as HBA - Host Bus Adapter) properties"
msgstr ""
" <emphasis> XPT_PATH_INQ </emphasis> - consulta de caminho, em outras "
"palavras, obtenha o driver SIM e as propriedades do controlador SCSI (tamb�m "
"conhecido como HBA - Host Bus Adapter) "

#. (itstool) path: listitem/para
#: book.translate.xml:20914
#, fuzzy
msgid ""
"The properties are returned in the instance <quote>struct ccb_pathinq cpi</"
"quote> of the union ccb:"
msgstr ""
"As propriedades s�o retornadas na inst�ncia <quote> struct ccb_pathinq cpi </"
"quote> da uni�o ccb: "

#. (itstool) path: listitem/para
#: book.translate.xml:20920
#, fuzzy
msgid "version_num - the SIM driver version number, now all drivers use 1"
msgstr ""
"version_num - o n�mero da vers�o do driver do SIM, agora todos os drivers "
"usam 1"

#. (itstool) path: listitem/para
#: book.translate.xml:20925
#, fuzzy
msgid "hba_inquiry - bitmask of features supported by the controller:"
msgstr "hba_inquiry - bitmask de recursos suportados pelo controlador:"

#. (itstool) path: listitem/para
#: book.translate.xml:20930
#, fuzzy
msgid "PI_MDP_ABLE - supports MDP message (something from SCSI3?)"
msgstr "PI_MDP_ABLE - suporta mensagem MDP (algo do SCSI3?)"

#. (itstool) path: listitem/para
#: book.translate.xml:20935
#, fuzzy
msgid "PI_WIDE_32 - supports 32 bit wide SCSI"
msgstr "PI_WIDE_32 - suporta SCSI de 32 bits de largura"

#. (itstool) path: listitem/para
#: book.translate.xml:20940
#, fuzzy
msgid "PI_WIDE_16 - supports 16 bit wide SCSI"
msgstr "PI_WIDE_16 - suporta SCSI de 16 bits de largura"

#. (itstool) path: listitem/para
#: book.translate.xml:20945
#, fuzzy
msgid "PI_SDTR_ABLE - can negotiate synchronous transfer rate"
msgstr "PI_SDTR_ABLE - pode negociar taxa de transfer�ncia s�ncrona"

#. (itstool) path: listitem/para
#: book.translate.xml:20950
#, fuzzy
msgid "PI_LINKED_CDB - supports linked commands"
msgstr "PI_LINKED_CDB - suporta comandos vinculados"

#. (itstool) path: listitem/para
#: book.translate.xml:20955
#, fuzzy
msgid "PI_TAG_ABLE - supports tagged commands"
msgstr "PI_TAG_ABLE - suporta comandos marcados"

#. (itstool) path: listitem/para
#: book.translate.xml:20960
#, fuzzy
msgid ""
"PI_SOFT_RST - supports soft reset alternative (hard reset and soft reset are "
"mutually exclusive within a SCSI bus)"
msgstr ""
"PI_SOFT_RST - suporta alternativa de redefini��o suave (hard reset e soft "
"reset s�o mutuamente exclusivos dentro de um barramento SCSI)"

#. (itstool) path: listitem/para
#: book.translate.xml:20966
#, fuzzy
msgid "target_sprt - flags for target mode support, 0 if unsupported"
msgstr ""
"target_sprt - sinalizadores para suporte ao modo de destino, 0 se n�o "
"suportado"

#. (itstool) path: listitem/para
#: book.translate.xml:20971
#, fuzzy
msgid "hba_misc - miscellaneous controller features:"
msgstr "hba_misc - recursos diversos do controlador:"

#. (itstool) path: listitem/para
#: book.translate.xml:20976
#, fuzzy
msgid "PIM_SCANHILO - bus scans from high ID to low ID"
msgstr "PIM_SCANHILO - bus varre de alta identifica��o para baixa ID"

#. (itstool) path: listitem/para
#: book.translate.xml:20981
#, fuzzy
msgid "PIM_NOREMOVE - removable devices not included in scan"
msgstr "PIM_NOREMOVE - dispositivos remov�veis n�o inclu�dos na verifica��o"

#. (itstool) path: listitem/para
#: book.translate.xml:20986
#, fuzzy
msgid "PIM_NOINITIATOR - initiator role not supported"
msgstr "PIM_NOINITIATOR - fun��o do iniciador n�o suportada"

#. (itstool) path: listitem/para
#: book.translate.xml:20991
#, fuzzy
msgid "PIM_NOBUSRESET - user has disabled initial BUS RESET"
msgstr "PIM_NOBUSRESET - usu�rio desabilitou inicial BUS RESET"

#. (itstool) path: listitem/para
#: book.translate.xml:20996
#, fuzzy
msgid ""
"hba_eng_cnt - mysterious HBA engine count, something related to compression, "
"now is always set to 0"
msgstr ""
"hba_eng_cnt - misteriosa contagem de mecanismos do HBA, algo relacionado � "
"compacta��o, agora est� sempre definido como 0"

#. (itstool) path: listitem/para
#: book.translate.xml:21001
#, fuzzy
msgid "vuhba_flags - vendor-unique flags, unused now"
msgstr "vuhba_flags - bandeiras exclusivas de fornecedores, n�o usadas agora"

#. (itstool) path: listitem/para
#: book.translate.xml:21005
#, fuzzy
msgid ""
"max_target - maximal supported target ID (7 for 8-bit bus, 15 for 16-bit "
"bus, 127 for Fibre Channel)"
msgstr ""
"max_target - ID de alvo suportado maximal (7 para bus de 8 bits, 15 para bus "
"de 16 bits, 127 para o Fibre Channel)"

#. (itstool) path: listitem/para
#: book.translate.xml:21011
#, fuzzy
msgid ""
"max_lun - maximal supported LUN ID (7 for older SCSI controllers, 63 for "
"newer ones)"
msgstr ""
"max_lun - maximal LUN ID suportado (7 para controladores SCSI mais antigos, "
"63 para os mais novos)"

#. (itstool) path: listitem/para
#: book.translate.xml:21016
#, fuzzy
msgid "async_flags - bitmask of installed Async handler, unused now"
msgstr "async_flags - bitmask do manipulador Async instalado, n�o usado agora"

#. (itstool) path: listitem/para
#: book.translate.xml:21021
#, fuzzy
msgid "hpath_id - highest Path ID in the subsystem, unused now"
msgstr "hpath_id - maior ID do caminho no subsistema, n�o usado agora"

#. (itstool) path: listitem/para
#: book.translate.xml:21026
#, fuzzy
msgid "unit_number - the controller unit number, cam_sim_unit(sim)"
msgstr "unit_number - o n�mero da unidade controladora, cam_sim_unit (sim)"

#. (itstool) path: listitem/para
#: book.translate.xml:21031
#, fuzzy
msgid "bus_id - the bus number, cam_sim_bus(sim)"
msgstr "bus_id - o n�mero do barramento, cam_sim_bus (sim)"

#. (itstool) path: listitem/para
#: book.translate.xml:21035
#, fuzzy
msgid "initiator_id - the SCSI ID of the controller itself"
msgstr "initiator_id - o ID SCSI do pr�prio controlador"

#. (itstool) path: listitem/para
#: book.translate.xml:21040
#, fuzzy
msgid ""
"base_transfer_speed - nominal transfer speed in KB/s for asynchronous narrow "
"transfers, equals to 3300 for SCSI"
msgstr ""
"base_transfer_speed - velocidade de transfer�ncia nominal em KB / s para "
"transfer�ncias estreitas ass�ncronas, igual a 3300 para SCSI"

#. (itstool) path: listitem/para
#: book.translate.xml:21046
#, fuzzy
msgid ""
"sim_vid - SIM driver's vendor id, a zero-terminated string of maximal length "
"SIM_IDLEN including the terminating zero"
msgstr ""
"sim_vid - ID do fornecedor do driver SIM, uma string terminada em zero de "
"comprimento m�ximo SIM_IDLEN incluindo o zero de finaliza��o"

#. (itstool) path: listitem/para
#: book.translate.xml:21052
#, fuzzy
msgid ""
"hba_vid - SCSI controller's vendor id, a zero-terminated string of maximal "
"length HBA_IDLEN including the terminating zero"
msgstr ""
"hba_vid - ID do fornecedor do controlador SCSI, uma cadeia terminada em zero "
"de comprimento m�ximo HBA_IDLEN incluindo o zero de finaliza��o"

#. (itstool) path: listitem/para
#: book.translate.xml:21058
#, fuzzy
msgid ""
"dev_name - device driver name, a zero-terminated string of maximal length "
"DEV_IDLEN including the terminating zero, equal to cam_sim_name(sim)"
msgstr ""
"dev_name - nome do driver de dispositivo, uma cadeia terminada em zero de "
"comprimento m�ximo DEV_IDLEN incluindo o zero final, igual a cam_sim_name "
"(sim)"

#. (itstool) path: listitem/para
#: book.translate.xml:21064
#, fuzzy
msgid ""
"The recommended way of setting the string fields is using strncpy, like:"
msgstr ""
"A maneira recomendada de configurar os campos de string � usando strncpy, "
"como:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:21067
#, no-wrap
msgid "    strncpy(cpi-&gt;dev_name, cam_sim_name(sim), DEV_IDLEN);"
msgstr "    strncpy(cpi-&gt;dev_name, cam_sim_name(sim), DEV_IDLEN);"

#. (itstool) path: listitem/para
#: book.translate.xml:21069
#, fuzzy
msgid ""
"After setting the values set the status to CAM_REQ_CMP and mark the CCB as "
"done."
msgstr ""
"Depois de definir os valores, defina o status como CAM_REQ_CMP e marque o "
"CCB como conclu�do."

#. (itstool) path: sect1/title
#: book.translate.xml:21076
#, fuzzy
msgid "Polling"
msgstr "Polling"

#. (itstool) path: sect1/para
#: book.translate.xml:21089
#, fuzzy
msgid ""
"The poll function is used to simulate the interrupts when the interrupt "
"subsystem is not functioning (for example, when the system has crashed and "
"is creating the system dump). The CAM subsystem sets the proper interrupt "
"level before calling the poll routine. So all it needs to do is to call the "
"interrupt routine (or the other way around, the poll routine may be doing "
"the real action and the interrupt routine would just call the poll routine). "
"Why bother about a separate function then? Because of different calling "
"conventions. The <function>xxx_poll</function> routine gets the struct "
"cam_sim pointer as its argument when the PCI interrupt routine by common "
"convention gets pointer to the struct <varname remap=\"structname"
"\">xxx_softc</varname> and the ISA interrupt routine gets just the device "
"unit number. So the poll routine would normally look as:"
msgstr ""
"A fun��o de pesquisa � usada para simular as interrup��es quando o "
"subsistema de interrup��o n�o est� funcionando (por exemplo, quando o "
"sistema travou e est� criando o dump do sistema). O subsistema CAM define o "
"n�vel de interrup��o adequado antes de chamar a rotina de pesquisa. ele "
"precisa fazer � chamar a rotina de interrup��o (ou vice-versa, a rotina de "
"poll pode estar fazendo a a��o real e a rotina de interrup��o apenas "
"chamaria a rotina de poll) Por que se preocupar com uma fun��o separada "
"ent�o? conven��es. <function> xxx_poll </function> rotina obt�m o ponteiro "
"struct cam_sim como seu argumento quando a rotina de interrup��o PCI por "
"conven��o comum obt�m ponteiro para a estrutura <varname remap=\"structname"
"\"> xxx_softc </varname> e a rotina de interrup��o ISA obt�m apenas o n�mero "
"da unidade do dispositivo. Ent�o a rotina de pesquisa normalmente seria "
"como: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21105
#, no-wrap
msgid ""
"static void\n"
"xxx_poll(struct cam_sim *sim)\n"
"{\n"
"    xxx_intr((struct xxx_softc *)cam_sim_softc(sim)); /* for PCI device */\n"
"}"
msgstr ""
"static void\n"
"xxx_poll(struct cam_sim *sim)\n"
"{\n"
"    xxx_intr((struct xxx_softc *)cam_sim_softc(sim)); /* for PCI device */\n"
"}"

#. (itstool) path: sect1/para
#: book.translate.xml:21111
#, fuzzy
msgid "or"
msgstr "ou"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21113
#, no-wrap
msgid ""
"static void\n"
"xxx_poll(struct cam_sim *sim)\n"
"{\n"
"    xxx_intr(cam_sim_unit(sim)); /* for ISA device */\n"
"}"
msgstr ""
"static void\n"
"xxx_poll(struct cam_sim *sim)\n"
"{\n"
"    xxx_intr(cam_sim_unit(sim)); /* for ISA device */\n"
"}"

#. (itstool) path: sect1/title
#: book.translate.xml:21121
#, fuzzy
msgid "Asynchronous Events"
msgstr "Eventos ass�ncronos"

#. (itstool) path: sect1/para
#: book.translate.xml:21123
#, fuzzy
msgid ""
"If an asynchronous event callback has been set up then the callback function "
"should be defined."
msgstr ""
"Se um retorno de chamada de evento ass�ncrono tiver sido configurado, a "
"fun��o de retorno de chamada dever� ser definida."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21126
#, no-wrap
msgid ""
"static void\n"
"ahc_async(void *callback_arg, u_int32_t code, struct cam_path *path, void *arg)"
msgstr ""
"static void\n"
"ahc_async(void *callback_arg, u_int32_t code, struct cam_path *path, void *arg)"

#. (itstool) path: listitem/para
#: book.translate.xml:21131
#, fuzzy
msgid "callback_arg - the value supplied when registering the callback"
msgstr "callback_arg - o valor fornecido ao registrar o retorno de chamada"

#. (itstool) path: listitem/para
#: book.translate.xml:21136
#, fuzzy
msgid "code - identifies the type of event"
msgstr "c�digo - identifica o tipo de evento"

#. (itstool) path: listitem/para
#: book.translate.xml:21140
#, fuzzy
msgid "path - identifies the devices to which the event applies"
msgstr "caminho - identifica os dispositivos aos quais o evento se aplica"

#. (itstool) path: listitem/para
#: book.translate.xml:21145
#, fuzzy
msgid "arg - event-specific argument"
msgstr "arg - argumento espec�fico do evento"

#. (itstool) path: sect1/para
#: book.translate.xml:21149
#, fuzzy
msgid "Implementation for a single type of event, AC_LOST_DEVICE, looks like:"
msgstr ""
"Implementa��o para um �nico tipo de evento, AC_LOST_DEVICE, se parece com:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21152
#, no-wrap
msgid ""
"    struct xxx_softc *softc;\n"
"    struct cam_sim *sim;\n"
"    int targ;\n"
"    struct ccb_trans_settings neg;\n"
"\n"
"    sim = (struct cam_sim *)callback_arg;\n"
"    softc = (struct xxx_softc *)cam_sim_softc(sim);\n"
"    switch (code) {\n"
"    case AC_LOST_DEVICE:\n"
"        targ = xpt_path_target_id(path);\n"
"        if(targ &lt;= OUR_MAX_SUPPORTED_TARGET) {\n"
"            clean_negotiations(softc, targ);\n"
"            /* send indication to CAM */\n"
"            neg.bus_width = 8;\n"
"            neg.sync_period = neg.sync_offset = 0;\n"
"            neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"                | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"        }\n"
"        break;\n"
"    default:\n"
"        break;\n"
"    }"
msgstr ""
"    struct xxx_softc *softc;\n"
"    struct cam_sim *sim;\n"
"    int targ;\n"
"    struct ccb_trans_settings neg;\n"
"\n"
"    sim = (struct cam_sim *)callback_arg;\n"
"    softc = (struct xxx_softc *)cam_sim_softc(sim);\n"
"    switch (code) {\n"
"    case AC_LOST_DEVICE:\n"
"        targ = xpt_path_target_id(path);\n"
"        if(targ &lt;= OUR_MAX_SUPPORTED_TARGET) {\n"
"            clean_negotiations(softc, targ);\n"
"            /* send indication to CAM */\n"
"            neg.bus_width = 8;\n"
"            neg.sync_period = neg.sync_offset = 0;\n"
"            neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"                | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"        }\n"
"        break;\n"
"    default:\n"
"        break;\n"
"    }"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:21180
#, fuzzy
msgid "<primary>SCSI</primary><secondary>interrupts</secondary>"
msgstr " <primary> SCSI </primary><secondary> interrompe </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:21182
#, fuzzy
msgid ""
"The exact type of the interrupt routine depends on the type of the "
"peripheral bus (PCI, ISA and so on) to which the SCSI controller is "
"connected."
msgstr ""
"O tipo exato da rotina de interrup��o depende do tipo de barramento do "
"perif�rico (PCI, ISA e assim por diante) ao qual o controlador SCSI est� "
"conectado."

#. (itstool) path: sect1/para
#: book.translate.xml:21186
#, fuzzy
msgid ""
"The interrupt routines of the SIM drivers run at the interrupt level splcam. "
"So <function>splcam()</function> should be used in the driver to synchronize "
"activity between the interrupt routine and the rest of the driver (for a "
"multiprocessor-aware driver things get yet more interesting but we ignore "
"this case here). The pseudo-code in this document happily ignores the "
"problems of synchronization. The real code must not ignore them. A simple-"
"minded approach is to set <function>splcam()</function> on the entry to the "
"other routines and reset it on return thus protecting them by one big "
"critical section. To make sure that the interrupt level will be always "
"restored a wrapper function can be defined, like:"
msgstr ""
"As rotinas de interrup��o dos drivers SIM s�o executadas no splcam do n�vel "
"de interrup��o. <function> splcam () </function> deve ser usado no driver "
"para sincronizar a atividade entre a rotina de interrup��o e o restante do "
"driver (para um driver com reconhecimento de multiprocessador, as coisas "
"ficam ainda mais interessantes, mas ignoramos este caso aqui). O pseudo-"
"c�digo neste documento ignora felizmente os problemas de sincroniza��o. O "
"c�digo real n�o deve ignor�-los. Uma abordagem simplista � definir "
"<function> splcam () </function> na entrada para as outras rotinas e "
"redefini-lo no retorno, protegendo-as por uma grande se��o cr�tica. Para ter "
"certeza de que o n�vel de interrup��o ser� sempre restaurado, uma fun��o "
"wrapper pode ser definida, como: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21199
#, no-wrap
msgid ""
"    static void\n"
"    xxx_action(struct cam_sim *sim, union ccb *ccb)\n"
"    {\n"
"        int s;\n"
"        s = splcam();\n"
"        xxx_action1(sim, ccb);\n"
"        splx(s);\n"
"    }\n"
"\n"
"    static void\n"
"    xxx_action1(struct cam_sim *sim, union ccb *ccb)\n"
"    {\n"
"        ... process the request ...\n"
"    }"
msgstr ""
"    static void\n"
"    xxx_action(struct cam_sim *sim, union ccb *ccb)\n"
"    {\n"
"        int s;\n"
"        s = splcam();\n"
"        xxx_action1(sim, ccb);\n"
"        splx(s);\n"
"    }\n"
"\n"
"    static void\n"
"    xxx_action1(struct cam_sim *sim, union ccb *ccb)\n"
"    {\n"
"        ... process the request ...\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:21214
#, fuzzy
msgid ""
"This approach is simple and robust but the problem with it is that "
"interrupts may get blocked for a relatively long time and this would "
"negatively affect the system's performance. On the other hand the functions "
"of the <function>spl()</function> family have rather high overhead, so vast "
"amount of tiny critical sections may not be good either."
msgstr ""
"Esta abordagem � simples e robusta, mas o problema � que as interrup��es "
"podem ficar bloqueadas por um tempo relativamente longo e isso afetaria "
"negativamente o desempenho do sistema. Por outro lado, as fun��es do "
"<function> spl () </function> a fam�lia tem uma sobrecarga bastante alta, "
"uma quantidade t�o grande de se��es cr�ticas min�sculas pode n�o ser boa "
"tamb�m \""

#. (itstool) path: sect1/para
#: book.translate.xml:21221
#, fuzzy
msgid ""
"The conditions handled by the interrupt routine and the details depend very "
"much on the hardware. We consider the set of <quote>typical</quote> "
"conditions."
msgstr ""
"As condi��es manipuladas pela rotina de interrup��o e os detalhes dependem "
"muito do hardware. Consideramos o conjunto de <quote> t�pica </quote> "
"condi��es. "

#. (itstool) path: sect1/para
#: book.translate.xml:21225
#, fuzzy
msgid ""
"First, we check if a SCSI reset was encountered on the bus (probably caused "
"by another SCSI controller on the same SCSI bus). If so we drop all the "
"enqueued and disconnected requests, report the events and re-initialize our "
"SCSI controller. It is important that during this initialization the "
"controller will not issue another reset or else two controllers on the same "
"SCSI bus could ping-pong resets forever. The case of fatal controller error/"
"hang could be handled in the same place, but it will probably need also "
"sending RESET signal to the SCSI bus to reset the status of the connections "
"with the SCSI devices."
msgstr ""
"Primeiro, verificamos se uma reinicializa��o SCSI foi encontrada no "
"barramento (provavelmente causada por outro controlador SCSI no mesmo "
"barramento SCSI). Se assim for, descartamos todas as solicita��es "
"enfileiradas e desconectadas, relatamos os eventos e reinicializamos nosso "
"controlador SCSI. � importante que durante esta inicializa��o o controlador "
"n�o emita outra reinicializa��o ou ent�o dois controladores no mesmo "
"barramento SCSI possam reiniciar o ping pong para sempre O caso de erro / "
"travamento do controlador fatal pode ser tratado no mesmo local, mas "
"provavelmente tamb�m precisa enviar o sinal RESET ao barramento SCSI para "
"redefinir o status das conex�es com os dispositivos SCSI. "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21237
#, no-wrap
msgid ""
"    int fatal=0;\n"
"    struct ccb_trans_settings neg;\n"
"    struct cam_path *path;\n"
"\n"
"    if( detected_scsi_reset(softc)\n"
"    || (fatal = detected_fatal_controller_error(softc)) ) {\n"
"        int targ, lun;\n"
"        struct xxx_hcb *h, *hh;\n"
"\n"
"        /* drop all enqueued CCBs */\n"
"        for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"            hh = h-&gt;next;\n"
"            free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"        }\n"
"\n"
"        /* the clean values of negotiations to report */\n"
"        neg.bus_width = 8;\n"
"        neg.sync_period = neg.sync_offset = 0;\n"
"        neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"            | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"\n"
"        /* drop all disconnected CCBs and clean negotiations  */\n"
"        for(targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {\n"
"            clean_negotiations(softc, targ);\n"
"\n"
"            /* report the event if possible */\n"
"            if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                    cam_sim_path(sim), targ,\n"
"                    CAM_LUN_WILDCARD) == CAM_REQ_CMP) {\n"
"                xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"                xpt_free_path(path);\n"
"            }\n"
"\n"
"            for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"                for(h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h = hh) {\n"
"                    hh=h-&gt;next;\n"
"                    if(fatal)\n"
"                        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_UNREC_HBA_ERROR);\n"
"                    else\n"
"                        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"                }\n"
"        }\n"
"\n"
"        /* report the event */\n"
"        xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);\n"
"\n"
"        /* re-initialization may take a lot of time, in such case\n"
"         * its completion should be signaled by another interrupt or\n"
"         * checked on timeout - but for simplicity we assume here that\n"
"         * it is really fast\n"
"         */\n"
"        if(!fatal) {\n"
"            reinitialize_controller_without_scsi_reset(softc);\n"
"        } else {\n"
"            reinitialize_controller_with_scsi_reset(softc);\n"
"        }\n"
"        schedule_next_hcb(softc);\n"
"        return;\n"
"    }"
msgstr ""
"    int fatal=0;\n"
"    struct ccb_trans_settings neg;\n"
"    struct cam_path *path;\n"
"\n"
"    if( detected_scsi_reset(softc)\n"
"    || (fatal = detected_fatal_controller_error(softc)) ) {\n"
"        int targ, lun;\n"
"        struct xxx_hcb *h, *hh;\n"
"\n"
"        /* drop all enqueued CCBs */\n"
"        for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"            hh = h-&gt;next;\n"
"            free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"        }\n"
"\n"
"        /* the clean values of negotiations to report */\n"
"        neg.bus_width = 8;\n"
"        neg.sync_period = neg.sync_offset = 0;\n"
"        neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"            | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"\n"
"        /* drop all disconnected CCBs and clean negotiations  */\n"
"        for(targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {\n"
"            clean_negotiations(softc, targ);\n"
"\n"
"            /* report the event if possible */\n"
"            if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                    cam_sim_path(sim), targ,\n"
"                    CAM_LUN_WILDCARD) == CAM_REQ_CMP) {\n"
"                xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"                xpt_free_path(path);\n"
"            }\n"
"\n"
"            for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"                for(h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h = hh) {\n"
"                    hh=h-&gt;next;\n"
"                    if(fatal)\n"
"                        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_UNREC_HBA_ERROR);\n"
"                    else\n"
"                        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"                }\n"
"        }\n"
"\n"
"        /* report the event */\n"
"        xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);\n"
"\n"
"        /* re-initialization may take a lot of time, in such case\n"
"         * its completion should be signaled by another interrupt or\n"
"         * checked on timeout - but for simplicity we assume here that\n"
"         * it is really fast\n"
"         */\n"
"        if(!fatal) {\n"
"            reinitialize_controller_without_scsi_reset(softc);\n"
"        } else {\n"
"            reinitialize_controller_with_scsi_reset(softc);\n"
"        }\n"
"        schedule_next_hcb(softc);\n"
"        return;\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:21297
#, fuzzy
msgid ""
"If interrupt is not caused by a controller-wide condition then probably "
"something has happened to the current hardware control block. Depending on "
"the hardware there may be other non-HCB-related events, we just do not "
"consider them here. Then we analyze what happened to this HCB:"
msgstr ""
"Se a interrup��o n�o � causada por uma condi��o de controle geral, "
"provavelmente algo aconteceu com o bloco de controle de hardware atual. "
"Dependendo do hardware, pode haver outros eventos n�o relacionados ao HCB, "
"n�s n�o os consideramos aqui. Ent�o analisamos o que aconteceu com este HCB: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21303
#, no-wrap
msgid ""
"    struct xxx_hcb *hcb, *h, *hh;\n"
"    int hcb_status, scsi_status;\n"
"    int ccb_status;\n"
"    int targ;\n"
"    int lun_to_freeze;\n"
"\n"
"    hcb = get_current_hcb(softc);\n"
"    if(hcb == NULL) {\n"
"        /* either stray interrupt or something went very wrong\n"
"         * or this is something hardware-dependent\n"
"         */\n"
"        handle as necessary;\n"
"        return;\n"
"    }\n"
"\n"
"    targ = hcb-&gt;target;\n"
"    hcb_status = get_status_of_current_hcb(softc);"
msgstr ""
"    struct xxx_hcb *hcb, *h, *hh;\n"
"    int hcb_status, scsi_status;\n"
"    int ccb_status;\n"
"    int targ;\n"
"    int lun_to_freeze;\n"
"\n"
"    hcb = get_current_hcb(softc);\n"
"    if(hcb == NULL) {\n"
"        /* either stray interrupt or something went very wrong\n"
"         * or this is something hardware-dependent\n"
"         */\n"
"        handle as necessary;\n"
"        return;\n"
"    }\n"
"\n"
"    targ = hcb-&gt;target;\n"
"    hcb_status = get_status_of_current_hcb(softc);"

#. (itstool) path: sect1/para
#: book.translate.xml:21321
#, fuzzy
msgid ""
"First we check if the HCB has completed and if so we check the returned SCSI "
"status."
msgstr ""
"Primeiro, verificamos se o HCB foi conclu�do e, nesse caso, verificamos o "
"status do SCSI retornado."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21324
#, no-wrap
msgid ""
"    if(hcb_status == COMPLETED) {\n"
"        scsi_status = get_completion_status(hcb);"
msgstr ""
"    if(hcb_status == COMPLETED) {\n"
"        scsi_status = get_completion_status(hcb);"

#. (itstool) path: sect1/para
#: book.translate.xml:21327
#, fuzzy
msgid ""
"Then look if this status is related to the REQUEST SENSE command and if so "
"handle it in a simple way."
msgstr ""
"Ent�o olhe se este status est� relacionado ao comando REQUEST SENSE e, se "
"for o caso, manipule-o de maneira simples."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21330
#, no-wrap
msgid ""
"        if(hcb-&gt;flags &amp; DOING_AUTOSENSE) {\n"
"            if(scsi_status == GOOD) { /* autosense was successful */\n"
"                hcb-&gt;ccb-&gt;ccb_h.status |= CAM_AUTOSNS_VALID;\n"
"                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_SCSI_STATUS_ERROR);\n"
"            } else {\n"
"        autosense_failed:\n"
"                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_AUTOSENSE_FAIL);\n"
"            }\n"
"            schedule_next_hcb(softc);\n"
"            return;\n"
"        }"
msgstr ""
"        if(hcb-&gt;flags &amp; DOING_AUTOSENSE) {\n"
"            if(scsi_status == GOOD) { /* autosense was successful */\n"
"                hcb-&gt;ccb-&gt;ccb_h.status |= CAM_AUTOSNS_VALID;\n"
"                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_SCSI_STATUS_ERROR);\n"
"            } else {\n"
"        autosense_failed:\n"
"                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_AUTOSENSE_FAIL);\n"
"            }\n"
"            schedule_next_hcb(softc);\n"
"            return;\n"
"        }"

#. (itstool) path: sect1/para
#: book.translate.xml:21342
#, fuzzy
msgid ""
"Else the command itself has completed, pay more attention to details. If "
"auto-sense is not disabled for this CCB and the command has failed with "
"sense data then run REQUEST SENSE command to receive that data."
msgstr ""
"Se o comando em si tiver sido conclu�do, preste mais aten��o aos detalhes. "
"Se o auto-sentido n�o estiver desativado para este CCB e o comando falhar "
"com dados de detec��o, execute o comando REQUEST SENSE para receber esses "
"dados."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21347
#, no-wrap
msgid ""
"        hcb-&gt;ccb-&gt;csio.scsi_status = scsi_status;\n"
"        calculate_residue(hcb);\n"
"\n"
"        if( (hcb-&gt;ccb-&gt;ccb_h.flags &amp; CAM_DIS_AUTOSENSE)==0\n"
"        &amp;&amp; ( scsi_status == CHECK_CONDITION\n"
"                || scsi_status == COMMAND_TERMINATED) ) {\n"
"            /* start auto-SENSE */\n"
"            hcb-&gt;flags |= DOING_AUTOSENSE;\n"
"            setup_autosense_command_in_hcb(hcb);\n"
"            restart_current_hcb(softc);\n"
"            return;\n"
"        }\n"
"        if(scsi_status == GOOD)\n"
"            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_REQ_CMP);\n"
"        else\n"
"            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_SCSI_STATUS_ERROR);\n"
"        schedule_next_hcb(softc);\n"
"        return;\n"
"    }"
msgstr ""
"        hcb-&gt;ccb-&gt;csio.scsi_status = scsi_status;\n"
"        calculate_residue(hcb);\n"
"\n"
"        if( (hcb-&gt;ccb-&gt;ccb_h.flags &amp; CAM_DIS_AUTOSENSE)==0\n"
"        &amp;&amp; ( scsi_status == CHECK_CONDITION\n"
"                || scsi_status == COMMAND_TERMINATED) ) {\n"
"            /* start auto-SENSE */\n"
"            hcb-&gt;flags |= DOING_AUTOSENSE;\n"
"            setup_autosense_command_in_hcb(hcb);\n"
"            restart_current_hcb(softc);\n"
"            return;\n"
"        }\n"
"        if(scsi_status == GOOD)\n"
"            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_REQ_CMP);\n"
"        else\n"
"            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_SCSI_STATUS_ERROR);\n"
"        schedule_next_hcb(softc);\n"
"        return;\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:21367
#, fuzzy
msgid ""
"One typical thing would be negotiation events: negotiation messages received "
"from a SCSI target (in answer to our negotiation attempt or by target's "
"initiative) or the target is unable to negotiate (rejects our negotiation "
"messages or does not answer them)."
msgstr ""
"Uma coisa t�pica seria eventos de negocia��o: mensagens de negocia��o "
"recebidas de um alvo SCSI (em resposta � nossa tentativa de negocia��o ou "
"por iniciativa do alvo) ou o alvo � incapaz de negociar (rejeita nossas "
"mensagens de negocia��o ou n�o as responde)."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21373
#, no-wrap
msgid ""
"    switch(hcb_status) {\n"
"    case TARGET_REJECTED_WIDE_NEG:\n"
"        /* revert to 8-bit bus */\n"
"        softc-&gt;current_bus_width[targ] = softc-&gt;goal_bus_width[targ] = 8;\n"
"        /* report the event */\n"
"        neg.bus_width = 8;\n"
"        neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    case TARGET_ANSWERED_WIDE_NEG:\n"
"        {\n"
"            int wd;\n"
"\n"
"            wd = get_target_bus_width_request(softc);\n"
"            if(wd &lt;= softc-&gt;goal_bus_width[targ]) {\n"
"                /* answer is acceptable */\n"
"                softc-&gt;current_bus_width[targ] =\n"
"                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;\n"
"\n"
"                /* report the event */\n"
"                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"            } else {\n"
"                prepare_reject_message(hcb);\n"
"            }\n"
"        }\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    case TARGET_REQUESTED_WIDE_NEG:\n"
"        {\n"
"            int wd;\n"
"\n"
"            wd = get_target_bus_width_request(softc);\n"
"            wd = min (wd, OUR_BUS_WIDTH);\n"
"            wd = min (wd, softc-&gt;user_bus_width[targ]);\n"
"\n"
"            if(wd != softc-&gt;current_bus_width[targ]) {\n"
"                /* the bus width has changed */\n"
"                softc-&gt;current_bus_width[targ] =\n"
"                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;\n"
"\n"
"                /* report the event */\n"
"                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"            }\n"
"            prepare_width_nego_rsponse(hcb, wd);\n"
"        }\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    }"
msgstr ""
"    switch(hcb_status) {\n"
"    case TARGET_REJECTED_WIDE_NEG:\n"
"        /* revert to 8-bit bus */\n"
"        softc-&gt;current_bus_width[targ] = softc-&gt;goal_bus_width[targ] = 8;\n"
"        /* report the event */\n"
"        neg.bus_width = 8;\n"
"        neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    case TARGET_ANSWERED_WIDE_NEG:\n"
"        {\n"
"            int wd;\n"
"\n"
"            wd = get_target_bus_width_request(softc);\n"
"            if(wd &lt;= softc-&gt;goal_bus_width[targ]) {\n"
"                /* answer is acceptable */\n"
"                softc-&gt;current_bus_width[targ] =\n"
"                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;\n"
"\n"
"                /* report the event */\n"
"                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"            } else {\n"
"                prepare_reject_message(hcb);\n"
"            }\n"
"        }\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    case TARGET_REQUESTED_WIDE_NEG:\n"
"        {\n"
"            int wd;\n"
"\n"
"            wd = get_target_bus_width_request(softc);\n"
"            wd = min (wd, OUR_BUS_WIDTH);\n"
"            wd = min (wd, softc-&gt;user_bus_width[targ]);\n"
"\n"
"            if(wd != softc-&gt;current_bus_width[targ]) {\n"
"                /* the bus width has changed */\n"
"                softc-&gt;current_bus_width[targ] =\n"
"                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;\n"
"\n"
"                /* report the event */\n"
"                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"            }\n"
"            prepare_width_nego_rsponse(hcb, wd);\n"
"        }\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:21425
#, fuzzy
msgid ""
"Then we handle any errors that could have happened during auto-sense in the "
"same simple-minded way as before. Otherwise we look closer at the details "
"again."
msgstr ""
"Ent�o, lidamos com quaisquer erros que poderiam ter ocorrido durante a "
"detec��o autom�tica da mesma maneira simpl�ria de antes. Caso contr�rio, "
"veremos mais de perto os detalhes novamente."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21429
#, no-wrap
msgid ""
"    if(hcb-&gt;flags &amp; DOING_AUTOSENSE)\n"
"        goto autosense_failed;\n"
"\n"
"    switch(hcb_status) {"
msgstr ""
"    if(hcb-&gt;flags &amp; DOING_AUTOSENSE)\n"
"        goto autosense_failed;\n"
"\n"
"    switch(hcb_status) {"

#. (itstool) path: sect1/para
#: book.translate.xml:21434
#, fuzzy
msgid ""
"The next event we consider is unexpected disconnect. Which is considered "
"normal after an ABORT or BUS DEVICE RESET message and abnormal in other "
"cases."
msgstr ""
"O pr�ximo evento que consideramos � uma desconex�o inesperada. O que � "
"considerado normal ap�s uma mensagem ABORT ou BUS DEVICE RESET e anormal em "
"outros casos."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21438
#, no-wrap
msgid ""
"    case UNEXPECTED_DISCONNECT:\n"
"        if(requested_abort(hcb)) {\n"
"            /* abort affects all commands on that target+LUN, so\n"
"             * mark all disconnected HCBs on that target+LUN as aborted too\n"
"             */\n"
"            for(h = softc-&gt;first_discon_hcb[hcb-&gt;target][hcb-&gt;lun];\n"
"                    h != NULL; h = hh) {\n"
"                hh=h-&gt;next;\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQ_ABORTED);\n"
"            }\n"
"            ccb_status = CAM_REQ_ABORTED;\n"
"        } else if(requested_bus_device_reset(hcb)) {\n"
"            int lun;\n"
"\n"
"            /* reset affects all commands on that target, so\n"
"             * mark all disconnected HCBs on that target+LUN as reset\n"
"             */\n"
"\n"
"            for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"                for(h = softc-&gt;first_discon_hcb[hcb-&gt;target][lun];\n"
"                        h != NULL; h = hh) {\n"
"                    hh=h-&gt;next;\n"
"                    free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"                }\n"
"\n"
"            /* send event */\n"
"            xpt_async(AC_SENT_BDR, hcb-&gt;ccb-&gt;ccb_h.path_id, NULL);\n"
"\n"
"            /* this was the CAM_RESET_DEV request itself, it is completed */\n"
"            ccb_status = CAM_REQ_CMP;\n"
"        } else {\n"
"            calculate_residue(hcb);\n"
"            ccb_status = CAM_UNEXP_BUSFREE;\n"
"            /* request the further code to freeze the queue */\n"
"            hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"            lun_to_freeze = hcb-&gt;lun;\n"
"        }\n"
"        break;"
msgstr ""
"    case UNEXPECTED_DISCONNECT:\n"
"        if(requested_abort(hcb)) {\n"
"            /* abort affects all commands on that target+LUN, so\n"
"             * mark all disconnected HCBs on that target+LUN as aborted too\n"
"             */\n"
"            for(h = softc-&gt;first_discon_hcb[hcb-&gt;target][hcb-&gt;lun];\n"
"                    h != NULL; h = hh) {\n"
"                hh=h-&gt;next;\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQ_ABORTED);\n"
"            }\n"
"            ccb_status = CAM_REQ_ABORTED;\n"
"        } else if(requested_bus_device_reset(hcb)) {\n"
"            int lun;\n"
"\n"
"            /* reset affects all commands on that target, so\n"
"             * mark all disconnected HCBs on that target+LUN as reset\n"
"             */\n"
"\n"
"            for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"                for(h = softc-&gt;first_discon_hcb[hcb-&gt;target][lun];\n"
"                        h != NULL; h = hh) {\n"
"                    hh=h-&gt;next;\n"
"                    free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"                }\n"
"\n"
"            /* send event */\n"
"            xpt_async(AC_SENT_BDR, hcb-&gt;ccb-&gt;ccb_h.path_id, NULL);\n"
"\n"
"            /* this was the CAM_RESET_DEV request itself, it is completed */\n"
"            ccb_status = CAM_REQ_CMP;\n"
"        } else {\n"
"            calculate_residue(hcb);\n"
"            ccb_status = CAM_UNEXP_BUSFREE;\n"
"            /* request the further code to freeze the queue */\n"
"            hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"            lun_to_freeze = hcb-&gt;lun;\n"
"        }\n"
"        break;"

#. (itstool) path: sect1/para
#: book.translate.xml:21477
#, fuzzy
msgid ""
"If the target refuses to accept tags we notify CAM about that and return "
"back all commands for this LUN:"
msgstr ""
"Se o destino se recusar a aceitar tags, n�s notificaremos o CAM sobre isso e "
"retornaremos todos os comandos para este LUN:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21480
#, no-wrap
msgid ""
"    case TAGS_REJECTED:\n"
"        /* report the event */\n"
"        neg.flags = 0 &amp; ~CCB_TRANS_TAG_ENB;\n"
"        neg.valid = CCB_TRANS_TQ_VALID;\n"
"        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"\n"
"        ccb_status = CAM_MSG_REJECT_REC;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = hcb-&gt;lun;\n"
"        break;"
msgstr ""
"    case TAGS_REJECTED:\n"
"        /* report the event */\n"
"        neg.flags = 0 &amp; ~CCB_TRANS_TAG_ENB;\n"
"        neg.valid = CCB_TRANS_TQ_VALID;\n"
"        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"\n"
"        ccb_status = CAM_MSG_REJECT_REC;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = hcb-&gt;lun;\n"
"        break;"

#. (itstool) path: sect1/para
#: book.translate.xml:21492
#, fuzzy
msgid ""
"Then we check a number of other conditions, with processing basically "
"limited to setting the CCB status:"
msgstr ""
"Em seguida, verificamos v�rias outras condi��es, com o processamento "
"basicamente limitado � configura��o do status do CCB:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21495
#, no-wrap
msgid ""
"    case SELECTION_TIMEOUT:\n"
"        ccb_status = CAM_SEL_TIMEOUT;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = CAM_LUN_WILDCARD;\n"
"        break;\n"
"    case PARITY_ERROR:\n"
"        ccb_status = CAM_UNCOR_PARITY;\n"
"        break;\n"
"    case DATA_OVERRUN:\n"
"    case ODD_WIDE_TRANSFER:\n"
"        ccb_status = CAM_DATA_RUN_ERR;\n"
"        break;\n"
"    default:\n"
"        /* all other errors are handled in a generic way */\n"
"        ccb_status = CAM_REQ_CMP_ERR;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = CAM_LUN_WILDCARD;\n"
"        break;\n"
"    }"
msgstr ""
"    case SELECTION_TIMEOUT:\n"
"        ccb_status = CAM_SEL_TIMEOUT;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = CAM_LUN_WILDCARD;\n"
"        break;\n"
"    case PARITY_ERROR:\n"
"        ccb_status = CAM_UNCOR_PARITY;\n"
"        break;\n"
"    case DATA_OVERRUN:\n"
"    case ODD_WIDE_TRANSFER:\n"
"        ccb_status = CAM_DATA_RUN_ERR;\n"
"        break;\n"
"    default:\n"
"        /* all other errors are handled in a generic way */\n"
"        ccb_status = CAM_REQ_CMP_ERR;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = CAM_LUN_WILDCARD;\n"
"        break;\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:21517
#, fuzzy
msgid ""
"Then we check if the error was serious enough to freeze the input queue "
"until it gets proceeded and do so if it is:"
msgstr ""
"Em seguida, verificamos se o erro foi grave o suficiente para congelar a "
"fila de entrada at� que ela continue e fa�a isso, se for:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21520
#, no-wrap
msgid ""
"    if(hcb-&gt;ccb-&gt;ccb_h.status &amp; CAM_DEV_QFRZN) {\n"
"        /* freeze the queue */\n"
"        xpt_freeze_devq(ccb-&gt;ccb_h.path, /*count*/1);\n"
"\n"
"        /* re-queue all commands for this target/LUN back to CAM */\n"
"\n"
"        for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"            hh = h-&gt;next;\n"
"\n"
"            if(targ == h-&gt;targ\n"
"            &amp;&amp; (lun_to_freeze == CAM_LUN_WILDCARD || lun_to_freeze == h-&gt;lun) )\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQUEUE_REQ);\n"
"        }\n"
"    }\n"
"    free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, ccb_status);\n"
"    schedule_next_hcb(softc);\n"
"    return;"
msgstr ""
"    if(hcb-&gt;ccb-&gt;ccb_h.status &amp; CAM_DEV_QFRZN) {\n"
"        /* freeze the queue */\n"
"        xpt_freeze_devq(ccb-&gt;ccb_h.path, /*count*/1);\n"
"\n"
"        /* re-queue all commands for this target/LUN back to CAM */\n"
"\n"
"        for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"            hh = h-&gt;next;\n"
"\n"
"            if(targ == h-&gt;targ\n"
"            &amp;&amp; (lun_to_freeze == CAM_LUN_WILDCARD || lun_to_freeze == h-&gt;lun) )\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQUEUE_REQ);\n"
"        }\n"
"    }\n"
"    free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, ccb_status);\n"
"    schedule_next_hcb(softc);\n"
"    return;"

#. (itstool) path: sect1/para
#: book.translate.xml:21538
#, fuzzy
msgid ""
"This concludes the generic interrupt handling although specific controllers "
"may require some additions."
msgstr ""
"Isso conclui o tratamento gen�rico de interrup��o, embora os controladores "
"espec�ficos possam exigir algumas adi��es."

#. (itstool) path: sect1/title
#: book.translate.xml:21543
#, fuzzy
msgid "Errors Summary"
msgstr "Resumo de Erros"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:21545
#, fuzzy
msgid "<primary>SCSI</primary><secondary>errors</secondary>"
msgstr " <primary> SCSI </primary><secondary> erros </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:21547
#, fuzzy
msgid ""
"When executing an I/O request many things may go wrong. The reason of error "
"can be reported in the CCB status with great detail. Examples of use are "
"spread throughout this document. For completeness here is the summary of "
"recommended responses for the typical error conditions:"
msgstr ""
"Ao executar uma solicita��o de E / S, muitas coisas podem dar errado. O "
"motivo do erro pode ser relatado no status CCB com muitos detalhes. Exemplos "
"de uso est�o espalhados por este documento. Para completar, aqui est� o "
"resumo das respostas recomendadas para o t�pico condi��es de erro: "

#. (itstool) path: listitem/para
#: book.translate.xml:21555
#, fuzzy
msgid ""
"<emphasis>CAM_RESRC_UNAVAIL</emphasis> - some resource is temporarily "
"unavailable and the SIM driver cannot generate an event when it will become "
"available. An example of this resource would be some intra-controller "
"hardware resource for which the controller does not generate an interrupt "
"when it becomes available."
msgstr ""
" <emphasis> CAM_RESRC_UNAVAIL </emphasis> - algum recurso est� "
"temporariamente indispon�vel e o driver do SIM n�o pode gerar um evento "
"quando ele estiver dispon�vel. Um exemplo desse recurso seria algum recurso "
"de hardware intra-controlador para o qual o controlador n�o gera uma "
"interrup��o quando se torna dispon�vel. "

#. (itstool) path: listitem/para
#: book.translate.xml:21564
#, fuzzy
msgid ""
"<emphasis>CAM_UNCOR_PARITY</emphasis> - unrecovered parity error occurred"
msgstr ""
" <emphasis> CAM_UNCOR_PARITY </emphasis> - erro de paridade n�o recuperado "
"ocorrido "

#. (itstool) path: listitem/para
#: book.translate.xml:21569
#, fuzzy
msgid ""
"<emphasis>CAM_DATA_RUN_ERR</emphasis> - data overrun or unexpected data "
"phase (going in other direction than specified in CAM_DIR_MASK) or odd "
"transfer length for wide transfer"
msgstr ""
" <emphasis> CAM_DATA_RUN_ERR </emphasis> - satura��o de dados ou fase de "
"dados inesperada (indo em outra dire��o que n�o a especificada em "
"CAM_DIR_MASK) ou comprimento de transfer�ncia �mpar para transfer�ncia ampla "

#. (itstool) path: listitem/para
#: book.translate.xml:21576
#, fuzzy
msgid ""
"<emphasis>CAM_SEL_TIMEOUT</emphasis> - selection timeout occurred (target "
"does not respond)"
msgstr ""
" <emphasis> CAM_SEL_TIMEOUT </emphasis> - tempo limite de sele��o ocorreu (o "
"alvo n�o responde) "

#. (itstool) path: listitem/para
#: book.translate.xml:21581
#, fuzzy
msgid ""
"<emphasis>CAM_CMD_TIMEOUT</emphasis> - command timeout occurred (the timeout "
"function ran)"
msgstr ""
" <emphasis> CAM_CMD_TIMEOUT </emphasis> - ocorreu o tempo limite do comando "
"(a fun��o de tempo limite foi executada) "

#. (itstool) path: listitem/para
#: book.translate.xml:21586
#, fuzzy
msgid "<emphasis>CAM_SCSI_STATUS_ERROR</emphasis> - the device returned error"
msgstr ""
" <emphasis> CAM_SCSI_STATUS_ERROR </emphasis> - o dispositivo retornou o "
"erro "

#. (itstool) path: listitem/para
#: book.translate.xml:21591
#, fuzzy
msgid ""
"<emphasis>CAM_AUTOSENSE_FAIL</emphasis> - the device returned error and the "
"REQUEST SENSE COMMAND failed"
msgstr ""
" <emphasis> CAM_AUTOSENSE_FAIL </emphasis> - o dispositivo retornou um erro "
"e o comando REQUEST SENSE COMMAND falhou "

#. (itstool) path: listitem/para
#: book.translate.xml:21596
#, fuzzy
msgid ""
"<emphasis>CAM_MSG_REJECT_REC</emphasis> - MESSAGE REJECT message was received"
msgstr ""
" <emphasis> CAM_MSG_REJECT_REC </emphasis> - Mensagem de REJEI��O DE "
"MENSAGEM foi recebida "

#. (itstool) path: listitem/para
#: book.translate.xml:21601
#, fuzzy
msgid "<emphasis>CAM_SCSI_BUS_RESET</emphasis> - received SCSI bus reset"
msgstr ""
" <emphasis> CAM_SCSI_BUS_RESET </emphasis> - reset do barramento SCSI recebid"

#. (itstool) path: listitem/para
#: book.translate.xml:21606
#, fuzzy
msgid ""
"<emphasis>CAM_REQ_CMP_ERR</emphasis> - <quote>impossible</quote> SCSI phase "
"occurred or something else as weird or just a generic error if further "
"detail is not available"
msgstr ""
" <emphasis> CAM_REQ_CMP_ERR </emphasis> - <quote> imposs�vel </quote> Fase "
"SCSI ocorreu ou algo mais estranho ou apenas um erro gen�rico se mais "
"detalhes n�o estiverem dispon�veis "

#. (itstool) path: listitem/para
#: book.translate.xml:21613
#, fuzzy
msgid "<emphasis>CAM_UNEXP_BUSFREE</emphasis> - unexpected disconnect occurred"
msgstr ""
" <emphasis> CAM_UNEXP_BUSFREE </emphasis> - desconex�o inesperada ocorreu "

#. (itstool) path: listitem/para
#: book.translate.xml:21618
#, fuzzy
msgid ""
"<emphasis>CAM_BDR_SENT</emphasis> - BUS DEVICE RESET message was sent to the "
"target"
msgstr ""
" <emphasis> CAM_BDR_SENT </emphasis> - A mensagem BUS DEVICE RESET foi "
"enviada para o alvo "

#. (itstool) path: listitem/para
#: book.translate.xml:21623
#, fuzzy
msgid ""
"<emphasis>CAM_UNREC_HBA_ERROR</emphasis> - unrecoverable Host Bus Adapter "
"Error"
msgstr ""
" <emphasis> CAM_UNREC_HBA_ERROR </emphasis> - erro de adaptador de "
"barramento de host irrecuper�vel "

#. (itstool) path: listitem/para
#: book.translate.xml:21628
#, fuzzy
msgid ""
"<emphasis>CAM_REQ_TOO_BIG</emphasis> - the request was too large for this "
"controller"
msgstr ""
" <emphasis> CAM_REQ_TOO_BIG </emphasis> - o pedido era muito grande para "
"esse controlador "

#. (itstool) path: listitem/para
#: book.translate.xml:21633
#, fuzzy
msgid ""
"<emphasis>CAM_REQUEUE_REQ</emphasis> - this request should be re-queued to "
"preserve transaction ordering. This typically occurs when the SIM recognizes "
"an error that should freeze the queue and must place other queued requests "
"for the target at the sim level back into the XPT queue. Typical cases of "
"such errors are selection timeouts, command timeouts and other like "
"conditions. In such cases the troublesome command returns the status "
"indicating the error, the and the other commands which have not be sent to "
"the bus yet get re-queued."
msgstr ""
" <emphasis> CAM_REQUEUE_REQ </emphasis> - essa solicita��o deve ser "
"enfileirada novamente para preservar a ordem de transa��o. Isso normalmente "
"ocorre quando o SIM reconhece um erro que deve congelar a fila e deve "
"colocar outras solicita��es na fila para o destino no n�vel do sim de volta "
"na fila do XPT. Casos t�picos de tais erros s�o tempos limite de sele��o, "
"tempos limite de comando e outras condi��es semelhantes. Em tais casos, o "
"comando problem�tico retorna o status indicando o erro, oe os outros "
"comandos que n�o foram enviados para o barramento ainda s�o re-enfileirados. "

#. (itstool) path: listitem/para
#: book.translate.xml:21646
#, fuzzy
msgid ""
"<emphasis>CAM_LUN_INVALID</emphasis> - the LUN ID in the request is not "
"supported by the SCSI controller"
msgstr ""
" <emphasis> CAM_LUN_INVALID </emphasis> - o ID do LUN na solicita��o n�o � "
"suportado pelo controlador SCSI "

#. (itstool) path: listitem/para
#: book.translate.xml:21651
#, fuzzy
msgid ""
"<emphasis>CAM_TID_INVALID</emphasis> - the target ID in the request is not "
"supported by the SCSI controller"
msgstr ""
" <emphasis> CAM_TID_INVALID </emphasis> - o ID de destino na solicita��o n�o "
"� suportado pelo controlador SCSI "

#. (itstool) path: sect1/title
#: book.translate.xml:21658
#, fuzzy
msgid "Timeout Handling"
msgstr "Timeout Handling"

#. (itstool) path: sect1/para
#: book.translate.xml:21660
#, fuzzy
msgid ""
"When the timeout for an HCB expires that request should be aborted, just "
"like with an XPT_ABORT request. The only difference is that the returned "
"status of aborted request should be CAM_CMD_TIMEOUT instead of "
"CAM_REQ_ABORTED (that is why implementation of the abort better be done as a "
"function). But there is one more possible problem: what if the abort request "
"itself will get stuck? In this case the SCSI bus should be reset, just like "
"with an XPT_RESET_BUS request (and the idea about implementing it as a "
"function called from both places applies here too). Also we should reset the "
"whole SCSI bus if a device reset request got stuck. So after all the timeout "
"function would look like:"
msgstr ""
"Quando o tempo limite de um HCB expira, o pedido deve ser abortado, assim "
"como com um pedido XPT_ABORT. A �nica diferen�a � que o status retornado do "
"pedido abortado deve ser CAM_CMD_TIMEOUT ao inv�s de CAM_REQ_ABORTED (� por "
"isso que a implementa��o do aborto deve ser feita como Mas h� mais um "
"problema poss�vel: e se o pr�prio pedido de abortar ficar preso? Nesse caso, "
"o barramento SCSI deve ser redefinido, assim como com uma solicita��o "
"XPT_RESET_BUS (e a id�ia de implement�-lo como uma fun��o chamada de ambos "
"os lugares se aplicam aqui tamb�m. Tamb�m devemos redefinir todo o "
"barramento SCSI se uma solicita��o de reinicializa��o do dispositivo ficar "
"travada. Ent�o, depois de toda a fun��o de tempo limite, seria: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21673
#, no-wrap
msgid ""
"static void\n"
"xxx_timeout(void *arg)\n"
"{\n"
"    struct xxx_hcb *hcb = (struct xxx_hcb *)arg;\n"
"    struct xxx_softc *softc;\n"
"    struct ccb_hdr *ccb_h;\n"
"\n"
"    softc = hcb-&gt;softc;\n"
"    ccb_h = &amp;hcb-&gt;ccb-&gt;ccb_h;\n"
"\n"
"    if(hcb-&gt;flags &amp; HCB_BEING_ABORTED\n"
"    || ccb_h-&gt;func_code == XPT_RESET_DEV) {\n"
"        xxx_reset_bus(softc);\n"
"    } else {\n"
"        xxx_abort_ccb(hcb-&gt;ccb, CAM_CMD_TIMEOUT);\n"
"    }\n"
"}"
msgstr ""
"static void\n"
"xxx_timeout(void *arg)\n"
"{\n"
"    struct xxx_hcb *hcb = (struct xxx_hcb *)arg;\n"
"    struct xxx_softc *softc;\n"
"    struct ccb_hdr *ccb_h;\n"
"\n"
"    softc = hcb-&gt;softc;\n"
"    ccb_h = &amp;hcb-&gt;ccb-&gt;ccb_h;\n"
"\n"
"    if(hcb-&gt;flags &amp; HCB_BEING_ABORTED\n"
"    || ccb_h-&gt;func_code == XPT_RESET_DEV) {\n"
"        xxx_reset_bus(softc);\n"
"    } else {\n"
"        xxx_abort_ccb(hcb-&gt;ccb, CAM_CMD_TIMEOUT);\n"
"    }\n"
"}"

#. (itstool) path: sect1/para
#: book.translate.xml:21691
#, fuzzy
msgid ""
"When we abort a request all the other disconnected requests to the same "
"target/LUN get aborted too. So there appears a question, should we return "
"them with status CAM_REQ_ABORTED or CAM_CMD_TIMEOUT? The current drivers use "
"CAM_CMD_TIMEOUT. This seems logical because if one request got timed out "
"then probably something really bad is happening to the device, so if they "
"would not be disturbed they would time out by themselves."
msgstr ""
"Quando abortamos um pedido, todos os outros pedidos desconectados para o "
"mesmo destino / LUN s�o abortados tamb�m. Ent�o, aparece uma pergunta, "
"devemos devolv�-los com status CAM_REQ_ABORTED ou CAM_CMD_TIMEOUT? Os "
"drivers atuais usam CAM_CMD_TIMEOUT. Isso parece l�gico porque se um pedido "
"Se o tempo expirar, � prov�vel que algo realmente ruim esteja acontecendo "
"com o dispositivo, por isso, se eles n�o forem incomodados, eles perder�o o "
"tempo sozinhos \""

#. (itstool) path: info/title
#: book.translate.xml:21709
#, fuzzy
msgid "USB Devices"
msgstr "Dispositivos USB"

#. (itstool) path: authorgroup/author
#: book.translate.xml:21712
#, fuzzy
msgid ""
"<personname> <firstname>Nick</firstname> <surname>Hibma</surname> </"
"personname> <contrib>Written by </contrib>"
msgstr ""
" <personname><firstname> Nick </firstname><surname> Hibma </surname></"
"personname><contrib> Escrito por </contrib> "

#. (itstool) path: authorgroup/author
#: book.translate.xml:21721
#, fuzzy
msgid ""
"<personname> <firstname>Murray</firstname> <surname>Stokely</surname> </"
"personname> <contrib>Modifications for Handbook made by </contrib>"
msgstr ""
" <personname><firstname> Murray </firstname><surname> Stokely </surname></"
"personname><contrib> Modifica��es para o manual feito por </contrib> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:21734
#, fuzzy
msgid "<primary>Universal Serial Bus (USB)</primary>"
msgstr " <primary> Barramento Serial Universal (USB) </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:21736
#, fuzzy
msgid "<primary>NetBSD</primary>"
msgstr " <primary> NetBSD </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:21738
#, fuzzy
msgid ""
"The Universal Serial Bus (USB) is a new way of attaching devices to personal "
"computers. The bus architecture features two-way communication and has been "
"developed as a response to devices becoming smarter and requiring more "
"interaction with the host. USB support is included in all current PC "
"chipsets and is therefore available in all recently built PCs. Apple's "
"introduction of the USB-only iMac has been a major incentive for hardware "
"manufacturers to produce USB versions of their devices. The future PC "
"specifications specify that all legacy connectors on PCs should be replaced "
"by one or more USB connectors, providing generic plug and play capabilities. "
"Support for USB hardware was available at a very early stage in NetBSD and "
"was developed by Lennart Augustsson for the NetBSD project. The code has "
"been ported to FreeBSD and we are currently maintaining a shared code base. "
"For the implementation of the USB subsystem a number of features of USB are "
"important."
msgstr ""
"O Universal Serial Bus (USB) � uma nova maneira de conectar dispositivos a "
"computadores pessoais. A arquitetura de barramento possui comunica��o "
"bidirecional e foi desenvolvida como uma resposta a dispositivos que se "
"tornam mais inteligentes e exigem mais intera��o com o host. O suporte USB "
"est� inclu�do em todos os atuais chipsets para PC e, portanto, est� "
"dispon�vel em todos os PCs rec�m-constru�dos.A introdu��o do iMac apenas "
"para USB tem sido um grande incentivo para fabricantes de hardware "
"produzirem vers�es USB de seus dispositivos.As especifica��es futuras do PC "
"especificam que todos os conectores legados em PCs deve ser substitu�do por "
"um ou mais conectores USB, fornecendo capacidades gen�ricas de plug and play "
"O suporte para hardware USB estava dispon�vel em um est�gio muito inicial no "
"NetBSD e foi desenvolvido por Lennart Augustsson para o projeto NetBSD O "
"c�digo foi portado para o FreeBSD e n�s Atualmente, est�o mantendo uma base "
"de c�digo compartilhada. Para a implementa��o do subsistema USB, um n�mero "
"de recursos de USB � importante. "

#. (itstool) path: sect1/para
#: book.translate.xml:21755
#, fuzzy
msgid ""
"<emphasis>Lennart Augustsson has done most of the implementation of the USB "
"support for the NetBSD project. Many thanks for this incredible amount of "
"work. Many thanks also to Ardy and Dirk for their comments and proofreading "
"of this paper.</emphasis>"
msgstr ""
" <emphasis> Lennart Augustsson fez a maior parte da implementa��o do suporte "
"a USB para o projeto NetBSD. Muito obrigado por esta incr�vel quantidade de "
"trabalho. Muito obrigado tamb�m a Ardy e Dirk por seus coment�rios e revis�o "
"deste artigo. </emphasis> "

#. (itstool) path: listitem/para
#: book.translate.xml:21764
#, fuzzy
msgid ""
"Devices connect to ports on the computer directly or on devices called hubs, "
"forming a treelike device structure."
msgstr ""
"Os dispositivos se conectam a portas no computador diretamente ou em "
"dispositivos chamados hubs, formando uma estrutura de dispositivo semelhante "
"a uma �rvore."

#. (itstool) path: listitem/para
#: book.translate.xml:21770
#, fuzzy
msgid "The devices can be connected and disconnected at run time."
msgstr ""
"Os dispositivos podem ser conectados e desconectados em tempo de execu��o."

#. (itstool) path: listitem/para
#: book.translate.xml:21775
#, fuzzy
msgid "Devices can suspend themselves and trigger resumes of the host system"
msgstr "Dispositivos podem se suspender e acionar curr�culos do sistema host"

#. (itstool) path: listitem/para
#: book.translate.xml:21780
#, fuzzy
msgid ""
"As the devices can be powered from the bus, the host software has to keep "
"track of power budgets for each hub."
msgstr ""
"Como os dispositivos podem ser alimentados pelo barramento, o software "
"hospedeiro precisa monitorar os or�amentos de energia de cada hub\""

#. (itstool) path: listitem/para
#: book.translate.xml:21786
#, fuzzy
msgid ""
"Different quality of service requirements by the different device types "
"together with the maximum of 126 devices that can be connected to the same "
"bus, require proper scheduling of transfers on the shared bus to take full "
"advantage of the 12Mbps bandwidth available. (over 400Mbps with USB 2.0)"
msgstr ""
"Diferentes exig�ncias de qualidade de servi�o pelos diferentes tipos de "
"dispositivos, juntamente com o m�ximo de 126 dispositivos que podem ser "
"conectados ao mesmo barramento, requerem agendamento adequado de "
"transfer�ncias no barramento compartilhado para aproveitar ao m�ximo a "
"largura de banda de 12Mbps dispon�vel. USB 2.0) "

#. (itstool) path: listitem/para
#: book.translate.xml:21795
#, fuzzy
msgid ""
"Devices are intelligent and contain easily accessible information about "
"themselves"
msgstr ""
"Os dispositivos s�o inteligentes e cont�m informa��es facilmente acess�veis "
"sobre si mesmos"

#. (itstool) path: sect1/para
#: book.translate.xml:21801
#, fuzzy
msgid ""
"The development of drivers for the USB subsystem and devices connected to it "
"is supported by the specifications that have been developed and will be "
"developed. These specifications are publicly available from the USB home "
"pages. Apple has been very strong in pushing for standards based drivers, by "
"making drivers for the generic classes available in their operating system "
"MacOS and discouraging the use of separate drivers for each new device. This "
"chapter tries to collate essential information for a basic understanding of "
"the USB 2.0 implementation stack in FreeBSD/NetBSD. It is recommended "
"however to read it together with the relevant 2.0 specifications and other "
"developer resources:"
msgstr ""
"O desenvolvimento de drivers para o subsistema USB e dispositivos conectados "
"a ele � suportado pelas especifica��es que foram desenvolvidas e que ser�o "
"desenvolvidas. Essas especifica��es est�o dispon�veis publicamente nas home "
"pages USB. A Apple tem sido muito forte em pressionar por drivers baseados "
"em padr�es. , fazendo drivers para as classes gen�ricas dispon�veis em seu "
"sistema operacional MacOS e desencorajando o uso de drivers separados para "
"cada novo dispositivo.Este cap�tulo tenta coletar informa��es essenciais "
"para uma compreens�o b�sica da pilha de implementa��o USB 2.0 no FreeBSD / "
"NetBSD. recomendado, no entanto, para l�-lo em conjunto com as "
"especifica��es relevantes 2.0 e outros recursos do desenvolvedor: "

#. (itstool) path: listitem/para
#: book.translate.xml:21816
#, fuzzy
msgid ""
"USB 2.0 Specification (<link xlink:href=\"http://www.usb.org/developers/docs/"
"usb20_docs/\">http://www.usb.org/developers/docs/usb20_docs/</link>)"
msgstr ""
"Especifica��o USB 2.0 ( <link xlink:href=\"http://www.usb.org/developers/"
"docs/usb20_docs/\"> http://www.usb.org/developers/docs/usb20_docs/ </link> ) "

#. (itstool) path: listitem/para
#: book.translate.xml:21820
#, fuzzy
msgid ""
"Universal Host Controller Interface (<acronym>UHCI</acronym>) Specification "
"(<link xlink:href=\"ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf"
"\">ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf)</link>"
msgstr ""
"Especifica��o <acronym>UHCI</acronym> (Universal Host Controller Interface) "
"<link xlink:href=\"ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf\"> "
"ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf) </link> "

#. (itstool) path: listitem/para
#: book.translate.xml:21825
#, fuzzy
msgid ""
"Open Host Controller Interface (<acronym>OHCI</acronym>) Specification(<link "
"xlink:href=\"ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a.pdf"
"\">ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a.pdf</link>)"
msgstr ""
"Especifica��o da Interface do Controlador de Host Aberto ( <acronym>OHCI</"
"acronym> ) ( <link xlink:href=\"ftp://ftp.compaq.com/pub/supportinformation/"
"papers/hcir1_0a.pdf\"> ftp://ftp.compaq.com/pub/supportinformation/papers/"
"hcir1_0a.pdf </link> ) "

#. (itstool) path: listitem/para
#: book.translate.xml:21830
#, fuzzy
msgid ""
"Developer section of <acronym>USB</acronym> home page (<link xlink:href="
"\"http://www.usb.org/developers/\">http://www.usb.org/developers/</link>)"
msgstr ""
"Se��o do desenvolvedor da home page do <acronym>USB</acronym> ( <link xlink:"
"href=\"http://www.usb.org/developers/\"> http://www.usb.org/developers/ </"
"link> ) "

#. (itstool) path: sect2/title
#: book.translate.xml:21836
#, fuzzy
msgid "Structure of the USB Stack"
msgstr "Estrutura da pilha USB"

#. (itstool) path: sect2/para
#: book.translate.xml:21838
#, fuzzy
msgid ""
"The USB support in FreeBSD can be split into three layers. The lowest layer "
"contains the host controller driver, providing a generic interface to the "
"hardware and its scheduling facilities. It supports initialisation of the "
"hardware, scheduling of transfers and handling of completed and/or failed "
"transfers. Each host controller driver implements a virtual hub providing "
"hardware independent access to the registers controlling the root ports on "
"the back of the machine."
msgstr ""
"O suporte USB no FreeBSD pode ser dividido em tr�s camadas. A camada mais "
"baixa cont�m o driver controlador host, fornecendo uma interface gen�rica "
"para o hardware e suas facilidades de agendamento. Suporta inicializa��o do "
"hardware, agendamento de transfer�ncias e tratamento de Cada controlador de "
"host implementa um hub virtual fornecendo acesso independente de hardware "
"aos registros que controlam as portas raiz na parte traseira da m�quina. "

#. (itstool) path: sect2/para
#: book.translate.xml:21848
#, fuzzy
msgid ""
"The middle layer handles the device connection and disconnection, basic "
"initialisation of the device, driver selection, the communication channels "
"(pipes) and does resource management. This services layer also controls the "
"default pipes and the device requests transferred over them."
msgstr ""
"A camada intermedi�ria lida com a conex�o e desconex�o do dispositivo, "
"inicializa��o b�sica do dispositivo, sele��o de driver, canais de "
"comunica��o (pipes) e gerenciamento de recursos. Essa camada de servi�os "
"tamb�m controla os pipes padr�o e as solicita��es de dispositivos "
"transferidos."

#. (itstool) path: sect2/para
#: book.translate.xml:21855
#, fuzzy
msgid ""
"The top layer contains the individual drivers supporting specific (classes "
"of) devices. These drivers implement the protocol that is used over the "
"pipes other than the default pipe. They also implement additional "
"functionality to make the device available to other parts of the kernel or "
"userland. They use the USB driver interface (USBDI) exposed by the services "
"layer."
msgstr ""
"A camada superior cont�m os drivers individuais que suportam dispositivos "
"espec�ficos (classes de). Esses drivers implementam o protocolo que � usado "
"nos pipes diferentes do padr�o. Eles tamb�m implementam funcionalidade "
"adicional para disponibilizar o dispositivo para outras partes do kernel ou "
"Eles usam a interface do driver USB (USBDI) exposta pela camada de servi�os. "

#. (itstool) path: sect1/title
#: book.translate.xml:21866
#, fuzzy
msgid "Host Controllers"
msgstr "Host Controllers"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:21868
#, fuzzy
msgid "<primary>USB</primary><secondary>host controllers</secondary>"
msgstr ""
" <primary> USB </primary><secondary> controladores de host </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:21870
#, fuzzy
msgid ""
"The host controller (HC) controls the transmission of packets on the bus. "
"Frames of 1 millisecond are used. At the start of each frame the host "
"controller generates a Start of Frame (SOF) packet."
msgstr ""
"O controlador host (HC) controla a transmiss�o de pacotes no barramento. S�o "
"usados ​​quadros de 1 milissegundo. No in�cio de cada quadro, o controlador "
"host gera um pacote Start of Frame (SOF)."

#. (itstool) path: sect1/para
#: book.translate.xml:21875
#, fuzzy
msgid ""
"The SOF packet is used to synchronise to the start of the frame and to keep "
"track of the frame number. Within each frame packets are transferred, either "
"from host to device (out) or from device to host (in). Transfers are always "
"initiated by the host (polled transfers). Therefore there can only be one "
"host per USB bus. Each transfer of a packet has a status stage in which the "
"recipient of the data can return either ACK (acknowledge reception), NAK "
"(retry), STALL (error condition) or nothing (garbled data stage, device not "
"available or disconnected). Section 8.5 of the USB 2.0 Specification "
"explains the details of packets in more detail. Four different types of "
"transfers can occur on a USB bus: control, bulk, interrupt and isochronous. "
"The types of transfers and their characteristics are described below."
msgstr ""
"O pacote SOF � usado para sincronizar com o in�cio do quadro e para "
"acompanhar o n�mero do quadro. Dentro de cada pacote de quadros s�o "
"transferidos, de host para dispositivo (out) ou de dispositivo para host "
"(in). As transfer�ncias s�o sempre Portanto, s� pode haver um host por "
"barramento USB Cada transfer�ncia de um pacote tem um est�gio de status no "
"qual o destinat�rio dos dados pode retornar ou ACK (recep��o de "
"confirma��o), NAK (repeti��o), STALL (condi��o de erro) ou nada (est�gio de "
"dados truncados, dispositivo n�o dispon�vel ou desconectado). A Se��o 8.5 da "
"Especifica��o USB 2.0 explica os detalhes dos pacotes em mais detalhes. "
"Quatro tipos diferentes de transfer�ncias podem ocorrer em um barramento "
"USB: controle, volume , interrup��es e is�cronas. Os tipos de transfer�ncias "
"e suas caracter�sticas s�o descritas a seguir. "

#. (itstool) path: sect1/para
#: book.translate.xml:21890
#, fuzzy
msgid ""
"Large transfers between the device on the USB bus and the device driver are "
"split up into multiple packets by the host controller or the HC driver."
msgstr ""
"Grandes transfer�ncias entre o dispositivo no barramento USB e o driver do "
"dispositivo s�o divididas em v�rios pacotes pelo controlador host ou pelo "
"driver HC."

#. (itstool) path: sect1/para
#: book.translate.xml:21894
#, fuzzy
msgid ""
"Device requests (control transfers) to the default endpoints are special. "
"They consist of two or three phases: SETUP, DATA (optional) and STATUS. The "
"set-up packet is sent to the device. If there is a data phase, the direction "
"of the data packet(s) is given in the set-up packet. The direction in the "
"status phase is the opposite of the direction during the data phase, or IN "
"if there was no data phase. The host controller hardware also provides "
"registers with the current status of the root ports and the changes that "
"have occurred since the last reset of the status change register. Access to "
"these registers is provided through a virtualised hub as suggested in the "
"USB specification. The virtual hub must comply with the hub device class "
"given in chapter 11 of that specification. It must provide a default pipe "
"through which device requests can be sent to it. It returns the standard "
"andhub class specific set of descriptors. It should also provide an "
"interrupt pipe that reports changes happening at its ports. There are "
"currently two specifications for host controllers available: Universal Host "
"Controller Interface (<acronym>UHCI</acronym>) from Intel and Open Host "
"Controller Interface (<acronym>OHCI</acronym>) from Compaq, Microsoft, and "
"National Semiconductor. The <acronym>UHCI</acronym> specification has been "
"designed to reduce hardware complexity by requiring the host controller "
"driver to supply a complete schedule of the transfers for each frame. OHCI "
"type controllers are much more independent by providing a more abstract "
"interface doing a lot of work themselves."
msgstr ""
"As solicita��es de dispositivos (transfer�ncias de controle) para os "
"terminais padr�o s�o especiais. Elas consistem em duas ou tr�s fases: "
"CONFIGURA��O, DADOS (opcional) e STATUS. O pacote de configura��o � enviado "
"para o dispositivo. Se houver uma fase de dados, o A dire��o do (s) pacote "
"(s) de dados � dada no pacote de configura��o A dire��o na fase de status � "
"o oposto da dire��o durante a fase de dados, ou IN se n�o houver fase de "
"dados O hardware controlador de host tamb�m fornece registros com o status "
"atual das portas raiz e as mudan�as ocorridas desde a �ltima reconfigura��o "
"do registro de mudan�a de status.O acesso a esses registros � fornecido por "
"meio de um hub virtualizado, conforme sugerido na especifica��o USB.O hub "
"virtual deve estar de acordo com o dispositivo de hub classe dada no "
"cap�tulo 11 da especifica��o.Ele deve fornecer um pipe padr�o atrav�s do "
"qual as solicita��es de dispositivo podem ser enviadas para ele.Ele retorna "
"o conjunto de descritores de classe andhub padr�o.Ele tamb�m deve fornecer "
"um pipe de interrup��o que relata mudan�as happe nos seus portos. Existem "
"atualmente duas especifica��es para controladores host dispon�veis: "
"Interface <acronym>UHCI</acronym> (Universal Host Controller Interface) da "
"Intel e <acronym>OHCI</acronym> (Open Host Controller Interface) da Compaq, "
"Microsoft e National Semiconductor. A especifica��o <acronym>UHCI</acronym> "
"foi projetada para reduzir a complexidade do hardware exigindo que o driver "
"do controlador host forne�a uma programa��o completa das transfer�ncias para "
"cada quadro. Os controladores do tipo OHCI s�o muito mais independentes, "
"fornecendo uma interface mais abstrata, fazendo muito trabalho por conta "
"pr�pria. "

#. (itstool) path: sect2/title
#: book.translate.xml:21923
#, fuzzy
msgid "UHCI"
msgstr "UHCI"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:21925
#, fuzzy
msgid "<primary>USB</primary> <secondary>UHCI</secondary>"
msgstr " <primary> USB </primary><secondary> UHCI </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:21930
#, fuzzy
msgid ""
"The UHCI host controller maintains a framelist with 1024 pointers to per "
"frame data structures. It understands two different data types: transfer "
"descriptors (TD) and queue heads (QH). Each TD represents a packet to be "
"communicated to or from a device endpoint. QHs are a means to groupTDs (and "
"QHs) together."
msgstr ""
"O controlador host UHCI mant�m uma lista de quadros com 1024 ponteiros para "
"estruturas de dados por quadro. Ele entende dois tipos de dados diferentes: "
"descritores de transfer�ncia (TD) e cabe�alhos de fila (QH). Cada TD "
"representa um pacote a ser comunicado para ou de um terminal de dispositivo "
"QHs s�o um meio para agrupar os DTs (e os QHs) juntos. "

#. (itstool) path: sect2/para
#: book.translate.xml:21937
#, fuzzy
msgid ""
"Each transfer consists of one or more packets. The UHCI driver splits large "
"transfers into multiple packets. For every transfer, apart from isochronous "
"transfers, a QH is allocated. For every type of transfer these QHs are "
"collected at a QH for that type. Isochronous transfers have to be executed "
"first because of the fixed latency requirement and are directly referred to "
"by the pointer in the framelist. The last isochronous TD refers to the QH "
"for interrupt transfers for that frame. All QHs for interrupt transfers "
"point at the QH for control transfers, which in turn points at the QH for "
"bulk transfers. The following diagram gives a graphical overview of this:"
msgstr ""
"Cada transfer�ncia consiste em um ou mais pacotes. O driver UHCI divide "
"grandes transfer�ncias em v�rios pacotes. Para cada transfer�ncia, al�m das "
"transfer�ncias is�cronas, um QH � alocado. Para cada tipo de transfer�ncia, "
"esses QHs s�o coletados em um QH para esse tipo. Transfer�ncias is�cronas "
"t�m que ser executadas primeiro por causa do requisito de lat�ncia fixa e "
"s�o diretamente referenciadas pelo ponteiro na lista de quadros.O �ltimo TD "
"is�crono refere-se ao QH para transfer�ncias de interrup��o para esse quadro."
"Todos os QHs para transfer�ncias interrompidas apontam para o QH para "
"controle de transfer�ncias, que por sua vez, aponta para o QH para "
"transfer�ncias em massa. O diagrama a seguir d� uma vis�o geral do gr�fico: "

#. (itstool) path: sect2/para
#: book.translate.xml:21950
#, fuzzy
msgid ""
"This results in the following schedule being run in each frame. After "
"fetching the pointer for the current frame from the framelist the controller "
"first executes the TDs for all the isochronous packets in that frame. The "
"last of these TDs refers to the QH for the interrupt transfers for "
"thatframe. The host controller will then descend from that QH to the QHs for "
"the individual interrupt transfers. After finishing that queue, the QH for "
"the interrupt transfers will refer the controller to the QH for all control "
"transfers. It will execute all the subqueues scheduled there, followed by "
"all the transfers queued at the bulk QH. To facilitate the handling of "
"finished or failed transfers different types of interrupts are generated by "
"the hardware at the end of each frame. In the last TD for a transfer the "
"Interrupt-On Completion bit is set by the HC driver to flag an interrupt "
"when the transfer has completed. An error interrupt is flagged if a TD "
"reaches its maximum error count. If the short packet detect bit is set in a "
"TD and less than the set packet length is transferred this interrupt is "
"flagged to notify the controller driver of the completed transfer. It is the "
"host controller driver's task to find out which transfer has completed or "
"produced an error. When called the interrupt service routine will locate all "
"the finished transfers and call their callbacks."
msgstr ""
"Isso resulta no seguinte cronograma sendo executado em cada quadro. Depois "
"de buscar o ponteiro para o quadro atual a partir da lista de quadros, o "
"controlador primeiro executa os TDs para todos os pacotes is�cronos naquele "
"quadro. O �ltimo desses TDs refere-se ao QH para o quadro. interromper "
"transfer�ncias para aquele frame.O controlador host ent�o descer� daquele QH "
"para os QHs para as transfer�ncias de interrup��es individuais.Depois de "
"terminar essa fila, o QH para as transfer�ncias de interrup��es ir� "
"referenciar o controlador para o QH para todas as transfer�ncias de "
"controle. as subfilas programadas l�, seguidas por todas as transfer�ncias "
"enfileiradas no QH em massa Para facilitar o processamento de transfer�ncias "
"conclu�das ou com falha, diferentes tipos de interrup��es s�o gerados pelo "
"hardware no final de cada quadro. -On O bit de conclus�o � definido pelo "
"driver HC para sinalizar uma interrup��o quando a transfer�ncia for "
"conclu�da.Uma interrup��o de erro � sinalizada se um TD atingir sua contagem "
"m�xima de erros. bit de detec��o de pacote � definido em um TD e menor que o "
"comprimento do pacote configurado � transferido, essa interrup��o � marcada "
"para notificar o driver do controlador da transfer�ncia conclu�da. � a "
"tarefa do driver do controlador host descobrir qual transfer�ncia concluiu "
"ou produziu um erro. Quando chamada, a rotina de servi�o de interrup��o "
"localizar� todas as transfer�ncias conclu�das e chamar� seus retornos de "
"chamada. "

#. (itstool) path: sect2/para
#: book.translate.xml:21974
#, fuzzy
msgid ""
"Refer to the <acronym>UHCI</acronym> Specification for a more elaborate "
"description."
msgstr ""
"Consulte a Especifica��o <acronym>UHCI</acronym> para uma descri��o mais "
"elaborada."

#. (itstool) path: sect2/title
#: book.translate.xml:21980
#, fuzzy
msgid "OHCI"
msgstr "OHCI"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:21982
#, fuzzy
msgid "<primary>USB</primary> <secondary>OHCI</secondary>"
msgstr " <primary> USB </primary><secondary> OHCI </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:21987
#, fuzzy
msgid ""
"Programming an OHCI host controller is much simpler. The controller assumes "
"that a set of endpoints is available, and is aware of scheduling priorities "
"and the ordering of the types of transfers in a frame. The main data "
"structure used by the host controller is the endpoint descriptor (ED) to "
"which a queue of transfer descriptors (TDs) is attached. The ED contains the "
"maximum packet size allowed for an endpoint and the controller hardware does "
"the splitting into packets. The pointers to the data buffers are updated "
"after each transfer and when the start and end pointer are equal, the TD is "
"retired to the done-queue. The four types of endpoints (interrupt, "
"isochronous, control, and bulk) have their own queues. Control and bulk "
"endpoints are queued each at their own queue. Interrupt EDs are queued in a "
"tree, with the level in the tree defining the frequency at which they run."
msgstr ""
"A programa��o de um controlador host OHCI � muito mais simples. O "
"controlador assume que um conjunto de terminais est� dispon�vel e est� "
"ciente das prioridades de planejamento e da ordena��o dos tipos de "
"transfer�ncias em um quadro. A estrutura de dados principal usada pelo "
"controlador host � a descritor de endpoint (ED) ao qual uma fila de "
"descritores de transfer�ncia (TDs) � anexada.O ED cont�m o tamanho m�ximo de "
"pacote permitido para um endpoint e o hardware do controlador faz a divis�o "
"em pacotes.Os ponteiros para os buffers de dados s�o atualizados ap�s cada "
"transfer�ncia e quando o ponteiro inicial e final s�o iguais, o TD � "
"retirado para a fila done.Os quatro tipos de endpoints (interrup��o, "
"is�crono, controle e bulk) t�m suas pr�prias filas.Os endpoints de controle "
"e em massa s�o enfileirados cada um em suas pr�prias filas. Os EDs de "
"interrup��o s�o enfileirados em uma �rvore, com o n�vel na �rvore definindo "
"a frequ�ncia na qual eles s�o executados. "

#. (itstool) path: sect2/para
#: book.translate.xml:22003
#, fuzzy
msgid ""
"The schedule being run by the host controller in each frame looks as "
"follows. The controller will first run the non-periodic control and bulk "
"queues, up to a time limit set by the HC driver. Then the interrupt "
"transfers for that frame number are run, by using the lower five bits of the "
"frame number as an index into level 0 of the tree of interrupts EDs. At the "
"end of this tree the isochronous EDs are connected and these are traversed "
"subsequently. The isochronous TDs contain the frame number of the first "
"frame the transfer should be run in. After all the periodic transfers have "
"been run, the control and bulk queues are traversed again. Periodically the "
"interrupt service routine is called to process the done queue and call the "
"callbacks for each transfer and reschedule interrupt and isochronous "
"endpoints."
msgstr ""
"O agendamento que est� sendo executado pelo controlador host em cada quadro "
"� o seguinte. O controlador primeiro executar� o controle n�o peri�dico e as "
"filas em massa, at� um limite de tempo definido pelo driver HC. Ent�o as "
"transfer�ncias de interrup��o para esse n�mero de quadros s�o executado, "
"usando os cinco bits inferiores do n�mero do quadro como um �ndice no n�vel "
"0 da �rvore de interrup��es EDs. No final desta �rvore os EDs is�cronos s�o "
"conectados e estes s�o percorridos subseq�entemente.Os TDs is�cronos cont�m "
"o n�mero do quadro de interrup��es. o primeiro quadro em que a transfer�ncia "
"deve ser executada. Depois que todas as transfer�ncias peri�dicas tiverem "
"sido executadas, as filas de controle e em massa ser�o novamente "
"percorridas. Periodicamente, a rotina de servi�o de interrup��o � chamada "
"para processar a fila conclu�da e chamar os retornos de chamada para cada "
"interrup��o de transfer�ncia e reprograma��o e pontos finais is�cronos \""

#. (itstool) path: sect2/para
#: book.translate.xml:22018
#, fuzzy
msgid ""
"See the <acronym>UHCI</acronym> Specification for a more elaborate "
"description. The middle layer provides access to the device in a controlled "
"way and maintains resources in use by the different drivers and the services "
"layer. The layer takes care of the following aspects:"
msgstr ""
"Veja a Especifica��o <acronym>UHCI</acronym> para uma descri��o mais "
"elaborada. A camada intermedi�ria fornece acesso ao dispositivo de maneira "
"controlada e mant�m os recursos em uso pelos diferentes drivers e pela "
"camada de servi�os. A camada cuida dos seguintes aspectos:"

#. (itstool) path: listitem/para
#: book.translate.xml:22026
#, fuzzy
msgid "The device configuration information"
msgstr "A informa��o de configura��o do dispositivo"

#. (itstool) path: listitem/para
#: book.translate.xml:22029
#, fuzzy
msgid "The pipes to communicate with a device"
msgstr "Os canais para se comunicar com um dispositivo"

#. (itstool) path: listitem/para
#: book.translate.xml:22032
#, fuzzy
msgid "Probing and attaching and detaching form a device."
msgstr "Sondar e anexar e desanexar formam um dispositivo."

#. (itstool) path: sect1/title
#: book.translate.xml:22040
#, fuzzy
msgid "USB Device Information"
msgstr "Informa��es do dispositivo USB"

#. (itstool) path: sect2/title
#: book.translate.xml:22043
#, fuzzy
msgid "Device Configuration Information"
msgstr "Informa��es de configura��o do dispositivo"

#. (itstool) path: sect2/para
#: book.translate.xml:22045
#, fuzzy
msgid ""
"Each device provides different levels of configuration information. Each "
"device has one or more configurations, of which one is selected during probe/"
"attach. A configuration provides power and bandwidth requirements. Within "
"each configuration there can be multiple interfaces. A device interface is a "
"collection of endpoints. For example USB speakers can have an interface for "
"the audio data (Audio Class) and an interface for the knobs, dials and "
"buttons (HID Class). All interfaces in a configuration are active at the "
"same time and can be attached to by different drivers. Each interface can "
"have alternates, providing different quality of service parameters. In for "
"example cameras this is used to provide different frame sizes and numbers of "
"frames per second."
msgstr ""
"Cada dispositivo fornece diferentes n�veis de informa��es de configura��o. "
"Cada dispositivo tem uma ou mais configura��es, uma das quais � selecionada "
"durante a sonda / conex�o. Uma configura��o fornece requisitos de pot�ncia e "
"largura de banda. Dentro de cada configura��o pode haver v�rias interfaces. "
"Uma interface de dispositivo � uma cole��o de pontos de extremidade.Por "
"exemplo, os alto-falantes USB podem ter uma interface para os dados de �udio "
"(classe de �udio) e uma interface para os bot�es, bot�es e mostradores "
"(classe HID) .Todas as interfaces em uma configura��o est�o ativas ao mesmo "
"tempo por diferentes drivers. Cada interface pode ter alternativas, "
"fornecendo diferentes par�metros de qualidade de servi�o. Em c��meras, por "
"exemplo, isso � usado para fornecer diferentes tamanhos de quadros e n�meros "
"de quadros por segundo. "

#. (itstool) path: sect2/para
#: book.translate.xml:22060
#, fuzzy
msgid ""
"Within each interface, 0 or more endpoints can be specified. Endpoints are "
"the unidirectional access points for communicating with a device. They "
"provide buffers to temporarily store incoming or outgoing data from the "
"device. Each endpoint has a unique address within a configuration, the "
"endpoint's number plus its direction. The default endpoint, endpoint 0, is "
"not part of any interface and available in all configurations. It is managed "
"by the services layer and not directly available to device drivers."
msgstr ""
"Dentro de cada interface, 0 ou mais n�s de extremidade podem ser "
"especificados. Os pontos de extremidade s�o os pontos de acesso "
"unidirecionais para comunica��o com um dispositivo. Eles fornecem buffers "
"para armazenar temporariamente dados de entrada ou sa�da do dispositivo. "
"Cada n� de extremidade possui um endere�o exclusivo dentro de uma "
"configura��o. O n�mero do n� de extremidade mais sua dire��o. O ponto de "
"extremidade padr�o, ponto de extremidade 0, n�o faz parte de nenhuma "
"interface e est� dispon�vel em todas as configura��es. Ele � gerenciado pela "
"camada de servi�os e n�o est� diretamente dispon�vel para os drivers de "
"dispositivos. "

#. (itstool) path: sect2/para
#: book.translate.xml:22076
#, fuzzy
msgid ""
"This hierarchical configuration information is described in the device by a "
"standard set of descriptors (see section 9.6 of the USB specification). They "
"can be requested through the Get Descriptor Request. The services layer "
"caches these descriptors to avoid unnecessary transfers on the USB bus. "
"Access to the descriptors is provided through function calls."
msgstr ""
"Essas informa��es de configura��o hier�rquica s�o descritas no dispositivo "
"por um conjunto padr�o de descritores (consulte a se��o 9.6 da especifica��o "
"USB). Elas podem ser solicitadas por meio da solicita��o Get Descriptor. A "
"camada de servi�os armazena esses descritores para evitar transfer�ncias "
"desnecess�rias no barramento USB O acesso aos descritores � fornecido "
"atrav�s de chamadas de fun��o. "

#. (itstool) path: listitem/para
#: book.translate.xml:22086
#, fuzzy
msgid ""
"Device descriptors: General information about the device, like Vendor, "
"Product and Revision Id, supported device class, subclass and protocol if "
"applicable, maximum packet size for the default endpoint, etc."
msgstr ""
"Descritores de dispositivo: informa��es gerais sobre o dispositivo, como "
"fornecedor, produto e ID de revis�o, classe de dispositivo compat�vel, "
"subclasse e protocolo, se aplic�vel, tamanho m�ximo de pacote para o "
"endpoint padr�o etc."

#. (itstool) path: listitem/para
#: book.translate.xml:22093
#, fuzzy
msgid ""
"Configuration descriptors: The number of interfaces in this configuration, "
"suspend and resume functionality supported and power requirements."
msgstr ""
"Descritores de configura��o: o n�mero de interfaces nesta configura��o, "
"suspender e retomar a funcionalidade suportada e os requisitos de energia."

#. (itstool) path: listitem/para
#: book.translate.xml:22099
#, fuzzy
msgid ""
"Interface descriptors: interface class, subclass and protocol if applicable, "
"number of alternate settings for the interface and the number of endpoints."
msgstr ""
"Descritores de interface: classe de interface, subclasse e protocolo, se "
"aplic�vel, n�mero de configura��es alternativas para a interface e o n�mero "
"de pontos de extremidade."

#. (itstool) path: listitem/para
#: book.translate.xml:22105
#, fuzzy
msgid ""
"Endpoint descriptors: Endpoint address, direction and type, maximum packet "
"size supported and polling frequency if type is interrupt endpoint. There is "
"no descriptor for the default endpoint (endpoint 0) and it is never counted "
"in an interface descriptor."
msgstr ""
"Endpoint descriptors: Endere�o, dire��o e tipo do endpoint, tamanho m�ximo "
"do pacote suportado e frequ�ncia de sondagem se o tipo for ponto final de "
"interrup��o. N�o h� um descritor para o endpoint padr�o (endpoint 0) e ele "
"nunca � contado em um descritor de interface."

#. (itstool) path: listitem/para
#: book.translate.xml:22113
#, fuzzy
msgid ""
"String descriptors: In the other descriptors string indices are supplied for "
"some fields.These can be used to retrieve descriptive strings, possibly in "
"multiple languages."
msgstr ""
"Descritores de strings: Nos outros descritores, s�o fornecidos �ndices de "
"strings para alguns campos. Eles podem ser usados ​​para recuperar strings "
"descritivas, possivelmente em m�ltiplos idiomas."

#. (itstool) path: sect2/para
#: book.translate.xml:22120
#, fuzzy
msgid ""
"Class specifications can add their own descriptor types that are available "
"through the GetDescriptor Request."
msgstr ""
"As especifica��es de classe podem adicionar seus pr�prios tipos de "
"descritores que est�o dispon�veis por meio da solicita��o GetDescriptor."

#. (itstool) path: sect2/para
#: book.translate.xml:22123
#, fuzzy
msgid ""
"Pipes Communication to end points on a device flows through so-called pipes. "
"Drivers submit transfers to endpoints to a pipe and provide a callback to be "
"called on completion or failure of the transfer (asynchronous transfers) or "
"wait for completion (synchronous transfer). Transfers to an endpoint are "
"serialised in the pipe. A transfer can either complete, fail or time-out (if "
"a time-out has been set). There are two types of time-outs for transfers. "
"Time-outs can happen due to time-out on the USBbus (milliseconds). These "
"time-outs are seen as failures and can be due to disconnection of the "
"device. A second form of time-out is implemented in software and is "
"triggered when a transfer does not complete within a specified amount of "
"time (seconds). These are caused by a device acknowledging negatively (NAK) "
"the transferred packets. The cause for this is the device not being ready to "
"receive data, buffer under- or overrun or protocol errors."
msgstr ""
"Pipes Comunica��o para pontos finais em um dispositivo flui atrav�s de "
"chamados pipes. Drivers enviam transfer�ncias para pontos de extremidade "
"para um pipe e fornecem um retorno de chamada a ser chamado na conclus�o ou "
"falha da transfer�ncia (transfer�ncias ass�ncronas) ou aguardar conclus�o "
"(transfer�ncia s�ncrona) Transfer�ncias para um endpoint s�o serializadas no "
"pipe Uma transfer�ncia pode ser completada, falha ou time-out (se um time-"
"out tiver sido definido) Existem dois tipos de time-outs para "
"transfer�ncias. para time-out no USBbus (milissegundos). Estes tempos "
"debitados s�o vistos como falhas e podem ser devidos � desconex�o do "
"dispositivo.Uma segunda forma de time-out � implementada no software e � "
"disparada quando uma transfer�ncia n�o � conclu�da dentro um determinado "
"per�odo de tempo (segundos). Eles s�o causados ​​por um dispositivo que "
"reconhece negativamente (NAK) os pacotes transferidos. A causa para isso � o "
"dispositivo n�o estar pronto para receber dados, erros de buffer ou de sub "
"ou de protocolo. "

#. (itstool) path: sect2/para
#: book.translate.xml:22141
#, fuzzy
msgid ""
"If a transfer over a pipe is larger than the maximum packet size specified "
"in the associated endpoint descriptor, the host controller (OHCI) or the HC "
"driver (UHCI) will split the transfer into packets of maximum packet size, "
"with the last packet possibly smaller than the maximum packet size."
msgstr ""
"Se uma transfer�ncia em um pipe for maior que o tamanho m�ximo de pacote "
"especificado no descritor de terminal associado, o controlador host (OHCI) "
"ou o driver HC (UHCI) dividir� a transfer�ncia em pacotes de tamanho m�ximo "
"de pacote, com o �ltimo pacote possivelmente menor que o tamanho m�ximo do "
"pacote. "

#. (itstool) path: sect2/para
#: book.translate.xml:22148
#, fuzzy
msgid ""
"Sometimes it is not a problem for a device to return less data than "
"requested. For example abulk-in-transfer to a modem might request 200 bytes "
"of data, but the modem has only 5 bytes available at that time. The driver "
"can set the short packet (SPD) flag. It allows the host controller to accept "
"a packet even if the amount of data transferred is less than requested. This "
"flag is only valid for in-transfers, as the amount of data to be sent to a "
"device is always known beforehand. If an unrecoverable error occurs in a "
"device during a transfer the pipe is stalled. Before any more data is "
"accepted or sent the driver needs to resolve the cause of the stall and "
"clear the endpoint stall condition through send the clear endpoint halt "
"device request over the default pipe. The default endpoint should never "
"stall."
msgstr ""
"�s vezes, n�o � um problema para um dispositivo retornar menos dados do que "
"o solicitado. Por exemplo, a transfer�ncia de dados em um modem pode "
"solicitar 200 bytes de dados, mas o modem tem apenas 5 bytes dispon�veis no "
"momento. O driver pode definir O sinalizador de pacote curto (SPD) permite "
"que o controlador host aceite um pacote, mesmo que a quantidade de dados "
"transferidos seja menor que a solicitada, este sinalizador s� � v�lido para "
"transfer�ncias, como a quantidade de dados a ser enviada para um "
"dispositivo. Se um erro irrecuper�vel ocorrer em um dispositivo durante uma "
"transfer�ncia, o tubo ser� paralisado.Antes de mais dados serem aceitos ou "
"enviados, o driver precisa resolver a causa da paralisa��o e limpar a "
"condi��o de parada do endpoint atrav�s do envio do ponto de extremidade "
"limpo interromper a solicita��o do dispositivo pelo canal padr�o. O ponto de "
"extremidade padr�o nunca deve parar. "

#. (itstool) path: sect2/para
#: book.translate.xml:22163
#, fuzzy
msgid ""
"There are four different types of endpoints and corresponding pipes: - "
"Control pipe / default pipe: There is one control pipe per device, connected "
"to the default endpoint (endpoint 0). The pipe carries the device requests "
"and associated data. The difference between transfers over the default pipe "
"and other pipes is that the protocol for the transfers is described in the "
"USB specification. These requests are used to reset and configure the "
"device. A basic set of commands that must be supported by each device is "
"provided in chapter 9 of the USB specification. The commands supported on "
"this pipe can be extended by a device class specification to support "
"additional functionality."
msgstr ""
"Existem quatro tipos diferentes de terminais e canais correspondentes: - "
"Canal de controle / canal padr�o: H� um canal de controle por dispositivo, "
"conectado ao ponto de extremidade padr�o (ponto de extremidade 0). O canal "
"transporta as solicita��es de dispositivo e dados associados. A diferen�a "
"entre transfer�ncias atrav�s do pipe padr�o e outros canais � que o "
"protocolo para as transfer�ncias � descrito na especifica��o USB.Esses "
"pedidos s�o usados ​​para redefinir e configurar o dispositivo.Um conjunto "
"b�sico de comandos que devem ser suportados por cada dispositivo � fornecido "
"no cap�tulo 9 da especifica��o USB. Os comandos suportados neste pipe podem "
"ser estendidos por uma especifica��o de classe de dispositivo para suportar "
"funcionalidades adicionais. "

#. (itstool) path: listitem/para
#: book.translate.xml:22178
#, fuzzy
msgid "Bulk pipe: This is the USB equivalent to a raw transmission medium."
msgstr ""
"Tubo em massa: este � o equivalente USB a um meio de transmiss�o bruto."

#. (itstool) path: listitem/para
#: book.translate.xml:22183
#, fuzzy
msgid ""
"Interrupt pipe: The host sends a request for data to the device and if the "
"device has nothing to send, it will NAK the data packet. Interrupt transfers "
"are scheduled at a frequency specified when creating the pipe."
msgstr ""
"Interrupt pipe: O host envia uma solicita��o de dados para o dispositivo e "
"se o dispositivo n�o tiver nada para enviar, ele NAK o pacote de dados. "
"Interromper transfer�ncias s�o agendadas em uma freq��ncia especificada ao "
"criar o pipe."

#. (itstool) path: listitem/para
#: book.translate.xml:22191
#, fuzzy
msgid ""
"Isochronous pipe: These pipes are intended for isochronous data, for example "
"video or audio streams, with fixed latency, but no guaranteed delivery. Some "
"support for pipes of this type is available in the current implementation. "
"Packets in control, bulk and interrupt transfers are retried if an error "
"occurs during transmission or the device acknowledges the packet negatively "
"(NAK) due to for example lack of buffer space to store the incoming data. "
"Isochronous packets are however not retried in case of failed delivery or "
"NAK of a packet as this might violate the timing constraints."
msgstr ""
"Tubo Is�crono: Esses canos s�o destinados a dados is�cronos, por exemplo, "
"fluxos de v�deo ou �udio, com lat�ncia fixa, mas sem entrega garantida. "
"Algum suporte para tubos deste tipo est� dispon�vel na implementa��o atual. "
"Pacotes no controle, em massa e interrup��o de transfer�ncias s�o repetidos "
"se ocorrer um erro durante a transmiss�o ou o dispositivo reconhecer o "
"pacote negativamente (NAK) devido a, por exemplo, falta de espa�o no buffer "
"para armazenar os dados recebidos.N�o � poss�vel tentar novamente pacotes "
"is�cronos em caso de falha na entrega ou NAK de um pacote. pode violar as "
"restri��es de tempo. "

#. (itstool) path: sect2/para
#: book.translate.xml:22206
#, fuzzy
msgid ""
"The availability of the necessary bandwidth is calculated during the "
"creation of the pipe. Transfers are scheduled within frames of 1 "
"millisecond. The bandwidth allocation within a frame is prescribed by the "
"USB specification, section 5.6 [ 2]. Isochronous and interrupt transfers are "
"allowed to consume up to 90% of the bandwidth within a frame. Packets for "
"control and bulk transfers are scheduled after all isochronous and interrupt "
"packets and will consume all the remaining bandwidth."
msgstr ""
"A disponibilidade da largura de banda necess�ria � calculada durante a "
"cria��o do pipe. As transfer�ncias s�o programadas em quadros de 1 "
"milissegundo. A aloca��o de largura de banda dentro de um quadro � prescrita "
"pela especifica��o USB, se��o 5.6 [2]. S�o permitidas transfer�ncias "
"is�cronas e de interrup��o para consumir at� 90% da largura de banda dentro "
"de um quadro. Pacotes para controle e transfer�ncias em massa s�o agendados "
"ap�s todos os pacotes is�cronos e de interrup��o e consumir�o toda a largura "
"de banda restante. "

#. (itstool) path: sect2/para
#: book.translate.xml:22216
#, fuzzy
msgid ""
"More information on scheduling of transfers and bandwidth reclamation can be "
"found in chapter 5 of the USB specification, section 1.3 of the UHCI "
"specification, and section 3.4.2 of the OHCI specification."
msgstr ""
"Mais informa��es sobre o agendamento de transfer�ncias e a recupera��o de "
"banda podem ser encontradas no cap�tulo 5 da especifica��o USB, na se��o 1.3 "
"da especifica��o UHCI e na se��o 3.4.2 da especifica��o OHCI."

#. (itstool) path: sect1/title
#: book.translate.xml:22224
#, fuzzy
msgid "Device Probe and Attach"
msgstr "Device Probe and Attach"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:22226
#, fuzzy
msgid "<primary>USB</primary> <secondary>probe</secondary>"
msgstr " <primary> USB </primary><secondary> sonda </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:22231
#, fuzzy
msgid ""
"After the notification by the hub that a new device has been connected, the "
"service layer switches on the port, providing the device with 100 mA of "
"current. At this point the device is in its default state and listening to "
"device address 0. The services layer will proceed to retrieve the various "
"descriptors through the default pipe. After that it will send a Set Address "
"request to move the device away from the default device address (address 0). "
"Multiple device drivers might be able to support the device. For example a "
"modem driver might be able to support an ISDN TA through the AT "
"compatibility interface. A driver for that specific model of the ISDN "
"adapter might however be able to provide much better support for this "
"device. To support this flexibility, the probes return priorities indicating "
"their level of support. Support for a specific revision of a product ranks "
"the highest and the generic driver the lowest priority. It might also be "
"that multiple drivers could attach to one device if there are multiple "
"interfaces within one configuration. Each driver only needs to support a "
"subset of the interfaces."
msgstr ""
"Ap�s a notifica��o pelo hub de que um novo dispositivo foi conectado, a "
"camada de servi�o liga a porta, fornecendo ao dispositivo 100 mA de "
"corrente. Neste ponto, o dispositivo est� no estado padr�o e escutando o "
"endere�o 0 do dispositivo. A camada de servi�os proceder� � recupera��o dos "
"v�rios descritores por meio do canal padr�o e, depois disso, enviar� uma "
"solicita��o Set Address para afastar o dispositivo do endere�o padr�o do "
"dispositivo (endere�o 0). V�rios drivers de dispositivo podem ser "
"compat�veis com o dispositivo. Por exemplo, um driver de modem pode ser "
"capaz de suportar um ISDN TA atrav�s da interface de compatibilidade AT Um "
"driver para esse modelo espec�fico do adaptador ISDN pode, no entanto, ser "
"capaz de fornecer um suporte muito melhor para este dispositivo Para "
"suportar essa flexibilidade, as sondas retornam prioridades indicando o seu "
"n�vel de suporte Suporte para uma revis�o espec�fica de um produto "
"classifica o mais alto eo driver gen�rico a menor prioridade.Pode tamb�m ser "
"que v�rios drivers poderiam anexar a um dev gelo se houver v�rias interfaces "
"dentro de uma configura��o. Cada driver precisa apenas suportar um "
"subconjunto das interfaces. "

#. (itstool) path: sect1/para
#: book.translate.xml:22250
#, fuzzy
msgid ""
"The probing for a driver for a newly attached device checks first for device "
"specific drivers. If not found, the probe code iterates over all supported "
"configurations until a driver attaches in a configuration. To support "
"devices with multiple drivers on different interfaces, the probe iterates "
"over all interfaces in a configuration that have not yet been claimed by a "
"driver. Configurations that exceed the power budget for the hub are ignored. "
"During attach the driver should initialise the device to its proper state, "
"but not reset it, as this will make the device disconnect itself from the "
"bus and restart the probing process for it. To avoid consuming unnecessary "
"bandwidth should not claim the interrupt pipe at attach time, but should "
"postpone allocating the pipe until the file is opened and the data is "
"actually used. When the file is closed the pipe should be closed again, even "
"though the device might still be attached."
msgstr ""
"A detec��o de um driver para um dispositivo rec�m-conectado verifica "
"primeiro os drivers espec�ficos do dispositivo. Se n�o encontrado, o c�digo "
"do probe repete todas as configura��es suportadas at� que um driver seja "
"anexado em uma configura��o. Para suportar dispositivos com v�rios drivers "
"em diferentes interfaces itera em todas as interfaces em uma configura��o "
"que ainda n�o foi reivindicada por um driver. As configura��es que excedem o "
"or�amento de energia para o hub s�o ignoradas. Durante a conex�o, o driver "
"deve inicializar o dispositivo no estado correto, mas n�o redefini-lo, pois "
"isso fa�a com que o dispositivo desconecte-se do barramento e reinicie o "
"processo de teste para evitar o consumo de largura de banda desnecess�ria "
"n�o deve reivindicar o pipe de interrup��o no momento da conex�o, mas deve "
"adiar a aloca��o do canal at� que o arquivo seja aberto e os dados realmente "
"usados. o arquivo est� fechado, o tubo deve ser fechado novamente, mesmo que "
"o dispositivo ainda possa estar conectado. "

#. (itstool) path: sect2/title
#: book.translate.xml:22268
#, fuzzy
msgid "Device Disconnect and Detach"
msgstr "Desconectar e desanexar o dispositivo"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:22270
#, fuzzy
msgid "<primary>USB</primary> <secondary>disconnect</secondary>"
msgstr " <primary> USB </primary><secondary> desconectar </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:22275
#, fuzzy
msgid ""
"A device driver should expect to receive errors during any transaction with "
"the device. The design of USB supports and encourages the disconnection of "
"devices at any point in time. Drivers should make sure that they do the "
"right thing when the device disappears."
msgstr ""
"Um driver de dispositivo deve esperar receber erros durante qualquer "
"transa��o com o dispositivo. O design do USB suporta e encoraja a desconex�o "
"de dispositivos a qualquer momento. Os drivers devem garantir que eles fa�am "
"a coisa certa quando o dispositivo desaparecer."

#. (itstool) path: sect2/para
#: book.translate.xml:22281
#, fuzzy
msgid ""
"Furthermore a device that has been disconnected and reconnected will not be "
"reattached at the same device instance. This might change in the future when "
"more devices support serial numbers (see the device descriptor) or other "
"means of defining an identity for a device have been developed."
msgstr ""
"Al�m disso, um dispositivo que tenha sido desconectado e reconectado n�o "
"ser� reconectado na mesma inst�ncia do dispositivo. Isso pode mudar no "
"futuro quando mais dispositivos suportarem n�meros de s�rie (consulte o "
"descritor de dispositivo) ou outros meios de definir uma identidade para um "
"dispositivo. desenvolvido."

#. (itstool) path: sect2/para
#: book.translate.xml:22288
#, fuzzy
msgid ""
"The disconnection of a device is signaled by a hub in the interrupt packet "
"delivered to the hub driver. The status change information indicates which "
"port has seen a connection change. The device detach method for all device "
"drivers for the device connected on that port are called and the structures "
"cleaned up. If the port status indicates that in the mean time a device has "
"been connected to that port, the procedure for probing and attaching the "
"device will be started. A device reset will produce a disconnect-connect "
"sequence on the hub and will be handled as described above."
msgstr ""
"A desconex�o de um dispositivo � sinalizada por um hub no pacote de "
"interrup��o entregue ao driver do hub. As informa��es de mudan�a de status "
"indicam qual porta detectou uma altera��o de conex�o. O m�todo de remo��o de "
"dispositivo para todos os drivers de dispositivos conectados ao dispositivo "
"est� Se o status da porta indicar que, nesse meio tempo, um dispositivo foi "
"conectado a essa porta, ser� iniciado o procedimento para sondar e conectar "
"o dispositivo.Uma reinicializa��o do dispositivo produzir� uma sequ�ncia de "
"conex�o de desconex�o no sistema. hub e ser� tratado conforme descrito "
"acima. "

#. (itstool) path: sect1/title
#: book.translate.xml:22303
#, fuzzy
msgid "USB Drivers Protocol Information"
msgstr "Informa��es do protocolo de drivers USB"

#. (itstool) path: sect1/para
#: book.translate.xml:22305
#, fuzzy
msgid ""
"The protocol used over pipes other than the default pipe is undefined by the "
"USB specification. Information on this can be found from various sources. "
"The most accurate source is the developer's section on the USB home pages. "
"From these pages, a growing number of deviceclass specifications are "
"available. These specifications specify what a compliant device should look "
"like from a driver perspective, basic functionality it needs to provide and "
"the protocol that is to be used over the communication channels. The USB "
"specification includes the description of the Hub Class. A class "
"specification for Human Interface Devices (HID) has been created to cater "
"for keyboards, tablets, bar-code readers, buttons, knobs, switches, etc. A "
"third example is the class specification for mass storage devices. For a "
"full list of device classes see the developers section on the USB home pages."
msgstr ""
"O protocolo usado em outros pipes al�m do pipe padr�o � indefinido pela "
"especifica��o USB. Informa��es sobre isso podem ser encontradas em v�rias "
"fontes. A fonte mais precisa � a se��o do desenvolvedor nas home pages USB. "
"A partir dessas p�ginas, um n�mero crescente de Est�o dispon�veis "
"especifica��es deviceclass Estas especifica��es especificam como deve ser um "
"dispositivo compat�vel do ponto de vista do driver, a funcionalidade b�sica "
"que ele precisa fornecer e o protocolo que deve ser usado nos canais de "
"comunica��o.A especifica��o USB inclui a descri��o da Classe Hub. Uma "
"especifica��o de classe para dispositivos de interface humana (HID) foi "
"criada para atender a teclados, tablets, leitores de c�digo de barras, "
"bot�es, bot�es, switches, etc. Um terceiro exemplo � a especifica��o de "
"classe para dispositivos de armazenamento em massa. classes de dispositivos, "
"consulte a se��o de desenvolvedores nas p�ginas iniciais do USB. "

#. (itstool) path: sect1/para
#: book.translate.xml:22321
#, fuzzy
msgid ""
"For many devices the protocol information has not yet been published "
"however. Information on the protocol being used might be available from the "
"company making the device. Some companies will require you to sign a Non -"
"Disclosure Agreement (NDA) before giving you the specifications. This in "
"most cases precludes making the driver open source."
msgstr ""
"Para muitos dispositivos, as informa��es do protocolo ainda n�o foram "
"publicadas. Informa��es sobre o protocolo usado podem estar dispon�veis na "
"empresa que faz o dispositivo. Algumas empresas exigir�o que voc� assine um "
"Acordo de N�o-Divulga��o (NDA) antes de fornecer as especifica��es. Isso, na "
"maioria dos casos, impede que o driver seja open source. "

#. (itstool) path: sect1/para
#: book.translate.xml:22328
#, fuzzy
msgid ""
"Another good source of information is the Linux driver sources, as a number "
"of companies have started to provide drivers for Linux for their devices. It "
"is always a good idea to contact the authors of those drivers for their "
"source of information."
msgstr ""
"Outra boa fonte de informa��o s�o as fontes de drivers do Linux, j� que "
"v�rias empresas come�aram a fornecer drivers para o Linux em seus "
"dispositivos. � sempre uma boa id�ia entrar em contato com os autores desses "
"drivers para obter informa��es."

#. (itstool) path: sect1/para
#: book.translate.xml:22334
#, fuzzy
msgid ""
"Example: Human Interface Devices The specification for the Human Interface "
"Devices like keyboards, mice, tablets, buttons, dials,etc. is referred to in "
"other device class specifications and is used in many devices."
msgstr ""
"Exemplo: dispositivos de interface humana A especifica��o para dispositivos "
"de interface humana como teclados, mouses, tablets, bot�es, dials, etc. � "
"referida em outras especifica��es de classe de dispositivo e � usada em "
"muitos dispositivos."

#. (itstool) path: sect1/para
#: book.translate.xml:22339
#, fuzzy
msgid ""
"For example audio speakers provide endpoints to the digital to analogue "
"converters and possibly an extra pipe for a microphone. They also provide a "
"HID endpoint in a separate interface for the buttons and dials on the front "
"of the device. The same is true for the monitor control class. It is "
"straightforward to build support for these interfaces through the available "
"kernel and userland libraries together with the HID class driver or the "
"generic driver. Another device that serves as an example for interfaces "
"within one configuration driven by different device drivers is a cheap "
"keyboard with built-in legacy mouse port. To avoid having the cost of "
"including the hardware for a USB hub in the device, manufacturers combined "
"the mouse data received from the PS/2 port on the back of the keyboard and "
"the key presses from the keyboard into two separate interfaces in the same "
"configuration. The mouse and keyboard drivers each attach to the appropriate "
"interface and allocate the pipes to the two independent endpoints."
msgstr ""
"Por exemplo, os alto-falantes de �udio fornecem pontos finais para os "
"conversores digitais para anal�gicos e possivelmente um tubo extra para um "
"microfone. Eles tamb�m fornecem um ponto de extremidade HID em uma interface "
"separada para os bot�es e mostradores na frente do dispositivo. O mesmo vale "
"para o � f�cil criar suporte para essas interfaces por meio das bibliotecas "
"kernel e userland dispon�veis, juntamente com o driver de classe HID ou o "
"driver gen�rico.Um outro dispositivo que serve como exemplo para interfaces "
"dentro de uma configura��o controlada por drivers de dispositivo diferentes "
"� um Teclado barato com porta de mouse legado integrada Para evitar o custo "
"de incluir o hardware de um hub USB no dispositivo, os fabricantes "
"combinaram os dados do mouse recebidos da porta PS / 2 na parte de tr�s do "
"teclado e as teclas pressionadas de o teclado em duas interfaces separadas "
"na mesma configura��o.Os drivers de mouse e teclado cada um anexar � "
"interface apropriada e alocar os tubos para os dois endpoints independentes. "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:22358
#, fuzzy
msgid "<primary>USB</primary> <secondary>firmware</secondary>"
msgstr " <primary> USB </primary><secondary> firmware </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:22363
#, fuzzy
msgid ""
"Example: Firmware download Many devices that have been developed are based "
"on a general purpose processor with an additional USB core added to it. "
"Because the development of drivers and firmware for USB devices is still "
"very new, many devices require the downloading of the firmware after they "
"have been connected."
msgstr ""
"Exemplo: download de firmware Muitos dispositivos que foram desenvolvidos "
"s�o baseados em um processador de uso geral com um n�cleo USB adicional. "
"Como o desenvolvimento de drivers e firmware para dispositivos USB ainda � "
"muito novo, muitos dispositivos exigem o download do firmware depois de "
"terem sido conectados \""

#. (itstool) path: sect1/para
#: book.translate.xml:22370
#, fuzzy
msgid ""
"The procedure followed is straightforward. The device identifies itself "
"through a vendor and product Id. The first driver probes and attaches to it "
"and downloads the firmware into it. After that the device soft resets itself "
"and the driver is detached. After a short pause the device announces its "
"presence on the bus. The device will have changed its vendor/product/"
"revision Id to reflect the fact that it has been supplied with firmware and "
"as a consequence a second driver will probe it and attach to it."
msgstr ""
"O procedimento seguido � direto. O dispositivo se identifica por meio de um "
"fornecedor e um ID do produto. O primeiro driver detecta e anexa a ele e faz "
"o download do firmware. Depois disso, o dispositivo � reiniciado e o driver "
"� desconectado. Ap�s uma breve pausa o dispositivo anuncia sua presen�a no "
"barramento. O dispositivo ter� mudado seu ID de fornecedor / produto / "
"revis�o para refletir o fato de que ele foi fornecido com firmware e, como "
"conseq��ncia, um segundo driver ir� sond�-lo e anex�-lo. "

#. (itstool) path: sect1/para
#: book.translate.xml:22380
#, fuzzy
msgid ""
"An example of these types of devices is the ActiveWire I/O board, based on "
"the EZ-USB chip. For this chip a generic firmware downloader is available. "
"The firmware downloaded into the ActiveWire board changes the revision Id. "
"It will then perform a soft reset of the USB part of the EZ-USB chip to "
"disconnect from the USB bus and again reconnect."
msgstr ""
"Um exemplo desses tipos de dispositivos � a placa de E / S do ActiveWire, "
"baseada no chip EZ-USB. Para este chip, um downloader de firmware gen�rico "
"est� dispon�vel. O firmware baixado no quadro do ActiveWire altera o ID da "
"revis�o. uma reinicializa��o suave da parte USB do chip EZ-USB para "
"desconectar do barramento USB e reconectar novamente. "

#. (itstool) path: sect1/para
#: book.translate.xml:22387
#, fuzzy
msgid ""
"Example: Mass Storage Devices Support for mass storage devices is mainly "
"built around existing protocols. The Iomega USB Zipdrive is based on the "
"SCSI version of their drive. The SCSI commands and status messages are "
"wrapped in blocks and transferred over the bulk pipes to and from the "
"device, emulating a SCSI controller over the USB wire. ATAPI and UFI "
"commands are supported in a similar fashion."
msgstr ""
"Exemplo: Dispositivos de armazenamento em massa O suporte para dispositivos "
"de armazenamento em massa � constru�do principalmente em torno dos "
"protocolos existentes. O Iomega USB Zipdrive � baseado na vers�o SCSI da "
"unidade. Os comandos SCSI e as mensagens de status s�o agrupados em blocos e "
"transferidos para a partir do dispositivo, emulando um controlador SCSI "
"atrav�s do cabo USB. Os comandos ATAPI e UFI s�o suportados de forma "
"semelhante. "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:22395
#, fuzzy
msgid "<primary>ATAPI</primary>"
msgstr " <primary> ATAPI </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:22397
#, fuzzy
msgid ""
"The Mass Storage Specification supports 2 different types of wrapping of the "
"command block.The initial attempt was based on sending the command and "
"status through the default pipe and using bulk transfers for the data to be "
"moved between the host and the device. Based on experience a second approach "
"was designed that was based on wrapping the command and status blocks and "
"sending them over the bulk out and in endpoint. The specification specifies "
"exactly what has to happen when and what has to be done in case an error "
"condition is encountered. The biggest challenge when writing drivers for "
"these devices is to fit USB based protocol into the existing support for "
"mass storage devices. CAM provides hooks to do this in a fairly straight "
"forward way. ATAPI is less simple as historically the IDE interface has "
"never had many different appearances."
msgstr ""
"A especifica��o de armazenamento em massa suporta dois tipos diferentes de "
"quebra autom�tica do bloco de comando. A tentativa inicial foi baseada no "
"envio do comando e status atrav�s do pipe padr�o e usando transfer�ncias em "
"massa para os dados a serem movidos entre o host e o dispositivo. "
"experi�ncia uma segunda abordagem foi projetada com base em agrupar os "
"blocos de comando e status e envi�-los pelo bulk out e no endpoint.A "
"especifica��o especifica exatamente o que deve acontecer quando e o que deve "
"ser feito no caso de uma condi��o de erro ser encontrada. O maior desafio ao "
"escrever drivers para esses dispositivos � adequar o protocolo baseado em "
"USB ao suporte existente para dispositivos de armazenamento em massa.AMPI � "
"mais simples, j� que historicamente a interface IDE nunca teve muitos "
"recursos. apar�ncias diferentes \""

#. (itstool) path: sect1/para
#: book.translate.xml:22412
#, fuzzy
msgid ""
"The support for the USB floppy from Y-E Data is again less straightforward "
"as a new command set has been designed."
msgstr ""
"O suporte para o disquete USB da YE Data � novamente menos simples, j� que "
"um novo conjunto de comandos foi projetado."

#. (itstool) path: info/title
#: book.translate.xml:22443
#, fuzzy
msgid "Newbus"
msgstr "Newbus"

#. (itstool) path: affiliation/address
#: book.translate.xml:22452
#, fuzzy, no-wrap
msgid ""
"\n"
"\t    <email>asmodai@FreeBSD.org</email>\n"
"\t  "
msgstr "<email>asmodai@FreeBSD.org</email>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:22446
#, fuzzy
msgid ""
"<personname> <firstname>Jeroen</firstname> <surname>Ruigrok van der Werven "
"(asmodai)</surname> </personname> <affiliation> <_:address-1/> </"
"affiliation> <contrib>Written by </contrib>"
msgstr ""
" <personname><firstname> Jeroen </firstname><surname> Ruigrok van der Werven "
"(asmodai) </surname></personname><affiliation> <_: endere�o-1 /> </"
"affiliation><contrib> Escrito por </contrib> "

#. (itstool) path: affiliation/address
#: book.translate.xml:22464
#, fuzzy, no-wrap
msgid ""
"\n"
"\t    <email>hiten@uk.FreeBSD.org</email>\n"
"\t  "
msgstr "<email>hiten@uk.FreeBSD.org</email>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:22458
#, fuzzy
msgid ""
"<personname> <firstname>Hiten</firstname> <surname>Pandya</surname> </"
"personname> <affiliation> <_:address-1/> </affiliation>"
msgstr ""
" <personname><firstname> Hiten </firstname><surname> Pandya </surname></"
"personname><affiliation> <_: endere�o-1 /> </affiliation> "

#. (itstool) path: chapter/para
#: book.translate.xml:22472
#, fuzzy
msgid ""
"<emphasis>Special thanks to Matthew N. Dodd, Warner Losh, Bill Paul, Doug "
"Rabson, Mike Smith, Peter Wemm and Scott Long</emphasis>."
msgstr ""
" <emphasis> Agradecimentos especiais a Matthew N. Dodd, Warner Losh, Bill "
"Paul, Doug Rabson, Mike Smith, Peter Wemm e Scott Long </emphasis> "

#. (itstool) path: chapter/para
#: book.translate.xml:22476
#, fuzzy
msgid "This chapter explains the Newbus device framework in detail."
msgstr "Este cap�tulo explica a estrutura do dispositivo Newbus em detalhes."

#. (itstool) path: sect2/title
#: book.translate.xml:22483
#, fuzzy
msgid "Purpose of a Device Driver"
msgstr "Prop�sito de um driver de dispositivo"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:22487
#, fuzzy
msgid "<primary>device driver</primary><secondary>introduction</secondary>"
msgstr ""
" <primary> driver do dispositivo </primary><secondary> introdu��o </"
"secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:22490
#, fuzzy
msgid ""
"A device driver is a software component which provides the interface between "
"the kernel's generic view of a peripheral (e.g., disk, network adapter) and "
"the actual implementation of the peripheral. The <emphasis>device driver "
"interface (DDI)</emphasis> is the defined interface between the kernel and "
"the device driver component."
msgstr ""
"Um driver de dispositivo � um componente de software que fornece a interface "
"entre a vis�o gen�rica do kernel de um perif�rico (por exemplo, disco, "
"adaptador de rede) ea implementa��o real do perif�rico. <emphasis> interface "
"de driver de dispositivo (DDI) </emphasis> � a interface definida entre o "
"kernel e o componente do driver de dispositivo. "

#. (itstool) path: sect2/title
#: book.translate.xml:22499
#, fuzzy
msgid "Types of Device Drivers"
msgstr "Tipos de drivers de dispositivos"

#. (itstool) path: sect2/para
#: book.translate.xml:22501
#, fuzzy
msgid ""
"There used to be days in <trademark class=\"registered\">UNIX</trademark>, "
"and thus FreeBSD, in which there were four types of devices defined:"
msgstr ""
"Costumava haver dias em <trademark class=\"registered\"> UNIX </trademark> "
"e, portanto, FreeBSD, em que havia quatro tipos de dispositivos definidos: "

#. (itstool) path: listitem/para
#: book.translate.xml:22505
#, fuzzy
msgid "block device drivers"
msgstr "bloquear drivers de dispositivo"

#. (itstool) path: listitem/para
#: book.translate.xml:22506
#, fuzzy
msgid "character device drivers"
msgstr "drivers de dispositivo de caractere"

#. (itstool) path: listitem/para
#: book.translate.xml:22507
#, fuzzy
msgid "network device drivers"
msgstr "drivers de dispositivo de rede"

#. (itstool) path: listitem/para
#: book.translate.xml:22508
#, fuzzy
msgid "pseudo-device drivers"
msgstr "drivers de pseudo-dispositivo"

#. (itstool) path: sect2/para
#: book.translate.xml:22513
#, fuzzy
msgid ""
"<emphasis>Block devices</emphasis> performed in a way that used fixed size "
"blocks [of data]. This type of driver depended on the so-called "
"<emphasis>buffer cache</emphasis>, which had cached accessed blocks of data "
"in a dedicated part of memory. Often this buffer cache was based on write-"
"behind, which meant that when data was modified in memory it got synced to "
"disk whenever the system did its periodical disk flushing, thus optimizing "
"writes."
msgstr ""
" <emphasis> Dispositivos de bloco </emphasis> realizada de maneira que "
"usasse blocos de tamanho fixo [de dados]. Este tipo de driver dependia do "
"chamado <emphasis> cache de buffer </emphasis> , que armazenou em cache "
"blocos de dados acessados ​​em uma parte dedicada da mem�ria. Muitas vezes, "
"esse cache de buffer era baseado em write-behind, o que significava que "
"quando os dados eram modificados na mem�ria, ele era sincronizado com o "
"disco sempre que o sistema fazia a limpeza peri�dica do disco, otimizando as "
"grava��es. "

#. (itstool) path: sect2/para
#: book.translate.xml:22528
#, fuzzy
msgid ""
"However, in the versions of FreeBSD 4.0 and onward the distinction between "
"block and character devices became non-existent."
msgstr ""
"No entanto, nas vers�es do FreeBSD 4.0 e em diante a distin��o entre os "
"dispositivos de bloco e de caractere tornou-se inexistente."

#. (itstool) path: sect1/title
#: book.translate.xml:22539
#, fuzzy
msgid "Overview of Newbus"
msgstr "Vis�o geral do Newbus"

#. (itstool) path: sect1/para
#: book.translate.xml:22543
#, fuzzy
msgid ""
"<emphasis>Newbus</emphasis> is the implementation of a new bus architecture "
"based on abstraction layers which saw its introduction in FreeBSD 3.0 when "
"the Alpha port was imported into the source tree. It was not until 4.0 "
"before it became the default system to use for device drivers. Its goals are "
"to provide a more object-oriented means of interconnecting the various "
"busses and devices which a host system provides to the <emphasis>Operating "
"System</emphasis>."
msgstr ""
" <emphasis> Newbus </emphasis> � a implementa��o de uma nova arquitetura de "
"barramento baseada em camadas de abstra��o que viu sua introdu��o no FreeBSD "
"3.0 quando a porta Alpha foi importada para a �rvore de fontes. N�o era at� "
"4.0 antes de se tornar o sistema padr�o para usar drivers de dispositivo. "
"Seus objetivos s�o fornecer meios mais orientados a objeto de interconectar "
"os v�rios barramentos e dispositivos que um sistema host fornece ao "
"<emphasis> Sistema operacional </emphasis> "

#. (itstool) path: sect1/para
#: book.translate.xml:22552
#, fuzzy
msgid "Its main features include amongst others:"
msgstr "Suas principais caracter�sticas incluem entre outras:"

#. (itstool) path: listitem/para
#: book.translate.xml:22555
#, fuzzy
msgid "dynamic attaching"
msgstr "anexa��o din�mica"

#. (itstool) path: listitem/para
#: book.translate.xml:22556
#, fuzzy
msgid "easy modularization of drivers"
msgstr "modulariza��o f�cil de drivers"

#. (itstool) path: listitem/para
#: book.translate.xml:22557
#, fuzzy
msgid "pseudo-busses"
msgstr "pseudo-�nibus"

#. (itstool) path: sect1/para
#: book.translate.xml:22560
#, fuzzy
msgid ""
"One of the most prominent changes is the migration from the flat and ad-hoc "
"system to a device tree layout."
msgstr ""
"Uma das mudan�as mais proeminentes � a migra��o do sistema plano e ad-hoc "
"para o layout de uma �rvore de dispositivos."

#. (itstool) path: sect1/para
#: book.translate.xml:22563
#, fuzzy
msgid ""
"At the top level resides the <emphasis><quote>root</quote></emphasis> device "
"which is the parent to hang all other devices on. For each architecture, "
"there is typically a single child of <quote>root</quote> which has such "
"things as <emphasis>host-to-PCI bridges</emphasis>, etc. attached to it. For "
"x86, this <quote>root</quote> device is the <emphasis><quote>nexus</quote></"
"emphasis> device. For Alpha, various different models of Alpha have "
"different top-level devices corresponding to the different hardware "
"chipsets, including <emphasis>lca</emphasis>, <emphasis>apecs</emphasis>, "
"<emphasis>cia</emphasis> and <emphasis>tsunami</emphasis>."
msgstr ""
"No n�vel superior reside o <emphasis><quote> raiz </quote></emphasis> "
"dispositivo que � o pai para pendurar todos os outros dispositivos. Para "
"cada arquitetura, normalmente h� um �nico filho de <quote> raiz </quote> que "
"tem coisas como <emphasis> pontes host-para-PCI </emphasis> , etc. anexado a "
"ele. Para x86, isso <quote> raiz </quote> dispositivo � o <emphasis><quote> "
"nexo </quote></emphasis> dispositivo. Para Alpha, v�rios modelos diferentes "
"de Alpha t�m diferentes dispositivos de n�vel superior correspondentes aos "
"diferentes chipsets de hardware, incluindo <emphasis> lca </emphasis> , "
"<emphasis> apecs </emphasis> , <emphasis> cia </emphasis> e <emphasis> "
"tsunami </emphasis> "

#. (itstool) path: sect1/para
#: book.translate.xml:22576
#, fuzzy
msgid ""
"A device in the Newbus context represents a single hardware entity in the "
"system. For instance each PCI device is represented by a Newbus device. Any "
"device in the system can have children; a device which has children is often "
"called a <emphasis><quote>bus</quote></emphasis>. Examples of common busses "
"in the system are ISA and PCI, which manage lists of devices attached to ISA "
"and PCI busses respectively."
msgstr ""
"Um dispositivo no contexto Newbus representa uma �nica entidade de hardware "
"no sistema. Por exemplo, cada dispositivo PCI � representado por um "
"dispositivo Newbus. Qualquer dispositivo no sistema pode ter filhos; um "
"dispositivo que tem filhos � muitas vezes chamado de <emphasis><quote> "
"�nibus </quote></emphasis> . Exemplos de barramentos comuns no sistema s�o "
"ISA e PCI, que gerenciam listas de dispositivos conectados aos barramentos "
"ISA e PCI, respectivamente. "

#. (itstool) path: sect1/para
#: book.translate.xml:22584
#, fuzzy
msgid ""
"Often, a connection between different kinds of bus is represented by a "
"<emphasis><quote>bridge</quote></emphasis> device, which normally has one "
"child for the attached bus. An example of this is a <emphasis>PCI-to-PCI "
"bridge</emphasis> which is represented by a device "
"<emphasis><filename>pcibN</filename></emphasis> on the parent PCI bus and "
"has a child <emphasis><filename>pciN</filename></emphasis> for the attached "
"bus. This layout simplifies the implementation of the PCI bus tree, allowing "
"common code to be used for both top-level and bridged busses."
msgstr ""
"Muitas vezes, uma conex�o entre diferentes tipos de �nibus � representada "
"por um <emphasis><quote> ponte </quote></emphasis> dispositivo, que "
"normalmente tem um filho para o barramento conectado. Um exemplo disso � um "
"<emphasis> Ponte PCI-para-PCI </emphasis> que � representado por um "
"dispositivo <emphasis><filename> pcibN </filename></emphasis> no barramento "
"PCI pai e tem um filho <emphasis><filename> pciN </filename></emphasis> para "
"o barramento anexado. Esse layout simplifica a implementa��o da �rvore de "
"barramento PCI, permitindo que c�digo comum seja usado para barramentos de "
"n�vel superior e em ponte. "

#. (itstool) path: sect1/para
#: book.translate.xml:22596
#, fuzzy
msgid ""
"Each device in the Newbus architecture asks its parent to map its resources. "
"The parent then asks its own parent until the nexus is reached. So, "
"basically the nexus is the only part of the Newbus system which knows about "
"all resources."
msgstr ""
"Cada dispositivo na arquitetura Newbus pede ao seu pai para mapear seus "
"recursos. O pai ent�o pergunta ao seu pr�prio pai at� que o nexo seja "
"alcan�ado. Ent�o, basicamente, o nexo � a �nica parte do sistema Newbus que "
"conhece todos os recursos."

#. (itstool) path: tip/para
#: book.translate.xml:22601
#, fuzzy
msgid ""
"An ISA device might want to map its IO port at <literal>0x230</literal>, so "
"it asks its parent, in this case the ISA bus. The ISA bus hands it over to "
"the PCI-to-ISA bridge which in its turn asks the PCI bus, which reaches the "
"host-to-PCI bridge and finally the nexus. The beauty of this transition "
"upwards is that there is room to translate the requests. For example, the "
"<literal>0x230</literal> IO port request might become memory-mapped at "
"<literal>0xb0000230</literal> on a <acronym>MIPS</acronym> box by the PCI "
"bridge."
msgstr ""
"Um dispositivo ISA pode querer mapear sua porta IO em <literal> 0x230 </"
"literal> , ent�o ele pergunta a seus pais, neste caso, o barramento ISA. O "
"barramento ISA passa para a ponte PCI-para-ISA, que, por sua vez, solicita o "
"barramento PCI, que alcan�a a ponte host-para-PCI e, finalmente, o nexus. A "
"beleza dessa transi��o para cima � que h� espa�o para traduzir os pedidos. "
"Por exemplo, o <literal> 0x230 </literal> A solicita��o de porta IO pode se "
"tornar mapeada na mem�ria em <literal> 0xb0000230 </literal> em uma caixa "
"<acronym>MIPS</acronym> pela ponte PCI \""

#. (itstool) path: sect1/para
#: book.translate.xml:22612
#, fuzzy
msgid ""
"Resource allocation can be controlled at any place in the device tree. For "
"instance on many Alpha platforms, ISA interrupts are managed separately from "
"PCI interrupts and resource allocations for ISA interrupts are managed by "
"the Alpha's ISA bus device. On IA-32, ISA and PCI interrupts are both "
"managed by the top-level nexus device. For both ports, memory and port "
"address space is managed by a single entity - nexus for IA-32 and the "
"relevant chipset driver on Alpha (e.g., CIA or tsunami)."
msgstr ""
"A aloca��o de recursos pode ser controlada em qualquer lugar na �rvore de "
"dispositivos. Por exemplo, em muitas plataformas Alpha, as interrup��es do "
"ISA s�o gerenciadas separadamente das interrup��es PCI e as aloca��es de "
"recursos para as interrup��es do ISA s�o gerenciadas pelo dispositivo de "
"barramento ISA do Alpha. e interrup��es PCI s�o gerenciadas pelo dispositivo "
"nexus de n�vel superior.Para as duas portas, mem�ria e espa�o de endere�o de "
"porta s�o gerenciados por uma �nica entidade - nexo para IA-32 e o driver do "
"chipset relevante em Alpha (por exemplo, CIA ou tsunami). "

#. (itstool) path: sect1/para
#: book.translate.xml:22622
#, fuzzy
msgid ""
"In order to normalize access to memory and port mapped resources, Newbus "
"integrates the <literal>bus_space</literal> APIs from NetBSD. These provide "
"a single API to replace inb/outb and direct memory reads/writes. The "
"advantage of this is that a single driver can easily use either memory-"
"mapped registers or port-mapped registers (some hardware supports both)."
msgstr ""
"Para normalizar o acesso � mem�ria e aos recursos mapeados pela porta, o "
"Newbus integra <literal> bus_space </literal> APIs do NetBSD. Eles fornecem "
"uma �nica API para substituir leituras / grava��es de mem�ria inb / outb e "
"direta. A vantagem disso � que um �nico driver pode facilmente usar "
"registradores mapeados na mem�ria ou registradores mapeados pela porta "
"(alguns suportam hardware ambos). "

#. (itstool) path: sect1/para
#: book.translate.xml:22629
#, fuzzy
msgid ""
"This support is integrated into the resource allocation mechanism. When a "
"resource is allocated, a driver can retrieve the associated <varname remap="
"\"structfield\">bus_space_tag_t</varname> and <varname remap=\"structfield"
"\">bus_space_handle_t</varname> from the resource."
msgstr ""
"Esse suporte � integrado ao mecanismo de aloca��o de recursos. Quando um "
"recurso � alocado, um driver pode recuperar <varname remap=\"structfield\"> "
"bus_space_tag_t </varname> e <varname remap=\"structfield\"> "
"bus_space_handle_t </varname> do recurso \""

#. (itstool) path: sect1/para
#: book.translate.xml:22634
#, fuzzy
msgid ""
"Newbus also allows for definitions of interface methods in files dedicated "
"to this purpose. These are the <filename>.m</filename> files that are found "
"under the <filename>src/sys</filename> hierarchy."
msgstr ""
"O Newbus tamb�m permite defini��es de m�todos de interface em arquivos "
"dedicados a este prop�sito. Estes s�o os <filename> .m </filename> arquivos "
"que s�o encontrados sob o <filename> src / sys </filename> hierarquia."

#. (itstool) path: sect1/para
#: book.translate.xml:22639
#, fuzzy
msgid ""
"The core of the Newbus system is an extensible <quote>object-based "
"programming</quote> model. Each device in the system has a table of methods "
"which it supports. The system and other devices uses those methods to "
"control the device and request services. The different methods supported by "
"a device are defined by a number of <quote>interfaces</quote>. An "
"<quote>interface</quote> is simply a group of related methods which can be "
"implemented by a device."
msgstr ""
"O n�cleo do sistema Newbus � um extens�vel <quote> programa��o baseada em "
"objetos </quote> modelo. Cada dispositivo no sistema possui uma tabela de "
"m�todos que ele suporta. O sistema e outros dispositivos usam esses m�todos "
"para controlar o dispositivo e solicitar servi�os. Os diferentes m�todos "
"suportados por um dispositivo s�o definidos por um n�mero de <quote> "
"interfaces </quote> . A <quote> interface </quote> � simplesmente um grupo "
"de m�todos relacionados que podem ser implementados por um dispositivo \""

#. (itstool) path: sect1/para
#: book.translate.xml:22648
#, fuzzy
msgid ""
"In the Newbus system, the methods for a device are provided by the various "
"device drivers in the system. When a device is attached to a driver during "
"<emphasis>auto-configuration</emphasis>, it uses the method table declared "
"by the driver. A device can later <emphasis>detach</emphasis> from its "
"driver and <emphasis>re-attach</emphasis> to a new driver with a new method "
"table. This allows dynamic replacement of drivers which can be useful for "
"driver development."
msgstr ""
"No sistema Newbus, os m�todos para um dispositivo s�o fornecidos pelos "
"v�rios drivers de dispositivo no sistema. Quando um dispositivo � conectado "
"a um driver durante <emphasis> configura��o autom�tica </emphasis> , ele usa "
"a tabela de m�todos declarada pelo driver. Um dispositivo pode mais tarde "
"<emphasis> desanexar </emphasis> do seu motorista e <emphasis> re-anexar </"
"emphasis> para um novo driver com uma nova tabela de m�todos. Isso permite a "
"substitui��o din�mica de drivers, o que pode ser �til para o desenvolvimento "
"de drivers. "

#. (itstool) path: sect1/para
#: book.translate.xml:22658
#, fuzzy
msgid ""
"The interfaces are described by an interface definition language similar to "
"the language used to define vnode operations for file systems. The interface "
"would be stored in a methods file (which would normally be named "
"<filename>foo_if.m</filename>)."
msgstr ""
"As interfaces s�o descritas por uma linguagem de defini��o de interface "
"semelhante � linguagem usada para definir opera��es de vnode para sistemas "
"de arquivos. A interface seria armazenada em um arquivo de m�todos (que "
"normalmente seria nomeado <filename> foo_if.m </filename> ) "

#. (itstool) path: example/title
#: book.translate.xml:22665
#, fuzzy
msgid "Newbus Methods"
msgstr "M�todos Newbus"

#. (itstool) path: example/programlisting
#: book.translate.xml:22667
#, no-wrap
msgid ""
"      # Foo subsystem/driver (a comment...)\n"
"\n"
"\t  INTERFACE foo\n"
"\n"
"\tMETHOD int doit {\n"
"\t\tdevice_t dev;\n"
"\t};\n"
"\n"
"\t# DEFAULT is the method that will be used, if a method was not\n"
"\t# provided via: DEVMETHOD()\n"
"\n"
"\tMETHOD void doit_to_child {\n"
"\t\tdevice_t dev;\n"
"\t\tdriver_t child;\n"
"\t} DEFAULT doit_generic_to_child;"
msgstr ""
"      # Foo subsystem/driver (a comment...)\n"
"\n"
"\t  INTERFACE foo\n"
"\n"
"\tMETHOD int doit {\n"
"\t\tdevice_t dev;\n"
"\t};\n"
"\n"
"\t# DEFAULT is the method that will be used, if a method was not\n"
"\t# provided via: DEVMETHOD()\n"
"\n"
"\tMETHOD void doit_to_child {\n"
"\t\tdevice_t dev;\n"
"\t\tdriver_t child;\n"
"\t} DEFAULT doit_generic_to_child;"

#. (itstool) path: sect1/para
#: book.translate.xml:22684
#, fuzzy
msgid ""
"When this interface is compiled, it generates a header file "
"<quote><filename>foo_if.h</filename></quote> which contains function "
"declarations:"
msgstr ""
"Quando esta interface � compilada, ela gera um arquivo de cabe�alho "
"<quote><filename> foo_if.h </filename></quote> que cont�m declara��es de "
"fun��o: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:22688
#, no-wrap
msgid ""
"      int FOO_DOIT(device_t dev);\n"
"      int FOO_DOIT_TO_CHILD(device_t dev, device_t child);"
msgstr ""
"      int FOO_DOIT(device_t dev);\n"
"      int FOO_DOIT_TO_CHILD(device_t dev, device_t child);"

#. (itstool) path: sect1/para
#: book.translate.xml:22691
#, fuzzy
msgid ""
"A source file, <quote><filename>foo_if.c</filename></quote> is also created "
"to accompany the automatically generated header file; it contains "
"implementations of those functions which look up the location of the "
"relevant functions in the object's method table and call that function."
msgstr ""
"Um arquivo de origem, <quote><filename> foo_if.c </filename></quote> tamb�m "
"� criado para acompanhar o arquivo de cabe�alho gerado automaticamente; "
"cont�m implementa��es dessas fun��es que procuram a localiza��o das fun��es "
"relevantes na tabela de m�todos do objeto e chamam essa fun��o. "

#. (itstool) path: sect1/para
#: book.translate.xml:22697
#, fuzzy
msgid ""
"The system defines two main interfaces. The first fundamental interface is "
"called <emphasis><quote>device</quote></emphasis> and includes methods which "
"are relevant to all devices. Methods in the <emphasis><quote>device</quote></"
"emphasis> interface include <emphasis><quote>probe</quote></emphasis>, "
"<emphasis><quote>attach</quote></emphasis> and <emphasis><quote>detach</"
"quote></emphasis> to control detection of hardware and "
"<emphasis><quote>shutdown</quote></emphasis>, <emphasis><quote>suspend</"
"quote></emphasis> and <emphasis><quote>resume</quote></emphasis> for "
"critical event notification."
msgstr ""
"O sistema define duas interfaces principais. A primeira interface "
"fundamental � chamada <emphasis><quote> dispositivo </quote></emphasis> e "
"inclui m�todos relevantes para todos os dispositivos. M�todos no "
"<emphasis><quote> dispositivo </quote></emphasis> interface incluem "
"<emphasis><quote> sonda </quote></emphasis> , <emphasis><quote> anexar </"
"quote></emphasis> e <emphasis><quote> desanexar </quote></emphasis> para "
"controlar a detec��o de hardware e <emphasis><quote> desligar </quote></"
"emphasis> , <emphasis><quote> suspender </quote></emphasis> e "
"<emphasis><quote> curr�culo </quote></emphasis> para notifica��o de eventos "
"cr�ticos. "

#. (itstool) path: footnote/para
#: book.translate.xml:22714
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>bus_generic_read_ivar</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> and "
"<citerefentry><refentrytitle>bus_generic_write_ivar</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""
" <citerefentry><refentrytitle> bus_generic_read_ivar </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> e "
"<citerefentry><refentrytitle> bus_generic_write_ivar </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> "

#. (itstool) path: sect1/para
#: book.translate.xml:22710
#, fuzzy
msgid ""
"The second, more complex interface is <emphasis><quote>bus</quote></"
"emphasis>. This interface contains methods suitable for devices which have "
"children, including methods to access bus specific per-device information <_:"
"footnote-1/>, event notification (<emphasis><literal>child_detached</"
"literal></emphasis>, <emphasis><literal>driver_added</literal></emphasis>) "
"and resource management (<emphasis><literal>alloc_resource</literal></"
"emphasis>, <emphasis><literal>activate_resource</literal></emphasis>, "
"<emphasis><literal>deactivate_resource</literal></emphasis>, "
"<emphasis><literal>release_resource</literal></emphasis>)."
msgstr ""
"A segunda interface mais complexa � <emphasis><quote> �nibus </quote></"
"emphasis> . Essa interface cont�m m�todos adequados para dispositivos que "
"t�m filhos, incluindo m�todos para acessar informa��es espec�ficas do "
"barramento por dispositivo <_: footnote-1 />, notifica��o de eventos "
"( <emphasis><literal> child_detached </literal></emphasis> , "
"<emphasis><literal> driver_added </literal></emphasis> ) e gest�o de "
"recursos ( <emphasis><literal> alloc_resource </literal></emphasis> , "
"<emphasis><literal> activate_resource </literal></emphasis> , "
"<emphasis><literal> deactivate_resource </literal></emphasis> , "
"<emphasis><literal> release_resource </literal></emphasis> ) "

#. (itstool) path: sect1/para
#: book.translate.xml:22725
#, fuzzy
msgid ""
"Many methods in the <quote>bus</quote> interface are performing services for "
"some child of the bus device. These methods would normally use the first two "
"arguments to specify the bus providing the service and the child device "
"which is requesting the service. To simplify driver code, many of these "
"methods have accessor functions which lookup the parent and call a method on "
"the parent. For instance the method <literal>BUS_TEARDOWN_INTR(device_t dev, "
"device_t child, ...)</literal> can be called using the function "
"<literal>bus_teardown_intr(device_t child, ...)</literal>."
msgstr ""
"Muitos m�todos no <quote> �nibus </quote> interface est�o executando "
"servi�os para algum filho do dispositivo de barramento. Esses m�todos "
"normalmente usariam os dois primeiros argumentos para especificar o "
"barramento que fornece o servi�o e o dispositivo filho que est� solicitando "
"o servi�o. Para simplificar o c�digo do driver, muitos desses m�todos t�m "
"fun��es de acesso que procuram o pai e chamam um m�todo no pai. Por exemplo, "
"o m�todo <literal> BUS_TEARDOWN_INTR (device_t dev, device_t filho, ...) </"
"literal> pode ser chamado usando a fun��o <literal> bus_teardown_intr (filho "
"device_t, ...) </literal> "

#. (itstool) path: sect1/para
#: book.translate.xml:22737
#, fuzzy
msgid ""
"Some bus types in the system define additional interfaces to provide access "
"to bus-specific functionality. For instance, the PCI bus driver defines the "
"<quote>pci</quote> interface which has two methods "
"<emphasis><literal>read_config</literal></emphasis> and "
"<emphasis><literal>write_config</literal></emphasis> for accessing the "
"configuration registers of a PCI device."
msgstr ""
"Alguns tipos de barramento no sistema definem interfaces adicionais para "
"fornecer acesso � funcionalidade espec�fica do barramento. Por exemplo, o "
"driver de barramento PCI define <quote> pci </quote> interface que tem dois "
"m�todos <emphasis><literal> read_config </literal></emphasis> e "
"<emphasis><literal> write_config </literal></emphasis> para acessar os "
"registros de configura��o de um dispositivo PCI. "

#. (itstool) path: sect1/title
#: book.translate.xml:22747
#, fuzzy
msgid "Newbus API"
msgstr "Newbus API"

#. (itstool) path: sect1/para
#: book.translate.xml:22749
#, fuzzy
msgid ""
"As the Newbus API is huge, this section makes some effort at documenting it. "
"More information to come in the next revision of this document."
msgstr ""
"Como a API Newbus � enorme, esta se��o faz algum esfor�o para document�-la. "
"Mais informa��es est�o na pr�xima revis�o deste documento."

#. (itstool) path: sect2/title
#: book.translate.xml:22754
#, fuzzy
msgid "Important Locations in the Source Hierarchy"
msgstr "Locais importantes na hierarquia de origem"

#. (itstool) path: sect2/para
#: book.translate.xml:22756
#, fuzzy
msgid ""
"<filename>src/sys/[arch]/[arch]</filename> - Kernel code for a specific "
"machine architecture resides in this directory. For example, the "
"<literal>i386</literal> architecture, or the <literal>SPARC64</literal> "
"architecture."
msgstr ""
" <filename> src / sys / [arco] / [arco] </filename> - O c�digo do kernel "
"para uma arquitetura de m�quina espec�fica reside neste diret�rio. Por "
"exemplo, o <literal> i386 </literal> arquitetura, ou o <literal> SPARC64 </"
"literal> arquitetura."

#. (itstool) path: sect2/para
#: book.translate.xml:22761
#, fuzzy
msgid ""
"<filename>src/sys/dev/[bus]</filename> - device support for a specific "
"<literal>[bus]</literal> resides in this directory."
msgstr ""
" <filename> src / sys / dev / [barramento] </filename> - suporte de "
"dispositivo para um espec�fico <literal> [�nibus] </literal> reside neste "
"diret�rio. "

#. (itstool) path: sect2/para
#: book.translate.xml:22765
#, fuzzy
msgid ""
"<filename>src/sys/dev/pci</filename> - PCI bus support code resides in this "
"directory."
msgstr ""
" <filename> src / sys / dev / pci </filename> - O c�digo de suporte do "
"barramento PCI reside neste diret�rio. "

#. (itstool) path: sect2/para
#: book.translate.xml:22768
#, fuzzy
msgid ""
"<filename>src/sys/[isa|pci]</filename> - PCI/ISA device drivers reside in "
"this directory. The PCI/ISA bus support code used to exist in this directory "
"in FreeBSD version <literal>4.0</literal>."
msgstr ""
" <filename> src / sys / [isa | pci] </filename> - Os drivers de dispositivos "
"PCI / ISA residem nesse diret�rio. O c�digo de suporte do barramento PCI / "
"ISA costumava existir neste diret�rio na vers�o FreeBSD <literal> 4,0 </"
"literal> "

#. (itstool) path: sect2/title
#: book.translate.xml:22775
#, fuzzy
msgid "Important Structures and Type Definitions"
msgstr "Estruturas importantes e defini��es de tipo"

#. (itstool) path: sect2/para
#: book.translate.xml:22777
#, fuzzy
msgid ""
"<literal>devclass_t</literal> - This is a type definition of a pointer to a "
"<literal>struct devclass</literal>."
msgstr ""
" <literal> devclass_t </literal> - Esta � uma defini��o de tipo de um "
"ponteiro para um <literal> struct devclass </literal> "

#. (itstool) path: sect2/para
#: book.translate.xml:22780
#, fuzzy
msgid ""
"<literal>device_method_t</literal> - This is the same as "
"<literal>kobj_method_t</literal> (see <filename>src/sys/kobj.h</filename>)."
msgstr ""
" <literal> device_method_t </literal> - Isso � o mesmo que <literal> "
"kobj_method_t </literal> (Vejo <filename> src / sys / kobj.h </filename> ) "

#. (itstool) path: sect2/para
#: book.translate.xml:22784
#, fuzzy
msgid ""
"<literal>device_t</literal> - This is a type definition of a pointer to a "
"<literal>struct device</literal>. <literal>device_t</literal> represents a "
"device in the system. It is a kernel object. See <filename>src/sys/sys/"
"bus_private.h</filename> for implementation details."
msgstr ""
" <literal> device_t </literal> - Esta � uma defini��o de tipo de um ponteiro "
"para um <literal> dispositivo struct </literal> . <literal> device_t </"
"literal> representa um dispositivo no sistema. � um objeto do kernel. Vejo "
"<filename> src / sys / sys / bus_private.h </filename> para detalhes de "
"implementa��o. "

#. (itstool) path: sect2/para
#: book.translate.xml:22791
#, fuzzy
msgid ""
"<literal>driver_t</literal> - This is a type definition which references "
"<literal>struct driver</literal>. The <literal>driver</literal> struct is a "
"class of the <literal>device</literal> kernel object; it also holds data "
"private to the driver."
msgstr ""
" <literal> driver_t </literal> - Esta � uma defini��o de tipo que referencia "
"<literal> driver struct </literal> . o <literal> motorista </literal> struct "
"� uma classe do <literal> dispositivo </literal> objeto do kernel; ele "
"tamb�m mant�m dados privados para o driver \""

#. (itstool) path: figure/title
#: book.translate.xml:22798
#, fuzzy
msgid "<emphasis>driver_t</emphasis> Implementation"
msgstr " <emphasis> driver_t </emphasis> Implementa��o"

#. (itstool) path: figure/programlisting
#: book.translate.xml:22800
#, no-wrap
msgid ""
"\t  struct driver {\n"
"\t\tKOBJ_CLASS_FIELDS;\n"
"\t\tvoid\t*priv;\t\t\t/* driver private data */\n"
"\t  };"
msgstr ""
"\t  struct driver {\n"
"\t\tKOBJ_CLASS_FIELDS;\n"
"\t\tvoid\t*priv;\t\t\t/* driver private data */\n"
"\t  };"

#. (itstool) path: sect2/para
#: book.translate.xml:22806
#, fuzzy
msgid ""
"A <literal>device_state_t</literal> type, which is an enumeration, "
"<literal>device_state</literal>. It contains the possible states of a Newbus "
"device before and after the autoconfiguration process."
msgstr ""
"UMA <literal> device_state_t </literal> tipo, que � uma enumera��o, "
"<literal> device_state </literal> . Ele cont�m os estados poss�veis de um "
"dispositivo Newbus antes e depois do processo de configura��o autom�tica. "

#. (itstool) path: figure/title
#: book.translate.xml:22812
#, fuzzy
msgid "Device States <emphasis>device_state_t</emphasis>"
msgstr "Estados do dispositivo <emphasis> device_state_t </emphasis> "

#. (itstool) path: figure/programlisting
#: book.translate.xml:22815
#, no-wrap
msgid ""
"\t  /*\n"
"\t   * src/sys/sys/bus.h\n"
"\t   */\n"
"\t  typedef enum device_state {\n"
"\t\tDS_NOTPRESENT,\t/* not probed or probe failed */\n"
"\t\tDS_ALIVE,\t\t/* probe succeeded */\n"
"\t\tDS_ATTACHED,\t/* attach method called */\n"
"\t\tDS_BUSY\t\t\t/* device is open */\n"
"\t  } device_state_t;"
msgstr ""
"\t  /*\n"
"\t   * src/sys/sys/bus.h\n"
"\t   */\n"
"\t  typedef enum device_state {\n"
"\t\tDS_NOTPRESENT,\t/* not probed or probe failed */\n"
"\t\tDS_ALIVE,\t\t/* probe succeeded */\n"
"\t\tDS_ATTACHED,\t/* attach method called */\n"
"\t\tDS_BUSY\t\t\t/* device is open */\n"
"\t  } device_state_t;"

#. (itstool) path: info/title
#: book.translate.xml:22838
#, fuzzy
msgid "Sound Subsystem"
msgstr "Subsistema de Som"

#. (itstool) path: authorgroup/author
#: book.translate.xml:22841
#, fuzzy
msgid ""
"<personname> <firstname>Jean-Francois</firstname> <surname>Dockes</surname> "
"</personname> <contrib>Contributed by </contrib>"
msgstr ""
" <personname><firstname> Jean-Fran�ois </firstname><surname> Dockes </"
"surname></personname><contrib> Contribu�ram por </contrib> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:22854
#, fuzzy
msgid "<primary>sound subsystem</primary>"
msgstr " <primary> subsistema de som </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:22856
#, fuzzy
msgid ""
"The FreeBSD sound subsystem cleanly separates generic sound handling issues "
"from device-specific ones. This makes it easier to add support for new "
"hardware."
msgstr ""
"O subsistema de som do FreeBSD separa de forma limpa os problemas gen�ricos "
"de manipula��o de som dos espec�ficos do dispositivo. Isso facilita a adi��o "
"de suporte para novo hardware."

#. (itstool) path: sect1/para
#: book.translate.xml:22860
#, fuzzy
msgid ""
"The <citerefentry><refentrytitle>pcm</refentrytitle><manvolnum>4</"
"manvolnum></citerefentry> framework is the central piece of the sound "
"subsystem. It mainly implements the following elements:"
msgstr ""
"O <citerefentry><refentrytitle> pcm </refentrytitle><manvolnum> 4 </"
"manvolnum></citerefentry> framework � a pe�a central do subsistema de som. "
"Ele implementa principalmente os seguintes elementos: "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:22863
#, fuzzy
msgid "<primary>system call interface</primary>"
msgstr " <primary> interface de chamada do sistema </primary> "

#. (itstool) path: listitem/para
#: book.translate.xml:22867
#, fuzzy
msgid ""
"A system call interface (read, write, ioctls) to digitized sound and mixer "
"functions. The ioctl command set is compatible with the legacy "
"<emphasis>OSS</emphasis> or <emphasis>Voxware</emphasis> interface, allowing "
"common multimedia applications to be ported without modification."
msgstr ""
"Uma interface de chamada do sistema (leitura, grava��o, ioctls) para fun��es "
"de som e mixer digitalizadas. O conjunto de comandos ioctl � compat�vel com "
"o legado <emphasis> OSS </emphasis> ou <emphasis> Voxware </emphasis> "
"interface, permitindo que aplica��es multim�dia comuns sejam portadas sem "
"modifica��o. "

#. (itstool) path: listitem/para
#: book.translate.xml:22876
#, fuzzy
msgid ""
"Common code for processing sound data (format conversions, virtual channels)."
msgstr ""
"C�digo comum para processamento de dados sonoros (convers�es de formato, "
"canais virtuais)."

#. (itstool) path: listitem/para
#: book.translate.xml:22881
#, fuzzy
msgid ""
"A uniform software interface to hardware-specific audio interface modules."
msgstr ""
"Uma interface de software uniforme para m�dulos de interface de �udio "
"espec�ficos de hardware."

#. (itstool) path: listitem/para
#: book.translate.xml:22886
#, fuzzy
msgid ""
"Additional support for some common hardware interfaces (ac97), or shared "
"hardware-specific code (ex: ISA DMA routines)."
msgstr ""
"Suporte adicional para algumas interfaces comuns de hardware (ac97), ou "
"c�digo espec�fico de hardware compartilhado (ex: rotinas ISA DMA)."

#. (itstool) path: sect1/para
#: book.translate.xml:22892
#, fuzzy
msgid ""
"The support for specific sound cards is implemented by hardware-specific "
"drivers, which provide channel and mixer interfaces to plug into the generic "
"<filename>pcm</filename> code."
msgstr ""
"O suporte para placas de som espec�ficas � implementado por drivers "
"espec�ficos de hardware, que fornecem interfaces de canal e mixer para serem "
"plugados no gen�rico. <filename> pcm </filename> c�digo."

#. (itstool) path: sect1/para
#: book.translate.xml:22897
#, fuzzy
msgid ""
"In this chapter, the term <filename>pcm</filename> will refer to the "
"central, common part of the sound driver, as opposed to the hardware-"
"specific modules."
msgstr ""
"Neste cap�tulo, o termo <filename> pcm </filename> referir-se-� � parte "
"central e comum do driver de som, ao contr�rio dos m�dulos espec�ficos de "
"hardware. "

#. (itstool) path: sect1/para
#: book.translate.xml:22901
#, fuzzy
msgid ""
"The prospective driver writer will of course want to start from an existing "
"module and use the code as the ultimate reference. But, while the sound code "
"is nice and clean, it is also mostly devoid of comments. This document tries "
"to give an overview of the framework interface and answer some questions "
"that may arise while adapting the existing code."
msgstr ""
"Naturalmente, o candidato a driver dever� iniciar a partir de um m�dulo "
"existente e usar o c�digo como a refer�ncia final. Mas, embora o c�digo de "
"som seja bom e limpo, ele tamb�m � desprovido de coment�rios. Este documento "
"tenta fornecer uma vis�o geral. da interface do framework e responder a "
"algumas perguntas que possam surgir durante a adapta��o do c�digo existente. "

#. (itstool) path: sect1/para
#: book.translate.xml:22908
#, fuzzy
msgid ""
"As an alternative, or in addition to starting from a working example, you "
"can find a commented driver template at <link xlink:href=\"https://people."
"FreeBSD.org/~cg/template.c\"> https://people.FreeBSD.org/~cg/template.c</"
"link>"
msgstr ""
"Como alternativa, ou al�m de partir de um exemplo de trabalho, voc� pode "
"encontrar um modelo de driver <link xlink:href=\"https://people.FreeBSD.org/"
"~cg/template.c\"> https://people.FreeBSD.org/~cg/template.c </link> "

#. (itstool) path: sect1/title
#: book.translate.xml:22915
#, fuzzy
msgid "Files"
msgstr "Arquivos"

#. (itstool) path: sect1/para
#: book.translate.xml:22917
#, fuzzy
msgid ""
"All the relevant code lives in <filename>/usr/src/sys/dev/sound/</filename>, "
"except for the public ioctl interface definitions, found in <filename>/usr/"
"src/sys/sys/soundcard.h</filename>"
msgstr ""
"Todo o c�digo relevante vive em <filename> / usr / src / sys / dev / sound / "
"</filename> , exceto para as defini��es de interface p�blica do ioctl, "
"encontradas em <filename> /usr/src/sys/sys/soundcard.h </filename> "

#. (itstool) path: sect1/para
#: book.translate.xml:22922
#, fuzzy
msgid ""
"Under <filename>/usr/src/sys/dev/sound/</filename>, the <filename>pcm/</"
"filename> directory holds the central code, while the <filename>pci/</"
"filename>, <filename>isa/</filename> and <filename>usb/</filename> "
"directories have the drivers for PCI and ISA boards, and for USB audio "
"devices."
msgstr ""
"Sob <filename> / usr / src / sys / dev / sound / </filename> , a <filename> "
"pcm / </filename> diret�rio mant�m o c�digo central, enquanto o <filename> "
"pci / </filename> , <filename> � um/ </filename> e <filename> USB/ </"
"filename> diret�rios t�m os drivers para placas PCI e ISA, e para "
"dispositivos de �udio USB \""

#. (itstool) path: sect1/title
#: book.translate.xml:22930
#, fuzzy
msgid "Probing, Attaching, etc."
msgstr "Sondando, Anexando, etc."

#. (itstool) path: sect1/para
#: book.translate.xml:22932
#, fuzzy
msgid ""
"Sound drivers probe and attach in almost the same way as any hardware driver "
"module. You might want to look at the <link linkend=\"isa-driver\">ISA</"
"link> or <link linkend=\"pci\">PCI</link> specific sections of the handbook "
"for more information."
msgstr ""
"Drivers de som sondam e conectam quase da mesma maneira que qualquer m�dulo "
"de driver de hardware. Voc� pode querer <link linkend=\"isa-driver\"> � UM </"
"link> ou <link linkend=\"pci\"> PCI </link> se��es espec�ficas do manual "
"para mais informa��es. "

#. (itstool) path: sect1/para
#: book.translate.xml:22936
#, fuzzy
msgid "However, sound drivers differ in some ways:"
msgstr "No entanto, os drivers de som diferem em alguns aspectos:"

#. (itstool) path: listitem/para
#: book.translate.xml:22940
#, fuzzy
msgid ""
"They declare themselves as <filename>pcm</filename> class devices, with a "
"<varname remap=\"structname\">struct snddev_info</varname> device private "
"structure:"
msgstr ""
"Eles se declaram como <filename> pcm </filename> dispositivos de classe, com "
"um <varname remap=\"structname\"> struct snddev_info </varname> estrutura "
"privada do dispositivo: "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:22944
#, no-wrap
msgid ""
"          static driver_t xxx_driver = {\n"
"              \"pcm\",\n"
"              xxx_methods,\n"
"              sizeof(struct snddev_info)\n"
"          };\n"
"\n"
"          DRIVER_MODULE(snd_xxxpci, pci, xxx_driver, pcm_devclass, 0, 0);\n"
"          MODULE_DEPEND(snd_xxxpci, snd_pcm, PCM_MINVER, PCM_PREFVER,PCM_MAXVER);"
msgstr ""
"          static driver_t xxx_driver = {\n"
"              \"pcm\",\n"
"              xxx_methods,\n"
"              sizeof(struct snddev_info)\n"
"          };\n"
"\n"
"          DRIVER_MODULE(snd_xxxpci, pci, xxx_driver, pcm_devclass, 0, 0);\n"
"          MODULE_DEPEND(snd_xxxpci, snd_pcm, PCM_MINVER, PCM_PREFVER,PCM_MAXVER);"

#. (itstool) path: para/indexterm
#: book.translate.xml:22954
#, fuzzy
msgid "<primary>device drivers</primary> <secondary>sound</secondary>"
msgstr ""
" <primary> drivers de dispositivo </primary><secondary> som </secondary> "

#. (itstool) path: listitem/para
#: book.translate.xml:22953
#, fuzzy
msgid ""
"Most sound drivers <_:indexterm-1/> need to store additional private "
"information about their device. A private data structure is usually "
"allocated in the attach routine. Its address is passed to <filename>pcm</"
"filename> by the calls to <function>pcm_register()</function> and "
"<function>mixer_init()</function>. <filename>pcm</filename> later passes "
"back this address as a parameter in calls to the sound driver interfaces."
msgstr ""
"A maioria dos drivers de som <_: indexterm-1 /> precisa armazenar "
"informa��es particulares adicionais sobre o dispositivo. Geralmente, uma "
"estrutura de dados privada � alocada na rotina de anexa��o. Seu endere�o � "
"passado para <filename> pcm </filename> pelas chamadas para <function> "
"pcm_register () </function> e <function> mixer_init () </function> . "
"<filename> pcm </filename> mais tarde passa de volta este endere�o como um "
"par�metro em chamadas para as interfaces do driver de som. "

#. (itstool) path: listitem/para
#: book.translate.xml:22970
#, fuzzy
msgid ""
"The sound driver attach routine should declare its MIXER or AC97 interface "
"to <filename>pcm</filename> by calling <function>mixer_init()</function>. "
"For a MIXER interface, this causes in turn a call to <link linkend="
"\"xxxmixer-init\"><function>xxxmixer_init()</function></link>."
msgstr ""
"A rotina de anexa��o do driver de som deve declarar sua interface MIXER ou "
"AC97 <filename> pcm </filename> chamando <function> mixer_init () </"
"function> . Para uma interface MIXER, isso faz com que uma chamada para "
"<link linkend=\"xxxmixer-init\"><function> xxxmixer_init () </function></"
"link> "

#. (itstool) path: listitem/para
#: book.translate.xml:22977
#, fuzzy
msgid ""
"The sound driver attach routine declares its general CHANNEL configuration "
"to <filename>pcm</filename> by calling <function>pcm_register(dev, sc, "
"nplay, nrec)</function>, where <varname>sc</varname> is the address for the "
"device data structure, used in further calls from <filename>pcm</filename>, "
"and <varname>nplay</varname> and <varname>nrec</varname> are the number of "
"play and record channels."
msgstr ""
"A rotina de anexa��o do driver de som declara sua configura��o geral de "
"CHANNEL <filename> pcm </filename> chamando <function> pcm_register (dev, "
"sc, nplay, nrec) </function> , Onde <varname> sc </varname> � o endere�o da "
"estrutura de dados do dispositivo, usado em outras chamadas <filename> pcm </"
"filename> e <varname> nplay </varname> e <varname> nrec </varname> s�o o "
"n�mero de canais de reprodu��o e grava��o. "

#. (itstool) path: listitem/para
#: book.translate.xml:22988
#, fuzzy
msgid ""
"The sound driver attach routine declares each of its channel objects by "
"calls to <function>pcm_addchan()</function>. This sets up the channel glue "
"in <filename>pcm</filename> and causes in turn a call to <link linkend="
"\"xxxchannel-init\"> <function>xxxchannel_init()</function></link>."
msgstr ""
"A rotina de anexa��o do driver de som declara cada um dos seus objetos de "
"canal <function> pcm_addchan () </function> . Isso configura a cola do canal "
"<filename> pcm </filename> e provoca por sua vez uma chamada para <link "
"linkend=\"xxxchannel-init\"><function> xxxchannel_init () </function></link> "

#. (itstool) path: listitem/para
#: book.translate.xml:22998
#, fuzzy
msgid ""
"The sound driver detach routine should call <function>pcm_unregister()</"
"function> before releasing its resources."
msgstr ""
"A rotina de desconex�o do driver de som deve chamar <function> "
"pcm_unregister () </function> antes de liberar seus recursos \""

#. (itstool) path: sect1/para
#: book.translate.xml:23004
#, fuzzy
msgid "There are two possible methods to handle non-PnP devices:"
msgstr "Existem dois m�todos poss�veis para lidar com dispositivos n�o-PnP:"

#. (itstool) path: listitem/para
#: book.translate.xml:23009
#, fuzzy
msgid ""
"Use a <function>device_identify()</function> method (example: "
"<filename>sound/isa/es1888.c</filename>). The <function>device_identify()</"
"function> method probes for the hardware at known addresses and, if it finds "
"a supported device, creates a new pcm device which is then passed to probe/"
"attach."
msgstr ""
"Use um <function> device_identify () </function> m�todo (exemplo: <filename> "
"som / isa / es1888.c </filename> ). o <function> device_identify () </"
"function> m�todo investiga o hardware em endere�os conhecidos e, se "
"encontrar um dispositivo suportado, cria um novo dispositivo pcm que � ent�o "
"passado para o probe / attach. "

#. (itstool) path: listitem/para
#: book.translate.xml:23018
#, fuzzy
msgid ""
"Use a custom kernel configuration with appropriate hints for pcm devices "
"(example: <filename>sound/isa/mss.c</filename>)."
msgstr ""
"Use uma configura��o de kernel personalizada com dicas apropriadas para "
"dispositivos pcm (exemplo: <filename> som / isa / mss.c </filename> ) "

#. (itstool) path: sect1/para
#: book.translate.xml:23024
#, fuzzy
msgid ""
"<filename>pcm</filename> drivers should implement <function>device_suspend</"
"function>, <function>device_resume</function> and <function>device_shutdown</"
"function> routines, so that power management and module unloading function "
"correctly."
msgstr ""
" <filename> pcm </filename> motoristas devem implementar <function> "
"device_suspend </function> , <function> device_resume </function> e "
"<function> device_shutdown </function> rotinas, para que o gerenciamento de "
"energia e o descarregamento do m�dulo funcionem corretamente. "

#. (itstool) path: sect1/title
#: book.translate.xml:23032
#, fuzzy
msgid "Interfaces"
msgstr "Interfaces"

#. (itstool) path: sect1/para
#: book.translate.xml:23034
#, fuzzy
msgid ""
"The interface between the <filename>pcm</filename> core and the sound "
"drivers is defined in terms of <link linkend=\"kernel-objects\">kernel "
"objects</link>."
msgstr ""
"A interface entre o <filename> pcm </filename> n�cleo e os drivers de som � "
"definido em termos de <link linkend=\"kernel-objects\"> objetos do kernel </"
"link> "

#. (itstool) path: sect1/para
#: book.translate.xml:23037
#, fuzzy
msgid ""
"There are two main interfaces that a sound driver will usually provide: "
"<emphasis>CHANNEL</emphasis> and either <emphasis>MIXER</emphasis> or "
"<emphasis>AC97</emphasis>."
msgstr ""
"Existem duas interfaces principais que um driver de som geralmente fornece: "
"<emphasis> CANAL </emphasis> e tamb�m <emphasis> MISTURADOR </emphasis> ou "
"<emphasis> AC97 </emphasis> "

#. (itstool) path: sect1/para
#: book.translate.xml:23041
#, fuzzy
msgid ""
"The <emphasis>AC97</emphasis> interface is a very small hardware access "
"(register read/write) interface, implemented by drivers for hardware with an "
"AC97 codec. In this case, the actual MIXER interface is provided by the "
"shared AC97 code in <filename>pcm</filename>."
msgstr ""
"O <emphasis> AC97 </emphasis> interface � uma interface muito pequena de "
"acesso ao hardware (registra leitura / grava��o), implementada por drivers "
"para hardware com um codec AC97. Nesse caso, a interface MIXER real � "
"fornecida pelo c�digo AC97 compartilhado <filename> pcm </filename> "

#. (itstool) path: sect2/title
#: book.translate.xml:23048
#, fuzzy
msgid "The CHANNEL Interface"
msgstr "A interface do canal"

#. (itstool) path: sect3/title
#: book.translate.xml:23051
#, fuzzy
msgid "Common Notes for Function Parameters"
msgstr "Notas comuns para par�metros de fun��o"

#. (itstool) path: sect3/para
#: book.translate.xml:23053
#, fuzzy
msgid ""
"Sound drivers usually have a private data structure to describe their "
"device, and one structure for each play and record data channel that it "
"supports."
msgstr ""
"Os drivers de som geralmente t�m uma estrutura de dados privada para "
"descrever seu dispositivo e uma estrutura para cada canal de dados de "
"reprodu��o e grava��o que ele suporta."

#. (itstool) path: sect3/para
#: book.translate.xml:23057
#, fuzzy
msgid ""
"For all CHANNEL interface functions, the first parameter is an opaque "
"pointer."
msgstr ""
"Para todas as fun��es da interface CHANNEL, o primeiro par�metro � um "
"ponteiro opaco."

#. (itstool) path: sect3/para
#: book.translate.xml:23060
#, fuzzy
msgid ""
"The second parameter is a pointer to the private channel data structure, "
"except for <function>channel_init()</function> which has a pointer to the "
"private device structure (and returns the channel pointer for further use by "
"<filename>pcm</filename>)."
msgstr ""
"O segundo par�metro � um ponteiro para a estrutura de dados do canal "
"privado, exceto <function> channel_init () </function> que tem um ponteiro "
"para a estrutura do dispositivo privado (e retorna o ponteiro do canal para "
"uso posterior por <filename> pcm </filename> ) "

#. (itstool) path: sect3/title
#: book.translate.xml:23069
#, fuzzy
msgid "Overview of Data Transfer Operations"
msgstr "Vis�o geral das opera��es de transfer�ncia de dados"

#. (itstool) path: sect3/para
#: book.translate.xml:23071
#, fuzzy
msgid ""
"For sound data transfers, the <filename>pcm</filename> core and the sound "
"drivers communicate through a shared memory area, described by a <varname "
"remap=\"structname\">struct snd_dbuf</varname>."
msgstr ""
"Para transfer�ncias de dados de som, o <filename> pcm </filename> n�cleo e "
"os drivers de som se comunicam atrav�s de uma �rea de mem�ria compartilhada, "
"<varname remap=\"structname\"> struct snd_dbuf </varname> "

#. (itstool) path: sect3/para
#: book.translate.xml:23077
#, fuzzy
msgid ""
"<varname remap=\"structname\">struct snd_dbuf</varname> is private to "
"<filename>pcm</filename>, and sound drivers obtain values of interest by "
"calls to accessor functions (<function>sndbuf_getxxx()</function>)."
msgstr ""
" <varname remap=\"structname\"> struct snd_dbuf </varname> � privado para "
"<filename> pcm </filename> , e os drivers de som obt�m valores de interesse "
"por chamadas para fun��es acessadoras ( <function> sndbuf_getxxx () </"
"function> ) "

#. (itstool) path: sect3/para
#: book.translate.xml:23082
#, fuzzy
msgid ""
"The shared memory area has a size of <function>sndbuf_getsize()</function> "
"and is divided into fixed size blocks of <function>sndbuf_getblksz()</"
"function> bytes."
msgstr ""
"A �rea de mem�ria compartilhada tem um tamanho de <function> sndbuf_getsize "
"() </function> e � dividido em blocos de tamanho fixo <function> "
"sndbuf_getblksz () </function> bytes. "

#. (itstool) path: sect3/para
#: book.translate.xml:23087
#, fuzzy
msgid ""
"When playing, the general transfer mechanism is as follows (reverse the idea "
"for recording):"
msgstr ""
"Ao jogar, o mecanismo geral de transfer�ncia � o seguinte (inverter a ideia "
"de grava��o):"

#. (itstool) path: listitem/para
#: book.translate.xml:23092
#, fuzzy
msgid ""
"<filename>pcm</filename> initially fills up the buffer, then calls the sound "
"driver's <link linkend=\"channel-trigger\"> <function>xxxchannel_trigger()</"
"function></link> function with a parameter of PCMTRIG_START."
msgstr ""
" <filename> pcm </filename> inicialmente preenche o buffer, em seguida, "
"chama o driver do som <link linkend=\"channel-trigger\"><function> "
"xxxchannel_trigger () </function></link> fun��o com um par�metro de "
"PCMTRIG_START. "

#. (itstool) path: listitem/para
#: book.translate.xml:23099
#, fuzzy
msgid ""
"The sound driver then arranges to repeatedly transfer the whole memory area "
"(<function>sndbuf_getbuf()</function>, <function>sndbuf_getsize()</"
"function>) to the device, in blocks of <function>sndbuf_getblksz()</"
"function> bytes. It calls back the <function>chn_intr()</function> "
"<filename>pcm</filename> function for each transferred block (this will "
"typically happen at interrupt time)."
msgstr ""
"O driver de som ent�o organiza repetidamente a transfer�ncia de toda a �rea "
"de mem�ria ( <function> sndbuf_getbuf () </function> , <function> "
"sndbuf_getsize () </function> ) ao dispositivo, em blocos de <function> "
"sndbuf_getblksz () </function> bytes. Ele chama de volta o <function> "
"chn_intr () </function><filename> pcm </filename> fun��o para cada bloco "
"transferido (isso normalmente acontece no momento da interrup��o). "

#. (itstool) path: listitem/para
#: book.translate.xml:23111
#, fuzzy
msgid ""
"<function>chn_intr()</function> arranges to copy new data to the area that "
"was transferred to the device (now free), and make appropriate updates to "
"the <varname remap=\"structname\">snd_dbuf</varname> structure."
msgstr ""
" <function> chn_intr () </function> organiza a c�pia de novos dados para a "
"�rea que foi transferida para o dispositivo (agora livre) e faz as "
"atualiza��es apropriadas <varname remap=\"structname\"> snd_dbuf </varname> "
"estrutura."

#. (itstool) path: sect3/title
#: book.translate.xml:23120
#, fuzzy
msgid "channel_init"
msgstr "channel_init"

#. (itstool) path: sect3/para
#: book.translate.xml:23122
#, fuzzy
msgid ""
"<function>xxxchannel_init()</function> is called to initialize each of the "
"play or record channels. The calls are initiated from the sound driver "
"attach routine. (See the <link linkend=\"pcm-probe-and-attach\">probe and "
"attach section</link>)."
msgstr ""
" <function> xxxchannel_init () </function> � chamado para inicializar cada "
"um dos canais de reprodu��o ou grava��o. As chamadas s�o iniciadas a partir "
"da rotina de anexa��o do driver de som. (Veja o <link linkend=\"pcm-probe-"
"and-attach\"> sonda e anexar se��o </link> ) "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23128
#, no-wrap
msgid ""
"          static void *\n"
"          xxxchannel_init(kobj_t obj, void *data,\n"
"             struct snd_dbuf *b, struct pcm_channel *c, int dir)<co xml:id=\"co-chinit-params\"/>\n"
"          {\n"
"              struct xxx_info *sc = data;\n"
"              struct xxx_chinfo *ch;\n"
"               ...\n"
"              return ch;<co xml:id=\"co-chinit-return\"/>\n"
"           }"
msgstr ""
"          static void *\n"
"          xxxchannel_init(kobj_t obj, void *data,\n"
"             struct snd_dbuf *b, struct pcm_channel *c, int dir)<co xml:id=\"co-chinit-params\"/>\n"
"          {\n"
"              struct xxx_info *sc = data;\n"
"              struct xxx_chinfo *ch;\n"
"               ...\n"
"              return ch;<co xml:id=\"co-chinit-return\"/>\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23140
#, fuzzy
msgid ""
"<varname>b</varname> is the address for the channel <varname remap="
"\"structname\">struct snd_dbuf</varname>. It should be initialized in the "
"function by calling <function>sndbuf_alloc()</function>. The buffer size to "
"use is normally a small multiple of the 'typical' unit transfer size for "
"your device."
msgstr ""
" <varname> b </varname> � o endere�o do canal <varname remap=\"structname\"> "
"struct snd_dbuf </varname> . Deve ser inicializado na fun��o chamando "
"<function> sndbuf_alloc () </function> . O tamanho do buffer a ser usado � "
"normalmente um pequeno m�ltiplo do tamanho de transfer�ncia da unidade ';"
"t�pica'; para o seu dispositivo. "

#. (itstool) path: callout/para
#: book.translate.xml:23147
#, fuzzy
msgid ""
"<varname>c</varname> is the <filename>pcm</filename> channel control "
"structure pointer. This is an opaque object. The function should store it in "
"the local channel structure, to be used in later calls to <filename>pcm</"
"filename> (ie: <function>chn_intr(c)</function>)."
msgstr ""
" <varname> c </varname> � o <filename> pcm </filename> ponteiro de estrutura "
"de controle de canal. Este � um objeto opaco. A fun��o deve armazen�-lo na "
"estrutura do canal local, para ser usado em chamadas posteriores <filename> "
"pcm </filename> (ie: <function> chn_intr (c) </function> ) "

#. (itstool) path: callout/para
#: book.translate.xml:23154
#, fuzzy
msgid ""
"<varname>dir</varname> indicates the channel direction "
"(<literal>PCMDIR_PLAY</literal> or <literal>PCMDIR_REC</literal>)."
msgstr ""
" <varname> dir </varname> indica a dire��o do canal ( <literal> PCMDIR_PLAY "
"</literal> ou <literal> PCMDIR_REC </literal> ) "

#. (itstool) path: callout/para
#: book.translate.xml:23160
#, fuzzy
msgid ""
"The function should return a pointer to the private area used to control "
"this channel. This will be passed as a parameter to other channel interface "
"calls."
msgstr ""
"A fun��o deve retornar um ponteiro para a �rea privada usada para controlar "
"este canal. Isso ser� passado como um par�metro para outras chamadas de "
"interface de canal."

#. (itstool) path: sect3/title
#: book.translate.xml:23168
#, fuzzy
msgid "channel_setformat"
msgstr "channel_setformat"

#. (itstool) path: sect3/para
#: book.translate.xml:23170
#, fuzzy
msgid ""
"<function>xxxchannel_setformat()</function> should set up the hardware for "
"the specified channel for the specified sound format."
msgstr ""
" <function> xxxchannel_setformat () </function> deve configurar o hardware "
"para o canal especificado para o formato de som especificado. "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23174
#, no-wrap
msgid ""
"          static int\n"
"          xxxchannel_setformat(kobj_t obj, void *data, u_int32_t format)<co xml:id=\"co-chsetformat-params\"/>\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return 0;\n"
"           }"
msgstr ""
"          static int\n"
"          xxxchannel_setformat(kobj_t obj, void *data, u_int32_t format)<co xml:id=\"co-chsetformat-params\"/>\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return 0;\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23184
#, fuzzy
msgid ""
"<varname>format</varname> is specified as an <literal>AFMT_XXX value</"
"literal> (<filename>soundcard.h</filename>)."
msgstr ""
" <varname> formato </varname> � especificado como um <literal> Valor "
"AFMT_XXX </literal> ( <filename> soundcard.h </filename> ) "

#. (itstool) path: sect3/title
#: book.translate.xml:23192
#, fuzzy
msgid "channel_setspeed"
msgstr "channel_setspeed"

#. (itstool) path: sect3/para
#: book.translate.xml:23194
#, fuzzy
msgid ""
"<function>xxxchannel_setspeed()</function> sets up the channel hardware for "
"the specified sampling speed, and returns the possibly adjusted speed."
msgstr ""
" <function> xxxchannel_setspeed () </function> configura o hardware do canal "
"para a velocidade de amostragem especificada e retorna a velocidade "
"possivelmente ajustada. "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23198
#, no-wrap
msgid ""
"          static int\n"
"          xxxchannel_setspeed(kobj_t obj, void *data, u_int32_t speed)\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return speed;\n"
"           }"
msgstr ""
"          static int\n"
"          xxxchannel_setspeed(kobj_t obj, void *data, u_int32_t speed)\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return speed;\n"
"           }"

#. (itstool) path: sect3/title
#: book.translate.xml:23208
#, fuzzy
msgid "channel_setblocksize"
msgstr "channel_setblocksize"

#. (itstool) path: sect3/para
#: book.translate.xml:23210
#, fuzzy
msgid ""
"<function>xxxchannel_setblocksize()</function> sets the block size, which is "
"the size of unit transactions between <filename>pcm</filename> and the sound "
"driver, and between the sound driver and the device. Typically, this would "
"be the number of bytes transferred before an interrupt occurs. During a "
"transfer, the sound driver should call <filename>pcm</filename>'s "
"<function>chn_intr()</function> every time this size has been transferred."
msgstr ""
" <function> xxxchannel_setblocksize () </function> define o tamanho do "
"bloco, que � o tamanho das transa��es unit�rias entre <filename> pcm </"
"filename> e o driver de som e entre o driver de som e o dispositivo. "
"Normalmente, isso seria o n�mero de bytes transferidos antes de ocorrer uma "
"interrup��o. Durante uma transfer�ncia, o driver de som deve ligar "
"<filename> pcm </filename> ';s <function> chn_intr () </function> cada vez "
"que esse tamanho foi transferido. "

#. (itstool) path: sect3/para
#: book.translate.xml:23220
#, fuzzy
msgid ""
"Most sound drivers only take note of the block size here, to be used when an "
"actual transfer will be started."
msgstr ""
"A maioria dos drivers de som s� toma nota do tamanho do bloco aqui, para ser "
"usado quando uma transfer�ncia real for iniciada."

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23224
#, no-wrap
msgid ""
"          static int\n"
"          xxxchannel_setblocksize(kobj_t obj, void *data, u_int32_t blocksize)\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"                ...\n"
"              return blocksize;<co xml:id=\"co-chsetblocksize-return\"/>\n"
"           }"
msgstr ""
"          static int\n"
"          xxxchannel_setblocksize(kobj_t obj, void *data, u_int32_t blocksize)\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"                ...\n"
"              return blocksize;<co xml:id=\"co-chsetblocksize-return\"/>\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23234
#, fuzzy
msgid ""
"The function returns the possibly adjusted block size. In case the block "
"size is indeed changed, <function>sndbuf_resize()</function> should be "
"called to adjust the buffer."
msgstr ""
"A fun��o retorna o tamanho do bloco possivelmente ajustado. Caso o tamanho "
"do bloco seja realmente alterado, <function> sndbuf_resize () </function> "
"deve ser chamado para ajustar o buffer \""

#. (itstool) path: sect3/title
#: book.translate.xml:23243
#, fuzzy
msgid "channel_trigger"
msgstr "channel_trigger"

#. (itstool) path: sect3/para
#: book.translate.xml:23245
#, fuzzy
msgid ""
"<function>xxxchannel_trigger()</function> is called by <filename>pcm</"
"filename> to control data transfer operations in the driver."
msgstr ""
" <function> xxxchannel_trigger () </function> � chamado por <filename> pcm </"
"filename> para controlar as opera��es de transfer�ncia de dados no driver \""

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23249
#, no-wrap
msgid ""
"          static int\n"
"          xxxchannel_trigger(kobj_t obj, void *data, int go)<co xml:id=\"co-chtrigger-params\"/>\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return 0;\n"
"           }"
msgstr ""
"          static int\n"
"          xxxchannel_trigger(kobj_t obj, void *data, int go)<co xml:id=\"co-chtrigger-params\"/>\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return 0;\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23259
#, fuzzy
msgid ""
"<varname>go</varname> defines the action for the current call. The possible "
"values are:"
msgstr ""
" <varname> ir </varname> define a a��o para a chamada atual. Os valores "
"poss�veis s�o: "

#. (itstool) path: listitem/para
#: book.translate.xml:23264
#, fuzzy
msgid ""
"<literal>PCMTRIG_START</literal>: the driver should start a data transfer "
"from or to the channel buffer. If needed, the buffer base and size can be "
"retrieved through <function>sndbuf_getbuf()</function> and "
"<function>sndbuf_getsize()</function>."
msgstr ""
" <literal> PCMTRIG_START </literal> : o driver deve iniciar uma "
"transfer�ncia de dados de ou para o buffer do canal. Se necess�rio, a base e "
"o tamanho do buffer podem ser recuperados <function> sndbuf_getbuf () </"
"function> e <function> sndbuf_getsize () </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:23273
#, fuzzy
msgid ""
"<literal>PCMTRIG_EMLDMAWR</literal> / <literal>PCMTRIG_EMLDMARD</literal>: "
"this tells the driver that the input or output buffer may have been updated. "
"Most drivers just ignore these calls."
msgstr ""
" <literal> PCMTRIG_EMLDMAWR </literal> / <literal> PCMTRIG_EMLDMARD </"
"literal> : diz ao driver que o buffer de entrada ou sa�da pode ter sido "
"atualizado. A maioria dos motoristas simplesmente ignora essas chamadas. "

#. (itstool) path: listitem/para
#: book.translate.xml:23281
#, fuzzy
msgid ""
"<literal>PCMTRIG_STOP</literal> / <literal>PCMTRIG_ABORT</literal>: the "
"driver should stop the current transfer."
msgstr ""
" <literal> PCMTRIG_STOP </literal> / <literal> PCMTRIG_ABORT </literal> : o "
"motorista deve parar a transfer�ncia atual \""

#. (itstool) path: note/para
#: book.translate.xml:23290
#, fuzzy
msgid ""
"If the driver uses ISA DMA, <function>sndbuf_isadma()</function> should be "
"called before performing actions on the device, and will take care of the "
"DMA chip side of things."
msgstr ""
"Se o driver usa o ISA DMA, <function> sndbuf_isadma () </function> deve ser "
"chamado antes de executar a��es no dispositivo, e vai cuidar do lado do chip "
"DMA das coisas \""

#. (itstool) path: sect3/title
#: book.translate.xml:23298
#, fuzzy
msgid "channel_getptr"
msgstr "channel_getptr"

#. (itstool) path: sect3/para
#: book.translate.xml:23300
#, fuzzy
msgid ""
"<function>xxxchannel_getptr()</function> returns the current offset in the "
"transfer buffer. This will typically be called by <function>chn_intr()</"
"function>, and this is how <filename>pcm</filename> knows where it can "
"transfer new data."
msgstr ""
" <function> xxxchannel_getptr () </function> retorna o deslocamento atual no "
"buffer de transfer�ncia. Isso normalmente ser� chamado por <function> "
"chn_intr () </function> e � assim <filename> pcm </filename> sabe onde pode "
"transferir novos dados. "

#. (itstool) path: sect3/title
#: book.translate.xml:23308
#, fuzzy
msgid "channel_free"
msgstr "channel_free"

#. (itstool) path: sect3/para
#: book.translate.xml:23310
#, fuzzy
msgid ""
"<function>xxxchannel_free()</function> is called to free up channel "
"resources, for example when the driver is unloaded, and should be "
"implemented if the channel data structures are dynamically allocated or if "
"<function>sndbuf_alloc()</function> was not used for buffer allocation."
msgstr ""
" <function> xxxchannel_free () </function> � chamado para liberar recursos "
"do canal, por exemplo, quando o driver � descarregado, e deve ser "
"implementado se as estruturas de dados do canal forem alocadas dinamicamente "
"ou se <function> sndbuf_alloc () </function> n�o foi usado para aloca��o de "
"buffer. "

#. (itstool) path: sect3/title
#: book.translate.xml:23319
#, fuzzy
msgid "channel_getcaps"
msgstr "channel_getcaps"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23321
#, no-wrap
msgid ""
"          struct pcmchan_caps *\n"
"          xxxchannel_getcaps(kobj_t obj, void *data)\n"
"          {\n"
"              return &amp;xxx_caps;<co xml:id=\"co-chgetcaps-return\"/>\n"
"           }"
msgstr ""
"          struct pcmchan_caps *\n"
"          xxxchannel_getcaps(kobj_t obj, void *data)\n"
"          {\n"
"              return &amp;xxx_caps;<co xml:id=\"co-chgetcaps-return\"/>\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23330
#, fuzzy
msgid ""
"The routine returns a pointer to a (usually statically-defined) <varname "
"remap=\"structname\">pcmchan_caps</varname> structure (defined in "
"<filename>sound/pcm/channel.h</filename>. The structure holds the minimum "
"and maximum sampling frequencies, and the accepted sound formats. Look at "
"any sound driver for an example."
msgstr ""
"A rotina retorna um ponteiro para um (geralmente definido estaticamente) "
"<varname remap=\"structname\"> pcmchan_caps </varname> estrutura (definida "
"em <filename> som / pcm / channel.h </filename> . A estrutura cont�m as "
"freq��ncias de amostragem m�nima e m�xima e os formatos de som aceitos. Olhe "
"para qualquer driver de som como exemplo. "

#. (itstool) path: sect3/title
#: book.translate.xml:23341
#, fuzzy
msgid "More Functions"
msgstr "Mais fun��es"

#. (itstool) path: sect3/para
#: book.translate.xml:23343
#, fuzzy
msgid ""
"<function>channel_reset()</function>, <function>channel_resetdone()</"
"function>, and <function>channel_notify()</function> are for special "
"purposes and should not be implemented in a driver without discussing it on "
"the <link xlink:href=\"http://lists.FreeBSD.org/mailman/listinfo/freebsd-"
"multimedia\">FreeBSD multimedia mailing list</link>."
msgstr ""
" <function> channel_reset () </function> , <function> channel_resetdone () </"
"function> e <function> channel_notify () </function> s�o para fins especiais "
"e n�o devem ser implementados em um driver sem discuti-lo no <link xlink:"
"href=\"http://lists.FreeBSD.org/mailman/listinfo/freebsd-multimedia\"> Lista "
"de discuss�o multim�dia do FreeBSD </link> "

#. (itstool) path: sect3/para
#: book.translate.xml:23349
#, fuzzy
msgid "<function>channel_setdir()</function> is deprecated."
msgstr " <function> channel_setdir () </function> est� obsoleto. "

#. (itstool) path: sect2/title
#: book.translate.xml:23355
#, fuzzy
msgid "The MIXER Interface"
msgstr "A interface MIXER"

#. (itstool) path: sect3/title
#: book.translate.xml:23358
#, fuzzy
msgid "mixer_init"
msgstr "mixer_init"

#. (itstool) path: sect3/para
#: book.translate.xml:23360
#, fuzzy
msgid ""
"<function>xxxmixer_init()</function> initializes the hardware and tells "
"<filename>pcm</filename> what mixer devices are available for playing and "
"recording"
msgstr ""
" <function> xxxmixer_init () </function> inicializa o hardware e informa "
"<filename> pcm </filename> quais dispositivos de mixagem est�o dispon�veis "
"para tocar e gravar "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23364
#, no-wrap
msgid ""
"          static int\n"
"          xxxmixer_init(struct snd_mixer *m)\n"
"          {\n"
"              struct xxx_info   *sc = mix_getdevinfo(m);\n"
"              u_int32_t v;\n"
"\n"
"              [Initialize hardware]\n"
"\n"
"              [Set appropriate bits in v for play mixers]<co xml:id=\"co-mxini-sd\"/>\n"
"              mix_setdevs(m, v);\n"
"              [Set appropriate bits in v for record mixers]\n"
"              mix_setrecdevs(m, v)\n"
"\n"
"              return 0;\n"
"          }"
msgstr ""
"          static int\n"
"          xxxmixer_init(struct snd_mixer *m)\n"
"          {\n"
"              struct xxx_info   *sc = mix_getdevinfo(m);\n"
"              u_int32_t v;\n"
"\n"
"              [Initialize hardware]\n"
"\n"
"              [Set appropriate bits in v for play mixers]<co xml:id=\"co-mxini-sd\"/>\n"
"              mix_setdevs(m, v);\n"
"              [Set appropriate bits in v for record mixers]\n"
"              mix_setrecdevs(m, v)\n"
"\n"
"              return 0;\n"
"          }"

#. (itstool) path: callout/para
#: book.translate.xml:23382
#, fuzzy
msgid ""
"Set bits in an integer value and call <function>mix_setdevs()</function> and "
"<function>mix_setrecdevs()</function> to tell <filename>pcm</filename> what "
"devices exist."
msgstr ""
"Definir bits em um valor inteiro e chamar <function> mix_setdevs () </"
"function> e <function> mix_setrecdevs () </function> contar <filename> pcm </"
"filename> quais dispositivos existem \""

#. (itstool) path: sect3/para
#: book.translate.xml:23389
#, fuzzy
msgid ""
"Mixer bits definitions can be found in <filename>soundcard.h</filename> "
"(<literal>SOUND_MASK_XXX</literal> values and <literal>SOUND_MIXER_XXX</"
"literal> bit shifts)."
msgstr ""
"As defini��es dos misturadores podem ser encontradas em <filename> soundcard."
"h </filename> ( <literal> SOUND_MASK_XXX </literal> valores e <literal> "
"SOUND_MIXER_XXX </literal> mudan�as de bit). "

#. (itstool) path: sect3/title
#: book.translate.xml:23396
#, fuzzy
msgid "mixer_set"
msgstr "mixer_set"

#. (itstool) path: sect3/para
#: book.translate.xml:23398
#, fuzzy
msgid ""
"<function>xxxmixer_set()</function> sets the volume level for one mixer "
"device."
msgstr ""
" <function> xxxmixer_set () </function> define o n�vel de volume para um "
"dispositivo de mixagem. "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23401
#, no-wrap
msgid ""
"          static int\n"
"          xxxmixer_set(struct snd_mixer *m, unsigned dev,\n"
"                           unsigned left, unsigned right)<co xml:id=\"co-mxset-params\"/>\n"
"          {\n"
"              struct sc_info *sc = mix_getdevinfo(m);\n"
"              [set volume level]\n"
"              return left | (right &lt;&lt; 8);<co xml:id=\"co-mxset-return\"/>\n"
"          }"
msgstr ""
"          static int\n"
"          xxxmixer_set(struct snd_mixer *m, unsigned dev,\n"
"                           unsigned left, unsigned right)<co xml:id=\"co-mxset-params\"/>\n"
"          {\n"
"              struct sc_info *sc = mix_getdevinfo(m);\n"
"              [set volume level]\n"
"              return left | (right &lt;&lt; 8);<co xml:id=\"co-mxset-return\"/>\n"
"          }"

#. (itstool) path: callout/para
#: book.translate.xml:23412
#, fuzzy
msgid "The device is specified as a <literal>SOUND_MIXER_XXX</literal> value"
msgstr ""
"O dispositivo � especificado como <literal> SOUND_MIXER_XXX </literal> valor"

#. (itstool) path: callout/para
#: book.translate.xml:23415
#, fuzzy
msgid ""
"The volume values are specified in range [0-100]. A value of zero should "
"mute the device."
msgstr ""
"Os valores de volume s�o especificados no intervalo [0-100]. Um valor de "
"zero deve silenciar o dispositivo."

#. (itstool) path: callout/para
#: book.translate.xml:23420
#, fuzzy
msgid ""
"As the hardware levels probably will not match the input scale, and some "
"rounding will occur, the routine returns the actual level values (in range "
"0-100) as shown."
msgstr ""
"Como os n�veis de hardware provavelmente n�o corresponder�o � escala de "
"entrada, e algum arredondamento ocorrer�, a rotina retornar� os valores "
"reais de n�vel (no intervalo de 0 a 100), como mostrado."

#. (itstool) path: sect3/title
#: book.translate.xml:23430
#, fuzzy
msgid "mixer_setrecsrc"
msgstr "mixer_setrecsrc"

#. (itstool) path: sect3/para
#: book.translate.xml:23432
#, fuzzy
msgid ""
"<function>xxxmixer_setrecsrc()</function> sets the recording source device."
msgstr ""
" <function> xxxmixer_setrecsrc () </function> define o dispositivo de origem "
"de grava��o. "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23435
#, no-wrap
msgid ""
"          static int\n"
"          xxxmixer_setrecsrc(struct snd_mixer *m, u_int32_t src)<co xml:id=\"co-mxsr-params\"/>\n"
"          {\n"
"              struct xxx_info *sc = mix_getdevinfo(m);\n"
"\n"
"              [look for non zero bit(s) in src, set up hardware]\n"
"\n"
"              [update src to reflect actual action]\n"
"              return src;<co xml:id=\"co-mxsr-return\"/>\n"
"           }"
msgstr ""
"          static int\n"
"          xxxmixer_setrecsrc(struct snd_mixer *m, u_int32_t src)<co xml:id=\"co-mxsr-params\"/>\n"
"          {\n"
"              struct xxx_info *sc = mix_getdevinfo(m);\n"
"\n"
"              [look for non zero bit(s) in src, set up hardware]\n"
"\n"
"              [update src to reflect actual action]\n"
"              return src;<co xml:id=\"co-mxsr-return\"/>\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23448
#, fuzzy
msgid "The desired recording devices are specified as a bit field"
msgstr ""
"Os dispositivos de grava��o desejados s�o especificados como um campo de bits"

#. (itstool) path: callout/para
#: book.translate.xml:23453
#, fuzzy
msgid ""
"The actual devices set for recording are returned. Some drivers can only set "
"one device for recording. The function should return -1 if an error occurs."
msgstr ""
"Os dispositivos atuais configurados para grava��o s�o retornados. Alguns "
"drivers podem apenas configurar um dispositivo para grava��o. A fun��o deve "
"retornar -1 se ocorrer um erro."

#. (itstool) path: sect3/title
#: book.translate.xml:23461
#, fuzzy
msgid "mixer_uninit, mixer_reinit"
msgstr "mixer_uninit, mixer_reinit"

#. (itstool) path: sect3/para
#: book.translate.xml:23463
#, fuzzy
msgid ""
"<function>xxxmixer_uninit()</function> should ensure that all sound is muted "
"and if possible mixer hardware should be powered down."
msgstr ""
" <function> xxxmixer_uninit () </function> deve garantir que todo o som seja "
"silenciado e, se poss�vel, o hardware do mixer deve ser desligado "

#. (itstool) path: sect3/para
#: book.translate.xml:23467
#, fuzzy
msgid ""
"<function>xxxmixer_reinit()</function> should ensure that the mixer hardware "
"is powered up and any settings not controlled by <function>mixer_set()</"
"function> or <function>mixer_setrecsrc()</function> are restored."
msgstr ""
" <function> xxxmixer_reinit () </function> deve garantir que o hardware do "
"mixer esteja ligado e quaisquer configura��es n�o <function> mixer_set () </"
"function> ou <function> mixer_setrecsrc () </function> s�o restaurados \""

#. (itstool) path: sect2/title
#: book.translate.xml:23475
#, fuzzy
msgid "The AC97 Interface"
msgstr "A interface do AC97"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23477
#, fuzzy
msgid "<primary>AC97</primary>"
msgstr " <primary> AC97 </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:23479
#, fuzzy
msgid ""
"The <emphasis>AC97</emphasis> interface is implemented by drivers with an "
"AC97 codec. It only has three methods:"
msgstr ""
"O <emphasis> AC97 </emphasis> A interface � implementada por drivers com um "
"codec AC97. Tem apenas tr�s m�todos: "

#. (itstool) path: listitem/para
#: book.translate.xml:23485
#, fuzzy
msgid ""
"<function>xxxac97_init()</function> returns the number of ac97 codecs found."
msgstr ""
" <function> xxxac97_init () </function> retorna o n�mero de codecs ac97 "
"encontrados. "

#. (itstool) path: listitem/para
#: book.translate.xml:23490
#, fuzzy
msgid ""
"<function>ac97_read()</function> and <function>ac97_write()</function> read "
"or write a specified register."
msgstr ""
" <function> ac97_read () </function> e <function> ac97_write () </function> "
"ler ou escrever um registro especificado. "

#. (itstool) path: sect2/para
#: book.translate.xml:23496
#, fuzzy
msgid ""
"The <emphasis>AC97</emphasis> interface is used by the AC97 code in "
"<filename>pcm</filename> to perform higher level operations. Look at "
"<filename>sound/pci/maestro3.c</filename> or many others under "
"<filename>sound/pci/</filename> for an example."
msgstr ""
"O <emphasis> AC97 </emphasis> interface � usada pelo c�digo AC97 em "
"<filename> pcm </filename> para executar opera��es de n�vel superior. Olhe "
"para <filename> som / pci / maestro3.c </filename> ou muitos outros sob "
"<filename> som / pci / </filename> Por exemplo."

#. (itstool) path: chapter/title
#: book.translate.xml:23512
#, fuzzy
msgid "PC Card"
msgstr "PC Card"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:23514
#, fuzzy
msgid "<primary>PC Card</primary>"
msgstr " <primary> Cart�o PC </primary> "

#. (itstool) path: chapter/indexterm
#: book.translate.xml:23515
#, fuzzy
msgid "<primary>CardBus</primary>"
msgstr " <primary> CardBus </primary> "

#. (itstool) path: chapter/para
#: book.translate.xml:23517
#, fuzzy
msgid ""
"This chapter will talk about the FreeBSD mechanisms for writing a device "
"driver for a PC Card or CardBus device. However, at present it just "
"documents how to add a new device to an existing pccard driver."
msgstr ""
"Este cap�tulo vai falar sobre os mecanismos do FreeBSD para escrever um "
"driver de dispositivo para um PC Card ou um dispositivo CardBus. No entanto, "
"no momento ele apenas documenta como adicionar um novo dispositivo a um "
"driver de placa pc existente."

#. (itstool) path: sect1/title
#: book.translate.xml:23523
#, fuzzy
msgid "Adding a Device"
msgstr "Adicionando um dispositivo"

#. (itstool) path: sect1/para
#: book.translate.xml:23525
#, fuzzy
msgid ""
"Device drivers know what devices they support. There is a table of supported "
"devices in the kernel that drivers use to attach to a device."
msgstr ""
"Os drivers de dispositivos sabem quais dispositivos eles suportam. H� uma "
"tabela de dispositivos suportados no kernel que os drivers usam para "
"conectar a um dispositivo."

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23532
#, fuzzy
msgid "<primary>CIS</primary>"
msgstr " <primary> CIS </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:23533
#, fuzzy
msgid ""
"PC Cards are identified in one of two ways, both based on the "
"<firstterm>Card Information Structure</firstterm> (<acronym role=\"Card "
"Information Structure\">CIS</acronym>) stored on the card. The first method "
"is to use numeric manufacturer and product numbers. The second method is to "
"use the human readable strings that are also contained in the CIS. The PC "
"Card bus uses a centralized database and some macros to facilitate a design "
"pattern to help the driver writer match devices to his driver."
msgstr ""
"PC Cards s�o identificados de duas maneiras, ambas baseadas no <firstterm> "
"Estrutura de informa��es do cart�o </firstterm> ( <acronym role=\"Card "
"Information Structure\">CIS</acronym> ) armazenado no cart�o. O primeiro "
"m�todo � usar n�meros num�ricos de fabricantes e produtos. O segundo m�todo "
"� usar as cadeias humanas leg�veis que tamb�m est�o contidas no CIS. O "
"barramento da placa de PC usa um banco de dados centralizado e algumas "
"macros para facilitar um padr�o de projeto para ajudar o gravador do driver "
"a combinar os dispositivos com o driver. "

#. (itstool) path: sect2/para
#: book.translate.xml:23544
#, fuzzy
msgid ""
"Original equipment manufacturers (<acronym>OEM</acronym>s) often develop a "
"reference design for a PC Card product, then sell this design to other "
"companies to market. Those companies refine the design, market the product "
"to their target audience or geographic area, and put their own name plate "
"onto the card. The refinements to the physical card are typically very "
"minor, if any changes are made at all. To strengthen their brand, these "
"vendors place their company name in the human readable strings in the CIS "
"space, but leave the manufacturer and product IDs unchanged."
msgstr ""
"Fabricantes de equipamentos originais ( <acronym>OEMs</acronym> ) "
"frequentemente desenvolvem um design de refer�ncia para um produto de PC "
"Card e vendem esse projeto para outras empresas. Essas empresas refinam o "
"design, comercializam o produto para seu p�blico-alvo ou �rea geogr�fica e "
"placa de identifica��o para o cart�o.Os refinamentos para o cart�o f�sico "
"s�o normalmente muito pequenas, se forem feitas altera��es a todos.Para "
"fortalecer sua marca, esses fornecedores colocam o nome da empresa nas "
"seq��ncias leg�veis para humanos no espa�o CIS, mas deixam o fabricante e "
"IDs de produto inalterados. "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23555
msgid "<primary>NetGear</primary>"
msgstr "<primary>NetGear</primary>"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23556
msgid "<primary>Linksys</primary>"
msgstr "<primary>Linksys</primary>"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23557
msgid "<primary>D-Link</primary>"
msgstr "<primary>D-Link</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:23559
#, fuzzy
msgid ""
"Because of this practice, FreeBSD drivers usually rely on numeric IDs for "
"device identification. Using numeric IDs and a centralized database "
"complicates adding IDs and support for cards to the system. One must "
"carefully check to see who really made the card, especially when it appears "
"that the vendor who made the card might already have a different "
"manufacturer ID listed in the central database. Linksys, D-Link, and NetGear "
"are a number of US manufacturers of LAN hardware that often sell the same "
"design. These same designs can be sold in Japan under names such as Buffalo "
"and Corega. Often, these devices will all have the same manufacturer and "
"product IDs."
msgstr ""
"Devido a essa pr�tica, os drivers do FreeBSD geralmente dependem de IDs "
"num�ricos para identifica��o do dispositivo. O uso de IDs num�ricos e um "
"banco de dados centralizado dificulta a adi��o de IDs e suporte a cart�es no "
"sistema. � preciso verificar cuidadosamente quem realmente fez o cart�o, "
"especialmente quando Parece que o fornecedor que fez o cart�o j� pode ter um "
"ID de fabricante diferente listado no banco de dados central.A Linksys, D-"
"Link e NetGear s�o um n�mero de fabricantes dos EUA de hardware de rede "
"local que muitas vezes vendem o mesmo design. vendidos no Jap�o sob nomes "
"como Buffalo e Corega. Muitas vezes, esses dispositivos ter�o todos os "
"mesmos IDs de fabricantes e produtos. "

#. (itstool) path: sect2/para
#: book.translate.xml:23572
#, fuzzy
msgid ""
"The PC Card bus code keeps a central database of card information, but not "
"which driver is associated with them, in <filename>/sys/dev/pccard/"
"pccarddevs</filename>. It also provides a set of macros that allow one to "
"easily construct simple entries in the table the driver uses to claim "
"devices."
msgstr ""
"O c�digo de barramento do PC Card mant�m um banco de dados central de "
"informa��es do cart�o, mas n�o qual driver est� associado a eles, "
"<filename> / sys / dev / pccard / pccarddevs </filename> . Ele tamb�m "
"fornece um conjunto de macros que permitem construir facilmente entradas "
"simples na tabela que o driver usa para reivindicar dispositivos. "

#. (itstool) path: sect2/para
#: book.translate.xml:23579
#, fuzzy
msgid ""
"Finally, some really low end devices do not contain manufacturer "
"identification at all. These devices must be detected by matching the human "
"readable CIS strings. While it would be nice if we did not need this method "
"as a fallback, it is necessary for some very low end CD-ROM players and "
"Ethernet cards. This method should generally be avoided, but a number of "
"devices are listed in this section because they were added prior to the "
"recognition of the <acronym>OEM</acronym> nature of the PC Card business. "
"When adding new devices, prefer using the numeric method."
msgstr ""
"Finalmente, alguns dispositivos realmente low-end n�o cont�m identifica��o "
"do fabricante. Esses dispositivos devem ser detectados combinando as strings "
"CIS leg�veis. Embora seja bom se n�o precisarmos desse m�todo como um "
"fallback, � necess�rio que alguns reprodutores de CD-ROM e placas Ethernet "
"muito low end Esse m�todo deve ser geralmente evitado, mas v�rios "
"dispositivos s�o listados nesta se��o porque foram adicionados antes do "
"reconhecimento da natureza <acronym>OEM</acronym> do neg�cio do PC Card. , "
"prefira usar o m�todo num�rico. "

#. (itstool) path: sect2/title
#: book.translate.xml:23592
#, fuzzy
msgid "Format of <filename>pccarddevs</filename>"
msgstr "Formato de <filename> pccarddevs </filename> "

#. (itstool) path: sect2/para
#: book.translate.xml:23594
#, fuzzy
msgid ""
"There are four sections in the <filename>pccarddevs</filename> files. The "
"first section lists the manufacturer numbers for vendors that use them. This "
"section is sorted in numerical order. The next section has all of the "
"products that are used by these vendors, along with their product ID numbers "
"and a description string. The description string typically is not used "
"(instead we set the device's description based on the human readable CIS, "
"even if we match on the numeric version). These two sections are then "
"repeated for devices that use the string matching method. Finally, C-style "
"comments enclosed in <literal>/*</literal> and <literal>*/</literal> "
"characters are allowed anywhere in the file."
msgstr ""
"H� quatro se��es no <filename> pccarddevs </filename> arquivos. A primeira "
"se��o lista os n�meros do fabricante dos fornecedores que os utilizam. Esta "
"se��o � classificada em ordem num�rica. A pr�xima se��o tem todos os "
"produtos usados ​​por esses fornecedores, juntamente com seus n�meros de "
"identifica��o de produto e uma string de descri��o. A string de descri��o "
"geralmente n�o � usada (em vez disso, definimos a descri��o do dispositivo "
"com base no CIS leg�vel, mesmo se correspondermos � vers�o num�rica). Essas "
"duas se��es s�o repetidas para dispositivos que usam o m�todo de "
"correspond�ncia de seq��ncia de caracteres. Finalmente, coment�rios no "
"estilo C inclu�dos <literal> / * </literal> e <literal> * / </literal> "
"caracteres s�o permitidos em qualquer lugar do arquivo. "

#. (itstool) path: sect2/para
#: book.translate.xml:23608
#, fuzzy
msgid ""
"The first section of the file contains the vendor IDs. Please keep this list "
"sorted in numeric order. Also, please coordinate changes to this file "
"because we share it with NetBSD to help facilitate a common clearing house "
"for this information. For example, here are the first few vendor IDs:"
msgstr ""
"A primeira se��o do arquivo cont�m os IDs do fornecedor. Por favor, mantenha "
"esta lista classificada em ordem num�rica. Al�m disso, coordene as "
"altera��es neste arquivo, porque o compartilhamos com o NetBSD para ajudar a "
"facilitar uma c�mara de compensa��o comum para essas informa��es. Por "
"exemplo, aqui s�o os primeiros poucos IDs de fornecedores: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23615
#, no-wrap
msgid ""
"vendor FUJITSU\t\t\t0x0004  Fujitsu Corporation\n"
"vendor NETGEAR_2\t\t0x000b  Netgear\n"
"vendor PANASONIC\t\t0x0032\tMatsushita Electric Industrial Co.\n"
"vendor SANDISK\t\t\t0x0045\tSandisk Corporation"
msgstr ""
"vendor FUJITSU\t\t\t0x0004  Fujitsu Corporation\n"
"vendor NETGEAR_2\t\t0x000b  Netgear\n"
"vendor PANASONIC\t\t0x0032\tMatsushita Electric Industrial Co.\n"
"vendor SANDISK\t\t\t0x0045\tSandisk Corporation"

#. (itstool) path: sect2/para
#: book.translate.xml:23620
#, fuzzy
msgid ""
"Chances are very good that the <literal>NETGEAR_2</literal> entry is really "
"an OEM that NETGEAR purchased cards from and the author of support for those "
"cards was unaware at the time that Netgear was using someone else's ID. "
"These entries are fairly straightforward. The vendor keyword denotes the "
"kind of line that this is, followed by the name of the vendor. This name "
"will be repeated later in <filename>pccarddevs</filename>, as well as used "
"in the driver's match tables, so keep it short and a valid C identifier. A "
"numeric ID in hex identifies the manufacturer. Do not add IDs of the form "
"<literal>0xffffffff</literal> or <literal>0xffff</literal> because these are "
"reserved IDs (the former is <quote>no ID set</quote> while the latter is "
"sometimes seen in extremely poor quality cards to try to indicate "
"<quote>none</quote>). Finally there is a string description of the company "
"that makes the card. This string is not used in FreeBSD for anything but "
"commentary purposes."
msgstr ""
"As chances s�o muito boas que o <literal> NETGEAR_2 </literal> A entrada � "
"realmente um OEM do qual a NETGEAR comprou cart�es e o autor do suporte para "
"esses cart�es n�o sabia no momento em que a Netgear usava o ID de outra "
"pessoa. Essas entradas s�o bastante simples. A palavra-chave do fornecedor "
"indica o tipo de linha que � seguido pelo nome do fornecedor. Este nome ser� "
"repetido mais tarde <filename> pccarddevs </filename> , bem como usado nas "
"tabelas de correspond�ncia do driver, portanto, mantenha-o curto e um "
"identificador C v�lido. Um ID num�rico em hex identifica o fabricante. N�o "
"adicione IDs do formul�rio <literal> 0xffffffff </literal> ou <literal> "
"0xffff </literal> porque estes s�o IDs reservados (o primeiro � <quote> "
"nenhum conjunto de ID </quote> enquanto o �ltimo � visto �s vezes em cart�es "
"de extrema baixa qualidade para tentar indicar <quote> Nenhum </quote> ). "
"Finalmente, h� uma descri��o da string da empresa que faz o cart�o. Esta "
"string n�o � usada no FreeBSD para fins que n�o sejam coment�rios. "

#. (itstool) path: sect2/para
#: book.translate.xml:23639
#, fuzzy
msgid ""
"The second section of the file contains the products. As shown in this "
"example, the format is similar to the vendor lines:"
msgstr ""
"A segunda se��o do arquivo cont�m os produtos. Conforme mostrado neste "
"exemplo, o formato � semelhante �s linhas do fornecedor:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23643
#, no-wrap
msgid ""
"/* Allied Telesis K.K. */\n"
"product ALLIEDTELESIS LA_PCM\t0x0002 Allied Telesis LA-PCM\n"
"\n"
"/* Archos */\n"
"product\tARCHOS ARC_ATAPI\t0x0043 MiniCD"
msgstr ""
"/* Allied Telesis K.K. */\n"
"product ALLIEDTELESIS LA_PCM\t0x0002 Allied Telesis LA-PCM\n"
"\n"
"/* Archos */\n"
"product\tARCHOS ARC_ATAPI\t0x0043 MiniCD"

#. (itstool) path: sect2/para
#: book.translate.xml:23649
#, fuzzy
msgid ""
"The <literal>product</literal> keyword is followed by the vendor name, "
"repeated from above. This is followed by the product name, which is used by "
"the driver and should be a valid C identifier, but may also start with a "
"number. As with the vendors, the hex product ID for this card follows the "
"same convention for <literal>0xffffffff</literal> and <literal>0xffff</"
"literal>. Finally, there is a string description of the device itself. This "
"string typically is not used in FreeBSD, since FreeBSD's pccard bus driver "
"will construct a string from the human readable CIS entries, but it can be "
"used in the rare cases where this is somehow insufficient. The products are "
"in alphabetical order by manufacturer, then numerical order by product ID. "
"They have a C comment before each manufacturer's entries and there is a "
"blank line between entries."
msgstr ""
"O <literal> produtos </literal> palavra-chave � seguida pelo nome do "
"fornecedor, repetido de cima. Isto � seguido pelo nome do produto, que � "
"usado pelo driver e deve ser um identificador C v�lido, mas tamb�m pode "
"come�ar com um n�mero. Tal como acontece com os fornecedores, o ID do "
"produto hexadecimal para este cart�o segue a mesma conven��o para <literal> "
"0xffffffff </literal> e <literal> 0xffff </literal> . Finalmente, h� uma "
"descri��o de string do pr�prio dispositivo. Esta string normalmente n�o � "
"usada no FreeBSD, j� que o driver de barramento de pccard do FreeBSD ir� "
"construir uma string a partir das entradas do CIS leg�vel, mas pode ser "
"usado nos raros casos em que isso � de alguma forma insuficiente. Os "
"produtos est�o em ordem alfab�tica por fabricante, em seguida, ordem "
"num�rica por ID do produto. Eles t�m um coment�rio C antes das entradas de "
"cada fabricante e h� uma linha em branco entre as entradas. "

#. (itstool) path: sect2/para
#: book.translate.xml:23666
#, fuzzy
msgid ""
"The third section is like the previous vendor section, but with all of the "
"manufacturer numeric IDs set to <literal>-1</literal>, meaning <quote>match "
"anything found</quote> in the FreeBSD pccard bus code. Since these are C "
"identifiers, their names must be unique. Otherwise the format is identical "
"to the first section of the file."
msgstr ""
"A terceira se��o � como a se��o anterior do fornecedor, mas com todas as IDs "
"num�ricas do fabricante configuradas como <literal> -1 </literal> "
"significado <quote> coincidir com qualquer coisa encontrada </quote> no "
"c�digo de barramento do pccard do FreeBSD. Como esses s�o identificadores C, "
"seus nomes devem ser exclusivos. Caso contr�rio, o formato � id�ntico � "
"primeira se��o do arquivo. "

#. (itstool) path: sect2/para
#: book.translate.xml:23674
#, fuzzy
msgid ""
"The final section contains the entries for those cards that must be "
"identified by string entries. This section's format is a little different "
"from the generic section:"
msgstr ""
"A se��o final cont�m as entradas para as placas que devem ser identificadas "
"por entradas de string. O formato desta se��o � um pouco diferente da se��o "
"gen�rica:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23678
#, no-wrap
msgid ""
"product ADDTRON AWP100\t\t{ \"Addtron\", \"AWP-100&amp;spWireless&amp;spPCMCIA\", \"Version&amp;sp01.02\", NULL }\n"
"product ALLIEDTELESIS WR211PCM\t{ \"Allied&amp;spTelesis&amp;spK.K.\", \"WR211PCM\", NULL, NULL } Allied Telesis WR211PCM"
msgstr ""
"product ADDTRON AWP100\t\t{ \"Addtron\", \"AWP-100&amp;spWireless&amp;spPCMCIA\", \"Version&amp;sp01.02\", NULL }\n"
"product ALLIEDTELESIS WR211PCM\t{ \"Allied&amp;spTelesis&amp;spK.K.\", \"WR211PCM\", NULL, NULL } Allied Telesis WR211PCM"

#. (itstool) path: sect2/para
#: book.translate.xml:23681
#, fuzzy
msgid ""
"The familiar <literal>product</literal> keyword is followed by the vendor "
"name and the card name, just as in the second section of the file. Here the "
"format deviates from that used earlier. There is a {} grouping, followed by "
"a number of strings. These strings correspond to the vendor, product, and "
"extra information that is defined in a CIS_INFO tuple. These strings are "
"filtered by the program that generates <filename>pccarddevs.h</filename> to "
"replace &amp;sp with a real space. NULL strings mean that the corresponding "
"part of the entry should be ignored. The example shown here contains a bad "
"entry. It should not contain the version number unless that is critical for "
"the operation of the card. Sometimes vendors will have many different "
"versions of the card in the field that all work, in which case that "
"information only makes it harder for someone with a similar card to use it "
"with FreeBSD. Sometimes it is necessary when a vendor wishes to sell many "
"different parts under the same brand due to market considerations "
"(availability, price, and so forth). Then it can be critical to "
"disambiguating the card in those rare cases where the vendor kept the same "
"manufacturer/product pair. Regular expression matching is not available at "
"this time."
msgstr ""
"O familiar <literal> produtos </literal> A palavra-chave � seguida pelo nome "
"do fornecedor e pelo nome do cart�o, assim como na segunda se��o do arquivo. "
"Aqui o formato se desvia do usado anteriormente. H� um {} agrupamento, "
"seguido por v�rias sequ�ncias. Essas sequ�ncias correspondem ao fornecedor, "
"ao produto e �s informa��es extras definidas em uma tupla CIS_INFO. Essas "
"strings s�o filtradas pelo programa que gera <filename> pccarddevs.h </"
"filename> para substituir o sp por um espa�o real. Strings NULL significam "
"que a parte correspondente da entrada deve ser ignorada. O exemplo mostrado "
"aqui cont�m uma entrada incorreta. Ele n�o deve conter o n�mero da vers�o, a "
"menos que isso seja cr�tico para a opera��o do cart�o. �s vezes, os "
"fornecedores ter�o muitas vers�es diferentes do cart�o no campo que "
"funcionam, e nesse caso essa informa��o s� dificulta que algu�m com um "
"cart�o semelhante o use com o FreeBSD. �s vezes � necess�rio quando um "
"fornecedor deseja vender muitas pe�as diferentes sob a mesma marca devido a "
"considera��es de mercado (disponibilidade, pre�o e assim por diante). Ent�o, "
"pode ser cr�tico desambiguar o cart�o nos raros casos em que o fornecedor "
"manteve o mesmo par fabricante / produto. A correspond�ncia de express�o "
"regular n�o est� dispon�vel no momento. "

#. (itstool) path: sect2/title
#: book.translate.xml:23706
#, fuzzy
msgid "Sample Probe Routine"
msgstr "Rotina da Sonda de Amostra"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23708
msgid "<primary>PC Card</primary> <secondary>probe</secondary>"
msgstr "<primary>PC Card</primary> <secondary>probe</secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:23713
#, fuzzy
msgid ""
"To understand how to add a device to the list of supported devices, one must "
"understand the probe and/or match routines that many drivers have. It is "
"complicated a little in FreeBSD 5.x because there is a compatibility layer "
"for OLDCARD present as well. Since only the window-dressing is different, an "
"idealized version will be presented here."
msgstr ""
"Para entender como adicionar um dispositivo � lista de dispositivos "
"suportados, deve-se entender a sonda e / ou combinar as rotinas que muitos "
"drivers possuem. � um pouco complicado no FreeBSD 5.x porque existe uma "
"camada de compatibilidade para OLDCARD presente como Bem, uma vez que apenas "
"a janela de vestir � diferente, uma vers�o idealizada ser� apresentada aqui "
"\""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23720
#, no-wrap
msgid ""
"static const struct pccard_product wi_pccard_products[] = {\n"
"\tPCMCIA_CARD(3COM, 3CRWE737A, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_PCM_S11, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_CF_S11G, 0),\n"
"\tPCMCIA_CARD(TDK, LAK_CD011WL, 0),\n"
"\t{ NULL }\n"
"};\n"
"\n"
"static int\n"
"wi_pccard_probe(dev)\n"
"\tdevice_t\tdev;\n"
"{\n"
"\tconst struct pccard_product *pp;\n"
"\n"
"\tif ((pp = pccard_product_lookup(dev, wi_pccard_products,\n"
"\t    sizeof(wi_pccard_products[0]), NULL)) != NULL) {\n"
"\t\tif (pp-&gt;pp_name != NULL)\n"
"\t\t\tdevice_set_desc(dev, pp-&gt;pp_name);\n"
"\t\treturn (0);\n"
"\t}\n"
"\treturn (ENXIO);\n"
"}"
msgstr ""
"static const struct pccard_product wi_pccard_products[] = {\n"
"\tPCMCIA_CARD(3COM, 3CRWE737A, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_PCM_S11, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_CF_S11G, 0),\n"
"\tPCMCIA_CARD(TDK, LAK_CD011WL, 0),\n"
"\t{ NULL }\n"
"};\n"
"\n"
"static int\n"
"wi_pccard_probe(dev)\n"
"\tdevice_t\tdev;\n"
"{\n"
"\tconst struct pccard_product *pp;\n"
"\n"
"\tif ((pp = pccard_product_lookup(dev, wi_pccard_products,\n"
"\t    sizeof(wi_pccard_products[0]), NULL)) != NULL) {\n"
"\t\tif (pp-&gt;pp_name != NULL)\n"
"\t\t\tdevice_set_desc(dev, pp-&gt;pp_name);\n"
"\t\treturn (0);\n"
"\t}\n"
"\treturn (ENXIO);\n"
"}"

#. (itstool) path: sect2/para
#: book.translate.xml:23743
#, fuzzy
msgid ""
"Here we have a simple pccard probe routine that matches a few devices. As "
"stated above, the name may vary (if it is not <function>foo_pccard_probe()</"
"function> it will be <function>foo_pccard_match()</function>). The function "
"<function>pccard_product_lookup()</function> is a generalized function that "
"walks the table and returns a pointer to the first entry that it matches. "
"Some drivers may use this mechanism to convey additional information about "
"some cards to the rest of the driver, so there may be some variance in the "
"table. The only requirement is that each row of the table must have a "
"<function>struct</function> <varname remap=\"structname\">pccard_product</"
"varname> as the first element."
msgstr ""
"Aqui temos uma simples rotina de teste pccard que combina com alguns "
"dispositivos. Como dito acima, o nome pode variar (se n�o for <function> "
"foo_pccard_probe () </function> ser� <function> foo_pccard_match () </"
"function> ). A fun��o <function> pccard_product_lookup () </function> � uma "
"fun��o generalizada que percorre a tabela e retorna um ponteiro para a "
"primeira entrada correspondente. Alguns drivers podem usar esse mecanismo "
"para transmitir informa��es adicionais sobre alguns cart�es para o restante "
"do driver, portanto, pode haver alguma varia��o na tabela. O �nico requisito "
"� que cada linha da tabela deve ter um <function> struct </function><varname "
"remap=\"structname\"> pccard_product </varname> como o primeiro elemento \""

#. (itstool) path: sect2/para
#: book.translate.xml:23757
#, fuzzy
msgid ""
"Looking at the table <varname remap=\"structname\">wi_pccard_products</"
"varname>, one notices that all the entries are of the form "
"<function>PCMCIA_CARD(<replaceable>foo</replaceable>, <replaceable>bar</"
"replaceable>, <replaceable>baz</replaceable>)</function>. The "
"<replaceable>foo</replaceable> part is the manufacturer ID from "
"<filename>pccarddevs</filename>. The <replaceable>bar</replaceable> part is "
"the product ID. <replaceable>baz</replaceable> is the expected function "
"number for this card. Many pccards can have multiple functions, and some way "
"to disambiguate function 1 from function 0 is needed. You may see "
"<literal>PCMCIA_CARD_D</literal>, which includes the device description from "
"<filename>pccarddevs</filename>. You may also see <literal>PCMCIA_CARD2</"
"literal> and <literal>PCMCIA_CARD2_D</literal> which are used when you need "
"to match both CIS strings and manufacturer numbers, in the <quote>use the "
"default description</quote> and <quote>take the description from pccarddevs</"
"quote> flavors."
msgstr ""
"Olhando para a mesa <varname remap=\"structname\"> wi_pccard_products </"
"varname> , percebe-se que todas as entradas s�o da forma <function> "
"PCMCIA_CARD ( <replaceable> foo </replaceable> , <replaceable> Barra </"
"replaceable> , <replaceable> baz </replaceable> ) </function> . o "
"<replaceable> foo </replaceable> parte � o ID do fabricante de <filename> "
"pccarddevs </filename> . o <replaceable> Barra </replaceable> parte � o ID "
"do produto. <replaceable> baz </replaceable> � o n�mero da fun��o esperada "
"para este cart�o. Muitos pccards podem ter m�ltiplas fun��es, e alguma "
"maneira de desambiguar a fun��o 1 da fun��o 0 � necess�ria. Voc� pode ver "
"<literal> PCMCIA_CARD_D </literal> , que inclui a descri��o do dispositivo "
"de <filename> pccarddevs </filename> . Voc� tamb�m pode ver <literal> "
"PCMCIA_CARD2 </literal> e <literal> PCMCIA_CARD2_D </literal> que s�o usados ​​"
"quando voc� precisa combinar as seq��ncias de caracteres do CIS e os n�meros "
"do fabricante, no <quote> use a descri��o padr�o </quote> e <quote> Pegue a "
"descri��o do pccarddevs </quote> sabores. "

#. (itstool) path: sect2/title
#: book.translate.xml:23780
#, fuzzy
msgid "Putting it All Together"
msgstr "Colocando tudo junto"

#. (itstool) path: sect2/para
#: book.translate.xml:23782
#, fuzzy
msgid ""
"To add a new device, one must first obtain the identification information "
"from the device. The easiest way to do this is to insert the device into a "
"PC Card or CF slot and issue <command>devinfo -v</command>. Sample output:"
msgstr ""
"Para adicionar um novo dispositivo, � necess�rio primeiro obter as "
"informa��es de identifica��o do dispositivo. A maneira mais f�cil de fazer "
"isso � inserir o dispositivo em um slot e cart�o PC Card ou CF. <command> "
"devinfo -v </command> . Exemplo de sa�da: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23788
#, no-wrap
msgid ""
"        cbb1 pnpinfo vendor=0x104c device=0xac51 subvendor=0x1265 subdevice=0x0300 class=0x060700 at slot=10 function=1\n"
"          cardbus1\n"
"          pccard1\n"
"            unknown pnpinfo manufacturer=0x026f product=0x030c cisvendor=\"BUFFALO\" cisproduct=\"WLI2-CF-S11\" function_type=6 at function=0"
msgstr ""
"        cbb1 pnpinfo vendor=0x104c device=0xac51 subvendor=0x1265 subdevice=0x0300 class=0x060700 at slot=10 function=1\n"
"          cardbus1\n"
"          pccard1\n"
"            unknown pnpinfo manufacturer=0x026f product=0x030c cisvendor=\"BUFFALO\" cisproduct=\"WLI2-CF-S11\" function_type=6 at function=0"

#. (itstool) path: sect2/para
#: book.translate.xml:23793
#, fuzzy
msgid ""
"<literal>manufacturer</literal> and <literal>product</literal> are the "
"numeric IDs for this product, while <literal>cisvendor</literal> and "
"<literal>cisproduct</literal> are the product description strings from the "
"CIS."
msgstr ""
" <literal> fabricante </literal> e <literal> produtos </literal> s�o os IDs "
"num�ricos para este produto, enquanto <literal> cisvendor </literal> e "
"<literal> cisproduto </literal> s�o as strings de descri��o do produto do "
"CIS. "

#. (itstool) path: sect2/para
#: book.translate.xml:23799
#, fuzzy
msgid ""
"Since we first want to prefer the numeric option, first try to construct an "
"entry based on that. The above card has been slightly fictionalized for the "
"purpose of this example. The vendor is BUFFALO, which we see already has an "
"entry:"
msgstr ""
"Como queremos primeiro preferir a op��o num�rica, primeiro tente construir "
"uma entrada com base nisso. O cart�o acima foi ligeiramente ficcionalizado "
"para o prop�sito deste exemplo. O fornecedor � BUFFALO, que j� vemos com uma "
"entrada:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23805
#, no-wrap
msgid "vendor BUFFALO\t\t\t0x026f\tBUFFALO (Melco Corporation)"
msgstr "vendor BUFFALO\t\t\t0x026f\tBUFFALO (Melco Corporation)"

#. (itstool) path: sect2/para
#: book.translate.xml:23807
#, fuzzy
msgid "But there is no entry for this particular card. Instead we find:"
msgstr ""
"Mas n�o h� entrada para este cart�o em particular. Em vez disso, encontramos:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23810
#, no-wrap
msgid ""
"/* BUFFALO */\n"
"product BUFFALO WLI_PCM_S11\t0x0305\tBUFFALO AirStation 11Mbps WLAN\n"
"product BUFFALO LPC_CF_CLT\t0x0307\tBUFFALO LPC-CF-CLT\n"
"product\tBUFFALO\tLPC3_CLT\t0x030a\tBUFFALO LPC3-CLT Ethernet Adapter\n"
"product BUFFALO WLI_CF_S11G\t0x030b\tBUFFALO AirStation 11Mbps CF WLAN"
msgstr ""
"/* BUFFALO */\n"
"product BUFFALO WLI_PCM_S11\t0x0305\tBUFFALO AirStation 11Mbps WLAN\n"
"product BUFFALO LPC_CF_CLT\t0x0307\tBUFFALO LPC-CF-CLT\n"
"product\tBUFFALO\tLPC3_CLT\t0x030a\tBUFFALO LPC3-CLT Ethernet Adapter\n"
"product BUFFALO WLI_CF_S11G\t0x030b\tBUFFALO AirStation 11Mbps CF WLAN"

#. (itstool) path: sect2/para
#: book.translate.xml:23816
#, fuzzy
msgid ""
"To add the device, we can just add this entry to <filename>pccarddevs</"
"filename>:"
msgstr ""
"Para adicionar o dispositivo, podemos adicionar essa entrada para <filename> "
"pccarddevs </filename> : "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23819
#, no-wrap
msgid "product BUFFALO WLI2_CF_S11G\t0x030c\tBUFFALO AirStation ultra 802.11b CF"
msgstr "product BUFFALO WLI2_CF_S11G\t0x030c\tBUFFALO AirStation ultra 802.11b CF"

#. (itstool) path: sect2/para
#: book.translate.xml:23821
#, fuzzy
msgid ""
"Once these steps are complete, the card can be added to the driver. That is "
"a simple operation of adding one line:"
msgstr ""
"Depois que essas etapas forem conclu�das, o cart�o pode ser adicionado ao "
"driver. Essa � uma opera��o simples de adicionar uma linha:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23825
#, no-wrap
msgid ""
"static const struct pccard_product wi_pccard_products[] = {\n"
"\tPCMCIA_CARD(3COM, 3CRWE737A, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_PCM_S11, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_CF_S11G, 0),\n"
"+\tPCMCIA_CARD(BUFFALO, WLI_CF2_S11G, 0),\n"
"\tPCMCIA_CARD(TDK, LAK_CD011WL, 0),\n"
"\t{ NULL }\n"
"};"
msgstr ""
"static const struct pccard_product wi_pccard_products[] = {\n"
"\tPCMCIA_CARD(3COM, 3CRWE737A, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_PCM_S11, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_CF_S11G, 0),\n"
"+\tPCMCIA_CARD(BUFFALO, WLI_CF2_S11G, 0),\n"
"\tPCMCIA_CARD(TDK, LAK_CD011WL, 0),\n"
"\t{ NULL }\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:23834
#, fuzzy
msgid ""
"Note that I have included a '<literal>+</literal>' in the line before the "
"line that I added, but that is simply to highlight the line. Do not add it "
"to the actual driver. Once you have added the line, you can recompile your "
"kernel or module and test it. If the device is recognized and works, please "
"submit a patch. If it does not work, please figure out what is needed to "
"make it work and submit a patch. If the device is not recognized at all, you "
"have done something wrong and should recheck each step."
msgstr ""
"Note que eu inclu� um '; <literal> + </literal> ' na linha antes da linha "
"que eu adicionei, mas isso � simplesmente para destacar a linha. N�o o "
"adicione ao driver real. Depois de adicionar a linha, voc� pode recompilar "
"seu kernel ou m�dulo e test�-lo. Se o dispositivo for reconhecido e "
"funcionar, envie um patch. Se isso n�o funcionar, descubra o que � "
"necess�rio para que funcione e envie um patch. Se o dispositivo n�o for "
"reconhecido, voc� fez algo errado e deve verificar novamente cada etapa. "

#. (itstool) path: sect2/para
#: book.translate.xml:23844
#, fuzzy
msgid ""
"If you are a FreeBSD src committer, and everything appears to be working, "
"then you can commit the changes to the tree. However, there are some minor "
"tricky things to be considered. <filename>pccarddevs</filename> must be "
"committed to the tree first. Then <filename>pccarddevs.h</filename> must be "
"regenerated and committed as a second step, ensuring that the right $FreeBSD"
"$ tag is in the latter file. Finally, commit the additions to the driver."
msgstr ""
"Se voc� � um commitcador do FreeBSD src, e tudo parece estar funcionando, "
"ent�o voc� pode cometer as mudan�as na �rvore. No entanto, existem algumas "
"pequenas coisas complicadas a serem consideradas. <filename> pccarddevs </"
"filename> deve ser comprometido com a primeira �rvore. Ent�o <filename> "
"pccarddevs.h </filename> deve ser regenerado e confirmado como uma segunda "
"etapa, garantindo que a tag $ FreeBSD $ correta esteja no �ltimo arquivo. "
"Finalmente, confirme as adi��es ao driver. "

#. (itstool) path: sect2/title
#: book.translate.xml:23855
#, fuzzy
msgid "Submitting a New Device"
msgstr "Enviando um novo dispositivo"

#. (itstool) path: sect2/para
#: book.translate.xml:23857
#, fuzzy
msgid ""
"Please do not send entries for new devices to the author directly. Instead, "
"submit them as a PR and send the author the PR number for his records. This "
"ensures that entries are not lost. When submitting a PR, it is unnecessary "
"to include the <filename>pccardevs.h</filename> diffs in the patch, since "
"those will be regenerated. It is necessary to include a description of the "
"device, as well as the patches to the client driver. If you do not know the "
"name, use OEM99 as the name, and the author will adjust OEM99 accordingly "
"after investigation. Committers should not commit OEM99, but instead find "
"the highest OEM entry and commit one more than that."
msgstr ""
"Por favor, n�o envie entradas para novos dispositivos para o autor "
"diretamente. Em vez disso, envie-os como um PR e envie ao autor o n�mero PR "
"para seus registros. Isso garante que as entradas n�o sejam perdidas. Ao "
"enviar um PR, n�o � necess�rio incluir a <filename> pccardevs.h </filename> "
"diffs no patch, desde que esses ser�o regenerados. � necess�rio incluir uma "
"descri��o do dispositivo, bem como os patches para o driver cliente. Se voc� "
"n�o souber o nome, use OEM99 como o nome e o autor ajustar� o OEM99 "
"adequadamente ap�s a investiga��o. Os committers n�o devem confirmar o "
"OEM99, mas, em vez disso, encontrar a entrada OEM mais alta e cometer um a "
"mais do que isso. "

#. (itstool) path: part/title
#: book.translate.xml:23911
#, fuzzy
msgid "Appendices"
msgstr "Ap�ndices"

#. (itstool) path: authorgroup/author
#: book.translate.xml:23917
#, fuzzy
#| msgid ""
#| "<personname><firstname>Marshall</firstname><othername role=\"Middle"
#| "\">Kirk</othername><surname>McKusick</surname></personname>"
msgid ""
"<personname> <firstname>Marshall</firstname> <othername role=\"Middle"
"\">Kirk</othername> <surname>McKusick</surname> </personname>"
msgstr ""
"<personname><firstname>Marshall</firstname><othername role=\"Middle\">Kirk</"
"othername><surname>McKusick</surname></personname>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:23924
#, fuzzy
#| msgid ""
#| "<personname><firstname>Keith</firstname><surname>Bostic</surname></"
#| "personname>"
msgid ""
"<personname> <firstname>Keith</firstname> <surname>Bostic</surname> </"
"personname>"
msgstr ""
"<personname><firstname>Keith</firstname><surname>Bostic</surname></"
"personname>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:23930
#, fuzzy
#| msgid ""
#| "<personname><firstname>Michael</firstname><othername role=\"MI\">J</"
#| "othername><surname>Karels</surname></personname>"
msgid ""
"<personname> <firstname>Michael</firstname> <othername role=\"MI\">J</"
"othername> <surname>Karels</surname> </personname>"
msgstr ""
"<personname><firstname>Michael</firstname><othername role=\"MI\">J</"
"othername><surname>Karels</surname></personname>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:23937
#, fuzzy
#| msgid ""
#| "<personname><firstname>John</firstname><othername role=\"MI\">S</"
#| "othername><surname>Quarterman</surname></personname>"
msgid ""
"<personname> <firstname>John</firstname> <othername role=\"MI\">S</"
"othername> <surname>Quarterman</surname> </personname>"
msgstr ""
"<personname><firstname>John</firstname><othername role=\"MI\">S</"
"othername><surname>Quarterman</surname></personname>"

#. (itstool) path: biblioentry/copyright
#: book.translate.xml:23946
msgid ""
"<year>1996</year> <holder>Addison-Wesley Publishing Company, Inc.</holder>"
msgstr ""
"<year>1996</year> <holder>Addison-Wesley Publishing Company, Inc.</holder>"

#. (itstool) path: biblioentry/biblioid
#: book.translate.xml:23951
msgid "0-201-54979-4"
msgstr "0-201-54979-4"

#. (itstool) path: publisher/publishername
#: book.translate.xml:23954
msgid "Addison-Wesley Publishing Company, Inc."
msgstr "Addison-Wesley Publishing Company, Inc."

#. (itstool) path: biblioentry/citetitle
#: book.translate.xml:23958
msgid "The Design and Implementation of the 4.4 BSD Operating System"
msgstr "The Design and Implementation of the 4.4 BSD Operating System"

#. (itstool) path: biblioentry/pagenums
#: book.translate.xml:23961
msgid "1-2"
msgstr "1-2"
