# Sergio Carlavilla <carlavilla@mailbox.org>, 2019. #zanata
# Juan David Jaramillo Ortiz <juanda097@protonmail.ch>, 2020.
# Aaron H Farías Martinez <timido@ubuntu.com>, 2020.
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2020-06-06 11:08-0300\n"
"PO-Revision-Date: 2020-12-18 02:42+0000\n"
"Last-Translator: Aaron H Farías Martinez <timido@ubuntu.com>\n"
"Language-Team: Spanish <https://translate-dev.freebsd.org/projects/"
"freebsd-doc/articles_linux-emulation/es/>\n"
"Language: es_ES\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"
"X-Generator: Weblate 4.3.2\n"

#. Put one translator per line, in the form NAME <EMAIL>, YEAR1, YEAR2
msgctxt "_"
msgid "translator-credits"
msgstr ""
"Sergio Carlavilla carlavilla@FreeBSD.org, 2019\n"
"Aaron H Farias Martinez Timido@ubuntu.com,2020"

#. (itstool) path: info/title
#: article.translate.xml:7
msgid "<trademark class=\"registered\">Linux</trademark> emulation in FreeBSD"
msgstr ""
"Emulación de <trademark class=\"registered\">Linux</trademark> en FreeBSD"

#. (itstool) path: affiliation/address
#: article.translate.xml:15
#, no-wrap
msgid ""
"\n"
"\t  <email>rdivacky@FreeBSD.org</email>\n"
"\t"
msgstr ""
"\n"
"\t  <email>rdivacky@FreeBSD.org</email>\n"
"\t"

#. (itstool) path: info/author
#: article.translate.xml:9
msgid ""
"<personname> <firstname>Roman</firstname> <surname>Divacky</surname> </"
"personname> <affiliation> <_:address-1/> </affiliation>"
msgstr ""
"<personname> <firstname>Roman</firstname> <surname>Divacky</surname> </"
"personname> <affiliation> <_:address-1/> </affiliation>"

#. (itstool) path: legalnotice/para
#: article.translate.xml:22
msgid ""
"Adobe, Acrobat, Acrobat Reader, Flash and PostScript are either registered "
"trademarks or trademarks of Adobe Systems Incorporated in the United States "
"and/or other countries."
msgstr ""
"Adobe, Acrobat, Acrobat Reader, Flash y PostScript son marcas comerciales "
"registradas o marcas comerciales de Adobe Systems Incorporated en los "
"Estados Unidos y / o en otros países."

#. (itstool) path: legalnotice/para
#: article.translate.xml:26
msgid ""
"IBM, AIX, OS/2, PowerPC, PS/2, S/390, and ThinkPad are trademarks of "
"International Business Machines Corporation in the United States, other "
"countries, or both."
msgstr ""
"IBM, AIX, OS / 2, PowerPC, PS / 2, S / 390 y ThinkPad son marcas comerciales "
"de International Business Machines Corporation en los Estados Unidos, otros "
"países o ambos."

#. (itstool) path: legalnotice/para
#: article.translate.xml:30
msgid "FreeBSD is a registered trademark of the FreeBSD Foundation."
msgstr "FreeBSD es una marca registrada de FreeBSD Foundation."

#. (itstool) path: legalnotice/para
#: article.translate.xml:32
msgid "Linux is a registered trademark of Linus Torvalds."
msgstr "Linux es una marca registrada de Linus Torvalds."

#. (itstool) path: legalnotice/para
#: article.translate.xml:34
msgid "NetBSD is a registered trademark of the NetBSD Foundation."
msgstr "NetBSD es una marca registrada de NetBSD Foundation."

#. (itstool) path: legalnotice/para
#: article.translate.xml:36
msgid ""
"RealNetworks, RealPlayer, and RealAudio are the registered trademarks of "
"RealNetworks, Inc."
msgstr ""
"RealNetworks, RealPlayer y RealAudio son marcas comerciales registradas de "
"RealNetworks, Inc."

#. (itstool) path: legalnotice/para
#: article.translate.xml:39
msgid "Oracle is a registered trademark of Oracle Corporation."
msgstr "Oracle es una marca registrada de Oracle Corporation."

#. (itstool) path: legalnotice/para
#: article.translate.xml:41
msgid ""
"Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JRE, JSP, JVM, "
"Netra, OpenJDK, Solaris, StarOffice, SunOS and VirtualBox are trademarks or "
"registered trademarks of Sun Microsystems, Inc. in the United States and "
"other countries."
msgstr ""
"Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JRE, JSP, JVM, "
"Netra, OpenJDK, Solaris, StarOffice, SunOS y VirtualBox son marcas "
"comerciales o marcas comerciales registradas de Sun Microsystems, Inc. en "
"los Estados Unidos y otros países."

#. (itstool) path: legalnotice/para
#: article.translate.xml:46
msgid ""
"Many of the designations used by manufacturers and sellers to distinguish "
"their products are claimed as trademarks. Where those designations appear in "
"this document, and the FreeBSD Project was aware of the trademark claim, the "
"designations have been followed by the <quote>™</quote> or the <quote>®</"
"quote> symbol."
msgstr ""
"Muchas de las designaciones utilizadas por los fabricantes y vendedores para "
"distinguir sus productos se reclaman como marcas comerciales. Cuando esas "
"designaciones aparecen en este documento, y el Proyecto FreeBSD estaba al "
"tanto del reclamo de marca registrada, las designaciones han sido seguidas "
"por el <quote>™</quote> o el <quote>®</quote> símbolo."

#. (itstool) path: info/pubdate
#. (itstool) path: info/releaseinfo
#: article.translate.xml:54 article.translate.xml:56
msgid ""
"$FreeBSD: head/en_US.ISO8859-1/articles/linux-emulation/article.xml 53664 "
"2019-12-07 16:24:22Z carlavilla $"
msgstr ""
"$FreeBSD: head/en_US.ISO8859-1/articles/linux-emulation/article.xml 53664 "
"2019-12-07 16:24:22Z carlavilla $"

#. (itstool) path: abstract/para
#: article.translate.xml:59
msgid ""
"This masters thesis deals with updating the <trademark class=\"registered"
"\">Linux</trademark> emulation layer (the so called <firstterm>Linuxulator</"
"firstterm>). The task was to update the layer to match the functionality of "
"<trademark class=\"registered\">Linux</trademark> 2.6. As a reference "
"implementation, the <trademark class=\"registered\">Linux</trademark> 2.6.16 "
"kernel was chosen. The concept is loosely based on the NetBSD "
"implementation. Most of the work was done in the summer of 2006 as a part of "
"the Google Summer of Code students program. The focus was on bringing the "
"<firstterm>NPTL</firstterm> (new <trademark class=\"registered\">POSIX</"
"trademark> thread library) support into the emulation layer, including "
"<firstterm>TLS</firstterm> (thread local storage), <firstterm>futexes</"
"firstterm> (fast user space mutexes), <firstterm>PID mangling</firstterm>, "
"and some other minor things. Many small problems were identified and fixed "
"in the process. My work was integrated into the main FreeBSD source "
"repository and will be shipped in the upcoming 7.0R release. We, the "
"emulation development team, are working on making the <trademark class="
"\"registered\">Linux</trademark> 2.6 emulation the default emulation layer "
"in FreeBSD."
msgstr ""
"Esta tesis de maestría trata sobre la actualización del <trademark class="
"\"registered\">Linux</trademark> capa de emulación (la llamada "
"<firstterm>Linuxulator</firstterm>). La tarea consistía en actualizar la "
"capa para que coincidiera con la funcionalidad de <trademark class="
"\"registered\">Linux</trademark> 2.6. Como implementación de referencia, el "
"<trademark class=\"registered\">Linux</trademark>Se eligió el kernel 2.6.16. "
"El concepto se basa libremente en la implementación de NetBSD. La mayor "
"parte del trabajo se realizó en el verano de 2006 como parte del programa "
"para estudiantes de Google Summer of Code. El foco estaba en traer el "
"<firstterm>NPTL</firstterm> (new <trademark class=\"registered\">POSIX</"
"trademark> biblioteca de hilos) en la capa de emulación, "
"incluyendo<firstterm>TLS</firstterm> (hilo de almacenamiento local), "
"<firstterm>futexes</firstterm> (mutex rápidos del espacio de usuario), "
"<firstterm>PID destrozar</firstterm>, y algunas otras cosas menores. Se "
"identificaron y solucionaron muchos pequeños problemas en el proceso. Mi "
"trabajo se integró en el repositorio de fuentes principal de FreeBSD y se "
"enviará en la próxima versión 7.0R. Nosotros, el equipo de desarrollo de la "
"emulación, estamos trabajando para hacer <trademark class=\"registered\""
">Linux</trademark> 2.6 emulación la capa de emulación predeterminada en "
"FreeBSD."

#. (itstool) path: sect1/title
#: article.translate.xml:82
msgid "Introduction"
msgstr "Introducción"

#. (itstool) path: sect1/para
#: article.translate.xml:84
msgid ""
"In the last few years the open source <trademark class=\"registered\">UNIX</"
"trademark> based operating systems started to be widely deployed on server "
"and client machines. Among these operating systems I would like to point out "
"two: FreeBSD, for its BSD heritage, time proven code base and many "
"interesting features and <trademark class=\"registered\">Linux</trademark> "
"for its wide user base, enthusiastic open developer community and support "
"from large companies. FreeBSD tends to be used on server class machines "
"serving heavy duty networking tasks with less usage on desktop class "
"machines for ordinary users. While <trademark class=\"registered\">Linux</"
"trademark> has the same usage on servers, but it is used much more by home "
"based users. This leads to a situation where there are many binary only "
"programs available for <trademark class=\"registered\">Linux</trademark> "
"that lack support for FreeBSD."
msgstr ""
"En los últimos años, el código abierto <trademark class=\"registered\">UNIX</"
"trademark> Los sistemas operativos basados en la tecnología comenzaron a "
"implementarse ampliamente en servidores y máquinas cliente. Entre estos "
"sistemas operativos me gustaría señalar dos: FreeBSD, por su herencia BSD, "
"base de código probado en el tiempo y muchas características interesantes y "
"<trademark class=\"registered\">Linux</trademark> por su amplia base de "
"usuarios, una entusiasta comunidad de desarrolladores abierta y el apoyo de "
"grandes empresas. FreeBSD tiende a usarse en máquinas de clase servidor que "
"sirven para tareas de red de trabajo pesado con menos uso en máquinas de "
"clase de escritorio para usuarios normales. Mientras <trademark class="
"\"registered\">Linux</trademark> tiene el mismo uso en los servidores, pero "
"los usuarios domésticos lo utilizan mucho más. Esto conduce a una situación "
"en la que hay muchos programas binarios disponibles para <trademark class="
"\"registered\">Linux</trademark> que carecen de soporte para FreeBSD."

#. (itstool) path: sect1/para
#: article.translate.xml:98
msgid ""
"Naturally, a need for the ability to run <trademark class=\"registered"
"\">Linux</trademark> binaries on a FreeBSD system arises and this is what "
"this thesis deals with: the emulation of the <trademark class=\"registered"
"\">Linux</trademark> kernel in the FreeBSD operating system."
msgstr ""
"Naturalmente, la necesidad de poder correr <trademark class=\"registered\""
">Linux</trademark> binarios en un sistema FreeBSD y esto es de lo que trata "
"esta tesis: la emulación del<trademark class=\"registered\">Linux</"
"trademark>kernel en el sistema operativo FreeBSD."

#. (itstool) path: sect1/para
#: article.translate.xml:103
msgid ""
"During the Summer of 2006 Google Inc. sponsored a project which focused on "
"extending the <trademark class=\"registered\">Linux</trademark> emulation "
"layer (the so called Linuxulator) in FreeBSD to include <trademark class="
"\"registered\">Linux</trademark> 2.6 facilities. This thesis is written as a "
"part of this project."
msgstr ""
"Durante el verano de 2006, Google Inc. patrocinó un proyecto que se centró "
"en ampliar la<trademark class=\"registered\">Linux</trademark> capa de "
"emulación (el llamado Linuxulator) en FreeBSD para incluir <trademark class="
"\"registered\">Linux</trademark> 2.6 instalaciones. Esta tesis está escrita "
"como parte de este proyecto."

#. (itstool) path: sect1/title
#: article.translate.xml:110
msgid "A look inside…"
msgstr "Una mirada al interior …"

#. (itstool) path: sect1/para
#: article.translate.xml:112
msgid ""
"In this section we are going to describe every operating system in question. "
"How they deal with syscalls, trapframes etc., all the low-level stuff. We "
"also describe the way they understand common <trademark class=\"registered"
"\">UNIX</trademark> primitives like what a PID is, what a thread is, etc. In "
"the third subsection we talk about how <trademark class=\"registered\">UNIX</"
"trademark> on <trademark class=\"registered\">UNIX</trademark> emulation "
"could be done in general."
msgstr ""
"En esta sección vamos a describir cada sistema operativo en cuestión. Cómo "
"manejan las llamadas al sistema, los trapframes, etc., todas las cosas de "
"bajo nivel. También describimos la forma en que entienden los<trademark "
"class=\"registered\">UNIX</trademark>primitivas como qué es un PID, qué es "
"un hilo, etc. En la tercera subsección hablamos de cómo<trademark class="
"\"registered\">UNIX</trademark> en <trademark class=\"registered\">UNIX</"
"trademark>la emulación se podría hacer en general."

#. (itstool) path: sect2/title
#: article.translate.xml:120
msgid "What is <trademark class=\"registered\">UNIX</trademark>"
msgstr "Que es<trademark class=\"registered\">UNIX</trademark>"

#. (itstool) path: sect2/para
#: article.translate.xml:122
msgid ""
"<trademark class=\"registered\">UNIX</trademark> is an operating system with "
"a long history that has influenced almost every other operating system "
"currently in use. Starting in the 1960s, its development continues to this "
"day (although in different projects). <trademark class=\"registered\">UNIX</"
"trademark> development soon forked into two main ways: the BSDs and System "
"III/V families. They mutually influenced themselves by growing a common "
"<trademark class=\"registered\">UNIX</trademark> standard. Among the "
"contributions originated in BSD we can name virtual memory, TCP/IP "
"networking, FFS, and many others. The System V branch contributed to SysV "
"interprocess communication primitives, copy-on-write, etc. <trademark class="
"\"registered\">UNIX</trademark> itself does not exist any more but its ideas "
"have been used by many other operating systems world wide thus forming the "
"so called <trademark class=\"registered\">UNIX</trademark>-like operating "
"systems. These days the most influential ones are <trademark class="
"\"registered\">Linux</trademark>, Solaris, and possibly (to some extent) "
"FreeBSD. There are in-company <trademark class=\"registered\">UNIX</"
"trademark> derivatives (AIX, HP-UX etc.), but these have been more and more "
"migrated to the aforementioned systems. Let us summarize typical <trademark "
"class=\"registered\">UNIX</trademark> characteristics."
msgstr ""
"<trademark class=\"registered\">UNIX</trademark>es un sistema operativo con "
"una larga historia que ha influido en casi todos los demás sistemas "
"operativos actualmente en uso. A partir de la década de 1960, su desarrollo "
"continúa hasta la actualidad (aunque en diferentes proyectos). <trademark "
"class=\"registered\">UNIX</trademark> El desarrollo pronto se bifurcó en dos "
"formas principales: las familias BSD y System III/V. Se influenciaron "
"mutuamente al cultivar un <trademark class=\"registered\">UNIX</trademark> "
"estándar. Entre las contribuciones originadas en BSD podemos nombrar memoria "
"virtual, redes TCP/IP, FFS y muchas otras. La rama System V contribuyó a las "
"primitivas de comunicación entre procesos de SysV, copia en escritura, etc.. "
"<trademark class=\"registered\">UNIX</trademark> en sí ya no existe, pero "
"sus ideas han sido utilizadas por muchos otros sistemas operativos en todo "
"el mundo, formando así el llamado <trademark class=\"registered\""
">UNIX</trademark>-como los sistemas operativos. En estos días los más "
"influyentes son<trademark class=\"registered\">Linux</trademark>, Solaris y "
"posiblemente (hasta cierto punto) FreeBSD. Hay en la empresa <trademark "
"class=\"registered\">UNIX</trademark> derivados (AIX, HP-UX, etc.), pero "
"estos se han migrado cada vez más a los sistemas antes mencionados. "
"Resumamos los típicos<trademark class=\"registered\">UNIX</trademark> "
"caracteristicas."

#. (itstool) path: sect2/title
#. (itstool) path: sect3/title
#: article.translate.xml:143 article.translate.xml:312
#: article.translate.xml:491
msgid "Technical details"
msgstr "Detalles técnicos"

#. (itstool) path: sect2/para
#: article.translate.xml:145
msgid ""
"Every running program constitutes a process that represents a state of the "
"computation. Running process is divided between kernel-space and user-space. "
"Some operations can be done only from kernel space (dealing with hardware "
"etc.), but the process should spend most of its lifetime in the user space. "
"The kernel is where the management of the processes, hardware, and low-level "
"details take place. The kernel provides a standard unified <trademark class="
"\"registered\">UNIX</trademark> API to the user space. The most important "
"ones are covered below."
msgstr ""
"Cada programa en ejecución constituye un proceso que representa un estado "
"del cálculo. El proceso en ejecución se divide entre el espacio del núcleo y "
"el espacio del usuario. Algunas operaciones solo se pueden realizar desde el "
"espacio del kernel (que se ocupa de hardware, etc.), pero el proceso debería "
"pasar la mayor parte de su vida en el espacio del usuario. El kernel es "
"donde se lleva a cabo la gestión de los procesos, el hardware y los detalles "
"de bajo nivel. El kernel proporciona un estándar unificado<trademark class="
"\"registered\">UNIX</trademark>API al espacio de usuario. Los más "
"importantes se tratan a continuación."

#. (itstool) path: sect3/title
#: article.translate.xml:156
msgid "Communication between kernel and user space process"
msgstr "Comunicación entre el kernel y el proceso de espacio de usuario"

#. (itstool) path: sect3/para
#: article.translate.xml:159
msgid ""
"Common <trademark class=\"registered\">UNIX</trademark> API defines a "
"syscall as a way to issue commands from a user space process to the kernel. "
"The most common implementation is either by using an interrupt or "
"specialized instruction (think of <literal>SYSENTER</literal>/"
"<literal>SYSCALL</literal> instructions for ia32). Syscalls are defined by a "
"number. For example in FreeBSD, the syscall number 85 is the "
"<citerefentry><refentrytitle>swapon</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> syscall and the syscall number 132 is "
"<citerefentry><refentrytitle>mkfifo</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>. Some syscalls need parameters, which are passed from the user-"
"space to the kernel-space in various ways (implementation dependant). "
"Syscalls are synchronous."
msgstr ""
"Común <trademark class=\"registered\">UNIX</trademark> La API define una "
"llamada al sistema como una forma de emitir comandos desde un proceso de "
"espacio de usuario al kernel. La implementación más común es usar una "
"interrupción o una instrucción especializada (piense en "
"<literal>SYSENTER</literal><literal>SYSCALL</literal>instrucciones para ia32)"
". Las llamadas al sistema se definen mediante un número. Por ejemplo, en "
"FreeBSD, el número de llamada al sistema 85 es "
"el<citerefentry>swapon</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>syscall y el número de syscall 132 es "
"<citerefentry><refentrytitle>mkfifo</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> Algunas llamadas al sistema necesitan parámetros, que se pasan "
"del espacio del usuario al espacio del kernel de varias formas (según la "
"implementación). Las llamadas al sistema son sincrónicas."

#. (itstool) path: sect3/para
#: article.translate.xml:172
msgid ""
"Another possible way to communicate is by using a <firstterm>trap</"
"firstterm>. Traps occur asynchronously after some event occurs (division by "
"zero, page fault etc.). A trap can be transparent for a process (page fault) "
"or can result in a reaction like sending a <firstterm>signal</firstterm> "
"(division by zero)."
msgstr ""
"Otra forma posible de comunicarse es mediante un<firstterm>trap</"
"firstterm>Las trampas ocurren de forma asincrónica después de que ocurre "
"algún evento (división por cero, falla de página, etc.). Una trampa puede "
"ser transparente para un proceso (error de página) o puede resultar en una "
"reacción como enviar una<firstterm>signal</firstterm> (división por cero)."

#. (itstool) path: sect3/title
#: article.translate.xml:181
msgid "Communication between processes"
msgstr "Comunicación entre procesos"

#. (itstool) path: sect3/para
#: article.translate.xml:183
msgid ""
"There are other APIs (System V IPC, shared memory etc.) but the single most "
"important API is signal. Signals are sent by processes or by the kernel and "
"received by processes. Some signals can be ignored or handled by a user "
"supplied routine, some result in a predefined action that cannot be altered "
"or ignored."
msgstr ""
"Hay otras API (System V IPC, memoria compartida, etc.) pero la API más "
"importante es la señal. Las señales son enviadas por procesos o por el "
"kernel y recibidas por procesos. Algunas señales pueden ser ignoradas o "
"manejadas por una rutina proporcionada por el usuario, otras dan como "
"resultado una acción predefinida que no se puede alterar ni ignorar."

#. (itstool) path: sect3/title
#: article.translate.xml:192
msgid "Process management"
msgstr "Gestión de proceso"

#. (itstool) path: sect3/para
#: article.translate.xml:194
msgid ""
"Kernel instances are processed first in the system (so called init). Every "
"running process can create its identical copy using the "
"<citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> syscall. Some slightly modified versions of this syscall were "
"introduced but the basic semantic is the same. Every running process can "
"morph into some other process using the <citerefentry><refentrytitle>exec</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry> syscall. Some "
"modifications of this syscall were introduced but all serve the same basic "
"purpose. Processes end their lives by calling the "
"<citerefentry><refentrytitle>exit</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> syscall. Every process is identified by a unique number called "
"PID. Every process has a defined parent (identified by its PID)."
msgstr ""
"Las instancias de kernel se procesan primero en el sistema (llamado init). "
"Cada proceso en ejecución puede crear su copia idéntica utilizando el "
"<citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> syscall. Se introdujeron algunas versiones ligeramente "
"modificadas de esta llamada al sistema, pero la semántica básica es la "
"misma. Cada proceso en ejecución puede transformarse en algún otro proceso "
"utilizando el "
"<citerefentry><refentrytitle>exec</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry> syscall. Se introdujeron algunas modificaciones de esta "
"llamada al sistema, pero todas tienen el mismo propósito básico. Los "
"procesos terminan sus vidas llamando al "
"<citerefentry><refentrytitle>exit</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> syscall. Cada proceso está identificado por un número único "
"llamado PID. Cada proceso tiene un padre definido (identificado por su PID)."

#. (itstool) path: sect3/title
#: article.translate.xml:208
msgid "Thread management"
msgstr "Gestión de subprocesos"

#. (itstool) path: sect3/para
#: article.translate.xml:210
msgid ""
"Traditional <trademark class=\"registered\">UNIX</trademark> does not define "
"any API nor implementation for threading, while <trademark class=\"registered"
"\">POSIX</trademark> defines its threading API but the implementation is "
"undefined. Traditionally there were two ways of implementing threads. "
"Handling them as separate processes (1:1 threading) or envelope the whole "
"thread group in one process and managing the threading in userspace (1:N "
"threading). Comparing main features of each approach:"
msgstr ""
"Tradicional<trademark class=\"registered\">UNIX</trademark>no define ninguna "
"API ni implementación para subprocesos, mientras que<trademark class="
"\"registered\">POSIX</trademark>define su API de subprocesos, pero la "
"implementación no está definida. Tradicionalmente, había dos formas de "
"implementar subprocesos. Manejarlos como procesos separados (subprocesos 1: "
"1) o envolver todo el grupo de subprocesos en un proceso y administrar el "
"subproceso en el espacio de usuario (subprocesos 1: N). Comparación de las "
"principales características de cada enfoque:"

#. (itstool) path: sect3/para
#: article.translate.xml:219
msgid "1:1 threading"
msgstr "Roscado 1: 1"

#. (itstool) path: listitem/para
#: article.translate.xml:223
msgid "- heavyweight threads"
msgstr "- hilos de peso pesado"

#. (itstool) path: listitem/para
#: article.translate.xml:226
msgid ""
"- the scheduling cannot be altered by the user (slightly mitigated by the "
"<trademark class=\"registered\">POSIX</trademark> API)"
msgstr ""
"- la programación no puede ser alterada por el usuario (levemente mitigado "
"por el<trademark class=\"registered\">POSIX</trademark>API)"

#. (itstool) path: listitem/para
#: article.translate.xml:230
msgid "+ no syscall wrapping necessary"
msgstr "+ no es necesario envolver syscall"

#. (itstool) path: listitem/para
#: article.translate.xml:233
msgid "+ can utilize multiple CPUs"
msgstr "+ puede utilizar varias CPU"

#. (itstool) path: sect3/para
#: article.translate.xml:237
msgid "1:N threading"
msgstr "1: N roscado"

#. (itstool) path: listitem/para
#: article.translate.xml:241
msgid "+ lightweight threads"
msgstr "+ hilos ligeros"

#. (itstool) path: listitem/para
#: article.translate.xml:244
msgid "+ scheduling can be easily altered by the user"
msgstr "+ el usuario puede modificar fácilmente la programación"

#. (itstool) path: listitem/para
#: article.translate.xml:248
msgid "- syscalls must be wrapped"
msgstr "- las llamadas al sistema deben estar envueltas"

#. (itstool) path: listitem/para
#: article.translate.xml:251
msgid "- cannot utilize more than one CPU"
msgstr "- no puede utilizar más de una CPU"

#. (itstool) path: sect2/title
#: article.translate.xml:258
msgid "What is FreeBSD?"
msgstr "¿Qué es FreeBSD?"

#. (itstool) path: sect2/para
#: article.translate.xml:260
msgid ""
"The FreeBSD project is one of the oldest open source operating systems "
"currently available for daily use. It is a direct descendant of the genuine "
"<trademark class=\"registered\">UNIX</trademark> so it could be claimed that "
"it is a true <trademark class=\"registered\">UNIX</trademark> although "
"licensing issues do not permit that. The start of the project dates back to "
"the early 1990's when a crew of fellow BSD users patched the 386BSD "
"operating system. Based on this patchkit a new operating system arose named "
"FreeBSD for its liberal license. Another group created the NetBSD operating "
"system with different goals in mind. We will focus on FreeBSD."
msgstr ""
"El proyecto FreeBSD es uno de los sistemas operativos de código abierto más "
"antiguos disponibles actualmente para uso diario. Es un descendiente directo "
"del genuino<trademark class=\"registered\">UNIX</trademark>por lo que podría "
"afirmarse que es un verdadero<trademark class=\"registered\">UNIX</"
"trademark>aunque los problemas de licencias no lo permiten. El inicio del "
"proyecto se remonta a principios de la década de 1990 cuando un equipo de "
"usuarios de BSD parchó el sistema operativo 386BSD. Basado en este patchkit, "
"surgió un nuevo sistema operativo llamado FreeBSD por su licencia liberal. "
"Otro grupo creó el sistema operativo NetBSD con diferentes objetivos en "
"mente. Nos centraremos en FreeBSD."

#. (itstool) path: sect2/para
#: article.translate.xml:271
msgid ""
"FreeBSD is a modern <trademark class=\"registered\">UNIX</trademark>-based "
"operating system with all the features of <trademark class=\"registered"
"\">UNIX</trademark>. Preemptive multitasking, multiuser facilities, TCP/IP "
"networking, memory protection, symmetric multiprocessing support, virtual "
"memory with merged VM and buffer cache, they are all there. One of the "
"interesting and extremely useful features is the ability to emulate other "
"<trademark class=\"registered\">UNIX</trademark>-like operating systems. As "
"of December 2006 and 7-CURRENT development, the following emulation "
"functionalities are supported:"
msgstr ""
"FreeBSD es un moderno<trademark class=\"registered\">UNIX</trademark>sistema "
"operativo basado en todas las características de<trademark class=\"registered"
"\">UNIX</trademark>Multitarea preventiva, instalaciones multiusuario, redes "
"TCP / IP, protección de memoria, soporte de multiprocesamiento simétrico, "
"memoria virtual con VM fusionada y caché de búfer, todo está ahí. Una de las "
"características interesantes y extremadamente útiles es la capacidad de "
"emular otros<trademark class=\"registered\">UNIX</trademark>como los "
"sistemas operativos. A diciembre de 2006 y al desarrollo 7-CURRENT, se "
"admiten las siguientes funcionalidades de emulación:"

#. (itstool) path: listitem/para
#: article.translate.xml:283
msgid "FreeBSD/i386 emulation on FreeBSD/amd64"
msgstr "Emulación FreeBSD/i386 en FreeBSD/amd64"

#. (itstool) path: listitem/para
#: article.translate.xml:286
msgid "FreeBSD/i386 emulation on FreeBSD/ia64"
msgstr "Emulación FreeBSD/i386 en FreeBSD/ia64"

#. (itstool) path: listitem/para
#: article.translate.xml:289
msgid ""
"<trademark class=\"registered\">Linux</trademark>-emulation of <trademark "
"class=\"registered\">Linux</trademark> operating system on FreeBSD"
msgstr ""
"<trademark class=\"registered\">Linux</trademark>emulación de<trademark "
"class=\"registered\">Linux</trademark>sistema operativo en FreeBSD"

#. (itstool) path: listitem/para
#: article.translate.xml:293
msgid "NDIS-emulation of Windows networking drivers interface"
msgstr "Emulación NDIS de la interfaz de controladores de red de Windows"

#. (itstool) path: listitem/para
#: article.translate.xml:297
msgid "NetBSD-emulation of NetBSD operating system"
msgstr "Emulación NetBSD del sistema operativo NetBSD"

#. (itstool) path: listitem/para
#: article.translate.xml:300
msgid "PECoff-support for PECoff FreeBSD executables"
msgstr "Soporte PECoff para ejecutables PECoff FreeBSD"

#. (itstool) path: listitem/para
#: article.translate.xml:303
msgid ""
"SVR4-emulation of System V revision 4 <trademark class=\"registered\">UNIX</"
"trademark>"
msgstr ""
"Emulación SVR4 de System V revisión 4<trademark class=\"registered\""
">UNIX</trademark>"

#. (itstool) path: sect2/para
#: article.translate.xml:307
msgid ""
"Actively developed emulations are the <trademark class=\"registered\">Linux</"
"trademark> layer and various FreeBSD-on-FreeBSD layers. Others are not "
"supposed to work properly nor be usable these days."
msgstr ""
"Las emulaciones desarrolladas activamente son las<trademark class="
"\"registered\">Linux</trademark>layer y varias capas FreeBSD-on-FreeBSD. Se "
"supone que otros no funcionan correctamente ni se pueden utilizar en estos "
"días."

#. (itstool) path: sect3/para
#: article.translate.xml:314
msgid ""
"FreeBSD is traditional flavor of <trademark class=\"registered\">UNIX</"
"trademark> in the sense of dividing the run of processes into two halves: "
"kernel space and user space run. There are two types of process entry to the "
"kernel: a syscall and a trap. There is only one way to return. In the "
"subsequent sections we will describe the three gates to/from the kernel. The "
"whole description applies to the i386 architecture as the Linuxulator only "
"exists there but the concept is similar on other architectures. The "
"information was taken from [1] and the source code."
msgstr ""
"FreeBSD es el sabor tradicional de<trademark class=\"registered\">UNIX</"
"trademark>en el sentido de dividir la ejecución de procesos en dos mitades: "
"espacio de kernel y ejecución de espacio de usuario. Hay dos tipos de "
"entrada de proceso al kernel: una llamada al sistema y una trampa. Solo hay "
"una forma de regresar. En las secciones siguientes describiremos las tres "
"puertas hacia / desde el kernel. La descripción completa se aplica a la "
"arquitectura i386 ya que el Linuxulator solo existe allí, pero el concepto "
"es similar en otras arquitecturas. La información se tomó de [1] y el código "
"fuente."

#. (itstool) path: sect4/title
#: article.translate.xml:326
msgid "System entries"
msgstr "Entradas del sistema"

#. (itstool) path: sect4/para
#: article.translate.xml:328
msgid ""
"FreeBSD has an abstraction called an execution class loader, which is a "
"wedge into the <citerefentry><refentrytitle>execve</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> syscall. This employs "
"a structure <literal>sysentvec</literal>, which describes an executable ABI. "
"It contains things like errno translation table, signal translation table, "
"various functions to serve syscall needs (stack fixup, coredumping, etc.). "
"Every ABI the FreeBSD kernel wants to support must define this structure, as "
"it is used later in the syscall processing code and at some other places. "
"System entries are handled by trap handlers, where we can access both the "
"kernel-space and the user-space at once."
msgstr ""
"FreeBSD tiene una abstracción llamada cargador de clases de ejecución, que "
"es una cuña en el<citerefentry><refentrytitle>execve</refentrytitle><manvolnu"
"m>2</manvolnum></citerefentry>syscall. Esto emplea una "
"estructura<literal>sysentvec</literal>que describe una ABI ejecutable. "
"Contiene cosas como tabla de traducción de errno, tabla de traducción de "
"señales, varias funciones para satisfacer las necesidades de llamadas al "
"sistema (reparación de pila, volcado de núcleos, etc.). Cada ABI que el "
"kernel de FreeBSD desee admitir debe definir esta estructura, ya que se usa "
"más adelante en el código de procesamiento de llamadas al sistema y en otros "
"lugares. Las entradas del sistema son manejadas por controladores de "
"trampas, donde podemos acceder tanto al espacio del núcleo como al espacio "
"del usuario a la vez."

#. (itstool) path: sect4/title
#: article.translate.xml:343 article.translate.xml:502
msgid "Syscalls"
msgstr "llamadas al sistema"

#. (itstool) path: sect4/para
#: article.translate.xml:345
msgid ""
"Syscalls on FreeBSD are issued by executing interrupt <literal>0x80</"
"literal> with register <varname>%eax</varname> set to a desired syscall "
"number with arguments passed on the stack."
msgstr ""
"Las llamadas al sistema en FreeBSD se emiten ejecutando "
"interrupt<literal>0x80</literal>con registro<varname>%eax</"
"varname>establecido en un número de llamada al sistema deseado con "
"argumentos pasados en la pila."

#. (itstool) path: sect4/para
#: article.translate.xml:350
msgid ""
"When a process issues an interrupt <literal>0x80</literal>, the "
"<literal>int0x80</literal> syscall trap handler is issued (defined in "
"<filename>sys/i386/i386/exception.s</filename>), which prepares arguments (i."
"e. copies them on to the stack) for a call to a C function "
"<citerefentry><refentrytitle>syscall</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> (defined in <filename>sys/i386/i386/trap.c</"
"filename>), which processes the passed in trapframe. The processing consists "
"of preparing the syscall (depending on the <literal>sysvec</literal> entry), "
"determining if the syscall is 32-bit or 64-bit one (changes size of the "
"parameters), then the parameters are copied, including the syscall. Next, "
"the actual syscall function is executed with processing of the return code "
"(special cases for <literal>ERESTART</literal> and <literal>EJUSTRETURN</"
"literal> errors). Finally an <literal>userret()</literal> is scheduled, "
"switching the process back to the users-pace. The parameters to the actual "
"syscall handler are passed in the form of <literal>struct thread *td</"
"literal>, <literal>struct syscall args *</literal> arguments where the "
"second parameter is a pointer to the copied in structure of parameters."
msgstr ""
"Cuando un proceso emite una interrupción <literal>0x80</literal>, el "
"<literal>int0x80</literal>Se emite el controlador de capturas syscall ("
"definido en <filename>sys/i386/i386/exception.s</filename>), que prepara "
"argumentos (es decir, los copia en la pila) para una llamada a una función C "
"<citerefentry><refentrytitle>syscall</refentrytitle><manvolnum>2</manvolnum><"
"/citerefentry> (definido en <filename>sys/i386/i386/trap.c</filename>), que "
"procesa el pasado en trampilla. El procesamiento consiste en preparar el "
"syscall (dependiendo del <literal>sysvec</literal> entrada), Al determinar "
"si la llamada al sistema es de 32 bits o de 64 bits (cambia el tamaño de los "
"parámetros), los parámetros se copian, incluida la llamada al sistema. A "
"continuación, la función syscall real se ejecuta con el procesamiento del "
"código de retorno (casos especiales para <literal>ERESTART</literal> y "
"<literal>EJUSTRETURN</literal> errores). Finalmente un <literal>userret()</"
"literal> está programado, cambiando el proceso de nuevo al ritmo de los "
"usuarios. Los parámetros del controlador de llamada al sistema real se pasan "
"en forma de<literal>struct thread *td</literal>, <literal>struct syscall "
"args *</literal> argumentos donde el segundo parámetro es un puntero a la "
"estructura de parámetros copiada."

#. (itstool) path: sect4/title
#. (itstool) path: sect2/title
#: article.translate.xml:376 article.translate.xml:548
#: article.translate.xml:1482
msgid "Traps"
msgstr "trampas"

#. (itstool) path: sect4/para
#: article.translate.xml:378
msgid ""
"Handling of traps in FreeBSD is similar to the handling of syscalls. "
"Whenever a trap occurs, an assembler handler is called. It is chosen between "
"alltraps, alltraps with regs pushed or calltrap depending on the type of the "
"trap. This handler prepares arguments for a call to a C function "
"<literal>trap()</literal> (defined in <filename>sys/i386/i386/trap.c</"
"filename>), which then processes the occurred trap. After the processing it "
"might send a signal to the process and/or exit to userland using "
"<literal>userret()</literal>."
msgstr ""
"El manejo de trampas en FreeBSD es similar al manejo de llamadas al sistema. "
"Siempre que ocurre una trampa, se llama a un manejador de ensamblador. Se "
"elige entre todas las trampas, todas las trampas con regs presionadas o "
"trampa de llamadas dependiendo del tipo de trampa. Este controlador prepara "
"argumentos para una llamada a una función C<literal>trap()</literal>("
"definido en<filename>sys/i386/i386/trap.c</filename>, que luego procesa la "
"trampa ocurrida. Después del procesamiento, puede enviar una señal al "
"proceso y / o salir al área de usuario usando<literal>userret()</literal>."

#. (itstool) path: sect4/title
#: article.translate.xml:391 article.translate.xml:558
msgid "Exits"
msgstr "Salida"

#. (itstool) path: sect4/para
#: article.translate.xml:393
msgid ""
"Exits from kernel to userspace happen using the assembler routine "
"<literal>doreti</literal> regardless of whether the kernel was entered via a "
"trap or via a syscall. This restores the program status from the stack and "
"returns to the userspace."
msgstr ""
"Las salidas del kernel al espacio de usuario ocurren usando la rutina del "
"ensamblador<literal>doreti</literal>independientemente de si se ingresó al "
"kernel mediante una trampa o mediante una llamada al sistema. Esto restaura "
"el estado del programa de la pila y vuelve al espacio de usuario."

#. (itstool) path: sect4/title
#: article.translate.xml:401 article.translate.xml:569
msgid "<trademark class=\"registered\">UNIX</trademark> primitives"
msgstr "<trademark class=\"registered\">UNIX</trademark>primitivos"

#. (itstool) path: sect4/para
#: article.translate.xml:403
msgid ""
"FreeBSD operating system adheres to the traditional <trademark class="
"\"registered\">UNIX</trademark> scheme, where every process has a unique "
"identification number, the so called <firstterm>PID</firstterm> (Process "
"ID). PID numbers are allocated either linearly or randomly ranging from "
"<literal>0</literal> to <literal>PID_MAX</literal>. The allocation of PID "
"numbers is done using linear searching of PID space. Every thread in a "
"process receives the same PID number as result of the "
"<citerefentry><refentrytitle>getpid</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> call."
msgstr ""
"El sistema operativo FreeBSD se adhiere al tradicional <trademark class="
"\"registered\">UNIX</trademark> esquema, donde cada proceso tiene un número "
"de identificación único, el llamado <firstterm>PID</firstterm> ("
"Identificacion de proceso). Los números PID se asignan de forma lineal o "
"aleatoria desde <literal>0</literal> a <literal>PID_MAX</literal>. La "
"asignación de números PID se realiza mediante una búsqueda lineal del "
"espacio PID. Cada hilo en un proceso recibe el mismo número PID como "
"resultado de la "
"<citerefentry><refentrytitle>getpid</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> llamada."

#. (itstool) path: sect4/para
#: article.translate.xml:413
msgid ""
"There are currently two ways to implement threading in FreeBSD. The first "
"way is M:N threading followed by the 1:1 threading model. The default "
"library used is M:N threading (<literal>libpthread</literal>) and you can "
"switch at runtime to 1:1 threading (<literal>libthr</literal>). The plan is "
"to switch to 1:1 library by default soon. Although those two libraries use "
"the same kernel primitives, they are accessed through different API(es). The "
"M:N library uses the <literal>kse_*</literal> family of syscalls while the "
"1:1 library uses the <literal>thr_*</literal> family of syscalls. Because of "
"this, there is no general concept of thread ID shared between kernel and "
"userspace. Of course, both threading libraries implement the pthread thread "
"ID API. Every kernel thread (as described by <literal>struct thread</"
"literal>) has td tid identifier but this is not directly accessible from "
"userland and solely serves the kernel's needs. It is also used for 1:1 "
"threading library as pthread's thread ID but handling of this is internal to "
"the library and cannot be relied on."
msgstr ""
"Actualmente hay dos formas de implementar subprocesos en FreeBSD. La primera "
"forma es el subproceso M: N seguido del modelo de subprocesamiento 1: 1. La "
"biblioteca predeterminada utilizada es el subproceso M: "
"N(<literal>libpthread</literal>) y puede cambiar en tiempo de ejecución a "
"subprocesos 1: 1 (<literal>libthr</literal>). el plan es cambiar pronto a la "
"biblioteca 1: 1 por defecto. Aunque esas dos bibliotecas usan las mismas "
"primitivas del kernel, se accede a ellas a través de diferentes API (s). La "
"biblioteca M: N usa la <literal>kse_*</literal> familia de llamadas al "
"sistema, mientras que la biblioteca 1: 1 utiliza la <literal>thr_*</literal> "
"familia de llamadas al sistema. Debido a esto, no existe un concepto general "
"de ID de hilo compartido entre el kernel y el espacio de usuario. Por "
"supuesto, ambas bibliotecas de subprocesos implementan la API de ID de "
"subprocesos pthread. Cada hilo del kernel (como lo describe <literal>struct "
"thread</literal>) tiene un identificador td tid pero no es directamente "
"accesible desde el área de usuario y solo sirve a las necesidades del "
"kernel. También se usa para la biblioteca de subprocesos 1: 1 como ID de "
"subproceso de pthread, pero el manejo de esto es interno a la biblioteca y "
"no se puede confiar en él."

#. (itstool) path: sect4/para
#: article.translate.xml:434
msgid ""
"As stated previously there are two implementations of threading in FreeBSD. "
"The M:N library divides the work between kernel space and userspace. Thread "
"is an entity that gets scheduled in the kernel but it can represent various "
"number of userspace threads. M userspace threads get mapped to N kernel "
"threads thus saving resources while keeping the ability to exploit "
"multiprocessor parallelism. Further information about the implementation can "
"be obtained from the man page or [1]. The 1:1 library directly maps a "
"userland thread to a kernel thread thus greatly simplifying the scheme. None "
"of these designs implement a fairness mechanism (such a mechanism was "
"implemented but it was removed recently because it caused serious slowdown "
"and made the code more difficult to deal with)."
msgstr ""
"Como se indicó anteriormente, hay dos implementaciones de subprocesamiento "
"en FreeBSD. La biblioteca M: N divide el trabajo entre el espacio del kernel "
"y el espacio de usuario. Thread es una entidad que se programa en el kernel, "
"pero puede representar varios subprocesos del espacio de usuario. Los "
"subprocesos del espacio de usuario M se asignan a los subprocesos del núcleo "
"N, lo que ahorra recursos y mantiene la capacidad de explotar el paralelismo "
"de multiprocesador. Se puede obtener más información sobre la implementación "
"en la página del manual o en [1]. La biblioteca 1: 1 mapea directamente un "
"subproceso de usuario a un subproceso del kernel, lo que simplifica "
"enormemente el esquema. Ninguno de estos diseños implementa un mecanismo de "
"equidad (se implementó un mecanismo de este tipo, pero se eliminó "
"recientemente porque causaba una grave desaceleración y hacía que el código "
"fuera más difícil de manejar)."

#. (itstool) path: sect2/title
#: article.translate.xml:454
msgid "What is <trademark class=\"registered\">Linux</trademark>"
msgstr "Que es <trademark class=\"registered\">Linux</trademark>"

#. (itstool) path: sect2/para
#: article.translate.xml:456
msgid ""
"<trademark class=\"registered\">Linux</trademark> is a <trademark class="
"\"registered\">UNIX</trademark>-like kernel originally developed by Linus "
"Torvalds, and now being contributed to by a massive crowd of programmers all "
"around the world. From its mere beginnings to today, with wide support from "
"companies such as IBM or Google, <trademark class=\"registered\">Linux</"
"trademark> is being associated with its fast development pace, full hardware "
"support and benevolent dictator model of organization."
msgstr ""
"<trademark class=\"registered\">Linux</trademark> es una <trademark class="
"\"registered\">UNIX</trademark>como el kernel desarrollado originalmente por "
"Linus Torvalds, y al que ahora contribuyen una multitud masiva de "
"programadores de todo el mundo. Desde sus meros inicios hasta hoy, con un "
"amplio apoyo de empresas como IBM o Google, <trademark class=\"registered\""
">Linux</trademark>se asocia con su rápido ritmo de desarrollo, soporte "
"completo de hardware y modelo de organización de dictador benevolente."

#. (itstool) path: sect2/para
#: article.translate.xml:464
msgid ""
"<trademark class=\"registered\">Linux</trademark> development started in "
"1991 as a hobbyist project at University of Helsinki in Finland. Since then "
"it has obtained all the features of a modern <trademark class=\"registered"
"\">UNIX</trademark>-like OS: multiprocessing, multiuser support, virtual "
"memory, networking, basically everything is there. There are also highly "
"advanced features like virtualization etc."
msgstr ""
"<trademark class=\"registered\">Linux</trademark>El desarrollo comenzó en "
"1991 como un proyecto de aficionados en la Universidad de Helsinki en "
"Finlandia. Desde entonces ha obtenido todas las características de un "
"moderno<trademark class=\"registered\">UNIX</trademark>como SO: "
"multiprocesamiento, soporte multiusuario, memoria virtual, redes, "
"básicamente todo está ahí. También hay funciones muy avanzadas como "
"virtualización, etc."

#. (itstool) path: sect2/para
#: article.translate.xml:471
msgid ""
"As of 2006 <trademark class=\"registered\">Linux</trademark> seems to be the "
"most widely used open source operating system with support from independent "
"software vendors like Oracle, RealNetworks, Adobe, etc. Most of the "
"commercial software distributed for <trademark class=\"registered\">Linux</"
"trademark> can only be obtained in a binary form so recompilation for other "
"operating systems is impossible."
msgstr ""
"Desde 2006 <trademark class=\"registered\">Linux</trademark>parece ser el "
"sistema operativo de código abierto más utilizado con el apoyo de "
"proveedores de software independientes como Oracle, RealNetworks, Adobe, "
"etc. La mayor parte del software comercial distribuido para<trademark class="
"\"registered\">Linux</trademark>solo se puede obtener en forma binaria, por "
"lo que la recopilación para otros sistemas operativos es imposible."

#. (itstool) path: sect2/para
#: article.translate.xml:478
msgid ""
"Most of the <trademark class=\"registered\">Linux</trademark> development "
"happens in a <application>Git</application> version control system. "
"<application>Git</application> is a distributed system so there is no "
"central source of the <trademark class=\"registered\">Linux</trademark> "
"code, but some branches are considered prominent and official. The version "
"number scheme implemented by <trademark class=\"registered\">Linux</"
"trademark> consists of four numbers A.B.C.D. Currently development happens "
"in 2.6.C.D, where C represents major version, where new features are added "
"or changed while D is a minor version for bugfixes only."
msgstr ""
"La mayoría de los <trademark class=\"registered\">Linux</trademark> el "
"desarrollo ocurre en un <application>Git</application> sistema de control de "
"versiones.<application>Git</application> es un sistema distribuido, por lo "
"que no hay una fuente central de <trademark class=\"registered\">Linux</"
"trademark>código, pero algunas ramas se consideran prominentes y oficiales. "
"El esquema de número de versión implementado por <trademark class="
"\"registered\">Linux</trademark> consta de cuatro números A.B.C.D. "
"Actualmente, el desarrollo ocurre en 2.6.C.D, donde C representa la versión "
"principal, donde se agregan o cambian nuevas características, mientras que D "
"es una versión secundaria solo para corrección de errores."

#. (itstool) path: sect2/para
#: article.translate.xml:488
msgid "More information can be obtained from [3]."
msgstr "Se puede obtener más información en [3]."

#. (itstool) path: sect3/para
#: article.translate.xml:493
msgid ""
"<trademark class=\"registered\">Linux</trademark> follows the traditional "
"<trademark class=\"registered\">UNIX</trademark> scheme of dividing the run "
"of a process in two halves: the kernel and user space. The kernel can be "
"entered in two ways: via a trap or via a syscall. The return is handled only "
"in one way. The further description applies to <trademark class=\"registered"
"\">Linux</trademark> 2.6 on the <trademark>i386</trademark> architecture. "
"This information was taken from [2]."
msgstr ""
"<trademark class=\"registered\">Linux</trademark>Sigue lo "
"tradicional<trademark class=\"registered\">UNIX</trademark> esquema de "
"dividir la ejecución de un proceso en dos mitades: el kernel y el espacio de "
"usuario. El kernel se puede ingresar de dos maneras: a través de una trampa "
"o mediante una llamada al sistema. La devolución se gestiona de una sola "
"forma. La descripción adicional se aplica a<trademark class=\"registered\""
">Linux</trademark> 2.6 sobre el<trademark>i386</trademark> arquitectura. "
"Esta información se tomó de [2]."

#. (itstool) path: sect4/para
#: article.translate.xml:504
msgid ""
"Syscalls in <trademark class=\"registered\">Linux</trademark> are performed "
"(in userspace) using <literal>syscallX</literal> macros where X substitutes "
"a number representing the number of parameters of the given syscall. This "
"macro translates to a code that loads <varname>%eax</varname> register with "
"a number of the syscall and executes interrupt <literal>0x80</literal>. "
"After this syscall return is called, which translates negative return values "
"to positive <literal>errno</literal> values and sets <literal>res</literal> "
"to <literal>-1</literal> in case of an error. Whenever the interrupt "
"<literal>0x80</literal> is called the process enters the kernel in system "
"call trap handler. This routine saves all registers on the stack and calls "
"the selected syscall entry. Note that the <trademark class=\"registered"
"\">Linux</trademark> calling convention expects parameters to the syscall to "
"be passed via registers as shown here:"
msgstr ""
"Syscalls en <trademark class=\"registered\">Linux</trademark> se realizan ("
"en el espacio de usuario) usando <literal>syscallX</literal> macros donde X "
"sustituye a un número que representa el número de parámetros de la llamada "
"al sistema dada. Esta macro se traduce en un código que se carga "
"<varname>%eax</varname> registrarse con un número de syscall y ejecutar "
"interrumpir <literal>0x80</literal>. Después de que se llame a este retorno "
"de llamada al sistema, que traduce los valores de retorno negativos en "
"positivos<literal>errno</literal> valores y conjuntos <literal>res</literal> "
"a <literal>-1</literal> en caso de un error. Siempre que la interrupción "
"<literal>0x80</literal>se llama el proceso ingresa al kernel en el "
"controlador de trampas de llamadas del sistema. Esta rutina guarda todos los "
"registros en la pila y llama a la entrada de llamada al sistema "
"seleccionada. Tenga en cuenta que el <trademark class=\"registered\">Linux</"
"trademark> la convención de llamada espera que los parámetros a la llamada "
"al sistema se pasen a través de registros como se muestra aquí:"

#. (itstool) path: listitem/para
#: article.translate.xml:523
msgid "parameter -&gt; <varname>%ebx</varname>"
msgstr "parámetro -&gt; <varname>%ebx</varname>"

#. (itstool) path: listitem/para
#: article.translate.xml:526
msgid "parameter -&gt; <varname>%ecx</varname>"
msgstr "parámetro -&gt; <varname>%ecx</varname>"

#. (itstool) path: listitem/para
#: article.translate.xml:529
msgid "parameter -&gt; <varname>%edx</varname>"
msgstr "parámetro -&gt; <varname>%edx</varname>"

#. (itstool) path: listitem/para
#: article.translate.xml:532
msgid "parameter -&gt; <varname>%esi</varname>"
msgstr "parámetro -&gt; <varname>%esi</varname>"

#. (itstool) path: listitem/para
#: article.translate.xml:535
msgid "parameter -&gt; <varname>%edi</varname>"
msgstr "parámetro -&gt; <varname>%edi</varname>"

#. (itstool) path: listitem/para
#: article.translate.xml:538
msgid "parameter -&gt; <varname>%ebp</varname>"
msgstr "parámetro -&gt; <varname>%ebp</varname>"

#. (itstool) path: sect4/para
#: article.translate.xml:542
msgid ""
"There are some exceptions to this, where <trademark class=\"registered"
"\">Linux</trademark> uses different calling convention (most notably the "
"<literal>clone</literal> syscall)."
msgstr ""
"Hay algunas excepciones a esto, donde <trademark class=\"registered\">Linux</"
"trademark> utiliza una convención de llamada diferente (más notablemente la "
"<literal>clone</literal> syscall)."

#. (itstool) path: sect4/para
#: article.translate.xml:550
msgid ""
"The trap handlers are introduced in <filename>arch/i386/kernel/traps.c</"
"filename> and most of these handlers live in <filename>arch/i386/kernel/"
"entry.S</filename>, where handling of the traps happens."
msgstr ""
"Los manipuladores de trampas se introducen en <filename>arch/i386/kernel/"
"traps.c</filename>y la mayoría de estos manipuladores viven en <filename>"
"arch/i386/kernel/entry.S</filename>, donde ocurre el manejo de las trampas."

#. (itstool) path: sect4/para
#: article.translate.xml:560
msgid ""
"Return from the syscall is managed by syscall "
"<citerefentry><refentrytitle>exit</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>, which checks for the process having unfinished work, then "
"checks whether we used user-supplied selectors. If this happens stack fixing "
"is applied and finally the registers are restored from the stack and the "
"process returns to the userspace."
msgstr ""
"El retorno del syscall es administrado por syscall "
"<citerefentry><refentrytitle>exit</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>, que verifica si el proceso tiene trabajo sin terminar, luego "
"verifica si usamos selectores proporcionados por el usuario. Si esto sucede, "
"se aplica la corrección de la pila y finalmente se restauran los registros "
"de la pila y el proceso vuelve al espacio de usuario."

#. (itstool) path: sect4/para
#: article.translate.xml:571
msgid ""
"In the 2.6 version, the <trademark class=\"registered\">Linux</trademark> "
"operating system redefined some of the traditional <trademark class="
"\"registered\">UNIX</trademark> primitives, notably PID, TID and thread. PID "
"is defined not to be unique for every process, so for some processes "
"(threads) <citerefentry><refentrytitle>getppid</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> returns the same value. Unique identification of "
"process is provided by TID. This is because <firstterm>NPTL</firstterm> (New "
"<trademark class=\"registered\">POSIX</trademark> Thread Library) defines "
"threads to be normal processes (so called 1:1 threading). Spawning a new "
"process in <trademark class=\"registered\">Linux</trademark> 2.6 happens "
"using the <literal>clone</literal> syscall (fork variants are reimplemented "
"using it). This clone syscall defines a set of flags that affect behavior of "
"the cloning process regarding thread implementation. The semantic is a bit "
"fuzzy as there is no single flag telling the syscall to create a thread."
msgstr ""
"En la versión 2.6, el <trademark class=\"registered\">Linux</trademark> "
"sistema operativo redefinió algunos de los tradicionales <trademark class="
"\"registered\">UNIX</trademark> primitivas, en particular PID, TID e hilo. "
"PID se define para no ser único para cada proceso, por lo que para algunos "
"procesos (subprocesos) <citerefentry><refentrytitle>getppid</refentrytitle><m"
"anvolnum>2</manvolnum></citerefentry> devuelve el mismo valor. TID "
"proporciona la identificación única del proceso. Esto es porque "
"<firstterm>NPTL</firstterm> (New <trademark class=\"registered\">POSIX</"
"trademark> Thread Library) define los subprocesos como procesos normales ("
"llamados subprocesos 1: 1). Generando un nuevo proceso en <trademark class="
"\"registered\">Linux</trademark> 2.6 sucede usando el <literal>clone</"
"literal> syscall (las variantes de la bifurcación se vuelven a implementar "
"usándolo). Esta llamada al sistema de clonación define un conjunto de "
"indicadores que afectan el comportamiento del proceso de clonación con "
"respecto a la implementación del hilo. La semántica es un poco difusa ya que "
"no hay una sola bandera que le diga al syscall que cree un hilo."

#. (itstool) path: sect4/para
#: article.translate.xml:588
msgid "Implemented clone flags are:"
msgstr "Las banderas de clonación implementadas son:"

#. (itstool) path: listitem/para
#: article.translate.xml:592
msgid "<literal>CLONE_VM</literal> - processes share their memory space"
msgstr ""
"<literal>CLONE_VM</literal> - los procesos comparten su espacio de memoria"

#. (itstool) path: listitem/para
#: article.translate.xml:596
msgid "<literal>CLONE_FS</literal> - share umask, cwd and namespace"
msgstr "<literal>CLONE_FS</literal> - compartir umask, cwd y espacio de nombres"

#. (itstool) path: listitem/para
#: article.translate.xml:600
msgid "<literal>CLONE_FILES</literal> - share open files"
msgstr "<literal>CLONE_FILES</literal> - compartir archivos abiertos"

#. (itstool) path: listitem/para
#: article.translate.xml:604
msgid ""
"<literal>CLONE_SIGHAND</literal> - share signal handlers and blocked signals"
msgstr ""
"<literal>CLONE_SIGHAND</literal> - compartir manejadores de señales y "
"señales bloqueadas"

#. (itstool) path: listitem/para
#: article.translate.xml:608
msgid "<literal>CLONE_PARENT</literal> - share parent"
msgstr "<literal>CLONE_PARENT</literal> - Compartir padre"

#. (itstool) path: listitem/para
#: article.translate.xml:612
msgid "<literal>CLONE_THREAD</literal> - be thread (further explanation below)"
msgstr ""
"<literal>CLONE_THREAD</literal> - ser hilo (más explicación a continuación)"

#. (itstool) path: listitem/para
#: article.translate.xml:616
msgid "<literal>CLONE_NEWNS</literal> - new namespace"
msgstr "<literal>CLONE_NEWNS</literal> - nuevo espacio de nombres"

#. (itstool) path: listitem/para
#: article.translate.xml:620
msgid "<literal>CLONE_SYSVSEM</literal> - share SysV undo structures"
msgstr ""
"<literal>CLONE_SYSVSEM</literal> - compartir estructuras de deshacer SysV"

#. (itstool) path: listitem/para
#: article.translate.xml:624
msgid "<literal>CLONE_SETTLS</literal> - setup TLS at supplied address"
msgstr ""
"<literal>CLONE_SETTLS</literal> - configurar TLS en la dirección "
"proporcionada"

#. (itstool) path: listitem/para
#: article.translate.xml:628
msgid "<literal>CLONE_PARENT_SETTID</literal> - set TID in the parent"
msgstr "<literal>CLONE_PARENT_SETTID</literal> - Establecer TID en el padre"

#. (itstool) path: listitem/para
#: article.translate.xml:632
msgid "<literal>CLONE_CHILD_CLEARTID</literal> - clear TID in the child"
msgstr "<literal>CLONE_CHILD_CLEARTID</literal> - TID claro en el niño"

#. (itstool) path: listitem/para
#: article.translate.xml:636
msgid "<literal>CLONE_CHILD_SETTID</literal> - set TID in the child"
msgstr "<literal>CLONE_CHILD_SETTID</literal> - Establecer TID en el niño"

#. (itstool) path: sect4/para
#: article.translate.xml:641
msgid ""
"<literal>CLONE_PARENT</literal> sets the real parent to the parent of the "
"caller. This is useful for threads because if thread A creates thread B we "
"want thread B to be parented to the parent of the whole thread group. "
"<literal>CLONE_THREAD</literal> does exactly the same thing as "
"<literal>CLONE_PARENT</literal>, <literal>CLONE_VM</literal> and "
"<literal>CLONE_SIGHAND</literal>, rewrites PID to be the same as PID of the "
"caller, sets exit signal to be none and enters the thread group. "
"<literal>CLONE_SETTLS</literal> sets up GDT entries for TLS handling. The "
"<literal>CLONE_*_*TID</literal> set of flags sets/clears user supplied "
"address to TID or 0."
msgstr ""
"<literal>CLONE_PARENT</literal> establece el padre real en el padre de la "
"persona que llama. Esto es útil para subprocesos porque si el subproceso A "
"crea el subproceso B, queremos que el subproceso B sea parental al padre de "
"todo el grupo de subprocesos. <literal>CLONE_THREAD</literal> hace "
"exactamente lo mismo que <literal>CLONE_PARENT</literal>, <literal>CLONE_VM</"
"literal> y <literal>CLONE_SIGHAND</literal>, reescribe el PID para que sea "
"el mismo que el PID de la persona que llama, configura la señal de salida "
"como ninguna y entra en el grupo de hilos. <literal>CLONE_SETTLS</literal> "
"configura entradas GDT para el manejo de TLS. los <literal>CLONE_*_*TID</"
"literal> conjunto de banderas establece/borra la dirección proporcionada por "
"el usuario a TID o 0."

#. (itstool) path: sect4/para
#: article.translate.xml:655
msgid ""
"As you can see the <literal>CLONE_THREAD</literal> does most of the work and "
"does not seem to fit the scheme very well. The original intention is unclear "
"(even for authors, according to comments in the code) but I think originally "
"there was one threading flag, which was then parcelled among many other "
"flags but this separation was never fully finished. It is also unclear what "
"this partition is good for as glibc does not use that so only hand-written "
"use of the clone permits a programmer to access this features."
msgstr ""
"Como puede ver el <literal>CLONE_THREAD</literal> hace la mayor parte del "
"trabajo y no parece encajar muy bien en el esquema. La intención original no "
"está clara (incluso para los autores, según los comentarios en el código), "
"pero creo que originalmente había una bandera de subprocesamiento, que luego "
"se dividió entre muchas otras banderas, pero esta separación nunca se "
"terminó por completo. Tampoco está claro para qué sirve esta partición, ya "
"que glibc no la usa, por lo que solo el uso escrito a mano del clon permite "
"al programador acceder a estas funciones."

#. (itstool) path: sect4/para
#: article.translate.xml:666
msgid ""
"For non-threaded programs the PID and TID are the same. For threaded "
"programs the first thread PID and TID are the same and every created thread "
"shares the same PID and gets assigned a unique TID (because "
"<literal>CLONE_THREAD</literal> is passed in) also parent is shared for all "
"processes forming this threaded program."
msgstr ""
"Para los programas sin subprocesos, el PID y el TID son los mismos. Para los "
"programas con subprocesos, el PID y el TID del primer subproceso son iguales "
"y cada subproceso creado comparte el mismo PID y se le asigna un TID único ("
"porque <literal>CLONE_THREAD</literal> se pasa) también el padre se comparte "
"para todos los procesos que forman este programa enhebrado."

#. (itstool) path: sect4/para
#: article.translate.xml:674
msgid ""
"The code that implements <citerefentry><refentrytitle>pthread_create</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry> in NPTL defines the "
"clone flags like this:"
msgstr ""
"El código que implementa <citerefentry><refentrytitle>pthread_create</refentr"
"ytitle><manvolnum>3</manvolnum></citerefentry> en NPTL define las banderas "
"de clonación como esta:"

#. (itstool) path: sect4/programlisting
#: article.translate.xml:677
#, no-wrap
msgid ""
"int clone_flags = (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGNAL\n"
"\n"
" | CLONE_SETTLS | CLONE_PARENT_SETTID\n"
"\n"
"| CLONE_CHILD_CLEARTID | CLONE_SYSVSEM\n"
"#if __ASSUME_NO_CLONE_DETACHED == 0\n"
"\n"
"| CLONE_DETACHED\n"
"#endif\n"
"\n"
"| 0);"
msgstr ""
"int clone_flags = (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGNAL\n"
"\n"
" | CLONE_SETTLS | CLONE_PARENT_SETTID\n"
"\n"
"| CLONE_CHILD_CLEARTID | CLONE_SYSVSEM\n"
"#if __ASSUME_NO_CLONE_DETACHED == 0\n"
"\n"
"| CLONE_DETACHED\n"
"#endif\n"
"\n"
"| 0);"

#. (itstool) path: sect4/para
#: article.translate.xml:689
msgid "The <literal>CLONE_SIGNAL</literal> is defined like"
msgstr "El <literal>CLONE_SIGNAL</literal> se define como"

#. (itstool) path: sect4/programlisting
#: article.translate.xml:692
#, fuzzy, no-wrap
msgid "#define CLONE_SIGNAL (CLONE_SIGHAND | CLONE_THREAD)"
msgstr "#define CLONE_SIGNAL (CLONE_SIGHAND | CLONE_THREAD)"

#. (itstool) path: sect4/para
#: article.translate.xml:694
msgid "the last 0 means no signal is sent when any of the threads exits."
msgstr ""
"el último 0 significa que no se envía ninguna señal cuando alguno de los "
"hilos sale."

#. (itstool) path: sect2/title
#: article.translate.xml:701
msgid "What is emulation"
msgstr "Que es la emulacion"

#. (itstool) path: sect2/para
#: article.translate.xml:703
msgid ""
"According to a dictionary definition, emulation is the ability of a program "
"or device to imitate another program or device. This is achieved by "
"providing the same reaction to a given stimulus as the emulated object. In "
"practice, the software world mostly sees three types of emulation - a "
"program used to emulate a machine (QEMU, various game console emulators "
"etc.), software emulation of a hardware facility (OpenGL emulators, floating "
"point units emulation etc.) and operating system emulation (either in kernel "
"of the operating system or as a userspace program)."
msgstr ""
"Según una definición de diccionario, la emulación es la capacidad de un "
"programa o dispositivo para imitar otro programa o dispositivo. Esto se "
"logra proporcionando la misma reacción a un estímulo dado que el objeto "
"emulado. En la práctica, el mundo del software ve principalmente tres tipos "
"de emulación: un programa utilizado para emular una máquina (QEMU, varios "
"emuladores de consola de juegos, etc.), emulación de software de una "
"instalación de hardware (emuladores OpenGL, emulación de unidades de punto "
"flotante, etc.) y operación emulación del sistema (ya sea en el núcleo del "
"sistema operativo o como un programa de espacio de usuario)."

#. (itstool) path: sect2/para
#: article.translate.xml:714
msgid ""
"Emulation is usually used in a place, where using the original component is "
"not feasible nor possible at all. For example someone might want to use a "
"program developed for a different operating system than they use. Then "
"emulation comes in handy. Sometimes there is no other way but to use "
"emulation - e.g. when the hardware device you try to use does not exist (yet/"
"anymore) then there is no other way but emulation. This happens often when "
"porting an operating system to a new (non-existent) platform. Sometimes it "
"is just cheaper to emulate."
msgstr ""
"La emulación se usa generalmente en un lugar donde usar el componente "
"original no es factible ni posible en absoluto. Por ejemplo, alguien podría "
"querer usar un programa desarrollado para un sistema operativo diferente al "
"que usa. Entonces la emulación es útil. A veces no hay otra forma que usar "
"la emulación, por ejemplo, cuando el dispositivo de hardware que intenta "
"utilizar no existe (todavía / más), no hay otra forma que la emulación. Esto "
"sucede a menudo cuando se traslada un sistema operativo a una plataforma "
"nueva (inexistente). A veces es más barato emular."

#. (itstool) path: sect2/para
#: article.translate.xml:725
msgid ""
"Looking from an implementation point of view, there are two main approaches "
"to the implementation of emulation. You can either emulate the whole thing - "
"accepting possible inputs of the original object, maintaining inner state "
"and emitting correct output based on the state and/or input. This kind of "
"emulation does not require any special conditions and basically can be "
"implemented anywhere for any device/program. The drawback is that "
"implementing such emulation is quite difficult, time-consuming and error-"
"prone. In some cases we can use a simpler approach. Imagine you want to "
"emulate a printer that prints from left to right on a printer that prints "
"from right to left. It is obvious that there is no need for a complex "
"emulation layer but simply reversing of the printed text is sufficient. "
"Sometimes the emulating environment is very similar to the emulated one so "
"just a thin layer of some translation is necessary to provide fully working "
"emulation! As you can see this is much less demanding to implement, so less "
"time-consuming and error-prone than the previous approach. But the necessary "
"condition is that the two environments must be similar enough. The third "
"approach combines the two previous. Most of the time the objects do not "
"provide the same capabilities so in a case of emulating the more powerful "
"one on the less powerful we have to emulate the missing features with full "
"emulation described above."
msgstr ""
"Desde el punto de vista de la implementación, hay dos enfoques principales "
"para la implementación de la emulación. Puede emular todo, aceptando "
"posibles entradas del objeto original, manteniendo el estado interno y "
"emitiendo la salida correcta según el estado y / o la entrada. Este tipo de "
"emulación no requiere condiciones especiales y básicamente se puede "
"implementar en cualquier lugar para cualquier dispositivo / programa. El "
"inconveniente es que implementar tal emulación es bastante difícil, requiere "
"mucho tiempo y es propenso a errores. En algunos casos, podemos utilizar un "
"enfoque más simple. Imagine que desea emular una impresora que imprime de "
"izquierda a derecha en una impresora que imprime de derecha a izquierda. Es "
"obvio que no hay necesidad de una capa de emulación compleja, pero basta con "
"invertir el texto impreso. A veces, el entorno de emulación es muy similar "
"al emulado, por lo que solo se necesita una capa fina de traducción para "
"proporcionar una emulación completamente funcional. Como puede ver, esto es "
"mucho menos exigente de implementar, por lo que consume menos tiempo y es "
"propenso a errores que el enfoque anterior. Pero la condición necesaria es "
"que los dos entornos sean lo suficientemente similares. El tercer enfoque "
"combina los dos anteriores. La mayoría de las veces los objetos no brindan "
"las mismas capacidades, por lo que en el caso de emular el más poderoso en "
"el menos poderoso, tenemos que emular las características faltantes con la "
"emulación completa descrita anteriormente."

#. (itstool) path: sect2/para
#: article.translate.xml:751
msgid ""
"This master thesis deals with emulation of <trademark class=\"registered"
"\">UNIX</trademark> on <trademark class=\"registered\">UNIX</trademark>, "
"which is exactly the case, where only a thin layer of translation is "
"sufficient to provide full emulation. The <trademark class=\"registered"
"\">UNIX</trademark> API consists of a set of syscalls, which are usually "
"self contained and do not affect some global kernel state."
msgstr ""
"Esta tesis de maestría trata sobre la emulación de <trademark class="
"\"registered\">UNIX</trademark> en <trademark class=\"registered\">UNIX</"
"trademark>, que es exactamente el caso, donde solo una fina capa de "
"traducción es suficiente para proporcionar una emulación completa. los "
"<trademark class=\"registered\">UNIX</trademark> La API consta de un "
"conjunto de llamadas al sistema, que normalmente son independientes y no "
"afectan al estado global del kernel."

#. (itstool) path: sect2/para
#: article.translate.xml:758
msgid ""
"There are a few syscalls that affect inner state but this can be dealt with "
"by providing some structures that maintain the extra state."
msgstr ""
"Hay algunas llamadas al sistema que afectan el estado interno, pero esto se "
"puede solucionar proporcionando algunas estructuras que mantienen el estado "
"adicional."

#. (itstool) path: sect2/para
#: article.translate.xml:762
msgid ""
"No emulation is perfect and emulations tend to lack some parts but this "
"usually does not cause any serious drawbacks. Imagine a game console "
"emulator that emulates everything but music output. No doubt that the games "
"are playable and one can use the emulator. It might not be that comfortable "
"as the original game console but its an acceptable compromise between price "
"and comfort."
msgstr ""
"Ninguna emulación es perfecta y las emulaciones tienden a carecer de algunas "
"partes, pero esto no suele causar inconvenientes graves. Imagina un emulador "
"de consola de juegos que emula todo menos la salida de música. No hay duda "
"de que los juegos son jugables y se puede usar el emulador. Puede que no sea "
"tan cómodo como la consola de juegos original, pero es un compromiso "
"aceptable entre precio y comodidad."

#. (itstool) path: sect2/para
#: article.translate.xml:770
msgid ""
"The same goes with the <trademark class=\"registered\">UNIX</trademark> API. "
"Most programs can live with a very limited set of syscalls working. Those "
"syscalls tend to be the oldest ones (<citerefentry><refentrytitle>read</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>/"
"<citerefentry><refentrytitle>write</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>, <citerefentry><refentrytitle>fork</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> family, "
"<citerefentry><refentrytitle>signal</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry> handling, <citerefentry><refentrytitle>exit</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>socket</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> API) hence it is easy to emulate because their semantics is "
"shared among all <trademark class=\"registered\">UNIX</trademark>es, which "
"exist todays."
msgstr ""
"Lo mismo ocurre con el <trademark class=\"registered\">UNIX</trademark> API. "
"La mayoría de los programas pueden vivir con un conjunto muy limitado de "
"llamadas al sistema funcionando. Esas llamadas al sistema tienden a ser las "
"más antiguas (<citerefentry><refentrytitle>leer</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>/<citerefentry><refentrytitle>write</refentrytitle><"
"manvolnum>2</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> family, "
"<citerefentry><refentrytitle>señal</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry> handling, "
"<citerefentry><refentrytitle>salida</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>, "
"<citerefentry><refentrytitle>socket</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> API), por lo que es fácil de emular porque su semántica se "
"comparte entre todos <trademark class=\"registered\">UNIX</trademark>es, que "
"existen hoy."

#. (itstool) path: sect1/title
#: article.translate.xml:781
msgid "Emulation"
msgstr "Emulación"

#. (itstool) path: sect2/title
#: article.translate.xml:784
msgid "How emulation works in FreeBSD"
msgstr "Cómo funciona la emulación en FreeBSD"

#. (itstool) path: sect2/para
#: article.translate.xml:786
msgid ""
"As stated earlier, FreeBSD supports running binaries from several other "
"<trademark class=\"registered\">UNIX</trademark>es. This works because "
"FreeBSD has an abstraction called the execution class loader. This wedges "
"into the <citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> syscall, so when "
"<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> is about to execute a binary it examines its type."
msgstr ""
"Como se dijo anteriormente, FreeBSD admite la ejecución de binarios de "
"varios otros <trademark class=\"registered\">UNIX</trademark>es. esto "
"funciona porque FreeBSD tiene una abstracción llamada cargador de clases de "
"ejecución. Esto encaja en el<citerefentry><refentrytitle>execve</refentrytitl"
"e><manvolnum>2</manvolnum></citerefentry>syscall, así que cuando "
"<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> está a punto de ejecutar un binario examina su tipo."

#. (itstool) path: sect2/para
#: article.translate.xml:792
msgid ""
"There are basically two types of binaries in FreeBSD. Shell-like text "
"scripts which are identified by <literal>#!</literal> as their first two "
"characters and normal (typically <firstterm>ELF</firstterm>) binaries, which "
"are a representation of a compiled executable object. The vast majority (one "
"could say all of them) of binaries in FreeBSD are from type ELF. ELF files "
"contain a header, which specifies the OS ABI for this ELF file. By reading "
"this information, the operating system can accurately determine what type of "
"binary the given file is."
msgstr ""
"Básicamente, existen dos tipos de binarios en FreeBSD. Scripts de texto tipo "
"shell que se identifican por <literal>#!</literal> como sus dos primeros "
"personajes y normal (typically <firstterm>ELF</firstterm>) binarios, que son "
"una representación de un objeto ejecutable compilado. La gran mayoría (se "
"podría decir que todos) de los binarios en FreeBSD son del tipo ELF. Los "
"archivos ELF contienen un encabezado, que especifica la ABI del sistema "
"operativo para este archivo ELF. Al leer esta información, el sistema "
"operativo puede determinar con precisión qué tipo de binario es el archivo "
"dado."

#. (itstool) path: sect2/para
#: article.translate.xml:803
msgid ""
"Every OS ABI must be registered in the FreeBSD kernel. This applies to the "
"FreeBSD native OS ABI, as well. So when <citerefentry><refentrytitle>execve</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> executes a binary it "
"iterates through the list of registered APIs and when it finds the right one "
"it starts to use the information contained in the OS ABI description (its "
"syscall table, <literal>errno</literal> translation table, etc.). So every "
"time the process calls a syscall, it uses its own set of syscalls instead of "
"some global one. This effectively provides a very elegant and easy way of "
"supporting execution of various binary formats."
msgstr ""
"Cada OS ABI debe estar registrado en el kernel de FreeBSD. Esto también se "
"aplica a la ABI del sistema operativo nativo de FreeBSD. Así que cuando "
"<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> ejecuta un binario, itera a través de la lista de API "
"registradas y cuando encuentra la correcta, comienza a usar la información "
"contenida en la descripción de la ABI del sistema operativo (su tabla "
"syscall,<literal>errno</literal> tabla de traducción, etc.). Entonces, cada "
"vez que el proceso llama a una llamada al sistema, utiliza su propio "
"conjunto de llamadas al sistema en lugar de una global. Esto proporciona "
"efectivamente una forma muy elegante y fácil de soportar la ejecución de "
"varios formatos binarios."

#. (itstool) path: sect2/para
#: article.translate.xml:814
msgid ""
"The nature of emulation of different OSes (and also some other subsystems) "
"led developers to invite a handler event mechanism. There are various places "
"in the kernel, where a list of event handlers are called. Every subsystem "
"can register an event handler and they are called accordingly. For example, "
"when a process exits there is a handler called that possibly cleans up "
"whatever the subsystem needs to be cleaned."
msgstr ""
"La naturaleza de la emulación de diferentes sistemas operativos (y también "
"algunos otros subsistemas) llevó a los desarrolladores a invitar a un "
"mecanismo de eventos de controlador. Hay varios lugares en el kernel, donde "
"se llama a una lista de controladores de eventos. Cada subsistema puede "
"registrar un controlador de eventos y se los llama en consecuencia. Por "
"ejemplo, cuando un proceso sale, se llama a un controlador que posiblemente "
"limpia lo que sea que el subsistema necesite limpiarse."

#. (itstool) path: sect2/para
#: article.translate.xml:823
msgid ""
"Those simple facilities provide basically everything that is needed for the "
"emulation infrastructure and in fact these are basically the only things "
"necessary to implement the <trademark class=\"registered\">Linux</trademark> "
"emulation layer."
msgstr ""
"Esas sencillas instalaciones proporcionan básicamente todo lo que se "
"necesita para la infraestructura de emulación y, de hecho, son básicamente "
"las únicas cosas necesarias para implementar el <trademark class=\"registered"
"\">Linux</trademark> capa de emulación."

#. (itstool) path: sect2/title
#: article.translate.xml:830
msgid "Common primitives in the FreeBSD kernel"
msgstr "Primitivas comunes en el kernel de FreeBSD"

#. (itstool) path: sect2/para
#: article.translate.xml:832
msgid ""
"Emulation layers need some support from the operating system. I am going to "
"describe some of the supported primitives in the FreeBSD operating system."
msgstr ""
"Las capas de emulación necesitan soporte del sistema operativo. Voy a "
"describir algunas de las primitivas soportadas en el sistema operativo "
"FreeBSD."

#. (itstool) path: sect3/title
#: article.translate.xml:837
msgid "Locking primitives"
msgstr "Bloqueo de primitivos"

#. (itstool) path: sect3/para
#: article.translate.xml:839
msgid "Contributed by: Attilio Rao <email>attilio@FreeBSD.org</email>"
msgstr "Contribuido por: Attilio Rao <email>attilio@FreeBSD.org</email>"

#. (itstool) path: sect3/para
#: article.translate.xml:841
msgid ""
"The FreeBSD synchronization primitive set is based on the idea to supply a "
"rather huge number of different primitives in a way that the better one can "
"be used for every particular, appropriate situation."
msgstr ""
"El conjunto de primitivas de sincronización de FreeBSD se basa en la idea de "
"suministrar un número bastante grande de primitivas diferentes de manera que "
"se pueda utilizar la mejor para cada situación particular y apropiada."

#. (itstool) path: sect3/para
#: article.translate.xml:846
msgid ""
"To a high level point of view you can consider three kinds of "
"synchronization primitives in the FreeBSD kernel:"
msgstr ""
"Desde un punto de vista de alto nivel, puede considerar tres tipos de "
"primitivas de sincronización en el kernel de FreeBSD:"

#. (itstool) path: listitem/para
#: article.translate.xml:852
msgid "atomic operations and memory barriers"
msgstr "operaciones atómicas y barreras de memoria"

#. (itstool) path: listitem/para
#: article.translate.xml:855
msgid "locks"
msgstr "Cerraduras"

#. (itstool) path: listitem/para
#: article.translate.xml:858
msgid "scheduling barriers"
msgstr "barreras de programación"

#. (itstool) path: sect3/para
#: article.translate.xml:862
msgid ""
"Below there are descriptions for the 3 families. For every lock, you should "
"really check the linked manpage (where possible) for more detailed "
"explanations."
msgstr ""
"A continuación hay descripciones de las 3 familias. Para cada bloqueo, "
"debería consultar la página de manual vinculada (cuando sea posible) para "
"obtener explicaciones más detalladas."

#. (itstool) path: sect4/title
#: article.translate.xml:867
msgid "Atomic operations and memory barriers"
msgstr "Operaciones atómicas y barreras de memoria"

#. (itstool) path: sect4/para
#: article.translate.xml:869
msgid ""
"Atomic operations are implemented through a set of functions performing "
"simple arithmetics on memory operands in an atomic way with respect to "
"external events (interrupts, preemption, etc.). Atomic operations can "
"guarantee atomicity just on small data types (in the magnitude order of the "
"<literal>.long.</literal> architecture C data type), so should be rarely "
"used directly in the end-level code, if not only for very simple operations "
"(like flag setting in a bitmap, for example). In fact, it is rather simple "
"and common to write down a wrong semantic based on just atomic operations "
"(usually referred as lock-less). The FreeBSD kernel offers a way to perform "
"atomic operations in conjunction with a memory barrier. The memory barriers "
"will guarantee that an atomic operation will happen following some specified "
"ordering with respect to other memory accesses. For example, if we need that "
"an atomic operation happen just after all other pending writes (in terms of "
"instructions reordering buffers activities) are completed, we need to "
"explicitly use a memory barrier in conjunction to this atomic operation. So "
"it is simple to understand why memory barriers play a key role for higher-"
"level locks building (just as refcounts, mutexes, etc.). For a detailed "
"explanatory on atomic operations, please refer to "
"<citerefentry><refentrytitle>atomic</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry>. It is far, however, noting that atomic operations (and memory "
"barriers as well) should ideally only be used for building front-ending "
"locks (as mutexes)."
msgstr ""
"Las operaciones atómicas se implementan a través de un conjunto de funciones "
"que realizan aritmética simple sobre operandos de memoria de forma atómica "
"con respecto a eventos externos (interrupciones, apropiación, etc.). Las "
"operaciones atómicas pueden garantizar la atomicidad solo en tipos de datos "
"pequeños (en el orden de magnitud del <literal>.long.</literal>tipo de datos "
"de arquitectura C), por lo que rara vez se debe usar directamente en el "
"código de nivel final, si no solo para operaciones muy simples (como la "
"configuración de banderas en un mapa de bits, por ejemplo). De hecho, es "
"bastante simple y común escribir una semántica incorrecta basada solo en "
"operaciones atómicas (generalmente referidas como sin bloqueo). El kernel de "
"FreeBSD ofrece una forma de realizar operaciones atómicas junto con una "
"barrera de memoria. Las barreras de memoria garantizarán que ocurra una "
"operación atómica siguiendo un orden específico con respecto a otros accesos "
"a la memoria. Por ejemplo, si necesitamos que ocurra una operación atómica "
"justo después de que se completen todas las demás escrituras pendientes (en "
"términos de instrucciones que reordenan las actividades de búfer), "
"necesitamos usar explícitamente una barrera de memoria junto con esta "
"operación atómica. Por lo tanto, es sencillo entender por qué las barreras "
"de memoria juegan un papel clave para la construcción de bloqueos de nivel "
"superior (como refcounts, mutexes, etc.). Para obtener una explicación "
"detallada sobre las operaciones atómicas, consulte "
"<citerefentry><refentrytitle>atomic</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry>. Sin embargo, está lejos de señalar que las operaciones "
"atómicas (y las barreras de memoria también) deberían idealmente usarse solo "
"para construir bloqueos frontales (como mutex)."

#. (itstool) path: sect4/title
#: article.translate.xml:900
msgid "Refcounts"
msgstr "Recuentos"

#. (itstool) path: sect4/para
#: article.translate.xml:902
msgid ""
"Refcounts are interfaces for handling reference counters. They are "
"implemented through atomic operations and are intended to be used just for "
"cases, where the reference counter is the only one thing to be protected, so "
"even something like a spin-mutex is deprecated. Using the refcount interface "
"for structures, where a mutex is already used is often wrong since we should "
"probably close the reference counter in some already protected paths. A "
"manpage discussing refcount does not exist currently, just check "
"<filename>sys/refcount.h</filename> for an overview of the existing API."
msgstr ""
"Los refcounts son interfaces para manejar contadores de referencia. Se "
"implementan a través de operaciones atómicas y están destinadas a usarse "
"solo en casos, donde el contador de referencia es lo único que debe "
"protegerse, por lo que incluso algo como un spin-mutex está en desuso. El "
"uso de la interfaz refcount para estructuras, donde ya se usa un mutex, a "
"menudo es incorrecto, ya que probablemente deberíamos cerrar el contador de "
"referencia en algunas rutas ya protegidas. Actualmente no existe una página "
"de manual que discuta refcount, solo verifique <filename>sys/refcount.h</"
"filename> para obtener una descripción general de la API existente."

#. (itstool) path: sect4/title
#: article.translate.xml:916
msgid "Locks"
msgstr "Cerraduras"

#. (itstool) path: sect4/para
#: article.translate.xml:918
msgid ""
"FreeBSD kernel has huge classes of locks. Every lock is defined by some "
"peculiar properties, but probably the most important is the event linked to "
"contesting holders (or in other terms, the behavior of threads unable to "
"acquire the lock). FreeBSD's locking scheme presents three different "
"behaviors for contenders:"
msgstr ""
"El kernel de FreeBSD tiene enormes clases de bloqueos. Cada bloqueo está "
"definido por algunas propiedades peculiares, pero probablemente la más "
"importante es el evento vinculado a los titulares de la competencia (o en "
"otros términos, el comportamiento de los hilos que no pueden adquirir el "
"bloqueo). El esquema de bloqueo de FreeBSD presenta tres comportamientos "
"diferentes para los contendientes:"

#. (itstool) path: listitem/para
#: article.translate.xml:927
msgid "spinning"
msgstr "hilado"

#. (itstool) path: listitem/para
#: article.translate.xml:930
msgid "blocking"
msgstr "bloqueo"

#. (itstool) path: listitem/para
#: article.translate.xml:933
msgid "sleeping"
msgstr "dormir"

#. (itstool) path: note/para
#: article.translate.xml:938
msgid "numbers are not casual"
msgstr "los números no son casuales"

#. (itstool) path: sect4/title
#: article.translate.xml:943
msgid "Spinning locks"
msgstr "Cerraduras giratorias"

#. (itstool) path: sect4/para
#: article.translate.xml:945
msgid ""
"Spin locks let waiters to spin until they cannot acquire the lock. An "
"important matter do deal with is when a thread contests on a spin lock if it "
"is not descheduled. Since the FreeBSD kernel is preemptive, this exposes "
"spin lock at the risk of deadlocks that can be solved just disabling "
"interrupts while they are acquired. For this and other reasons (like lack of "
"priority propagation support, poorness in load balancing schemes between "
"CPUs, etc.), spin locks are intended to protect very small paths of code, or "
"ideally not to be used at all if not explicitly requested (explained later)."
msgstr ""
"Las cerraduras giratorias permiten a los camareros girar hasta que no pueden "
"adquirir la cerradura. Un asunto importante con el que se trata es cuando un "
"hilo compite en un bloqueo de giro si no está programado. Dado que el kernel "
"de FreeBSD es preventivo, esto expone el bloqueo de giro al riesgo de "
"interbloqueos que pueden resolverse simplemente deshabilitando las "
"interrupciones mientras se adquieren. Por esta y otras razones (como la "
"falta de soporte de propagación de prioridad, deficiencias en los esquemas "
"de equilibrio de carga entre las CPU, etc.), los bloqueos de giro están "
"destinados a proteger rutas de código muy pequeñas o, idealmente, no deben "
"usarse en absoluto si no se solicitan explícitamente ( explicado más "
"adelante)."

#. (itstool) path: sect4/title
#: article.translate.xml:959
msgid "Blocking"
msgstr "Bloqueo"

#. (itstool) path: sect4/para
#: article.translate.xml:961
msgid ""
"Block locks let waiters to be descheduled and blocked until the lock owner "
"does not drop it and wakes up one or more contenders. In order to avoid "
"starvation issues, blocking locks do priority propagation from the waiters "
"to the owner. Block locks must be implemented through the turnstile "
"interface and are intended to be the most used kind of locks in the kernel, "
"if no particular conditions are met."
msgstr ""
"Las cerraduras de bloque permiten que los camareros sean desprogramados y "
"bloqueados hasta que el propietario de la cerradura no la deje caer y "
"despierte a uno o más contendientes. Para evitar problemas de inanición, las "
"cerraduras de bloqueo se propagan prioritariamente de los camareros al "
"propietario. Los bloqueos de bloqueo deben implementarse a través de la "
"interfaz del torniquete y están destinados a ser el tipo de bloqueo más "
"utilizado en el núcleo, si no se cumplen condiciones particulares."

#. (itstool) path: sect4/title
#: article.translate.xml:972
msgid "Sleeping"
msgstr "Dormir"

#. (itstool) path: sect4/para
#: article.translate.xml:974
msgid ""
"Sleep locks let waiters to be descheduled and fall asleep until the lock "
"holder does not drop it and wakes up one or more waiters. Since sleep locks "
"are intended to protect large paths of code and to cater asynchronous "
"events, they do not do any form of priority propagation. They must be "
"implemented through the <citerefentry><refentrytitle>sleepqueue</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> interface."
msgstr ""
"Las cerraduras para dormir permiten que los camareros se desagreguen y se "
"duerman hasta que el soporte de la cerradura no se caiga y despierte a uno o "
"más camareros. Dado que los bloqueos de suspensión están destinados a "
"proteger grandes rutas de código y atender eventos asincrónicos, no realizan "
"ningún tipo de propagación de prioridad. Deben implementarse a través del <ci"
"terefentry><refentrytitle>sleepqueue</refentrytitle><manvolnum>9</manvolnum><"
"/citerefentry> interfaz."

#. (itstool) path: sect4/para
#: article.translate.xml:982
msgid ""
"The order used to acquire locks is very important, not only for the "
"possibility to deadlock due at lock order reversals, but even because lock "
"acquisition should follow specific rules linked to locks natures. If you "
"give a look at the table above, the practical rule is that if a thread holds "
"a lock of level n (where the level is the number listed close to the kind of "
"lock) it is not allowed to acquire a lock of superior levels, since this "
"would break the specified semantic for a path. For example, if a thread "
"holds a block lock (level 2), it is allowed to acquire a spin lock (level 1) "
"but not a sleep lock (level 3), since block locks are intended to protect "
"smaller paths than sleep lock (these rules are not about atomic operations "
"or scheduling barriers, however)."
msgstr ""
"El orden utilizado para adquirir cerraduras es muy importante, no solo por "
"la posibilidad de interbloqueo debido a las inversiones de orden de "
"cerradura, sino incluso porque la adquisición de cerraduras debe seguir "
"reglas específicas vinculadas a la naturaleza de las cerraduras. Si echa un "
"vistazo a la tabla de arriba, la regla práctica es que si un hilo tiene un "
"candado de nivel n (donde el nivel es el número listado cerca del tipo de "
"candado) no está permitido adquirir un candado de niveles superiores , ya "
"que esto rompería la semántica especificada para una ruta. Por ejemplo, si "
"un hilo tiene un bloqueo de bloqueo (nivel 2), se le permite adquirir un "
"bloqueo de giro (nivel 1) pero no un bloqueo de suspensión (nivel 3), ya que "
"los bloqueos de bloqueo están destinados a proteger rutas más pequeñas que "
"el bloqueo de suspensión ( Sin embargo, estas reglas no se refieren a "
"operaciones atómicas o barreras de programación)."

#. (itstool) path: sect4/para
#: article.translate.xml:997
msgid "This is a list of lock with their respective behaviors:"
msgstr "Esta es una lista de bloqueo con sus respectivos comportamientos:"

#. (itstool) path: listitem/para
#: article.translate.xml:1002
#, fuzzy
msgid ""
"spin mutex - spinning - <citerefentry><refentrytitle>mutex</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""
"spin mutex - spinning - <citerefentry><refentrytitle>mutex</refentrytitle><ma"
"nvolnum>9</manvolnum></citerefentry>"

#. (itstool) path: listitem/para
#: article.translate.xml:1005
#, fuzzy
msgid ""
"sleep mutex - blocking - <citerefentry><refentrytitle>mutex</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""
"sleep mutex - blocking - <citerefentry><refentrytitle>mutex</refentrytitle><m"
"anvolnum>9</manvolnum></citerefentry>"

#. (itstool) path: listitem/para
#: article.translate.xml:1008
#, fuzzy
msgid ""
"pool mutex - blocking - <citerefentry><refentrytitle>mtx_pool</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""
"pool mutex - blocking - <citerefentry><refentrytitle>mtx_pool</refentrytitle>"
"<manvolnum>9</manvolnum></citerefentry>"

#. (itstool) path: listitem/para
#: article.translate.xml:1011
msgid ""
"sleep family - sleeping - <citerefentry><refentrytitle>sleep</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> pause tsleep msleep "
"msleep spin msleep rw msleep sx"
msgstr ""
"dormir familia - dormir - "
"<citerefentry><refentrytitle>sleep</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> pause tsleep msleep msleep spin msleep rw msleep sx"

#. (itstool) path: listitem/para
#: article.translate.xml:1015
#, fuzzy
msgid ""
"condvar - sleeping - <citerefentry><refentrytitle>condvar</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""
"condvar - sleeping - <citerefentry><refentrytitle>condvar</refentrytitle><man"
"volnum>9</manvolnum></citerefentry>"

#. (itstool) path: listitem/para
#: article.translate.xml:1018
msgid ""
"rwlock - blocking - <citerefentry><refentrytitle>rwlock</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""
"rwlock - bloqueo - <citerefentry><refentrytitle>rwlock</refentrytitle><manvol"
"num>9</manvolnum></citerefentry>"

#. (itstool) path: listitem/para
#: article.translate.xml:1021
#, fuzzy
msgid ""
"sxlock - sleeping - <citerefentry><refentrytitle>sx</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""
"sxlock - sleeping - <citerefentry><refentrytitle>sx</refentrytitle><manvolnum"
">9</manvolnum></citerefentry>"

#. (itstool) path: listitem/para
#: article.translate.xml:1024
#, fuzzy
msgid ""
"lockmgr - sleeping - <citerefentry><refentrytitle>lockmgr</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""
"lockmgr - sleeping - <citerefentry><refentrytitle>lockmgr</refentrytitle><man"
"volnum>9</manvolnum></citerefentry>"

#. (itstool) path: listitem/para
#: article.translate.xml:1027
#, fuzzy
msgid ""
"semaphores - sleeping - <citerefentry><refentrytitle>sema</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""
"semaphores - sleeping - <citerefentry><refentrytitle>sema</refentrytitle><man"
"volnum>9</manvolnum></citerefentry>"

#. (itstool) path: sect4/para
#: article.translate.xml:1031
msgid ""
"Among these locks only mutexes, sxlocks, rwlocks and lockmgrs are intended "
"to handle recursion, but currently recursion is only supported by mutexes "
"and lockmgrs."
msgstr ""
"Entre estos bloqueos, solo los mutex, sxlocks, rwlocks y lockmgrs están "
"destinados a manejar la recursividad, pero actualmente la recursividad solo "
"es compatible con mutexes y lockmgrs."

#. (itstool) path: sect4/title
#: article.translate.xml:1038
msgid "Scheduling barriers"
msgstr "Barreras de programación"

#. (itstool) path: sect4/para
#: article.translate.xml:1040
msgid ""
"Scheduling barriers are intended to be used in order to drive scheduling of "
"threading. They consist mainly of three different stubs:"
msgstr ""
"Las barreras de programación están destinadas a utilizarse para impulsar la "
"programación del enhebrado. Consisten principalmente en tres stubs "
"diferentes:"

#. (itstool) path: listitem/para
#: article.translate.xml:1046
msgid "critical sections (and preemption)"
msgstr "secciones críticas (y preferencia)"

#. (itstool) path: listitem/para
#: article.translate.xml:1049
#, fuzzy
msgid "sched_bind"
msgstr "sched_bind"

#. (itstool) path: listitem/para
#: article.translate.xml:1052
#, fuzzy
msgid "sched_pin"
msgstr "sched_pin"

#. (itstool) path: sect4/para
#: article.translate.xml:1056
msgid ""
"Generally, these should be used only in a particular context and even if "
"they can often replace locks, they should be avoided because they do not let "
"the diagnose of simple eventual problems with locking debugging tools (as "
"<citerefentry><refentrytitle>witness</refentrytitle><manvolnum>4</"
"manvolnum></citerefentry>)."
msgstr ""
"Generalmente, estos deben usarse solo en un contexto particular e incluso si "
"a menudo pueden reemplazar bloqueos, deben evitarse porque no permiten el "
"diagnóstico de problemas eventuales simples con herramientas de depuración "
"de bloqueo (como <citerefentry><refentrytitle>testigo</refentrytitle><manvoln"
"um>4</manvolnum></citerefentry>)."

#. (itstool) path: sect4/title
#: article.translate.xml:1064
msgid "Critical sections"
msgstr "Secciones críticas"

#. (itstool) path: sect4/para
#: article.translate.xml:1066
msgid ""
"The FreeBSD kernel has been made preemptive basically to deal with interrupt "
"threads. In fact, in order to avoid high interrupt latency, time-sharing "
"priority threads can be preempted by interrupt threads (in this way, they do "
"not need to wait to be scheduled as the normal path previews). Preemption, "
"however, introduces new racing points that need to be handled, as well. "
"Often, in order to deal with preemption, the simplest thing to do is to "
"completely disable it. A critical section defines a piece of code "
"(borderlined by the pair of functions "
"<citerefentry><refentrytitle>critical_enter</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> and <citerefentry><refentrytitle>critical_exit</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>, where preemption is "
"guaranteed to not happen (until the protected code is fully executed). This "
"can often replace a lock effectively but should be used carefully in order "
"to not lose the whole advantage that preemption brings."
msgstr ""
"El kernel de FreeBSD se ha hecho preventivo básicamente para tratar con "
"hilos de interrupción. De hecho, para evitar una latencia de interrupción "
"alta, los subprocesos de prioridad de tiempo compartido pueden ser "
"reemplazados por subprocesos de interrupción (de esta manera, no necesitan "
"esperar para ser programados como vistas previas de la ruta normal). La "
"preferencia, sin embargo, introduce nuevos puntos de carrera que también "
"deben manejarse. A menudo, para hacer frente a la preferencia, lo más "
"sencillo es desactivarla por completo. Una sección crítica define un "
"fragmento de código (delimitado por el par de funciones <citerefentry><refent"
"rytitle>critical_enter</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> y <citerefentry><refentrytitle>critical_exit</refentrytitle><ma"
"nvolnum>9</manvolnum></citerefentry>, donde se garantiza que la preferencia "
"no ocurrirá (hasta que el código protegido se ejecute por completo). Esto a "
"menudo puede reemplazar un candado de manera efectiva, pero debe usarse con "
"cuidado para no perder toda la ventaja que brinda la preferencia."

#. (itstool) path: sect4/title
#: article.translate.xml:1085
#, fuzzy
msgid "sched_pin/sched_unpin"
msgstr "sched_pin/sched_unpin"

#. (itstool) path: sect4/para
#: article.translate.xml:1087
msgid ""
"Another way to deal with preemption is the <function>sched_pin()</function> "
"interface. If a piece of code is closed in the <function>sched_pin()</"
"function> and <function>sched_unpin()</function> pair of functions it is "
"guaranteed that the respective thread, even if it can be preempted, it will "
"always be executed on the same CPU. Pinning is very effective in the "
"particular case when we have to access at per-cpu datas and we assume other "
"threads will not change those data. The latter condition will determine a "
"critical section as a too strong condition for our code."
msgstr ""
"Otra forma de lidiar con la preferencia es <function>sched_pin()</function> "
"interfaz. Si un fragmento de código está cerrado en el "
"<function>sched_pin()</function> y <function>sched_unpin()</function> par de "
"funciones, se garantiza que el subproceso respectivo, incluso si puede ser "
"reemplazado, siempre se ejecutará en la misma CPU. La fijación es muy eficaz "
"en el caso particular cuando tenemos que acceder a datos por CPU y asumimos "
"que otros hilos no cambiarán esos datos. La última condición determinará una "
"sección crítica como una condición demasiado fuerte para nuestro código."

#. (itstool) path: sect4/title
#: article.translate.xml:1101
#, fuzzy
msgid "sched_bind/sched_unbind"
msgstr "sched_bind/sched_unbind"

#. (itstool) path: sect4/para
#: article.translate.xml:1103
msgid ""
"<function>sched_bind</function> is an API used in order to bind a thread to "
"a particular CPU for all the time it executes the code, until a "
"<function>sched_unbind</function> function call does not unbind it. This "
"feature has a key role in situations where you cannot trust the current "
"state of CPUs (for example, at very early stages of boot), as you want to "
"avoid your thread to migrate on inactive CPUs. Since <function>sched_bind</"
"function> and <function>sched_unbind</function> manipulate internal "
"scheduler structures, they need to be enclosed in <function>sched_lock</"
"function> acquisition/releasing when used."
msgstr ""
"<function>sched_bind</function> es una API que se utiliza para vincular un "
"hilo a una CPU en particular durante todo el tiempo que ejecuta el código, "
"hasta que <function>sched_unbind</function>la llamada a la función no la "
"desvincula. Esta función tiene un papel clave en situaciones en las que no "
"puede confiar en el estado actual de las CPU (por ejemplo, en las primeras "
"etapas del arranque), ya que desea evitar que su hilo migre en CPU "
"inactivas. Ya que <function>sched_bind</function> y<function>sched_unbind</"
"function> manipular las estructuras internas del programador, es necesario "
"incluirlas en <function>sched_lock</function> adquisición/liberación cuando "
"se usa."

#. (itstool) path: sect3/title
#: article.translate.xml:1120
msgid "Proc structure"
msgstr "Estructura de proceso"

#. (itstool) path: sect3/para
#: article.translate.xml:1122
msgid ""
"Various emulation layers sometimes require some additional per-process data. "
"It can manage separate structures (a list, a tree etc.) containing these "
"data for every process but this tends to be slow and memory consuming. To "
"solve this problem the FreeBSD <literal>proc</literal> structure contains "
"<literal>p_emuldata</literal>, which is a void pointer to some emulation "
"layer specific data. This <literal>proc</literal> entry is protected by the "
"proc mutex."
msgstr ""
"Varias capas de emulación a veces requieren algunos datos adicionales por "
"proceso. Puede administrar estructuras separadas (una lista, un árbol, etc.) "
"que contienen estos datos para cada proceso, pero esto tiende a ser lento y "
"consume memoria. Para solucionar este problema el FreeBSD <literal>proc</"
"literal> estructura contiene <literal>p_emuldata</literal>,que es un puntero "
"vacío a algunos datos específicos de la capa de emulación. Esta "
"<literal>proc</literal> La entrada está protegida por proc mutex."

#. (itstool) path: sect3/para
#: article.translate.xml:1133
msgid ""
"The FreeBSD <literal>proc</literal> structure contains a <literal>p_sysent</"
"literal> entry that identifies, which ABI this process is running. In fact, "
"it is a pointer to the <literal>sysentvec</literal> described above. So by "
"comparing this pointer to the address where the <literal>sysentvec</literal> "
"structure for the given ABI is stored we can effectively determine whether "
"the process belongs to our emulation layer. The code typically looks like:"
msgstr ""
"El FreeBSD <literal>proc</literal> structure contains a <literal>p_sysent</"
"literal>entrada que identifica qué ABI está ejecutando este proceso. De "
"hecho, es un puntero al <literal>sysentvec</literal> descrito arriba. "
"Entonces, al comparar este puntero con la dirección donde el "
"<literal>sysentvec</literal> Si se almacena la estructura para la ABI dada, "
"podemos determinar efectivamente si el proceso pertenece a nuestra capa de "
"emulación. El código normalmente se ve así:"

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1143
#, no-wrap
msgid ""
"if (__predict_true(p-&gt;p_sysent != &amp;elf_<trademark class=\"registered\">Linux</trademark>_sysvec))\n"
"\t  return;"
msgstr ""
"if (__predict_true(p-&gt;p_sysent != &amp;elf_<trademark class=\"registered\">Linux</trademark>_sysvec))\n"
"\t  return;"

#. (itstool) path: sect3/para
#: article.translate.xml:1146
msgid ""
"As you can see, we effectively use the <literal>__predict_true</literal> "
"modifier to collapse the most common case (FreeBSD process) to a simple "
"return operation thus preserving high performance. This code should be "
"turned into a macro because currently it is not very flexible, i.e. we do "
"not support <trademark class=\"registered\">Linux</trademark>64 emulation "
"nor A.OUT <trademark class=\"registered\">Linux</trademark> processes on "
"i386."
msgstr ""
"Como puede ver, utilizamos eficazmente la <literal>__predict_true</literal> "
"modificador para colapsar el caso más común (proceso FreeBSD) a una "
"operación de retorno simple preservando así el alto rendimiento. Este código "
"debería convertirse en una macro porque actualmente no es muy flexible, es "
"decir, no admitimos <trademark class=\"registered\">Linux</trademark>64 "
"emulación ni A.OUT<trademark class=\"registered\">Linux</trademark> procesos "
"en i386."

#. (itstool) path: sect3/title
#: article.translate.xml:1156
msgid "VFS"
msgstr "VFS"

#. (itstool) path: sect3/para
#: article.translate.xml:1158
msgid ""
"The FreeBSD VFS subsystem is very complex but the <trademark class="
"\"registered\">Linux</trademark> emulation layer uses just a small subset "
"via a well defined API. It can either operate on vnodes or file handlers. "
"Vnode represents a virtual vnode, i.e. representation of a node in VFS. "
"Another representation is a file handler, which represents an opened file "
"from the perspective of a process. A file handler can represent a socket or "
"an ordinary file. A file handler contains a pointer to its vnode. More then "
"one file handler can point to the same vnode."
msgstr ""
"el subsistema FreeBSD VFS es muy complejo pero es <trademark class="
"\"registered\">Linux</trademark> La capa de emulación utiliza solo un "
"pequeño subconjunto a través de una API bien definida. Puede operar en "
"vnodes o controladores de archivos. Vnode representa un vnode virtual, es "
"decir, la representación de un nodo en VFS. Otra representación es un "
"controlador de archivos, que representa un archivo abierto desde la "
"perspectiva de un proceso. Un manejador de archivos puede representar un "
"socket o un archivo ordinario. Un controlador de archivos contiene un "
"puntero a su vnode. Más de un controlador de archivos puede apuntar al mismo "
"vnode."

#. (itstool) path: sect4/title
#: article.translate.xml:1170
#, fuzzy
msgid "namei"
msgstr "namei"

#. (itstool) path: sect4/para
#: article.translate.xml:1172
msgid ""
"The <citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> routine is a central entry point to pathname "
"lookup and translation. It traverses the path point by point from the "
"starting point to the end point using lookup function, which is internal to "
"VFS. The <citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> syscall can cope with symlinks, absolute and "
"relative paths. When a path is looked up using "
"<citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> it is inputed to the name cache. This behavior can be "
"suppressed. This routine is used all over the kernel and its performance is "
"very critical."
msgstr ""
"La "
"<citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> La rutina es un punto de entrada central para la búsqueda y "
"traducción de nombres de rutas. Atraviesa la ruta punto por punto desde el "
"punto de inicio hasta el punto final utilizando la función de búsqueda, que "
"es interna de VFS. los "
"<citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> syscall puede hacer frente a enlaces simbólicos, rutas "
"absolutas y relativas. Cuando se busca un camino usando "
"<citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> se ingresa en la caché de nombres. Este comportamiento se "
"puede suprimir. Esta rutina se utiliza en todo el kernel y su rendimiento es "
"muy crítico."

#. (itstool) path: sect4/title
#: article.translate.xml:1184
#, fuzzy
msgid "vn_fullpath"
msgstr "vn_fullpath"

#. (itstool) path: sect4/para
#: article.translate.xml:1186
msgid ""
"The <citerefentry><refentrytitle>vn_fullpath</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> function takes the best effort to traverse VFS "
"name cache and returns a path for a given (locked) vnode. This process is "
"unreliable but works just fine for the most common cases. The unreliability "
"is because it relies on VFS cache (it does not traverse the on medium "
"structures), it does not work with hardlinks, etc. This routine is used in "
"several places in the Linuxulator."
msgstr ""
"La <citerefentry><refentrytitle>vn_fullpath</refentrytitle><manvolnum>9</manv"
"olnum></citerefentry> La función hace el mejor esfuerzo para atravesar la "
"caché de nombres de VFS y devuelve una ruta para un vnode dado (bloqueado). "
"Este proceso no es confiable pero funciona bien para los casos más comunes. "
"La falta de confiabilidad se debe a que se basa en la caché VFS (no "
"atraviesa las estructuras medias), no funciona con enlaces duros, etc. Esta "
"rutina se usa en varios lugares del Linuxulator."

#. (itstool) path: sect4/title
#: article.translate.xml:1197
msgid "Vnode operations"
msgstr "Operaciones de vnode"

#. (itstool) path: listitem/para
#: article.translate.xml:1201
msgid ""
"<function>fgetvp</function> - given a thread and a file descriptor number it "
"returns the associated vnode"
msgstr ""
"<function>fgetvp</function> - dado un hilo y un número de descriptor de "
"archivo, devuelve el vnode asociado"

#. (itstool) path: listitem/para
#: article.translate.xml:1206
msgid ""
"<citerefentry><refentrytitle>vn_lock</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> - locks a vnode"
msgstr ""
"<citerefentry><refentrytitle>vn_lock</refentrytitle><manvolnum>9</manvolnum><"
"/citerefentry> - bloquea un vnode"

#. (itstool) path: listitem/para
#: article.translate.xml:1209
msgid "<function>vn_unlock</function> - unlocks a vnode"
msgstr "<function>vn_unlock</function> - desbloquea un vnode"

#. (itstool) path: listitem/para
#: article.translate.xml:1213
msgid ""
"<citerefentry><refentrytitle>VOP_READDIR</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> - reads a directory referenced by a vnode"
msgstr ""
"<citerefentry><refentrytitle>VOP_READDIR</refentrytitle><manvolnum>9</manvoln"
"um></citerefentry> - lee un directorio al que hace referencia un vnode"

#. (itstool) path: listitem/para
#: article.translate.xml:1217
msgid ""
"<citerefentry><refentrytitle>VOP_GETATTR</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> - gets attributes of a file or a directory "
"referenced by a vnode"
msgstr ""
"<citerefentry><refentrytitle>VOP_GETATTR</refentrytitle><manvolnum>9</manvoln"
"um></citerefentry> - obtiene atributos de un archivo o directorio al que "
"hace referencia un vnode"

#. (itstool) path: listitem/para
#: article.translate.xml:1221
msgid ""
"<citerefentry><refentrytitle>VOP_LOOKUP</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> - looks up a path to a given directory"
msgstr ""
"<citerefentry><refentrytitle>VOP_LOOKUP</refentrytitle><manvolnum>9</manvolnu"
"m></citerefentry> - busca una ruta a un directorio determinado"

#. (itstool) path: listitem/para
#: article.translate.xml:1225
msgid ""
"<citerefentry><refentrytitle>VOP_OPEN</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> - opens a file referenced by a vnode"
msgstr ""
"<citerefentry><refentrytitle>VOP_OPEN</refentrytitle><manvolnum>9</manvolnum>"
"</citerefentry> - abre un archivo referenciado por un vnode"

#. (itstool) path: listitem/para
#: article.translate.xml:1229
msgid ""
"<citerefentry><refentrytitle>VOP_CLOSE</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> - closes a file referenced by a vnode"
msgstr ""
"<citerefentry><refentrytitle>VOP_CLOSE</refentrytitle><manvolnum>9</manvolnum"
"></citerefentry> - cierra un archivo al que hace referencia un vnode"

#. (itstool) path: listitem/para
#: article.translate.xml:1233
msgid ""
"<citerefentry><refentrytitle>vput</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> - decrements the use count for a vnode and unlocks it"
msgstr ""
"<citerefentry><refentrytitle>vput</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> - disminuye el recuento de uso de un vnode y lo desbloquea"

#. (itstool) path: listitem/para
#: article.translate.xml:1237
msgid ""
"<citerefentry><refentrytitle>vrele</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> - decrements the use count for a vnode"
msgstr ""
"<citerefentry><refentrytitle>vrele</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> - disminuye el recuento de uso de un vnode"

#. (itstool) path: listitem/para
#: article.translate.xml:1241
msgid ""
"<citerefentry><refentrytitle>vref</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> - increments the use count for a vnode"
msgstr ""
"<citerefentry><refentrytitle>vref</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> - incrementa el recuento de uso de un vnode"

#. (itstool) path: sect4/title
#: article.translate.xml:1248
msgid "File handler operations"
msgstr "Operaciones del controlador de archivos"

#. (itstool) path: listitem/para
#: article.translate.xml:1252
msgid ""
"<function>fget</function> - given a thread and a file descriptor number it "
"returns associated file handler and references it"
msgstr ""
"<function>fget</function> - dado un hilo y un número de descriptor de "
"archivo, devuelve el controlador de archivo asociado y lo hace referencia"

#. (itstool) path: listitem/para
#: article.translate.xml:1257
msgid "<function>fdrop</function> - drops a reference to a file handler"
msgstr ""
"<function>fdrop</function> - suelta una referencia a un controlador de "
"archivos"

#. (itstool) path: listitem/para
#: article.translate.xml:1261
msgid "<function>fhold</function> - references a file handler"
msgstr ""
"<function>fhold</function> - hace referencia a un controlador de archivos"

#. (itstool) path: sect1/title
#: article.translate.xml:1271
msgid ""
"<trademark class=\"registered\">Linux</trademark> emulation layer -MD part"
msgstr ""
"<trademark class=\"registered\">Linux</trademark> capa de emulación-parte MD"

#. (itstool) path: sect1/para
#: article.translate.xml:1273
msgid ""
"This section deals with implementation of <trademark class=\"registered"
"\">Linux</trademark> emulation layer in FreeBSD operating system. It first "
"describes the machine dependent part talking about how and where interaction "
"between userland and kernel is implemented. It talks about syscalls, "
"signals, ptrace, traps, stack fixup. This part discusses i386 but it is "
"written generally so other architectures should not differ very much. The "
"next part is the machine independent part of the Linuxulator. This section "
"only covers i386 and ELF handling. A.OUT is obsolete and untested."
msgstr ""
"Esta sección trata de la implementación de <trademark class=\"registered\""
">Linux</trademark> capa de emulación en el sistema operativo FreeBSD. "
"Primero describe la parte dependiente de la máquina hablando de cómo y dónde "
"se implementa la interacción entre el área de usuario y el kernel. Habla de "
"llamadas al sistema, señales, ptrace, trampas, reparación de pila. Esta "
"parte trata sobre i386, pero está escrito en general, por lo que otras "
"arquitecturas no deberían diferir mucho. La siguiente parte es la parte "
"independiente de la máquina del Linuxulator. Esta sección solo cubre el "
"manejo de i386 y ELF. A.OUT es obsoleto y no se ha probado."

#. (itstool) path: sect2/title
#: article.translate.xml:1284
msgid "Syscall handling"
msgstr "Manejo de llamadas al sistema"

#. (itstool) path: sect2/para
#: article.translate.xml:1286
msgid ""
"Syscall handling is mostly written in <filename>linux_sysvec.c</filename>, "
"which covers most of the routines pointed out in the <literal>sysentvec</"
"literal> structure. When a <trademark class=\"registered\">Linux</trademark> "
"process running on FreeBSD issues a syscall, the general syscall routine "
"calls linux prepsyscall routine for the <trademark class=\"registered"
"\">Linux</trademark> ABI."
msgstr ""
"El manejo de syscall está escrito principalmente en <filename>linux_sysvec."
"c</filename>, que cubre la mayoría de las rutinas señaladas en la "
"<literal>sysentvec</literal> estructura. Cuando una <trademark class="
"\"registered\">Linux</trademark> proceso que se ejecuta en FreeBSD emite una "
"llamada al sistema, la rutina general de llamada al sistema llama a la "
"rutina prepsyscall de linux para <trademark class=\"registered\">Linux</"
"trademark> ABI."

#. (itstool) path: sect3/title
#: article.translate.xml:1294
#, fuzzy
msgid "<trademark class=\"registered\">Linux</trademark> prepsyscall"
msgstr "<trademark class=\"registered\">Linux</trademark> prepsyscall"

#. (itstool) path: sect3/para
#: article.translate.xml:1296
msgid ""
"<trademark class=\"registered\">Linux</trademark> passes arguments to "
"syscalls via registers (that is why it is limited to 6 parameters on i386) "
"while FreeBSD uses the stack. The <trademark class=\"registered\">Linux</"
"trademark> prepsyscall routine must copy parameters from registers to the "
"stack. The order of the registers is: <varname>%ebx</varname>, <varname>"
"%ecx</varname>, <varname>%edx</varname>, <varname>%esi</varname>, <varname>"
"%edi</varname>, <varname>%ebp</varname>. The catch is that this is true for "
"only <emphasis>most</emphasis> of the syscalls. Some (most notably "
"<function>clone</function>) uses a different order but it is luckily easy to "
"fix by inserting a dummy parameter in the <function>linux_clone</function> "
"prototype."
msgstr ""
"<trademark class=\"registered\">Linux</trademark>pasa argumentos a las "
"llamadas al sistema a través de registros (es por eso que está limitado a 6 "
"parámetros en i386) mientras que FreeBSD usa la pila. los <trademark class="
"\"registered\">Linux</trademark> La rutina prepsyscall debe copiar los "
"parámetros de los registros a la pila. El orden de los registros es: "
"<varname>%ebx</varname>, <varname>%ecx</varname>, <varname>%edx</varname>, "
"<varname>%esi</varname>, <varname>%edi</varname>, <varname>%ebp</varname>. "
"El problema es que esto es cierto solo para <emphasis>most</emphasis> de las "
"llamadas al sistema. Algunos (más notablemente <function>clone</function>) "
"usa un orden diferente pero afortunadamente es fácil de arreglar insertando "
"un parámetro ficticio en el <function>linux_clone</function> prototipo."

#. (itstool) path: sect3/title
#: article.translate.xml:1311
msgid "Syscall writing"
msgstr "Escritura de syscall"

#. (itstool) path: sect3/para
#: article.translate.xml:1313
msgid ""
"Every syscall implemented in the Linuxulator must have its prototype with "
"various flags in <filename>syscalls.master</filename>. The form of the file "
"is:"
msgstr ""
"Cada syscall implementada en Linuxulator debe tener su prototipo con varios "
"indicadores en <filename>syscalls.master</filename>. La forma del archivo es:"

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1318
#, fuzzy, no-wrap
msgid ""
"...\n"
"\tAUE_FORK STD\t\t{ int linux_fork(void); }\n"
"...\n"
"\tAUE_CLOSE NOPROTO\t{ int close(int fd); }\n"
"..."
msgstr ""
"...\n"
"\tAUE_FORK STD\t\t{ int linux_fork(void); }\n"
"...\n"
"\tAUE_CLOSE NOPROTO\t{ int close(int fd); }\n"
"..."

#. (itstool) path: sect3/para
#: article.translate.xml:1324
msgid ""
"The first column represents the syscall number. The second column is for "
"auditing support. The third column represents the syscall type. It is either "
"<literal>STD</literal>, <literal>OBSOL</literal>, <literal>NOPROTO</literal> "
"and <literal>UNIMPL</literal>. <literal>STD</literal> is a standard syscall "
"with full prototype and implementation. <literal>OBSOL</literal> is obsolete "
"and defines just the prototype. <literal>NOPROTO</literal> means that the "
"syscall is implemented elsewhere so do not prepend ABI prefix, etc. "
"<literal>UNIMPL</literal> means that the syscall will be substituted with "
"the <function>nosys</function> syscall (a syscall just printing out a "
"message about the syscall not being implemented and returning "
"<literal>ENOSYS</literal>)."
msgstr ""
"La primera columna representa el número de llamada al sistema. La segunda "
"columna es para el soporte de auditoría. La tercera columna representa el "
"tipo de llamada al sistema. Es bien <literal>STD</literal>, <literal>OBSOL</"
"literal>, <literal>NOPROTO</literal> y <literal>UNIMPL</literal>. "
"<literal>STD</literal> es una llamada al sistema estándar con prototipo "
"completo e implementación. <literal>OBSOL</literal> es Obsoleto y define "
"solo el prototipo.. <literal>NOPROTO</literal> significa que la llamada al "
"sistema se implementa en otro lugar, así que no anteponga el prefijo ABI, "
"etc. <literal>UNIMPL</literal> Significa que el syscall será sustituido por "
"el <function>nosys</function> syscall (una syscall que simplemente imprime "
"un mensaje sobre la no implementación del syscall y que regresa "
"<literal>ENOSYS</literal>)."

#. (itstool) path: sect3/para
#: article.translate.xml:1340
msgid ""
"From <filename>syscalls.master</filename> a script generates three files: "
"<filename>linux_syscall.h</filename>, <filename>linux_proto.h</filename> and "
"<filename>linux_sysent.c</filename>. The <filename>linux_syscall.h</"
"filename> contains definitions of syscall names and their numerical value, e."
"g.:"
msgstr ""
"Desde <filename>syscalls.master</filename> un script genera tres archivos: "
"<filename>linux_syscall.h</filename>, <filename>linux_proto.h</filename> y "
"<filename>linux_sysent.c</filename>. El <filename>linux_syscall.h</filename> "
"contiene definiciones de nombres de llamadas al sistema y su valor numérico, "
"por ejemplo:"

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1347
#, fuzzy, no-wrap
msgid ""
"...\n"
"#define LINUX_SYS_linux_fork 2\n"
"...\n"
"#define LINUX_SYS_close 6\n"
"..."
msgstr ""
"...\n"
"#define LINUX_SYS_linux_fork 2\n"
"...\n"
"#define LINUX_SYS_close 6\n"
"..."

#. (itstool) path: sect3/para
#: article.translate.xml:1353
msgid ""
"The <filename>linux_proto.h</filename> contains structure definitions of "
"arguments to every syscall, e.g.:"
msgstr ""
"El <filename>linux_proto.h</filename> contiene definiciones de estructura de "
"argumentos para cada llamada al sistema, por ejemplo:"

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1357
#, fuzzy, no-wrap
msgid ""
"struct linux_fork_args {\n"
"  register_t dummy;\n"
"};"
msgstr ""
"struct linux_fork_args {\n"
"  register_t dummy;\n"
"};"

#. (itstool) path: sect3/para
#: article.translate.xml:1361
msgid ""
"And finally, <filename>linux_sysent.c</filename> contains structure "
"describing the system entry table, used to actually dispatch a syscall, e.g.:"
msgstr ""
"Y finalmente, <filename>linux_sysent.c</filename> contiene una estructura "
"que describe la tabla de entrada del sistema, utilizada para enviar una "
"llamada al sistema, por ejemplo:"

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1365
#, fuzzy, no-wrap
msgid ""
"{ 0, (sy_call_t *)linux_fork, AUE_FORK, NULL, 0, 0 }, /* 2 = linux_fork */\n"
"{ AS(close_args), (sy_call_t *)close, AUE_CLOSE, NULL, 0, 0 }, /* 6 = close */"
msgstr ""
"{ 0, (sy_call_t *)linux_fork, AUE_FORK, NULL, 0, 0 }, /* 2 = linux_fork */\n"
"{ AS(close_args), (sy_call_t *)close, AUE_CLOSE, NULL, 0, 0 }, /* 6 = close "
"*/\n"
"{ AS(close_args), (sy_call_t *)close, AUE_CLOSE, NULL, 0, 0 }, /* 6 = close "
"*/"

#. (itstool) path: sect3/para
#: article.translate.xml:1368
msgid ""
"As you can see <function>linux_fork</function> is implemented in Linuxulator "
"itself so the definition is of <literal>STD</literal> type and has no "
"argument, which is exhibited by the dummy argument structure. On the other "
"hand <function>close</function> is just an alias for real FreeBSD "
"<citerefentry><refentrytitle>close</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> so it has no linux arguments structure associated and in the "
"system entry table it is not prefixed with linux as it calls the real "
"<citerefentry><refentrytitle>close</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> in the kernel."
msgstr ""
"Como puedes ver <function>linux_fork</function> se implementa en el propio "
"Linuxulator, por lo que la definición es de <literal>STD</literal> type y no "
"tiene argumento, que es exhibido por la estructura de argumento ficticia. "
"Por otra parte <function>close</function> es solo un alias de FreeBSD real "
"<citerefentry><refentrytitle>cierre</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> por lo que no tiene una estructura de argumentos linux "
"asociada y en la tabla de entrada del sistema no tiene el prefijo linux, ya "
"que llama al real "
"<citerefentry><refentrytitle>cierre</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> en el kernel."

#. (itstool) path: sect3/title
#: article.translate.xml:1380
msgid "Dummy syscalls"
msgstr "Llamadas al sistema ficticias"

#. (itstool) path: sect3/para
#: article.translate.xml:1382
msgid ""
"The <trademark class=\"registered\">Linux</trademark> emulation layer is not "
"complete, as some syscalls are not implemented properly and some are not "
"implemented at all. The emulation layer employs a facility to mark "
"unimplemented syscalls with the <literal>DUMMY</literal> macro. These dummy "
"definitions reside in <filename>linux_dummy.c</filename> in a form of "
"<literal>DUMMY(syscall);</literal>, which is then translated to various "
"syscall auxiliary files and the implementation consists of printing a "
"message saying that this syscall is not implemented. The <literal>UNIMPL</"
"literal> prototype is not used because we want to be able to identify the "
"name of the syscall that was called in order to know what syscalls are more "
"important to implement."
msgstr ""
"El <trademark class=\"registered\">Linux</trademark> La capa de emulación no "
"está completa, ya que algunas llamadas al sistema no se implementan "
"correctamente y otras no se implementan en absoluto. La capa de emulación "
"emplea una función para marcar llamadas al sistema no implementadas con "
"el<literal>DUMMY</literal> macro. Estas definiciones ficticias residen en "
"<filename>linux_dummy.c</filename>en forma de <literal>DUMMY(syscall);</"
"literal>, que luego se traduce a varios archivos auxiliares de syscall y la "
"implementación consiste en imprimir un mensaje diciendo que este syscall no "
"está implementado. los <literal>UNIMPL</literal> prototype no se utiliza "
"porque queremos poder identificar el nombre de la llamada al sistema que se "
"llamó para saber qué llamadas al sistema son más importantes de implementar."

#. (itstool) path: sect2/title
#: article.translate.xml:1399
msgid "Signal handling"
msgstr "Manejo de señales"

#. (itstool) path: sect2/para
#: article.translate.xml:1401
msgid ""
"Signal handling is done generally in the FreeBSD kernel for all binary "
"compatibilities with a call to a compat-dependent layer. <trademark class="
"\"registered\">Linux</trademark> compatibility layer defines "
"<function>linux_sendsig</function> routine for this purpose."
msgstr ""
"El manejo de señales se realiza generalmente en el kernel de FreeBSD para "
"todas las compatibilidades binarias con una llamada a una capa dependiente "
"de la compatibilidad. <trademark class=\"registered\">Linux</trademark> la "
"capa de compatibilidad define <function>linux_sendsig</function> rutina para "
"este propósito."

#. (itstool) path: sect3/title
#: article.translate.xml:1408
#, fuzzy
msgid "<trademark class=\"registered\">Linux</trademark> sendsig"
msgstr "<trademark class=\"registered\">Linux</trademark> sendsig"

#. (itstool) path: sect3/para
#: article.translate.xml:1410
msgid ""
"This routine first checks whether the signal has been installed with a "
"<literal>SA_SIGINFO</literal> in which case it calls "
"<function>linux_rt_sendsig</function> routine instead. Furthermore, it "
"allocates (or reuses an already existing) signal handle context, then it "
"builds a list of arguments for the signal handler. It translates the signal "
"number based on the signal translation table, assigns a handler, translates "
"sigset. Then it saves context for the <function>sigreturn</function> routine "
"(various registers, translated trap number and signal mask). Finally, it "
"copies out the signal context to the userspace and prepares context for the "
"actual signal handler to run."
msgstr ""
"Esta rutina comprueba primero si la señal se ha instalado con un "
"<literal>SA_SIGINFO</literal> en cuyo caso llama <function>linux_rt_sendsig</"
"function> rutina en su lugar. Además, asigna (o reutiliza un contexto de "
"manejador de señal ya existente), luego crea una lista de argumentos para el "
"manejador de señal. Traduce el número de señal basado en la tabla de "
"traducción de señales, asigna un manejador, traduce sigset. Luego guarda "
"contexto para el <function>sigreturn</function> rutina (varios registros, "
"número de trampa traducido y máscara de señal). Finalmente, copia el "
"contexto de la señal al espacio de usuario y prepara el contexto para que se "
"ejecute el manejador de señal real."

#. (itstool) path: sect3/title
#: article.translate.xml:1425
#, fuzzy
msgid "linux_rt_sendsig"
msgstr "linux_rt_sendsig"

#. (itstool) path: sect3/para
#: article.translate.xml:1427
msgid ""
"This routine is similar to <function>linux_sendsig</function> just the "
"signal context preparation is different. It adds <literal>siginfo</literal>, "
"<literal>ucontext</literal>, and some <trademark class=\"registered\">POSIX</"
"trademark> parts. It might be worth considering whether those two functions "
"could not be merged with a benefit of less code duplication and possibly "
"even faster execution."
msgstr ""
"Esta rutina es similar a <function>linux_sendsig</function> solo la "
"preparación del contexto de la señal es diferente. Agregando "
"<literal>siginfo</literal>, <literal>ucontext</literal>, y algo <trademark "
"class=\"registered\">POSIX</trademark> partes. Podría valer la pena "
"considerar si esas dos funciones no se pueden combinar con el beneficio de "
"una menor duplicación de código y posiblemente una ejecución aún más rápida."

#. (itstool) path: sect3/title
#: article.translate.xml:1438
#, fuzzy
msgid "linux_sigreturn"
msgstr "linux_sigreturn"

#. (itstool) path: sect3/para
#: article.translate.xml:1440
msgid ""
"This syscall is used for return from the signal handler. It does some "
"security checks and restores the original process context. It also unmasks "
"the signal in process signal mask."
msgstr ""
"Esta llamada al sistema se utiliza para la devolución del controlador de "
"señales. Realiza algunas comprobaciones de seguridad y restaura el contexto "
"del proceso original. También desenmascara la señal en la máscara de señal "
"de proceso."

#. (itstool) path: sect2/title
#: article.translate.xml:1448
#, fuzzy
msgid "Ptrace"
msgstr "Ptrace"

#. (itstool) path: sect2/para
#: article.translate.xml:1450
msgid ""
"Many <trademark class=\"registered\">UNIX</trademark> derivates implement "
"the <citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> syscall in order to allow various tracking and "
"debugging features. This facility enables the tracing process to obtain "
"various information about the traced process, like register dumps, any "
"memory from the process address space, etc. and also to trace the process "
"like in stepping an instruction or between system entries (syscalls and "
"traps). <citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> also lets you set various information in the "
"traced process (registers etc.). <citerefentry><refentrytitle>ptrace</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> is a <trademark class="
"\"registered\">UNIX</trademark>-wide standard implemented in most <trademark "
"class=\"registered\">UNIX</trademark>es around the world."
msgstr ""
"Muchos <trademark class=\"registered\">UNIX</trademark> derivados "
"implementan el "
"<citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> syscall para permitir varias funciones de seguimiento y "
"depuración. Esta función permite que el proceso de rastreo obtenga diversa "
"información sobre el proceso rastreado, como volcados de registros, "
"cualquier memoria del espacio de direcciones del proceso, etc. y también "
"rastrear el proceso como en el paso de una instrucción o entre entradas del "
"sistema (syscalls y trampas). "
"<citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>también le permite configurar diversa información en el proceso "
"de seguimiento (registros, etc.). "
"<citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> es a <trademark class=\"registered\">UNIX</trademark>-amplio "
"estándar implementado en la mayoría <trademark class=\"registered\">UNIX</"
"trademark>es alrededor del mundo."

#. (itstool) path: sect2/para
#: article.translate.xml:1461
msgid ""
"<trademark class=\"registered\">Linux</trademark> emulation in FreeBSD "
"implements the <citerefentry><refentrytitle>ptrace</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> facility in "
"<filename>linux_ptrace.c</filename>. The routines for converting registers "
"between <trademark class=\"registered\">Linux</trademark> and FreeBSD and "
"the actual <citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> syscall emulation syscall. The syscall is a long "
"switch block that implements its counterpart in FreeBSD for every "
"<citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> command. The <citerefentry><refentrytitle>ptrace</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> commands are mostly "
"equal between <trademark class=\"registered\">Linux</trademark> and FreeBSD "
"so usually just a small modification is needed. For example, "
"<literal>PT_GETREGS</literal> in <trademark class=\"registered\">Linux</"
"trademark> operates on direct data while FreeBSD uses a pointer to the data "
"so after performing a (native) <citerefentry><refentrytitle>ptrace</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> syscall, a copyout "
"must be done to preserve <trademark class=\"registered\">Linux</trademark> "
"semantics."
msgstr ""
"<trademark class=\"registered\">Linux</trademark> emulación en FreeBSD "
"implementa la "
"<citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> instalación en <filename>linux_ptrace.c</filename>. Las "
"rutinas para convertir registros entre <trademark class=\"registered\""
">Linux</trademark> Y FreeBSD y el actual "
"<citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> syscall emulación syscall. El syscall es un bloque de "
"conmutadores largo que implementa su contraparte en FreeBSD para cada<citeref"
"entry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> mando. los "
"<citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> los comandos son en su mayoría iguales entre <trademark class="
"\"registered\">Linux</trademark> y FreeBSD, por lo que normalmente solo se "
"necesita una pequeña modificación. Por ejemplo, <literal>PT_GETREGS</"
"literal> en <trademark class=\"registered\">Linux</trademark> opera con "
"datos directos, mientras que FreeBSD usa un puntero a los datos, por lo que "
"después de realizar un (nativo) "
"<citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> syscall, se debe realizar una copia para conservar <trademark "
"class=\"registered\">Linux</trademark> semántica."

#. (itstool) path: sect2/para
#: article.translate.xml:1474
msgid ""
"The <citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> implementation in Linuxulator has some known "
"weaknesses. There have been panics seen when using <command>strace</command> "
"(which is a <citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> consumer) in the Linuxulator environment. Also "
"<literal>PT_SYSCALL</literal> is not implemented."
msgstr ""
"La "
"<citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> La implementación en Linuxulator tiene algunas debilidades "
"conocidas. Ha habido pánico al usar <command>strace</command> (el cual es un "
"<citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> consumidor) en el entorno Linuxulator. también "
"<literal>PT_SYSCALL</literal> no está implementado."

#. (itstool) path: sect2/para
#: article.translate.xml:1484
msgid ""
"Whenever a <trademark class=\"registered\">Linux</trademark> process running "
"in the emulation layer traps the trap itself is handled transparently with "
"the only exception of the trap translation. <trademark class=\"registered"
"\">Linux</trademark> and FreeBSD differs in opinion on what a trap is so "
"this is dealt with here. The code is actually very short:"
msgstr ""
"Siempre que un <trademark class=\"registered\">Linux</trademark> proceso que "
"se ejecuta en la capa de emulación trampas la trampa en sí se maneja de "
"forma transparente con la única excepción de la traducción de trampas. "
"<trademark class=\"registered\">Linux</trademark> y FreeBSD difiere de "
"opinión sobre lo que es una trampa, así que esto se trata aquí. El código es "
"realmente muy corto:"

#. (itstool) path: sect2/programlisting
#: article.translate.xml:1490
#, fuzzy, no-wrap
msgid ""
"static int\n"
"translate_traps(int signal, int trap_code)\n"
"{\n"
"\n"
"  if (signal != SIGBUS)\n"
"    return signal;\n"
"\n"
"  switch (trap_code) {\n"
"\n"
"    case T_PROTFLT:\n"
"    case T_TSSFLT:\n"
"    case T_DOUBLEFLT:\n"
"    case T_PAGEFLT:\n"
"      return SIGSEGV;\n"
"\n"
"    default:\n"
"      return signal;\n"
"  }\n"
"}"
msgstr ""
"static int\n"
"translate_traps(int signal, int trap_code)\n"
"{\n"
"\n"
"  if (signal != SIGBUS)\n"
"    return signal;\n"
"\n"
"  switch (trap_code) {\n"
"\n"
"    case T_PROTFLT:\n"
"    case T_TSSFLT:\n"
"    case T_DOUBLEFLT:\n"
"    case T_PAGEFLT:\n"
"      return SIGSEGV;\n"
"\n"
"    default:\n"
"      return signal;\n"
"  }\n"
"}"

#. (itstool) path: sect2/title
#: article.translate.xml:1512
msgid "Stack fixup"
msgstr "Reparación de pila"

#. (itstool) path: sect2/para
#: article.translate.xml:1514
msgid ""
"The RTLD run-time link-editor expects so called AUX tags on stack during an "
"<function>execve</function> so a fixup must be done to ensure this. Of "
"course, every RTLD system is different so the emulation layer must provide "
"its own stack fixup routine to do this. So does Linuxulator. The "
"<function>elf_linux_fixup</function> simply copies out AUX tags to the stack "
"and adjusts the stack of the user space process to point right after those "
"tags. So RTLD works in a smart way."
msgstr ""
"El editor de enlaces en tiempo de ejecución de RTLD espera las llamadas "
"etiquetas AUX en la pila durante una <function>execve</function>por lo que "
"se debe realizar una reparación para garantizar esto. Por supuesto, cada "
"sistema RTLD es diferente, por lo que la capa de emulación debe proporcionar "
"su propia rutina de reparación de la pila para hacer esto. Linuxulator "
"también. los <function>elf_linux_fixup</function> simplemente copia las "
"etiquetas AUX a la pila y ajusta la pila del proceso de espacio de usuario "
"para que apunte justo después de esas etiquetas. Entonces RTLD funciona de "
"manera inteligente."

#. (itstool) path: sect2/title
#: article.translate.xml:1526
msgid "A.OUT support"
msgstr "soporte A.OUT"

#. (itstool) path: sect2/para
#: article.translate.xml:1528
msgid ""
"The <trademark class=\"registered\">Linux</trademark> emulation layer on "
"i386 also supports <trademark class=\"registered\">Linux</trademark> A.OUT "
"binaries. Pretty much everything described in the previous sections must be "
"implemented for A.OUT support (beside traps translation and signals "
"sending). The support for A.OUT binaries is no longer maintained, especially "
"the 2.6 emulation does not work with it but this does not cause any problem, "
"as the linux-base in ports probably do not support A.OUT binaries at all. "
"This support will probably be removed in future. Most of the stuff necessary "
"for loading <trademark class=\"registered\">Linux</trademark> A.OUT binaries "
"is in <filename>imgact_linux.c</filename> file."
msgstr ""
"La <trademark class=\"registered\">Linux</trademark> La capa de emulación en "
"i386 también admite <trademark class=\"registered\">Linux</trademark>A.OUT "
"binarios. Prácticamente todo lo descrito en las secciones anteriores debe "
"implementarse para la compatibilidad con A.OUT (además de la traducción de "
"trampas y el envío de señales). El soporte para los binarios A.OUT ya no se "
"mantiene, especialmente la emulación 2.6 no funciona con él, pero esto no "
"causa ningún problema, ya que la base de linux en los puertos probablemente "
"no soporte los binarios A.OUT en absoluto. Este soporte probablemente se "
"eliminará en el futuro. La mayoría de las cosas necesarias para "
"cargar<trademark class=\"registered\">Linux</trademark> A.OUT binarios está "
"en <filename>imgact_linux.c</filename> archivo."

#. (itstool) path: sect1/title
#: article.translate.xml:1543
msgid ""
"<trademark class=\"registered\">Linux</trademark> emulation layer -MI part"
msgstr ""
"<trademark class=\"registered\">Linux</trademark> capa de emulación - parte "
"MI"

#. (itstool) path: sect1/para
#: article.translate.xml:1545
msgid ""
"This section talks about machine independent part of the Linuxulator. It "
"covers the emulation infrastructure needed for <trademark class=\"registered"
"\">Linux</trademark> 2.6 emulation, the thread local storage (TLS) "
"implementation (on i386) and futexes. Then we talk briefly about some "
"syscalls."
msgstr ""
"Esta sección habla de la parte independiente de la máquina del Linuxulator. "
"Cubre la infraestructura de emulación necesaria para <trademark class="
"\"registered\">Linux</trademark> 2.6 emulación, la implementación del "
"almacenamiento local de subprocesos (TLS) (en i386) y futexes. Luego "
"hablamos brevemente sobre algunas llamadas al sistema."

#. (itstool) path: sect2/title
#: article.translate.xml:1552
msgid "Description of NPTL"
msgstr "Descripción de NPTEL"

#. (itstool) path: sect2/para
#: article.translate.xml:1554
msgid ""
"One of the major areas of progress in development of <trademark class="
"\"registered\">Linux</trademark> 2.6 was threading. Prior to 2.6, the "
"<trademark class=\"registered\">Linux</trademark> threading support was "
"implemented in the <application>linuxthreads</application> library. The "
"library was a partial implementation of <trademark class=\"registered"
"\">POSIX</trademark> threading. The threading was implemented using separate "
"processes for each thread using the <function>clone</function> syscall to "
"let them share the address space (and other things). The main weaknesses of "
"this approach was that every thread had a different PID, signal handling was "
"broken (from the pthreads perspective), etc. Also the performance was not "
"very good (use of <literal>SIGUSR</literal> signals for threads "
"synchronization, kernel resource consumption, etc.) so to overcome these "
"problems a new threading system was developed and named NPTL."
msgstr ""
"Una de las principales áreas de progreso en el desarrollo de <trademark "
"class=\"registered\">Linux</trademark> 2.6 estaba enhebrando. Antes de 2.6, "
"el <trademark class=\"registered\">Linux</trademark> El soporte de "
"subprocesos se implementó en el <application>linuxthreads</application> "
"biblioteca. La biblioteca fue una implementación parcial de <trademark class="
"\"registered\">POSIX</trademark> enhebrado. El subproceso se implementó "
"usando procesos separados para cada subproceso usando el <function>clone</"
"function> syscall para permitirles compartir el espacio de direcciones (y "
"otras cosas). La principal debilidad de este enfoque era que cada hilo tenía "
"un PID diferente, el manejo de la señal estaba roto (desde la perspectiva de "
"los pthreads), etc. Además, el rendimiento no era muy bueno (uso de "
"<literal>SIGUSR</literal> señales para sincronización de subprocesos, "
"consumo de recursos del kernel, etc.), por lo que para superar estos "
"problemas se desarrolló un nuevo sistema de subprocesos denominado NPTL."

#. (itstool) path: sect2/para
#: article.translate.xml:1570
msgid ""
"The NPTL library focused on two things but a third thing came along so it is "
"usually considered a part of NPTL. Those two things were embedding of "
"threads into a process structure and futexes. The additional third thing was "
"TLS, which is not directly required by NPTL but the whole NPTL userland "
"library depends on it. Those improvements yielded in much improved "
"performance and standards conformance. NPTL is a standard threading library "
"in <trademark class=\"registered\">Linux</trademark> systems these days."
msgstr ""
"La biblioteca NPTL se centró en dos cosas, pero apareció una tercera, por lo "
"que generalmente se considera parte de NPTL. Esas dos cosas fueron la "
"incrustación de subprocesos en una estructura de proceso y funciones. La "
"tercera cosa adicional fue TLS, que no es requerido directamente por NPTL, "
"pero toda la biblioteca de usuario de NPTL depende de ello. Esas mejoras "
"dieron como resultado un rendimiento y una conformidad con los estándares "
"mucho mejores. NPTL es una biblioteca de subprocesos estándar en <trademark "
"class=\"registered\">Linux</trademark> sistemas en estos días."

#. (itstool) path: sect2/para
#: article.translate.xml:1579
msgid ""
"The FreeBSD Linuxulator implementation approaches the NPTL in three main "
"areas. The TLS, futexes and PID mangling, which is meant to simulate the "
"<trademark class=\"registered\">Linux</trademark> threads. Further sections "
"describe each of these areas."
msgstr ""
"La implementación de FreeBSD Linuxulator se acerca a la NPTL en tres áreas "
"principales. TLS, futexes y PID mangling, que está destinado a simular el "
"<trademark class=\"registered\">Linux</trademark> hilos. Más secciones "
"describen cada una de estas áreas."

#. (itstool) path: sect2/title
#: article.translate.xml:1586
msgid ""
"<trademark class=\"registered\">Linux</trademark> 2.6 emulation "
"infrastructure"
msgstr ""
"<trademark class=\"registered\">Linux</trademark> 2.6 infraestructura de "
"emulación"

#. (itstool) path: sect2/para
#: article.translate.xml:1588
msgid ""
"These sections deal with the way <trademark class=\"registered\">Linux</"
"trademark> threads are managed and how we simulate that in FreeBSD."
msgstr ""
"Estas secciones tratan sobre la forma <trademark class=\"registered\">Linux</"
"trademark> se administran los hilos y cómo lo simulamos en FreeBSD."

#. (itstool) path: sect3/title
#: article.translate.xml:1592
msgid "Runtime determining of 2.6 emulation"
msgstr "Determinación del tiempo de ejecución de la emulación 2.6"

#. (itstool) path: sect3/para
#: article.translate.xml:1594
msgid ""
"The <trademark class=\"registered\">Linux</trademark> emulation layer in "
"FreeBSD supports runtime setting of the emulated version. This is done via "
"<citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry>, namely <literal>compat.linux.osrelease</literal>. Setting "
"this <citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry> affects runtime behavior of the emulation layer. "
"When set to 2.6.x it sets the value of <literal>linux_use_linux26</literal> "
"while setting to something else keeps it unset. This variable (plus per-"
"prison variables of the very same kind) determines whether 2.6 "
"infrastructure (mainly PID mangling) is used in the code or not. The version "
"setting is done system-wide and this affects all <trademark class="
"\"registered\">Linux</trademark> processes. The "
"<citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> should not be changed when running any <trademark class="
"\"registered\">Linux</trademark> binary as it might harm things."
msgstr ""
"En <trademark class=\"registered\">Linux</trademark>La capa de emulación en "
"FreeBSD admite la configuración de tiempo de ejecución de la versión "
"emulada. Esto se hace a través de "
"<citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry>, a saber <literal>compat.linux.osrelease</literal>. "
"configurando esto "
"<citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry>afecta el comportamiento en tiempo de ejecución de la capa de "
"emulación. Cuando se establece en 2.6.x, establece el valor de "
"<literal>linux_use_linux26</literal> mientras que el ajuste a otra cosa lo "
"mantiene desarmado. Esta variable (más las variables por prisión del mismo "
"tipo) determina si la infraestructura 2.6 (principalmente manipulación de "
"PID) se usa en el código o no. La configuración de la versión se realiza en "
"todo el sistema y esto afecta a todos<trademark class=\"registered\">Linux</"
"trademark> procesos. los<citerefentry><refentrytitle>sysctl</refentrytitle><m"
"anvolnum>8</manvolnum></citerefentry>no debe cambiarse al ejecutar cualquier "
"<trademark class=\"registered\">Linux</trademark>binario, ya que podría "
"dañar las cosas."

#. (itstool) path: sect3/title
#: article.translate.xml:1611
msgid ""
"<trademark class=\"registered\">Linux</trademark> processes and thread "
"identifiers"
msgstr ""
"<trademark class=\"registered\">Linux</trademark> identificadores de "
"procesos e hilos"

#. (itstool) path: sect3/para
#: article.translate.xml:1613
msgid ""
"The semantics of <trademark class=\"registered\">Linux</trademark> threading "
"are a little confusing and uses entirely different nomenclature to FreeBSD. "
"A process in <trademark class=\"registered\">Linux</trademark> consists of a "
"<literal>struct task</literal> embedding two identifier fields - PID and "
"TGID. PID is <emphasis>not</emphasis> a process ID but it is a thread ID. "
"The TGID identifies a thread group in other words a process. For single-"
"threaded process the PID equals the TGID."
msgstr ""
"La semántica de <trademark class=\"registered\">Linux</trademark> Los "
"subprocesos son un poco confusos y utilizan una nomenclatura completamente "
"diferente a la de FreeBSD. Un proceso en <trademark class=\"registered\""
">Linux</trademark> consiste en un <literal>estructura de la tarea</literal> "
"incrustando dos campos identificadores: PID y TGID. PID es <emphasis>no</"
"emphasis> un ID de proceso pero es un ID de hilo. El TGID identifica un "
"grupo de subprocesos, en otras palabras, un proceso. Para procesos de un "
"solo subproceso, el PID es igual al TGID."

#. (itstool) path: sect3/para
#: article.translate.xml:1622
msgid ""
"The thread in NPTL is just an ordinary process that happens to have TGID not "
"equal to PID and have a group leader not equal to itself (and shared VM etc. "
"of course). Everything else happens in the same way as to an ordinary "
"process. There is no separation of a shared status to some external "
"structure like in FreeBSD. This creates some duplication of information and "
"possible data inconsistency. The <trademark class=\"registered\">Linux</"
"trademark> kernel seems to use task -&gt; group information in some places "
"and task information elsewhere and it is really not very consistent and "
"looks error-prone."
msgstr ""
"El hilo en NPTL es solo un proceso ordinario que tiene TGID no igual a PID y "
"tiene un líder de grupo que no es igual a él (y VM compartida, etc., por "
"supuesto). Todo lo demás sucede de la misma manera que en un proceso "
"ordinario. No hay separación de un estado compartido a alguna estructura "
"externa como en FreeBSD. Esto crea cierta duplicación de información y una "
"posible inconsistencia de datos. los <trademark class=\"registered\">Linux</"
"trademark> el kernel parece utilizar task -&gt;; información de grupo en "
"algunos lugares e información de tareas en otros lugares y en realidad no es "
"muy consistente y parece propensa a errores."

#. (itstool) path: sect3/para
#: article.translate.xml:1633
msgid ""
"Every NPTL thread is created by a call to the <function>clone</function> "
"syscall with a specific set of flags (more in the next subsection). The NPTL "
"implements strict 1:1 threading."
msgstr ""
"cada hilo NPTL se crea mediante una llamada ala <function>clone</function> "
"syscall con un conjunto específico de indicadores (más en la siguiente "
"subsección). La NPTL implementa un subproceso estricto 1: 1."

#. (itstool) path: sect3/para
#: article.translate.xml:1638
msgid ""
"In FreeBSD we emulate NPTL threads with ordinary FreeBSD processes that "
"share VM space, etc. and the PID gymnastic is just mimicked in the emulation "
"specific structure attached to the process. The structure attached to the "
"process looks like:"
msgstr ""
"En FreeBSD emulamos hilos NPTL con procesos FreeBSD ordinarios que comparten "
"espacio VM, etc. y la gimnasia PID simplemente se imita en la estructura "
"específica de emulación adjunta al proceso. La estructura adjunta al proceso "
"se ve así:"

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1644
#, no-wrap
msgid ""
"struct linux_emuldata {\n"
"  pid_t pid;\n"
"\n"
"  int *child_set_tid; /* in clone(): Child.s TID to set on clone */\n"
"  int *child_clear_tid;/* in clone(): Child.s TID to clear on exit */\n"
"\n"
"  struct linux_emuldata_shared *shared;\n"
"\n"
"  int pdeath_signal; /* parent death signal */\n"
"\n"
"  LIST_ENTRY(linux_emuldata) threads; /* list of linux threads */\n"
"};"
msgstr ""
"struct linux_emuldata {\n"
"  pid_t pid;\n"
"\n"
"  int *child_set_tid; /* in clone(): Child.s TID to set on clone */\n"
"  int *child_clear_tid;/* in clone(): Child.s TID to clear on exit */\n"
"\n"
"  struct linux_emuldata_shared *shared;\n"
"\n"
"  int pdeath_signal; /* parent death signal */\n"
"\n"
"  LIST_ENTRY(linux_emuldata) threads; /* list of linux threads */\n"
"};"

#. (itstool) path: sect3/para
#: article.translate.xml:1657
msgid ""
"The PID is used to identify the FreeBSD process that attaches this "
"structure. The <function>child_se_tid</function> and "
"<function>child_clear_tid</function> are used for TID address copyout when a "
"process exits and is created. The <varname>shared</varname> pointer points "
"to a structure shared among threads. The <varname>pdeath_signal</varname> "
"variable identifies the parent death signal and the <varname>threads</"
"varname> pointer is used to link this structure to the list of threads. The "
"<literal>linux_emuldata_shared</literal> structure looks like:"
msgstr ""
"El PID se usa para identificar el proceso FreeBSD que adjunta esta "
"estructura. los <function>child_se_tid</function> y "
"<function>child_clear_tid</function> se utilizan para la copia de "
"direcciones TID cuando un proceso sale y se crea. los <varname>shared</"
"varname> puntero apunta a una estructura compartida entre subprocesos. los "
"<varname>pdeath_signal</varname> La variable identifica la señal de muerte "
"del padre y la <varname>threads</varname>El puntero se utiliza para vincular "
"esta estructura a la lista de subprocesos. los "
"<literal>linux_emuldata_shared</literal> estructura se parece a:"

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1670
#, fuzzy, no-wrap
msgid ""
"struct linux_emuldata_shared {\n"
"\n"
"  int refs;\n"
"\n"
"  pid_t group_pid;\n"
"\n"
"  LIST_HEAD(, linux_emuldata) threads; /* head of list of linux threads */\n"
"};"
msgstr ""
"struct linux_emuldata_shared {\n"
"\n"
"  int refs;\n"
"\n"
"  pid_t group_pid;\n"
"\n"
"  LIST_HEAD(, linux_emuldata) threads; /* head of list of linux threads */\n"
"};"

#. (itstool) path: sect3/para
#: article.translate.xml:1679
msgid ""
"The <varname>refs</varname> is a reference counter being used to determine "
"when we can free the structure to avoid memory leaks. The "
"<varname>group_pid</varname> is to identify PID ( = TGID) of the whole "
"process ( = thread group). The <varname>threads</varname> pointer is the "
"head of the list of threads in the process."
msgstr ""
"La <varname>refs</varname> es un contador de referencia que se utiliza para "
"determinar cuándo podemos liberar la estructura para evitar pérdidas de "
"memoria. los <varname>group_pid</varname> es identificar PID (= TGID) de "
"todo el proceso (= grupo de subprocesos). los  <varname>threads</varname> "
"puntero es el encabezado de la lista de subprocesos en el proceso."

#. (itstool) path: sect3/para
#: article.translate.xml:1686
msgid ""
"The <literal>linux_emuldata</literal> structure can be obtained from the "
"process using <function>em_find</function>. The prototype of the function is:"
msgstr ""
"El <literal>linux_emuldata</literal> La estructura se puede obtener del "
"proceso utilizando <function>em_find</function>. el prototipo de la función "
"es:"

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1691
#, fuzzy, no-wrap
msgid "struct linux_emuldata *em_find(struct proc *, int locked);"
msgstr "struct linux_emuldata *em_find(struct proc *, int locked);"

#. (itstool) path: sect3/para
#: article.translate.xml:1693
msgid ""
"Here, <varname>proc</varname> is the process we want the emuldata structure "
"from and the locked parameter determines whether we want to lock or not. The "
"accepted values are <literal>EMUL_DOLOCK</literal> and "
"<literal>EMUL_DOUNLOCK</literal>. More about locking later."
msgstr ""
"Aqui, <varname>proc</varname> es el proceso del que queremos la estructura "
"emuldata y el parámetro bloqueado determina si queremos bloquear o no. Los "
"valores aceptados son<literal>EMUL_DOLOCK</literal> y "
"<literal>EMUL_DOUNLOCK</literal>. Más sobre bloquear más tarde."

#. (itstool) path: sect3/title
#: article.translate.xml:1702
msgid "PID mangling"
msgstr "Destrucción de PID"

#. (itstool) path: sect3/para
#: article.translate.xml:1704
msgid ""
"Because of the described different view knowing what a process ID and thread "
"ID is between FreeBSD and <trademark class=\"registered\">Linux</trademark> "
"we have to translate the view somehow. We do it by PID mangling. This means "
"that we fake what a PID (=TGID) and TID (=PID) is between kernel and "
"userland. The rule of thumb is that in kernel (in Linuxulator) PID = PID and "
"TGID = shared -&gt; group pid and to userland we present <literal>PID = "
"shared -&gt; group_pid</literal> and <literal>TID = proc -&gt; p_pid</"
"literal>. The PID member of <literal>linux_emuldata structure</literal> is a "
"FreeBSD PID."
msgstr ""
"Debido a la vista diferente descrita, saber qué ID de proceso e ID de "
"subproceso es entre FreeBSD y <trademark class=\"registered\">Linux</"
"trademark> tenemos que traducir la vista de alguna manera. Lo hacemos "
"mediante la manipulación de PID. Esto significa que falsificamos lo que es "
"un PID (= TGID) y TID (= PID) entre el kernel y el área de usuario. La regla "
"general es que en el kernel (en Linuxulator) PID = PID y TGID = compartido "
"-&gt; pid de grupo y al área de usuario presentamos <literal>PID = shared "
"-&gt; group_pid</literal> y <literal>TID = proc -&gt; p_pid</literal>. El "
"miembro PID de<literal>linux_emuldata structure</literal> es un PID de "
"FreeBSD."

#. (itstool) path: sect3/para
#: article.translate.xml:1716
msgid ""
"The above affects mainly getpid, getppid, gettid syscalls. Where we use PID/"
"TGID respectively. In copyout of TIDs in <function>child_clear_tid</"
"function> and <function>child_set_tid</function> we copy out FreeBSD PID."
msgstr ""
"Lo anterior afecta principalmente a las llamadas al sistema getpid, getppid, "
"gettid. Donde usamos PID / TGID respectivamente. En copia de TID en "
"<function>child_clear_tid</function> y<function>child_set_tid</function> "
"copiamos FreeBSD PID."

#. (itstool) path: sect3/title
#: article.translate.xml:1724
msgid "Clone syscall"
msgstr "Clonar syscall"

#. (itstool) path: sect3/para
#: article.translate.xml:1726
msgid ""
"The <function>clone</function> syscall is the way threads are created in "
"<trademark class=\"registered\">Linux</trademark>. The syscall prototype "
"looks like this:"
msgstr ""
"La <function>clone</function> syscall es la forma en que se crean los hilos "
"en <trademark class=\"registered\">Linux</trademark>. El prototipo de "
"syscall se ve así:"

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1730
#, fuzzy, no-wrap
msgid ""
"int linux_clone(l_int flags, void *stack, void *parent_tidptr, int dummy,\n"
"void * child_tidptr);"
msgstr ""
"int linux_clone(l_int flags, void *stack, void *parent_tidptr, int dummy,\n"
"void * child_tidptr);"

#. (itstool) path: sect3/para
#: article.translate.xml:1733
msgid ""
"The <varname>flags</varname> parameter tells the syscall how exactly the "
"processes should be cloned. As described above, <trademark class=\"registered"
"\">Linux</trademark> can create processes sharing various things "
"independently, for example two processes can share file descriptors but not "
"VM, etc. Last byte of the <varname>flags</varname> parameter is the exit "
"signal of the newly created process. The <varname>stack</varname> parameter "
"if non-<literal>NULL</literal> tells, where the thread stack is and if it is "
"<literal>NULL</literal> we are supposed to copy-on-write the calling process "
"stack (i.e. do what normal <citerefentry><refentrytitle>fork</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> routine does). The "
"<varname>parent_tidptr</varname> parameter is used as an address for copying "
"out process PID (i.e. thread id) once the process is sufficiently "
"instantiated but is not runnable yet. The <varname>dummy</varname> parameter "
"is here because of the very strange calling convention of this syscall on "
"i386. It uses the registers directly and does not let the compiler do it "
"what results in the need of a dummy syscall. The <varname>child_tidptr</"
"varname> parameter is used as an address for copying out PID once the "
"process has finished forking and when the process exits."
msgstr ""
"El <varname>flags</varname> El parámetro le dice al syscall cómo exactamente "
"se deben clonar los procesos. Como se describió anteriormente, <trademark "
"class=\"registered\">Linux</trademark> puede crear procesos compartiendo "
"varias cosas de forma independiente, por ejemplo, dos procesos pueden "
"compartir descriptores de archivo pero no VM, etc. Último byte del "
"<varname>flags</varname> El parámetro es la señal de salida del proceso "
"recién creado. los <varname>stack</varname> parameter if non-<literal>NULL</"
"literal> dice dónde está la pila de subprocesos y si está <literal>NULL</"
"literal> se supone que debemos copiar al escribir la pila del proceso de "
"llamada (es decir, hacer lo normal "
"<citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> lo hace la rutina). los <varname>parent_tidptr</varname> El "
"parámetro se usa como una dirección para copiar el PID del proceso (es "
"decir, el ID del hilo) una vez que el proceso está suficientemente "
"instanciado pero aún no se puede ejecutar. los <varname>tonto</varname> El "
"parámetro está aquí debido a la muy extraña convención de llamada de esta "
"llamada al sistema en i386. Utiliza los registros directamente y no deja que "
"el compilador lo haga, lo que resulta en la necesidad de una llamada al "
"sistema ficticia. los <varname>child_tidptr</varname> El parámetro se "
"utiliza como dirección para copiar PID una vez que el proceso ha terminado "
"de bifurcarse y cuando el proceso finaliza."

#. (itstool) path: sect3/para
#: article.translate.xml:1755
msgid ""
"The syscall itself proceeds by setting corresponding flags depending on the "
"flags passed in. For example, <literal>CLONE_VM</literal> maps to RFMEM "
"(sharing of VM), etc. The only nit here is <literal>CLONE_FS</literal> and "
"<literal>CLONE_FILES</literal> because FreeBSD does not allow setting this "
"separately so we fake it by not setting RFFDG (copying of fd table and other "
"fs information) if either of these is defined. This does not cause any "
"problems, because those flags are always set together. After setting the "
"flags the process is forked using the internal <function>fork1</function> "
"routine, the process is instrumented not to be put on a run queue, i.e. not "
"to be set runnable. After the forking is done we possibly reparent the newly "
"created process to emulate <literal>CLONE_PARENT</literal> semantics. Next "
"part is creating the emulation data. Threads in <trademark class=\"registered"
"\">Linux</trademark> does not signal their parents so we set exit signal to "
"be 0 to disable this. After that setting of <varname>child_set_tid</varname> "
"and <varname>child_clear_tid</varname> is performed enabling the "
"functionality later in the code. At this point we copy out the PID to the "
"address specified by <varname>parent_tidptr</varname>. The setting of "
"process stack is done by simply rewriting thread frame <varname>%esp</"
"varname> register (<varname>%rsp</varname> on amd64). Next part is setting "
"up TLS for the newly created process. After this "
"<citerefentry><refentrytitle>vfork</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> semantics might be emulated and finally the newly created "
"process is put on a run queue and copying out its PID to the parent process "
"via <function>clone</function> return value is done."
msgstr ""
"La propia llamada al sistema procede estableciendo los indicadores "
"correspondientes en función de los indicadores pasados. Por ejemplo, "
"<literal>CLONE_VM</literal> mapas a RFMEM (compartir VM), etc. La única nit "
"aquí es <literal>CLONE_FS</literal> y <literal>CLONE_FILES</literal>porque "
"FreeBSD no permite configurar esto por separado, por lo que lo falsificamos "
"al no configurar RFFDG (copia de la tabla fd y otra información fs) si "
"alguno de estos está definido. Esto no causa ningún problema, porque esos "
"indicadores siempre se colocan juntos. Después de configurar las banderas, "
"el proceso se bifurca utilizando el <function>fork1</function> rutina, el "
"proceso está instrumentado para que no se ponga en una cola de ejecución, es "
"decir, no se establezca como ejecutable. Una vez finalizada la bifurcación, "
"posiblemente volvamos a hacer el proceso recién creado para emular "
"<literal>CLONE_PARENT</literal> semántica. La siguiente parte es crear los "
"datos de emulación. Hilos en <trademark class=\"registered\">Linux</"
"trademark> no envía una señal a sus padres, por lo que establecemos la señal "
"de salida en 0 para deshabilitar esto. Después de esa configuración de "
"<varname>child_set_tid</varname> and <varname>child_clear_tid</varname> se "
"realiza habilitando la funcionalidad más adelante en el código. En este "
"punto copiamos el PID a la dirección especificada por "
"<varname>parent_tidptr</varname>. la configuración de la pila de procesos se "
"realiza simplemente reescribiendo el marco del hilo <varname>%esp</varname> "
"registrar (<varname>%rsp</varname> en amd64). La siguiente parte es "
"configurar TLS para el proceso recién creado. Después de este "
"<citerefentry><refentrytitle>vfork</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> semantics podría ser emulado y finalmente el proceso recién "
"creado se coloca en una cola de ejecución y copia su PID al proceso padre a "
"través de <function>clone</function> el valor de retorno está hecho."

#. (itstool) path: sect3/para
#: article.translate.xml:1786
msgid ""
"The <function>clone</function> syscall is able and in fact is used for "
"emulating classic <citerefentry><refentrytitle>fork</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> and "
"<citerefentry><refentrytitle>vfork</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> syscalls. Newer glibc in a case of 2.6 kernel uses "
"<function>clone</function> to implement <citerefentry><refentrytitle>fork</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> and "
"<citerefentry><refentrytitle>vfork</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> syscalls."
msgstr ""
"El <function>clone</function> syscall es capaz y de hecho se usa para emular "
"el clásico "
"<citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> y "
"<citerefentry><refentrytitle>vfork</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> syscalls. Glibc más nuevo en un caso de usos del kernel 2.6 "
"<function>clonar</function> para implementar "
"<citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> y "
"<citerefentry><refentrytitle>vfork</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> syscalls."

#. (itstool) path: sect3/title
#: article.translate.xml:1794
msgid "Locking"
msgstr "Cierre"

#. (itstool) path: sect3/para
#: article.translate.xml:1796
msgid ""
"The locking is implemented to be per-subsystem because we do not expect a "
"lot of contention on these. There are two locks: <literal>emul_lock</"
"literal> used to protect manipulating of <literal>linux_emuldata</literal> "
"and <literal>emul_shared_lock</literal> used to manipulate "
"<literal>linux_emuldata_shared</literal>. The <literal>emul_lock</literal> "
"is a nonsleepable blocking mutex while <literal>emul_shared_lock</literal> "
"is a sleepable blocking <literal>sx_lock</literal>. Because of the per-"
"subsystem locking we can coalesce some locks and that is why the em find "
"offers the non-locking access."
msgstr ""
"el bloqueo se implementa para ser por subsistema porque no esperamos mucha "
"contención sobre estos. Hay dos candados:<literal>emul_lock</literal> "
"utilizado para proteger la manipulación de <literal>linux_emuldata</literal> "
"y <literal>emul_shared_lock</literal> usado para manipular "
"<literal>linux_emuldata_shared</literal>. El <literal>emul_lock</literal> es "
"un mutex de bloqueo que no se puede dormir mientras "
"<literal>emul_shared_lock</literal> es un bloqueo dormible <literal>sx_lock</"
"literal>. Debido al bloqueo por subsistema, podemos fusionar algunos "
"bloqueos y es por eso que em find ofrece acceso sin bloqueo."

#. (itstool) path: sect2/title
#: article.translate.xml:1812
#, fuzzy
msgid "TLS"
msgstr "TLS"

#. (itstool) path: sect2/para
#: article.translate.xml:1814
msgid "This section deals with TLS also known as thread local storage."
msgstr ""
"Esta sección trata sobre TLS, también conocido como almacenamiento local de "
"subprocesos."

#. (itstool) path: sect3/title
#: article.translate.xml:1818
msgid "Introduction to threading"
msgstr "Introducción al subproceso"

#. (itstool) path: sect3/para
#: article.translate.xml:1820
msgid ""
"Threads in computer science are entities within a process that can be "
"scheduled independently from each other. The threads in the process share "
"process wide data (file descriptors, etc.) but also have their own stack for "
"their own data. Sometimes there is a need for process-wide data specific to "
"a given thread. Imagine a name of the thread in execution or something like "
"that. The traditional <trademark class=\"registered\">UNIX</trademark> "
"threading API, <application>pthreads</application> provides a way to do it "
"via <citerefentry><refentrytitle>pthread_key_create</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>pthread_setspecific</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry> and "
"<citerefentry><refentrytitle>pthread_getspecific</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry> where a thread can "
"create a key to the thread local data and using "
"<citerefentry><refentrytitle>pthread_getspecific</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry> or "
"<citerefentry><refentrytitle>pthread_getspecific</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry> to manipulate those "
"data. You can easily see that this is not the most comfortable way this "
"could be accomplished. So various producers of C/C++ compilers introduced a "
"better way. They defined a new modifier keyword thread that specifies that a "
"variable is thread specific. A new method of accessing such variables was "
"developed as well (at least on i386). The <application>pthreads</"
"application> method tends to be implemented in userspace as a trivial lookup "
"table. The performance of such a solution is not very good. So the new "
"method uses (on i386) segment registers to address a segment, where TLS area "
"is stored so the actual accessing of a thread variable is just appending the "
"segment register to the address thus addressing via it. The segment "
"registers are usually <varname>%gs</varname> and <varname>%fs</varname> "
"acting like segment selectors. Every thread has its own area where the "
"thread local data are stored and the segment must be loaded on every context "
"switch. This method is very fast and used almost exclusively in the whole "
"i386 <trademark class=\"registered\">UNIX</trademark> world. Both FreeBSD "
"and <trademark class=\"registered\">Linux</trademark> implement this "
"approach and it yields very good results. The only drawback is the need to "
"reload the segment on every context switch which can slowdown context "
"switches. FreeBSD tries to avoid this overhead by using only 1 segment "
"descriptor for this while <trademark class=\"registered\">Linux</trademark> "
"uses 3. Interesting thing is that almost nothing uses more than 1 descriptor "
"(only <application>Wine</application> seems to use 2) so <trademark class="
"\"registered\">Linux</trademark> pays this unnecessary price for context "
"switches."
msgstr ""
"Los subprocesos en ciencias de la computación son entidades dentro de un "
"proceso que se pueden programar de forma independiente entre sí. Los "
"subprocesos del proceso comparten datos de todo el proceso (descriptores de "
"archivo, etc.) pero también tienen su propia pila para sus propios datos. A "
"veces existe la necesidad de datos de todo el proceso específicos para un "
"hilo dado. Imagina un nombre del hilo en ejecución o algo así. Lo "
"tradicional <trademark class=\"registered\">UNIX</trademark> API de "
"subprocesos, <application>pthreads</application> proporciona una forma de "
"hacerlo a través de <citerefentry><refentrytitle>pthread_key_create</refentry"
"title><manvolnum>3</manvolnum></citerefentry>, <citerefentry><refentrytitle>p"
"thread_setspecific</refentrytitle><manvolnum>3</manvolnum></citerefentry> y <"
"citerefentry><refentrytitle>pthread_getspecific</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry> donde un hilo puede crear una clave para los datos "
"locales del hilo y usar <citerefentry><refentrytitle>pthread_getspecific</ref"
"entrytitle><manvolnum>3</manvolnum></citerefentry> o <citerefentry><refentryt"
"itle>pthread_getspecific</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry> para manipular esos datos. Puede ver fácilmente que esta no es "
"la forma más cómoda de lograrlo. Entonces, varios productores de "
"compiladores C / C ++ introdujeron una mejor manera. Definieron un nuevo "
"hilo de palabra clave modificadora que especifica que una variable es "
"específica del hilo. También se desarrolló un nuevo método para acceder a "
"tales variables (al menos en i386). los <application>pthreads</application> "
"El método tiende a implementarse en el espacio de usuario como una tabla de "
"búsqueda trivial. El rendimiento de esta solución no es muy bueno. Por lo "
"tanto, el nuevo método usa (en i386) registros de segmento para direccionar "
"un segmento, donde el área TLS se almacena, por lo que el acceso real de una "
"variable de subproceso es simplemente agregar el registro de segmento a la "
"dirección, por lo que se direcciona a través de ella. Los registros de "
"segmento suelen ser <varname>%gs</varname> and <varname>%fs</varname> "
"actuando como selectores de segmento. Cada hilo tiene su propia área donde "
"se almacenan los datos locales del hilo y el segmento se debe cargar en cada "
"cambio de contexto. Este método es muy rápido y se utiliza casi "
"exclusivamente en todo el i386. <trademark class=\"registered\">UNIX</"
"trademark> mundo. Tanto FreeBSD como <trademark class=\"registered\">Linux</"
"trademark> implementar este enfoque y produce muy buenos resultados. El "
"único inconveniente es la necesidad de volver a cargar el segmento en cada "
"cambio de contexto que puede ralentizar los cambios de contexto. FreeBSD "
"intenta evitar esta sobrecarga usando solo 1 descriptor de segmento para "
"esto mientras <trademark class=\"registered\">Linux</trademark> utiliza 3. "
"Lo interesante es que casi nada utiliza más de 1 descriptor (solo "
"<application>Wine</application> parece usar 2) entonces<trademark class="
"\"registered\">Linux</trademark> paga este precio innecesario por los "
"cambios de contexto."

#. (itstool) path: sect3/title
#: article.translate.xml:1864
msgid "Segments on i386"
msgstr "Segmentos en i386"

#. (itstool) path: sect3/para
#: article.translate.xml:1866
msgid ""
"The i386 architecture implements the so called segments. A segment is a "
"description of an area of memory. The base address (bottom) of the memory "
"area, the end of it (ceiling), type, protection, etc. The memory described "
"by a segment can be accessed using segment selector registers (<varname>%cs</"
"varname>, <varname>%ds</varname>, <varname>%ss</varname>, <varname>%es</"
"varname>, <varname>%fs</varname>, <varname>%gs</varname>). For example let "
"us suppose we have a segment which base address is 0x1234 and length and "
"this code:"
msgstr ""
"La arquitectura i386 implementa los llamados segmentos. Un segmento es una "
"descripción de un área de la memoria. La dirección base (parte inferior) del "
"área de memoria, el final de la misma (techo), tipo, protección, etc. Se "
"puede acceder a la memoria descrita por un segmento utilizando registros de "
"selector de segmento (<varname>%cs</varname>, <varname>%ds</varname>, "
"<varname>%ss</varname>, <varname>%es</varname>, <varname>%fs</varname>, "
"<varname>%gs</varname>). Por ejemplo, supongamos que tenemos un segmento "
"cuya dirección base es 0x1234 y longitud y este código:"

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1877
#, fuzzy, no-wrap
msgid "mov %edx,%gs:0x10"
msgstr "mov %edx,%gs:0x10"

#. (itstool) path: sect3/para
#: article.translate.xml:1879
msgid ""
"This will load the content of the <varname>%edx</varname> register into "
"memory location 0x1244. Some segment registers have a special use, for "
"example <varname>%cs</varname> is used for code segment and <varname>%ss</"
"varname> is used for stack segment but <varname>%fs</varname> and <varname>"
"%gs</varname> are generally unused. Segments are either stored in a global "
"GDT table or in a local LDT table. LDT is accessed via an entry in the GDT. "
"The LDT can store more types of segments. LDT can be per process. Both "
"tables define up to 8191 entries."
msgstr ""
"Esto cargará el contenido del <varname>%edx</varname> registrarse en la "
"ubicación de memoria 0x1244. Algunos registros de segmento tienen un uso "
"especial, por ejemplo <varname>%cs</varname> se utiliza para el segmento de "
"código y<varname>%ss</varname>se utiliza para el segmento de pila pero "
"<varname>%fs</varname> y <varname>%gs</varname> generalmente no se utilizan. "
"Los segmentos se almacenan en una tabla GDT global o en una tabla LDT local. "
"Se accede a LDT a través de una entrada en el GDT. El LDT puede almacenar "
"más tipos de segmentos. LDT puede ser por proceso. Ambas tablas definen "
"hasta 8191 entradas."

#. (itstool) path: sect3/title
#: article.translate.xml:1893
msgid ""
"Implementation on <trademark class=\"registered\">Linux</trademark> i386"
msgstr ""
"Implementación en <trademark class=\"registered\">Linux</trademark> i386"

#. (itstool) path: sect3/para
#: article.translate.xml:1895
msgid ""
"There are two main ways of setting up TLS in <trademark class=\"registered"
"\">Linux</trademark>. It can be set when cloning a process using the "
"<function>clone</function> syscall or it can call <function>set_thread_area</"
"function>. When a process passes <literal>CLONE_SETTLS</literal> flag to "
"<function>clone</function>, the kernel expects the memory pointed to by the "
"<varname>%esi</varname> register a <trademark class=\"registered\">Linux</"
"trademark> user space representation of a segment, which gets translated to "
"the machine representation of a segment and loaded into a GDT slot. The GDT "
"slot can be specified with a number or -1 can be used meaning that the "
"system itself should choose the first free slot. In practice, the vast "
"majority of programs use only one TLS entry and does not care about the "
"number of the entry. We exploit this in the emulation and in fact depend on "
"it."
msgstr ""
"Hay dos formas principales de configurar TLS en <trademark class=\"registered"
"\">Linux</trademark>. se puede configurar al clonar un proceso usando el "
"<function>clone</function> syscall o puede llamar <function>set_thread_area</"
"function>. Cuando pasa un proceso <literal>CLONE_SETTLS</literal>bandera a "
"<function>clonar</function>, el kernel espera la memoria apuntada por el "
"<varname>%esi</varname> registrar un<trademark class=\"registered\">Linux</"
"trademark> representación en el espacio de usuario de un segmento, que se "
"traduce a la representación de máquina de un segmento y se carga en una "
"ranura GDT. La ranura GDT se puede especificar con un número o se puede usar "
"-1, lo que significa que el sistema debe elegir la primera ranura libre. En "
"la práctica, la gran mayoría de los programas utilizan solo una entrada TLS "
"y no se preocupa por el número de la entrada. Aprovechamos esto en la "
"emulación y de hecho dependemos de ello."

#. (itstool) path: sect3/title
#: article.translate.xml:1913
msgid "Emulation of <trademark class=\"registered\">Linux</trademark> TLS"
msgstr "Emulation of <trademark class=\"registered\">Linux</trademark> TLS"

#. (itstool) path: sect4/title
#: article.translate.xml:1916
#, fuzzy
msgid "i386"
msgstr "i386"

#. (itstool) path: sect4/para
#: article.translate.xml:1918
msgid ""
"Loading of TLS for the current thread happens by calling "
"<function>set_thread_area</function> while loading TLS for a second process "
"in <function>clone</function> is done in the separate block in "
"<function>clone</function>. Those two functions are very similar. The only "
"difference being the actual loading of the GDT segment, which happens on the "
"next context switch for the newly created process while "
"<function>set_thread_area</function> must load this directly. The code "
"basically does this. It copies the <trademark class=\"registered\">Linux</"
"trademark> form segment descriptor from the userland. The code checks for "
"the number of the descriptor but because this differs between FreeBSD and "
"<trademark class=\"registered\">Linux</trademark> we fake it a little. We "
"only support indexes of 6, 3 and -1. The 6 is genuine <trademark class="
"\"registered\">Linux</trademark> number, 3 is genuine FreeBSD one and -1 "
"means autoselection. Then we set the descriptor number to constant 3 and "
"copy out this to the userspace. We rely on the userspace process using the "
"number from the descriptor but this works most of the time (have never seen "
"a case where this did not work) as the userspace process typically passes in "
"1. Then we convert the descriptor from the <trademark class=\"registered"
"\">Linux</trademark> form to a machine dependant form (i.e. operating system "
"independent form) and copy this to the FreeBSD defined segment descriptor. "
"Finally we can load it. We assign the descriptor to threads PCB (process "
"control block) and load the <varname>%gs</varname> segment using "
"<function>load_gs</function>. This loading must be done in a critical "
"section so that nothing can interrupt us. The <literal>CLONE_SETTLS</"
"literal> case works exactly like this just the loading using "
"<function>load_gs</function> is not performed. The segment used for this "
"(segment number 3) is shared for this use between FreeBSD processes and "
"<trademark class=\"registered\">Linux</trademark> processes so the "
"<trademark class=\"registered\">Linux</trademark> emulation layer does not "
"add any overhead over plain FreeBSD."
msgstr ""
"La carga de TLS para el hilo actual se realiza llamando "
"<function>set_thread_area</function>mientras carga TLS para un segundo "
"proceso en <function>clone</function>se hace en el bloque separado en "
"<function>clone</function>. Esas dos funciones son muy similares. La única "
"diferencia es la carga real del segmento GDT, que ocurre en el siguiente "
"cambio de contexto para el proceso recién creado mientras "
"<function>set_thread_area</function>debe cargar esto directamente. El código "
"básicamente hace esto. Copia el <trademark class=\"registered\">Linux</"
"trademark> descriptor de segmento de formulario del área de usuario. El "
"código busca el número del descriptor, pero debido a que este difiere entre "
"FreeBSD y <trademark class=\"registered\">Linux</trademark> lo fingimos un "
"poco. Solo admitimos índices de 6, 3 y -1. El 6 es genuino <trademark class="
"\"registered\">Linux</trademark> número, 3 es uno genuino de FreeBSD y -1 "
"significa autoselección. Luego establecemos el número de descriptor en "
"constante 3 y lo copiamos en el espacio de usuario. Confiamos en el proceso "
"del espacio de usuario utilizando el número del descriptor, pero esto "
"funciona la mayor parte del tiempo (nunca he visto un caso en el que esto no "
"haya funcionado) ya que el proceso del espacio de usuario normalmente pasa "
"en 1. Luego, convertimos el descriptor del <trademark class=\"registered\""
">Linux</trademark>formulario a un formulario dependiente de la máquina (es "
"decir, formulario independiente del sistema operativo) y cópielo en el "
"descriptor de segmento definido de FreeBSD. Finalmente podemos cargarlo. "
"Asignamos el descriptor a los subprocesos PCB (bloque de control de proceso) "
"y cargamos el <varname>%gs</varname> segmento usando<function>load_gs</"
"function>. Esta carga debe hacerse en un tramo crítico para que nada nos "
"interrumpa. los <literal>CLONE_SETTLS</literal> El caso funciona exactamente "
"así, solo la carga usando <function>load_gs</function> no se realiza. El "
"segmento utilizado para esto (segmento número 3) se comparte para este uso "
"entre los procesos FreeBSD y <trademark class=\"registered\">Linux</"
"trademark> procesos para que el <trademark class=\"registered\">Linux</"
"trademark> La capa de emulación no agrega ninguna sobrecarga sobre FreeBSD "
"simple."

#. (itstool) path: sect4/title
#: article.translate.xml:1955
#, fuzzy
msgid "amd64"
msgstr "amd64"

#. (itstool) path: sect4/para
#: article.translate.xml:1957
msgid ""
"The amd64 implementation is similar to the i386 one but there was initially "
"no 32bit segment descriptor used for this purpose (hence not even native "
"32bit TLS users worked) so we had to add such a segment and implement its "
"loading on every context switch (when a flag signaling use of 32bit is set). "
"Apart from this the TLS loading is exactly the same just the segment numbers "
"are different and the descriptor format and the loading differs slightly."
msgstr ""
"La implementación de amd64 es similar a la de i386, pero inicialmente no se "
"utilizó un descriptor de segmento de 32 bits para este propósito (por lo "
"tanto, ni siquiera los usuarios nativos de TLS de 32 bits funcionaron), por "
"lo que tuvimos que agregar dicho segmento e implementar su carga en cada "
"cambio de contexto (cuando un se establece el uso de señalización de bandera "
"de 32 bits). Aparte de esto, la carga de TLS es exactamente la misma, solo "
"que los números de segmento son diferentes y el formato del descriptor y la "
"carga difieren ligeramente."

#. (itstool) path: sect2/title
#: article.translate.xml:1971
#, fuzzy
msgid "Futexes"
msgstr "Futexes"

#. (itstool) path: sect3/title
#: article.translate.xml:1974
msgid "Introduction to synchronization"
msgstr "Introducción a la sincronización"

#. (itstool) path: sect3/para
#: article.translate.xml:1976
msgid ""
"Threads need some kind of synchronization and <trademark class=\"registered"
"\">POSIX</trademark> provides some of them: mutexes for mutual exclusion, "
"read-write locks for mutual exclusion with biased ratio of reads and writes "
"and condition variables for signaling a status change. It is interesting to "
"note that <trademark class=\"registered\">POSIX</trademark> threading API "
"lacks support for semaphores. Those synchronization routines implementations "
"are heavily dependant on the type threading support we have. In pure 1:M "
"(userspace) model the implementation can be solely done in userspace and "
"thus be very fast (the condition variables will probably end up being "
"implemented using signals, i.e. not fast) and simple. In 1:1 model, the "
"situation is also quite clear - the threads must be synchronized using "
"kernel facilities (which is very slow because a syscall must be performed). "
"The mixed M:N scenario just combines the first and second approach or rely "
"solely on kernel. Threads synchronization is a vital part of thread-enabled "
"programming and its performance can affect resulting program a lot. Recent "
"benchmarks on FreeBSD operating system showed that an improved sx_lock "
"implementation yielded 40% speedup in <firstterm>ZFS</firstterm> (a heavy sx "
"user), this is in-kernel stuff but it shows clearly how important the "
"performance of synchronization primitives is."
msgstr ""
"Los subprocesos necesitan algún tipo de sincronización y <trademark class="
"\"registered\">POSIX</trademark> proporciona algunos de ellos: mutex para "
"exclusión mutua, bloqueos de lectura y escritura para exclusión mutua con "
"una proporción sesgada de lecturas y escrituras y variables de condición "
"para señalar un cambio de estado. Es interesante notar que<trademark class="
"\"registered\">POSIX</trademark> La API de subprocesos carece de soporte "
"para semáforos. Esas implementaciones de rutinas de sincronización dependen "
"en gran medida del tipo de soporte de subprocesos que tenemos. En el modelo "
"puro 1: M (espacio de usuario), la implementación se puede realizar "
"únicamente en el espacio de usuario y, por lo tanto, es muy rápida (las "
"variables de condición probablemente terminarán implementándose mediante "
"señales, es decir, no rápido) y simple. En el modelo 1: 1, la situación "
"también es bastante clara: los subprocesos deben sincronizarse utilizando "
"las instalaciones del kernel (lo cual es muy lento porque se debe realizar "
"una llamada al sistema). El escenario mixto M: N simplemente combina el "
"primer y segundo enfoque o se basa únicamente en el kernel. La "
"sincronización de subprocesos es una parte vital de la programación "
"habilitada para subprocesos y su rendimiento puede afectar mucho al programa "
"resultante. Pruebas de rendimiento recientes en el sistema operativo FreeBSD "
"mostraron que una implementación mejorada de sx_lock produjo un 40% de "
"aceleración en <firstterm>ZFS</firstterm> (un usuario pesado de sx), esto es "
"algo dentro del kernel pero muestra claramente cuán importante es el "
"rendimiento de las primitivas de sincronización."

#. (itstool) path: sect3/para
#: article.translate.xml:2000
msgid ""
"Threaded programs should be written with as little contention on locks as "
"possible. Otherwise, instead of doing useful work the thread just waits on a "
"lock. Because of this, the most well written threaded programs show little "
"locks contention."
msgstr ""
"Los programas con subprocesos deben escribirse con la menor contención "
"posible sobre los bloqueos. De lo contrario, en lugar de hacer un trabajo "
"útil, el hilo solo espera un bloqueo. Debido a esto, los programas con "
"subprocesos mejor escritos muestran poca contención de bloqueos."

#. (itstool) path: sect3/title
#: article.translate.xml:2008
msgid "Futexes introduction"
msgstr "Introducción a los futexes"

#. (itstool) path: sect3/para
#: article.translate.xml:2010
msgid ""
"<trademark class=\"registered\">Linux</trademark> implements 1:1 threading, "
"i.e. it has to use in-kernel synchronization primitives. As stated earlier, "
"well written threaded programs have little lock contention. So a typical "
"sequence could be performed as two atomic increase/decrease mutex reference "
"counter, which is very fast, as presented by the following example:"
msgstr ""
"<trademark class=\"registered\">Linux</trademark> implementa subprocesos 1: "
"1, es decir, tiene que usar primitivas de sincronización en el kernel. Como "
"se indicó anteriormente, los programas con subprocesos bien escritos tienen "
"poca contención de bloqueo. Entonces, una secuencia típica podría realizarse "
"como dos contadores de referencia mutex de aumento/disminución atómicos, que "
"es muy rápido, como se presenta en el siguiente ejemplo:"

#. (itstool) path: sect3/programlisting
#: article.translate.xml:2017
#, no-wrap
msgid ""
"pthread_mutex_lock(&amp;mutex);\n"
"....\n"
"pthread_mutex_unlock(&amp;mutex);"
msgstr ""
"pthread_mutex_lock(&amp;mutex);\n"
"....\n"
"pthread_mutex_unlock(&amp;mutex);"

#. (itstool) path: sect3/para
#: article.translate.xml:2021
msgid ""
"1:1 threading forces us to perform two syscalls for those mutex calls, which "
"is very slow."
msgstr ""
"El subproceso 1: 1 nos obliga a realizar dos llamadas al sistema para esas "
"llamadas mutex, lo cual es muy lento."

#. (itstool) path: sect3/para
#: article.translate.xml:2024
msgid ""
"The solution <trademark class=\"registered\">Linux</trademark> 2.6 "
"implements is called futexes. Futexes implement the check for contention in "
"userspace and call kernel primitives only in a case of contention. Thus the "
"typical case takes place without any kernel intervention. This yields "
"reasonably fast and flexible synchronization primitives implementation."
msgstr ""
"La solución <trademark class=\"registered\">Linux</trademark> 2.6 "
"implementos se llama futexes. Los futexes implementan la verificación de "
"contención en el espacio de usuario y llaman a las primitivas del núcleo "
"solo en caso de contención. Por tanto, el caso típico tiene lugar sin "
"ninguna intervención del núcleo. Esto produce una implementación de "
"primitivas de sincronización razonablemente rápida y flexible."

#. (itstool) path: sect3/title
#: article.translate.xml:2033
#, fuzzy
msgid "Futex API"
msgstr "Futex API"

#. (itstool) path: sect3/para
#: article.translate.xml:2035
msgid "The futex syscall looks like this:"
msgstr "La llamada al sistema futex se ve así:"

#. (itstool) path: sect3/programlisting
#: article.translate.xml:2037
#, fuzzy, no-wrap
msgid "int futex(void *uaddr, int op, int val, struct timespec *timeout, void *uaddr2, int val3);"
msgstr ""
"int futex(void *uaddr, int op, int val, struct timespec *timeout, void *"
"uaddr2, int val3);"

#. (itstool) path: sect3/para
#: article.translate.xml:2039
msgid ""
"In this example <varname>uaddr</varname> is an address of the mutex in "
"userspace, <varname>op</varname> is an operation we are about to perform and "
"the other parameters have per-operation meaning."
msgstr ""
"En este ejemplo <varname>uaddr</varname>es una dirección del mutex en el "
"espacio de usuario, <varname>op</varname> es una operación que estamos a "
"punto de realizar y los demás parámetros tienen un significado por operación."

#. (itstool) path: sect3/para
#: article.translate.xml:2044
msgid "Futexes implement the following operations:"
msgstr "Los Futexes implementan las siguientes operaciones:"

#. (itstool) path: listitem/para
#: article.translate.xml:2048
#, fuzzy
msgid "<literal>FUTEX_WAIT</literal>"
msgstr "<literal>FUTEX_WAIT</literal>"

#. (itstool) path: listitem/para
#: article.translate.xml:2051
#, fuzzy
msgid "<literal>FUTEX_WAKE</literal>"
msgstr "<literal>FUTEX_WAKE</literal>"

#. (itstool) path: listitem/para
#: article.translate.xml:2054
#, fuzzy
msgid "<literal>FUTEX_FD</literal>"
msgstr "<literal>FUTEX_FD</literal>"

#. (itstool) path: listitem/para
#: article.translate.xml:2057
#, fuzzy
msgid "<literal>FUTEX_REQUEUE</literal>"
msgstr "<literal>FUTEX_REQUEUE</literal>"

#. (itstool) path: listitem/para
#: article.translate.xml:2060
#, fuzzy
msgid "<literal>FUTEX_CMP_REQUEUE</literal>"
msgstr "<literal>FUTEX_CMP_REQUEUE</literal>"

#. (itstool) path: listitem/para
#: article.translate.xml:2063
#, fuzzy
msgid "<literal>FUTEX_WAKE_OP</literal>"
msgstr "<literal>FUTEX_WAKE_OP</literal>"

#. (itstool) path: sect4/title
#: article.translate.xml:2068
#, fuzzy
msgid "FUTEX_WAIT"
msgstr "FUTEX_WAIT"

#. (itstool) path: sect4/para
#: article.translate.xml:2070
msgid ""
"This operation verifies that on address <varname>uaddr</varname> the value "
"<varname>val</varname> is written. If not, <literal>EWOULDBLOCK</literal> is "
"returned, otherwise the thread is queued on the futex and gets suspended. If "
"the argument <varname>timeout</varname> is non-zero it specifies the maximum "
"time for the sleeping, otherwise the sleeping is infinite."
msgstr ""
"Esta operación verifica que en la dirección <varname>uaddr</varname> el "
"valor <varname>val</varname> está escrito. Si no, <literal>EWOULDBLOCK</"
"literal> se devuelve, de lo contrario, el hilo se pone en cola en el futex y "
"se suspende. Si el argumento <varname>timeout</varname> es distinto de cero, "
"especifica el tiempo máximo para dormir; de lo contrario, el sueño es "
"infinito."

#. (itstool) path: sect4/title
#: article.translate.xml:2081
msgid "FUTEX_WAKE"
msgstr "FUTEX_WAKE"

#. (itstool) path: sect4/para
#: article.translate.xml:2083
msgid ""
"This operation takes a futex at <varname>uaddr</varname> and wakes up "
"<varname>val</varname> first futexes queued on this futex."
msgstr ""
"Esta operación toma un futex en <varname>uaddr</varname> y se despierta "
"<varname>val</varname> Primeros futexes en cola en este futex."

#. (itstool) path: sect4/title
#: article.translate.xml:2090
msgid "FUTEX_FD"
msgstr "FUTEX_FD"

#. (itstool) path: sect4/para
#: article.translate.xml:2092
msgid "This operations associates a file descriptor with a given futex."
msgstr "Esta operación asocia un descriptor de archivo con un futex dado."

#. (itstool) path: sect4/title
#: article.translate.xml:2097
#, fuzzy
msgid "FUTEX_REQUEUE"
msgstr "FUTEX_REQUEUE"

#. (itstool) path: sect4/para
#: article.translate.xml:2099
msgid ""
"This operation takes <varname>val</varname> threads queued on futex at "
"<varname>uaddr</varname>, wakes them up, and takes <varname>val2</varname> "
"next threads and requeues them on futex at <varname>uaddr2</varname>."
msgstr ""
"Esta operación toma <varname>val</varname> hilos en cola en futex en "
"<varname>uaddr</varname>, Los despierta y toma<varname>val2</varname> "
"siguientes hilos y los coloca en futex en <varname>uaddr2</varname>."

#. (itstool) path: sect4/title
#: article.translate.xml:2107
#, fuzzy
msgid "FUTEX_CMP_REQUEUE"
msgstr "FUTEX_CMP_REQUEUE"

#. (itstool) path: sect4/para
#: article.translate.xml:2109
msgid ""
"This operation does the same as <literal>FUTEX_REQUEUE</literal> but it "
"checks that <varname>val3</varname> equals to <varname>val</varname> first."
msgstr ""
"Esta operación hace lo mismo que <literal>FUTEX_REQUEUE</literal>pero "
"comprueba que <varname>val3</varname> igual a <varname>val</varname> primero."

#. (itstool) path: sect4/title
#: article.translate.xml:2116
#, fuzzy
msgid "FUTEX_WAKE_OP"
msgstr "FUTEX_WAKE_OP"

#. (itstool) path: sect4/para
#: article.translate.xml:2118
msgid ""
"This operation performs an atomic operation on <varname>val3</varname> "
"(which contains coded some other value) and <varname>uaddr</varname>. Then "
"it wakes up <varname>val</varname> threads on futex at <varname>uaddr</"
"varname> and if the atomic operation returned a positive number it wakes up "
"<varname>val2</varname> threads on futex at <varname>uaddr2</varname>."
msgstr ""
"Esta operación realiza una operación atómica en <varname>val3</varname> (que "
"contiene algún otro valor codificado) y<varname>uaddr</varname>. Entonces se "
"despierta <varname>val</varname> hilos en futex en <varname>uaddr</varname> "
"y si la operación atómica devolvió un número positivo, se despierta "
"<varname>val2</varname> hilos en futex en<varname>uaddr2</varname>."

#. (itstool) path: sect4/para
#: article.translate.xml:2127
msgid "The operations implemented in <literal>FUTEX_WAKE_OP</literal>:"
msgstr "Las operaciones implementadas en <literal>FUTEX_WAKE_OP</literal>:"

#. (itstool) path: listitem/para
#: article.translate.xml:2132
msgid "<literal>FUTEX_OP_SET</literal>"
msgstr "<literal>FUTEX_OP_SET</literal>"

#. (itstool) path: listitem/para
#: article.translate.xml:2135
msgid "<literal>FUTEX_OP_ADD</literal>"
msgstr "<literal>FUTEX_OP_ADD</literal>"

#. (itstool) path: listitem/para
#: article.translate.xml:2138
msgid "<literal>FUTEX_OP_OR</literal>"
msgstr "<literal>FUTEX_OP_OR</literal>"

#. (itstool) path: listitem/para
#: article.translate.xml:2141
msgid "<literal>FUTEX_OP_AND</literal>"
msgstr "<literal>FUTEX_OP_AND</literal>"

#. (itstool) path: listitem/para
#: article.translate.xml:2144
msgid "<literal>FUTEX_OP_XOR</literal>"
msgstr "<literal>FUTEX_OP_XOR</literal>"

#. (itstool) path: note/para
#: article.translate.xml:2149
msgid ""
"There is no <varname>val2</varname> parameter in the futex prototype. The "
"<varname>val2</varname> is taken from the <varname>struct timespec *timeout</"
"varname> parameter for operations <literal>FUTEX_REQUEUE</literal>, "
"<literal>FUTEX_CMP_REQUEUE</literal> and <literal>FUTEX_WAKE_OP</literal>."
msgstr ""
"No hay <varname>val2</varname> parámetro en el prototipo futex. los "
"<varname>val2</varname> es tomado de la <varname>struct timespec *timeout</"
"varname> parámetro para operaciones <literal>FUTEX_REQUEUE</literal>, "
"<literal>FUTEX_CMP_REQUEUE</literal> y <literal>FUTEX_WAKE_OP</literal>."

#. (itstool) path: sect3/title
#: article.translate.xml:2161
msgid "Futex emulation in FreeBSD"
msgstr "Emulación Futex en FreeBSD"

#. (itstool) path: sect3/para
#: article.translate.xml:2163
msgid ""
"The futex emulation in FreeBSD is taken from NetBSD and further extended by "
"us. It is placed in <filename>linux_futex.c</filename> and "
"<filename>linux_futex.h</filename> files. The <literal>futex</literal> "
"structure looks like:"
msgstr ""
"La emulación futex en FreeBSD se toma de NetBSD y nosotros la ampliamos. Se "
"coloca en <filename>linux_futex.c</filename> and <filename>linux_futex.h</"
"filename> archivos. la <literal>futex</literal> estructura se parece a:"

#. (itstool) path: sect3/programlisting
#: article.translate.xml:2169
#, no-wrap
msgid ""
"struct futex {\n"
"  void *f_uaddr;\n"
"  int f_refcount;\n"
"\n"
"  LIST_ENTRY(futex) f_list;\n"
"\n"
"  TAILQ_HEAD(lf_waiting_paroc, waiting_proc) f_waiting_proc;\n"
"};"
msgstr ""
"struct futex {\n"
"  void *f_uaddr;\n"
"  int f_refcount;\n"
"\n"
"  LIST_ENTRY(futex) f_list;\n"
"\n"
"  TAILQ_HEAD(lf_waiting_paroc, waiting_proc) f_waiting_proc;\n"
"};"

#. (itstool) path: sect3/para
#: article.translate.xml:2178
msgid "And the structure <literal>waiting_proc</literal> is:"
msgstr "Y la estructura <literal>waiting_proc</literal> es:"

#. (itstool) path: sect3/programlisting
#: article.translate.xml:2181
#, no-wrap
msgid ""
"struct waiting_proc {\n"
"\n"
"  struct thread *wp_t;\n"
"\n"
"  struct futex *wp_new_futex;\n"
"\n"
"  TAILQ_ENTRY(waiting_proc) wp_list;\n"
"};"
msgstr ""
"struct waiting_proc {\n"
"\n"
"  struct thread *wp_t;\n"
"\n"
"  struct futex *wp_new_futex;\n"
"\n"
"  TAILQ_ENTRY(waiting_proc) wp_list;\n"
"};"

#. (itstool) path: sect4/title
#: article.translate.xml:2191
msgid "futex_get / futex_put"
msgstr "futex_get / futex_put"

#. (itstool) path: sect4/para
#: article.translate.xml:2193
msgid ""
"A futex is obtained using the <function>futex_get</function> function, which "
"searches a linear list of futexes and returns the found one or creates a new "
"futex. When releasing a futex from the use we call the <function>futex_put</"
"function> function, which decreases a reference counter of the futex and if "
"the refcount reaches zero it is released."
msgstr ""
"Un futex se obtiene utilizando el <function>futex_get</function>función, que "
"busca en una lista lineal de futexes y devuelve el encontrado o crea un "
"nuevo futex. Al liberar un futex del uso, lo llamamos <function>futex_put</"
"function> función, que disminuye un contador de referencia del futex y si el "
"refcount llega a cero se libera."

#. (itstool) path: sect4/title
#: article.translate.xml:2203
msgid "futex_sleep"
msgstr "futex_sleep"

#. (itstool) path: sect4/para
#: article.translate.xml:2205
msgid ""
"When a futex queues a thread for sleeping it creates a "
"<literal>working_proc</literal> structure and puts this structure to the "
"list inside the futex structure then it just performs a "
"<citerefentry><refentrytitle>tsleep</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> to suspend the thread. The sleep can be timed out. After "
"<citerefentry><refentrytitle>tsleep</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> returns (the thread was woken up or it timed out) the "
"<literal>working_proc</literal> structure is removed from the list and is "
"destroyed. All this is done in the <function>futex_sleep</function> "
"function. If we got woken up from <function>futex_wake</function> we have "
"<varname>wp_new_futex</varname> set so we sleep on it. This way the actual "
"requeueing is done in this function."
msgstr ""
"Cuando un futex pone en cola un hilo para dormir, crea un "
"<literal>working_proc</literal> estructura y coloca esta estructura en la "
"lista dentro de la estructura futex, entonces solo realiza una "
"<citerefentry><refentrytitle>tsleep</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> suspender el hilo. El tiempo de sueño se puede agotar. Después "
"<citerefentry><refentrytitle>tsleep</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> devuelve (el hilo se despertó o se agotó el tiempo de espera) "
"el <literal>working_proc</literal> La estructura se elimina de la lista y se "
"destruye. Todo esto se hace en el <function>futex_sleep</function>función. "
"Si nos despertaran de <function>futex_wake</function> Nosotros tenemos "
"<varname>wp_new_futex</varname> establecido para que podamos dormir en él. "
"De esta manera, la puesta en cola real se realiza en esta función.."

#. (itstool) path: sect4/title
#: article.translate.xml:2221
msgid "futex_wake"
msgstr "futex_wake"

#. (itstool) path: sect4/para
#: article.translate.xml:2223
msgid ""
"Waking up a thread sleeping on a futex is performed in the "
"<function>futex_wake</function> function. First in this function we mimic "
"the strange <trademark class=\"registered\">Linux</trademark> behavior, "
"where it wakes up N threads for all operations, the only exception is that "
"the REQUEUE operations are performed on N+1 threads. But this usually does "
"not make any difference as we are waking up all threads. Next in the "
"function in the loop we wake up n threads, after this we check if there is a "
"new futex for requeueing. If so, we requeue up to n2 threads on the new "
"futex. This cooperates with <function>futex_sleep</function>."
msgstr ""
"Despertar un hilo durmiendo en un futex se realiza en el "
"<function>futex_wake</function> función. Primero en esta función imitamos el "
"extraño <trademark class=\"registered\">Linux</trademark> comportamiento, "
"donde despierta N subprocesos para todas las operaciones, la única excepción "
"es que las operaciones REQUEUE se realizan en N + 1 subprocesos. Pero esto "
"generalmente no hace ninguna diferencia ya que estamos despertando todos los "
"hilos. A continuación, en la función en el bucle, activamos n subprocesos, "
"después de esto, verificamos si hay un nuevo futex para poner en cola. Si es "
"así, ponemos en cola hasta n2 subprocesos en el nuevo futex. Esto coopera "
"con <function>futex_sleep</function>."

#. (itstool) path: sect4/title
#: article.translate.xml:2237
msgid "futex_wake_op"
msgstr "futex_wake_op"

#. (itstool) path: sect4/para
#: article.translate.xml:2239
msgid ""
"The <literal>FUTEX_WAKE_OP</literal> operation is quite complicated. First "
"we obtain two futexes at addresses <varname>uaddr</varname> and "
"<varname>uaddr2</varname> then we perform the atomic operation using "
"<varname>val3</varname> and <varname>uaddr2</varname>. Then <varname>val</"
"varname> waiters on the first futex is woken up and if the atomic operation "
"condition holds we wake up <varname>val2</varname> (i.e. <varname>timeout</"
"varname>) waiter on the second futex."
msgstr ""
"La <literal>FUTEX_WAKE_OP</literal> El funcionamiento es bastante "
"complicado. Primero obtenemos dos futexes en direcciones<varname>uaddr</"
"varname> and <varname>uaddr2</varname> luego realizamos la operación atómica "
"usando <varname>val3</varname> and <varname>uaddr2</varname>. Then "
"<varname>val</varname> los camareros en el primer futex se despiertan y si "
"la condición de operación atómica se mantiene, nos despertamos "
"<varname>val2</varname> (es decir. <varname>timeout</varname>) camarero en "
"el segundo futex."

#. (itstool) path: sect4/title
#: article.translate.xml:2252
msgid "futex atomic operation"
msgstr "operación atómica futex"

#. (itstool) path: sect4/para
#: article.translate.xml:2254
msgid ""
"The atomic operation takes two parameters <varname>encoded_op</varname> and "
"<varname>uaddr</varname>. The encoded operation encodes the operation "
"itself, comparing value, operation argument, and comparing argument. The "
"pseudocode for the operation is like this one:"
msgstr ""
"La operación atómica toma dos parámetros <varname>encoded_op</varname> y "
"<varname>uaddr</varname>. La operación codificada codifica la operación en "
"sí, comparando valor, argumento de operación y argumento de comparación. El "
"pseudocódigo para la operación es como este:"

#. (itstool) path: sect4/programlisting
#: article.translate.xml:2261
#, no-wrap
msgid ""
"oldval = *uaddr2\n"
"*uaddr2 = oldval OP oparg"
msgstr ""
"oldval = *uaddr2\n"
"*uaddr2 = oldval OP oparg"

#. (itstool) path: sect4/para
#: article.translate.xml:2264
msgid ""
"And this is done atomically. First a copying in of the number at "
"<varname>uaddr</varname> is performed and the operation is done. The code "
"handles page faults and if no page fault occurs <varname>oldval</varname> is "
"compared to <varname>cmparg</varname> argument with cmp comparator."
msgstr ""
"Y esto se hace de forma atómica. Primero una copia del número en "
"<varname>uaddr</varname> se realiza y se hace la operación. El código maneja "
"fallas de página y si no ocurre ninguna falla de página <varname>oldval</"
"varname> se compara con <varname>cmparg</varname> argumento con comparador "
"cmp."

#. (itstool) path: sect4/title
#: article.translate.xml:2273
msgid "Futex locking"
msgstr "Bloqueo futex"

#. (itstool) path: sect4/para
#: article.translate.xml:2275
msgid ""
"Futex implementation uses two lock lists protecting <function>sx_lock</"
"function> and global locks (either Giant or another <function>sx_lock</"
"function>). Every operation is performed locked from the start to the very "
"end."
msgstr ""
"La implementación de Futex utiliza dos listas de bloqueo que "
"protegen<function>sx_lock</function> y cerraduras globales (ya sea gigante u "
"otra <function>sx_lock</function>). Cada operación se realiza bloqueada "
"desde el principio hasta el final."

#. (itstool) path: sect2/title
#: article.translate.xml:2285
msgid "Various syscalls implementation"
msgstr "Implementación de varias llamadas al sistema"

#. (itstool) path: sect2/para
#: article.translate.xml:2287
msgid ""
"In this section I am going to describe some smaller syscalls that are worth "
"mentioning because their implementation is not obvious or those syscalls are "
"interesting from other point of view."
msgstr ""
"En esta sección voy a describir algunas llamadas al sistema más pequeñas que "
"vale la pena mencionar porque su implementación no es obvia o esas llamadas "
"al sistema son interesantes desde otro punto de vista."

#. (itstool) path: sect3/title
#: article.translate.xml:2293
msgid "*at family of syscalls"
msgstr "*en familia de llamadas al sistema"

#. (itstool) path: sect3/para
#: article.translate.xml:2295
msgid ""
"During development of <trademark class=\"registered\">Linux</trademark> "
"2.6.16 kernel, the *at syscalls were added. Those syscalls "
"(<function>openat</function> for example) work exactly like their at-less "
"counterparts with the slight exception of the <varname>dirfd</varname> "
"parameter. This parameter changes where the given file, on which the syscall "
"is to be performed, is. When the <varname>filename</varname> parameter is "
"absolute <varname>dirfd</varname> is ignored but when the path to the file "
"is relative, it comes to the play. The <varname>dirfd</varname> parameter is "
"a directory relative to which the relative pathname is checked. The "
"<varname>dirfd</varname> parameter is a file descriptor of some directory or "
"<literal>AT_FDCWD</literal>. So for example the <function>openat</function> "
"syscall can be like this:"
msgstr ""
"Durante el desarrollo de <trademark class=\"registered\">Linux</"
"trademark>2.6.16 kernel, se agregaron las llamadas al sistema * at. Esas "
"llamadas al sistema (<function>openat</function>por ejemplo) funcionan "
"exactamente como sus contrapartes at-less con la ligera excepción de "
"<varname>dirfd</varname> parámetro. Este parámetro cambia donde está el "
"archivo dado, en el que se va a realizar la llamada al sistema. Cuando el "
"<varname>filename</varname> el parámetro es absoluto <varname>dirfd</"
"varname> se ignora pero cuando la ruta al archivo es relativa, se trata de "
"la obra. los <varname>dirfd</varname> El parámetro es un directorio relativo "
"al que se comprueba la ruta relativa. los <varname>dirfd</varname> parámetro "
"es un descriptor de archivo de algún directorio o <literal>AT_FDCWD</"
"literal>. Entonces, por ejemplo, el <function>openat</function> syscall "
"puede ser así:"

#. (itstool) path: sect3/programlisting
#: article.translate.xml:2311
#, no-wrap
msgid ""
"file descriptor 123 = /tmp/foo/, current working directory = /tmp/\n"
"\n"
"openat(123, /tmp/bah\\, flags, mode)\t/* opens /tmp/bah */\n"
"openat(123, bah\\, flags, mode)\t\t/* opens /tmp/foo/bah */\n"
"openat(AT_FDWCWD, bah\\, flags, mode)\t/* opens /tmp/bah */\n"
"openat(stdio, bah\\, flags, mode)\t/* returns error because stdio is not a directory */"
msgstr ""
"file descriptor 123 = /tmp/foo/, current working directory = /tmp/\n"
"\n"
"openat(123, /tmp/bah\\, flags, mode)\t/* opens /tmp/bah */\n"
"openat(123, bah\\, flags, mode)\t\t/* opens /tmp/foo/bah */\n"
"openat(AT_FDWCWD, bah\\, flags, mode)\t/* opens /tmp/bah */\n"
"openat(stdio, bah\\, flags, mode)\t/* returns error because stdio is not a directory */"

#. (itstool) path: sect3/para
#: article.translate.xml:2318
msgid ""
"This infrastructure is necessary to avoid races when opening files outside "
"the working directory. Imagine that a process consists of two threads, "
"thread A and thread B. Thread A issues <literal>open(./tmp/foo/bah., flags, "
"mode)</literal> and before returning it gets preempted and thread B runs. "
"Thread B does not care about the needs of thread A and renames or removes "
"<filename>/tmp/foo/</filename>. We got a race. To avoid this we can open "
"<filename>/tmp/foo</filename> and use it as <varname>dirfd</varname> for "
"<function>openat</function> syscall. This also enables user to implement per-"
"thread working directories."
msgstr ""
"Esta infraestructura es necesaria para evitar carreras al abrir archivos "
"fuera del directorio de trabajo. Imagine que un proceso consta de dos "
"subprocesos, el subproceso A y el subproceso B. Problemas del subproceso A "
"<literal>abrir(./tmp/foo/bah., flags, mode)</literal> y antes de regresar se "
"reemplaza y se ejecuta el hilo B. El hilo B no se preocupa por las "
"necesidades del hilo A y cambia el nombre o elimina<filename>/tmp/foo/</"
"filename>. Tenemos una carrera. Para evitar esto podemos abrir <filename>/"
"tmp/foo</filename> and use it as <varname>dirfd</varname>para "
"<function>openat</function>syscall. Esto también permite al usuario "
"implementar directorios de trabajo por subproceso."

#. (itstool) path: sect3/para
#: article.translate.xml:2332
msgid ""
"<trademark class=\"registered\">Linux</trademark> family of *at syscalls "
"contains: <function>linux_openat</function>, <function>linux_mkdirat</"
"function>, <function>linux_mknodat</function>, <function>linux_fchownat</"
"function>, <function>linux_futimesat</function>, <function>linux_fstatat64</"
"function>, <function>linux_unlinkat</function>, <function>linux_renameat</"
"function>, <function>linux_linkat</function>, <function>linux_symlinkat</"
"function>, <function>linux_readlinkat</function>, <function>linux_fchmodat</"
"function> and <function>linux_faccessat</function>. All these are "
"implemented using the modified <citerefentry><refentrytitle>namei</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> routine and simple "
"wrapping layer."
msgstr ""
"<trademark class=\"registered\">Linux</trademark> familia de *at syscalls "
"contiene: <function>linux_openat</function>, <function>linux_mkdirat</"
"function>, <function>linux_mknodat</function>, <function>linux_fchownat</"
"function>, <function>linux_futimesat</function>, <function>linux_fstatat64</"
"function>, <function>linux_unlinkat</function>, <function>linux_renameat</"
"function>, <function>linux_linkat</function>, <function>linux_symlinkat</"
"function>, <function>linux_readlinkat</function>, <function>linux_fchmodat</"
"function> and <function>linux_faccessat</function>. Todos estos se "
"implementan utilizando el modificado "
"<citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> capa de envoltura rutinaria y simple."

#. (itstool) path: sect4/title
#: article.translate.xml:2350
msgid "Implementation"
msgstr "Implementación"

#. (itstool) path: sect4/para
#: article.translate.xml:2352
msgid ""
"The implementation is done by altering the "
"<citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> routine (described above) to take additional parameter "
"<varname>dirfd</varname> in its <literal>nameidata</literal> structure, "
"which specifies the starting point of the pathname lookup instead of using "
"the current working directory every time. The resolution of <varname>dirfd</"
"varname> from file descriptor number to a vnode is done in native *at "
"syscalls. When <varname>dirfd</varname> is <literal>AT_FDCWD</literal> the "
"<varname>dvp</varname> entry in <literal>nameidata</literal> structure is "
"<literal>NULL</literal> but when <varname>dirfd</varname> is a different "
"number we obtain a file for this file descriptor, check whether this file is "
"valid and if there is vnode attached to it then we get a vnode. Then we "
"check this vnode for being a directory. In the actual "
"<citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> routine we simply substitute the <varname>dvp</varname> vnode "
"for <varname>dp</varname> variable in the "
"<citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> function, which determines the starting point. The "
"<citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> is not used directly but via a trace of different functions on "
"various levels. For example the <function>openat</function> goes like this:"
msgstr ""
"La implementación se realiza alterando el "
"<citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> rutina (descrita arriba) para tomar un parámetro adicional "
"<varname>dirfd</varname> en su <literal>nameidata</literal>estructura, que "
"especifica el punto de inicio de la búsqueda de nombre de ruta en lugar de "
"utilizar el directorio de trabajo actual cada vez. La resolución de "
"<varname>dirfd</varname> desde el número de descriptor de archivo hasta un "
"vnode se realiza en nativo *en syscalls. Cuando <varname>dirfd</varname> is "
"<literal>AT_FDCWD</literal> el <varname>dvp</varname> entrada en "
"<literal>nameidata</literal> la estructura es <literal>NULL</literal> pero "
"cuando <varname>dirfd</varname> es un número diferente, obtenemos un archivo "
"para este descriptor de archivo, verificamos si este archivo es válido y si "
"hay un vnode adjunto, obtenemos un vnode. Luego verificamos que este vnode "
"sea un directorio. En el actual "
"<citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> rutina simplemente sustituimos el <varname>dvp</varname> vnode "
"para <varname>dp</varname> variable en el "
"<citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> función, que determina el punto de partida. los "
"<citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> no se utiliza directamente, sino a través de un rastro de "
"diferentes funciones en varios niveles. Por ejemplo el <function>openat</"
"function> va así:"

#. (itstool) path: sect4/programlisting
#: article.translate.xml:2376
#, no-wrap
msgid "openat() --&gt; kern_openat() --&gt; vn_open() -&gt; namei()"
msgstr "openat() --&gt; kern_openat() --&gt; vn_open() -&gt; namei()"

#. (itstool) path: sect4/para
#: article.translate.xml:2378
msgid ""
"For this reason <function>kern_open</function> and <function>vn_open</"
"function> must be altered to incorporate the additional <varname>dirfd</"
"varname> parameter. No compat layer is created for those because there are "
"not many users of this and the users can be easily converted. This general "
"implementation enables FreeBSD to implement their own *at syscalls. This is "
"being discussed right now."
msgstr ""
"Por esta razón <function>kern_open</function> y <function>vn_open</function> "
"debe modificarse para incorporar el adicional <varname>dirfd</varname> "
"parámetro. No se crea una capa de compatibilidad para aquellos porque no hay "
"muchos usuarios de esta y los usuarios se pueden convertir fácilmente. Esta "
"implementación general permite a FreeBSD implementar su propio *en llamadas "
"al sistema. Esto se está discutiendo ahora mismo."

#. (itstool) path: sect3/title
#: article.translate.xml:2390
#, fuzzy
msgid "Ioctl"
msgstr "Ioctl"

#. (itstool) path: sect3/para
#: article.translate.xml:2392
msgid ""
"The ioctl interface is quite fragile due to its generality. We have to bear "
"in mind that devices differ between <trademark class=\"registered\">Linux</"
"trademark> and FreeBSD so some care must be applied to do ioctl emulation "
"work right. The ioctl handling is implemented in <filename>linux_ioctl.c</"
"filename>, where <function>linux_ioctl</function> function is defined. This "
"function simply iterates over sets of ioctl handlers to find a handler that "
"implements a given command. The ioctl syscall has three parameters, the file "
"descriptor, command and an argument. The command is a 16-bit number, which "
"in theory is divided into high 8 bits determining class of the ioctl command "
"and low 8 bits, which are the actual command within the given set. The "
"emulation takes advantage of this division. We implement handlers for each "
"set, like <function>sound_handler</function> or <function>disk_handler</"
"function>. Each handler has a maximum command and a minimum command defined, "
"which is used for determining what handler is used. There are slight "
"problems with this approach because <trademark class=\"registered\">Linux</"
"trademark> does not use the set division consistently so sometimes ioctls "
"for a different set are inside a set they should not belong to (SCSI generic "
"ioctls inside cdrom set, etc.). FreeBSD currently does not implement many "
"<trademark class=\"registered\">Linux</trademark> ioctls (compared to "
"NetBSD, for example) but the plan is to port those from NetBSD. The trend is "
"to use <trademark class=\"registered\">Linux</trademark> ioctls even in the "
"native FreeBSD drivers because of the easy porting of applications."
msgstr ""
"La interfaz ioctl es bastante frágil debido a su generalidad. Tenemos que "
"tener en cuenta que los dispositivos difieren entre <trademark class="
"\"registered\">Linux</trademark> y FreeBSD, por lo que se debe tener cuidado "
"para que la emulación de ioctl funcione correctamente. El manejo de ioctl se "
"implementa en <filename>linux_ioctl.c</filename>, donde "
"<function>linux_ioctl</function> la función está definida. Esta función "
"simplemente itera sobre conjuntos de manejadores ioctl para encontrar un "
"manejador que implemente un comando dado. El syscall ioctl tiene tres "
"parámetros, el descriptor de archivo, el comando y un argumento. El comando "
"es un número de 16 bits, que en teoría se divide en 8 bits altos que "
"determinan la clase del comando ioctl y 8 bits bajos, que son el comando "
"real dentro del conjunto dado. La emulación aprovecha esta división. "
"Implementamos controladores para cada conjunto, como "
"<function>sound_handler</function> o <function>disk_handler</function>.Cada "
"controlador tiene un comando máximo y un comando mínimo definido, que se "
"utiliza para determinar qué controlador se utiliza. Hay leves problemas con "
"este enfoque porque <trademark class=\"registered\">Linux</trademark> no usa "
"la división de conjuntos de manera consistente, por lo que a veces los "
"ioctls de un conjunto diferente están dentro de un conjunto al que no "
"deberían pertenecer (ioctls genéricos SCSI dentro del conjunto cdrom, etc.). "
"FreeBSD actualmente no implementa muchos <trademark class=\"registered\""
">Linux</trademark>ioctls (en comparación con NetBSD, por ejemplo) pero el "
"plan es portarlos de NetBSD. La tendencia es usar <trademark class="
"\"registered\">Linux</trademark> ioctls incluso en los controladores nativos "
"de FreeBSD debido a la fácil migración de las aplicaciones."

#. (itstool) path: sect3/title
#: article.translate.xml:2422
msgid "Debugging"
msgstr "Depuración"

#. (itstool) path: sect3/para
#: article.translate.xml:2424
msgid ""
"Every syscall should be debuggable. For this purpose we introduce a small "
"infrastructure. We have the ldebug facility, which tells whether a given "
"syscall should be debugged (settable via a sysctl). For printing we have "
"LMSG and ARGS macros. Those are used for altering a printable string for "
"uniform debugging messages."
msgstr ""
"Cada llamada al sistema debería ser depurable. Para ello introducimos una "
"pequeña infraestructura. Tenemos la función ldebug, que indica si una "
"llamada al sistema determinada debe depurarse (configurable mediante un "
"sysctl). Para imprimir tenemos macros LMSG y ARGS. Se utilizan para alterar "
"una cadena imprimible para mensajes de depuración uniformes."

#. (itstool) path: sect1/title
#: article.translate.xml:2435
msgid "Conclusion"
msgstr "Conclusión"

#. (itstool) path: sect2/title
#: article.translate.xml:2438
msgid "Results"
msgstr "Resultados"

#. (itstool) path: sect2/para
#: article.translate.xml:2440
msgid ""
"As of April 2007 the <trademark class=\"registered\">Linux</trademark> "
"emulation layer is capable of emulating the <trademark class=\"registered"
"\">Linux</trademark> 2.6.16 kernel quite well. The remaining problems "
"concern futexes, unfinished *at family of syscalls, problematic signals "
"delivery, missing <function>epoll</function> and <function>inotify</"
"function> and probably some bugs we have not discovered yet. Despite this we "
"are capable of running basically all the <trademark class=\"registered"
"\">Linux</trademark> programs included in FreeBSD Ports Collection with "
"Fedora Core 4 at 2.6.16 and there are some rudimentary reports of success "
"with Fedora Core 6 at 2.6.16. The Fedora Core 6 linux_base was recently "
"committed enabling some further testing of the emulation layer and giving us "
"some more hints where we should put our effort in implementing missing stuff."
msgstr ""
"En abril de 2007 el <trademark class=\"registered\">Linux</trademark> La "
"capa de emulación es capaz de emular la <trademark class=\"registered\""
">Linux</trademark> 2.6.16 kernel bastante bien. Los problemas restantes se "
"refieren a futexes, inacabados * en la familia de llamadas al sistema, "
"entrega de señales problemáticas, falta<function>epoll</function> y "
"<function>inotify</function> y probablemente algunos errores que aún no "
"hemos descubierto. A pesar de esto, somos capaces de ejecutar básicamente "
"todos los <trademark class=\"registered\">Linux</trademark> programas "
"incluidos en FreeBSD Ports Collection con Fedora Core 4 en 2.6.16 y hay "
"algunos informes rudimentarios de éxito con Fedora Core 6 en 2.6.16. Fedora "
"Core 6 linux_base se comprometió recientemente para permitir algunas pruebas "
"adicionales de la capa de emulación y darnos algunas pistas más sobre dónde "
"deberíamos poner nuestro esfuerzo en implementar las cosas que faltan."

#. (itstool) path: sect2/para
#: article.translate.xml:2455
msgid ""
"We are able to run the most used applications like <package>www/linux-"
"firefox</package>, <package>net-im/skype</package> and some games from the "
"Ports Collection. Some of the programs exhibit bad behavior under 2.6 "
"emulation but this is currently under investigation and hopefully will be "
"fixed soon. The only big application that is known not to work is the "
"<trademark class=\"registered\">Linux</trademark> <trademark>Java</"
"trademark> Development Kit and this is because of the requirement of "
"<function>epoll</function> facility which is not directly related to the "
"<trademark class=\"registered\">Linux</trademark> kernel 2.6."
msgstr ""
"Somos capaces de ejecutar las aplicaciones más utilizadas como <package>www/"
"linux-firefox</package>, <package>net-im/skype</package> y algunos juegos de "
"la colección Ports. Algunos de los programas exhiben un mal comportamiento "
"en la emulación 2.6, pero esto está actualmente bajo investigación y es de "
"esperar que se solucione pronto. La única gran aplicación que se sabe que no "
"funciona es la <trademark class=\"registered\">Linux</trademark> "
"<trademark>Java</trademark> Kit de desarrollo y esto se debe al requisito de "
"<function>epoll</function> instalación que no está directamente relacionada "
"con la <trademark class=\"registered\">Linux</trademark> kernel 2.6."

#. (itstool) path: sect2/para
#: article.translate.xml:2466
msgid ""
"We hope to enable 2.6.16 emulation by default some time after FreeBSD 7.0 is "
"released at least to expose the 2.6 emulation parts for some wider testing. "
"Once this is done we can switch to Fedora Core 6 linux_base, which is the "
"ultimate plan."
msgstr ""
"Esperamos habilitar la emulación 2.6.16 por defecto algún tiempo después del "
"lanzamiento de FreeBSD 7.0 al menos para exponer las partes de la emulación "
"2.6 para pruebas más amplias. Una vez hecho esto, podemos cambiar a Fedora "
"Core 6 linux_base, que es el plan definitivo."

#. (itstool) path: sect2/title
#: article.translate.xml:2474
msgid "Future work"
msgstr "Trabajo futuro"

#. (itstool) path: sect2/para
#: article.translate.xml:2476
msgid ""
"Future work should focus on fixing the remaining issues with futexes, "
"implement the rest of the *at family of syscalls, fix the signal delivery "
"and possibly implement the <function>epoll</function> and <function>inotify</"
"function> facilities."
msgstr ""
"El trabajo futuro debe centrarse en solucionar los problemas restantes con "
"futexes, implementar el resto de la familia de llamadas al sistema * at, "
"arreglar la entrega de señal y posiblemente implementar el <function>epoll</"
"function> y <function>inotify</function> instalaciones."

#. (itstool) path: sect2/para
#: article.translate.xml:2482
msgid ""
"We hope to be able to run the most important programs flawlessly soon, so we "
"will be able to switch to the 2.6 emulation by default and make the Fedora "
"Core 6 the default linux_base because our currently used Fedora Core 4 is "
"not supported any more."
msgstr ""
"Esperamos poder ejecutar los programas más importantes sin problemas pronto, "
"por lo que podremos cambiar a la emulación 2.6 por defecto y hacer que "
"Fedora Core 6 sea la linux_base predeterminada porque nuestro Fedora Core 4 "
"que usamos actualmente ya no es compatible."

#. (itstool) path: sect2/para
#: article.translate.xml:2488
msgid ""
"The other possible goal is to share our code with NetBSD and DragonflyBSD. "
"NetBSD has some support for 2.6 emulation but its far from finished and not "
"really tested. DragonflyBSD has expressed some interest in porting the 2.6 "
"improvements."
msgstr ""
"El otro objetivo posible es compartir nuestro código con NetBSD y "
"DragonflyBSD. NetBSD tiene algo de soporte para la emulación 2.6 pero está "
"lejos de estar terminado y no se ha probado realmente. DragonflyBSD ha "
"expresado cierto interés en portar las mejoras 2.6."

#. (itstool) path: sect2/para
#: article.translate.xml:2494
msgid ""
"Generally, as <trademark class=\"registered\">Linux</trademark> develops we "
"would like to keep up with their development, implementing newly added "
"syscalls. Splice comes to mind first. Some already implemented syscalls are "
"also heavily crippled, for example <function>mremap</function> and others. "
"Some performance improvements can also be made, finer grained locking and "
"others."
msgstr ""
"Generalmente, como <trademark class=\"registered\">Linux</trademark> "
"desarrolla nos gustaría mantenernos al día con su desarrollo, implementando "
"syscalls recién agregadas. El empalme viene a la mente primero. Algunas "
"llamadas al sistema ya implementadas también están muy paralizadas, por "
"ejemplo <function>mremap</function> y otros. También se pueden realizar "
"algunas mejoras de rendimiento, bloqueo de grano más fino y otros."

#. (itstool) path: sect2/title
#: article.translate.xml:2504
msgid "Team"
msgstr "Equipo"

#. (itstool) path: sect2/para
#: article.translate.xml:2506
msgid "I cooperated on this project with (in alphabetical order):"
msgstr "Colaboré en este proyecto con (en orden alfabético):"

#. (itstool) path: listitem/para
#: article.translate.xml:2511
msgid "John Baldwin <email>jhb@FreeBSD.org</email>"
msgstr "John Baldwin <email>jhb@FreeBSD.org</email>"

#. (itstool) path: listitem/para
#: article.translate.xml:2514
msgid "Konstantin Belousov <email>kib@FreeBSD.org</email>"
msgstr "Konstantin Belousov <email>kib@FreeBSD.org</email>"

#. (itstool) path: listitem/para
#: article.translate.xml:2517
msgid "Emmanuel Dreyfus"
msgstr "Emmanuel Dreyfus"

#. (itstool) path: listitem/para
#: article.translate.xml:2520
msgid "Scot Hetzel"
msgstr "Scot Hetzel"

#. (itstool) path: listitem/para
#: article.translate.xml:2523
msgid "Jung-uk Kim <email>jkim@FreeBSD.org</email>"
msgstr "Jung-uk Kim <email>jkim@FreeBSD.org</email>"

#. (itstool) path: listitem/para
#: article.translate.xml:2526
msgid "Alexander Leidinger <email>netchild@FreeBSD.org</email>"
msgstr "Alexander Leidinger <email>netchild@FreeBSD.org</email>"

#. (itstool) path: listitem/para
#: article.translate.xml:2529
msgid "Suleiman Souhlal <email>ssouhlal@FreeBSD.org</email>"
msgstr "Suleiman Souhlal <email>ssouhlal@FreeBSD.org</email>"

#. (itstool) path: listitem/para
#: article.translate.xml:2532
msgid "Li Xiao"
msgstr "Li Xiao"

#. (itstool) path: listitem/para
#: article.translate.xml:2535
msgid "David Xu <email>davidxu@FreeBSD.org</email>"
msgstr "David Xu <email>davidxu@FreeBSD.org</email>"

#. (itstool) path: sect2/para
#: article.translate.xml:2539
msgid ""
"I would like to thank all those people for their advice, code reviews and "
"general support."
msgstr ""
"Me gustaría agradecer a todas esas personas por sus consejos, revisiones de "
"código y apoyo general."

#. (itstool) path: sect1/title
#: article.translate.xml:2545
msgid "Literatures"
msgstr "Literaturas"

#. (itstool) path: listitem/para
#: article.translate.xml:2549
msgid ""
"Marshall Kirk McKusick - George V. Nevile-Neil. Design and Implementation of "
"the FreeBSD operating system. Addison-Wesley, 2005."
msgstr ""
"Marshall Kirk McKusick - George V. Nevile-Neil. Diseño e implementación del "
"sistema operativo FreeBSD. Addison-Wesley, 2005."

#. (itstool) path: listitem/para
#: article.translate.xml:2554
msgid "<uri xlink:href=\"https://tldp.org\">https://tldp.org</uri>"
msgstr "<uri xlink:href=\"https://tldp.org\">https://tldp.org</uri>"

#. (itstool) path: listitem/para
#: article.translate.xml:2557
msgid "<uri xlink:href=\"https://www.kernel.org\">https://www.kernel.org</uri>"
msgstr ""
"<uri xlink:href=\"https://www.kernel.org\">https://www.kernel.org</uri>"
